const __vite__mapDeps = (
  i,
  m = __vite__mapDeps,
  d = m.f ||
    (m.f = [
      "assets/embedded-wallet-9Mr_gfy5.js",
      "assets/if-defined-ByrZyKqn.js",
      "assets/index-nPScRndg.js",
      "assets/index-DwvsmXDK.js",
      "assets/ref-B7eLNx1F.js",
      "assets/index-DZf81vSY.js",
      "assets/index-C4bp3K0U.js",
      "assets/index-Dtg379WS.js",
      "assets/index-DVRXS-dc.js",
      "assets/index-D6gV_gNO.js",
      "assets/index-25MQhEf3.js",
      "assets/index-C_7cPqFl.js",
      "assets/email-C2igh4f6.js",
      "assets/index-DYd_1eFY.js",
      "assets/socials-BuxvScHX.js",
      "assets/index-CzQOYnTW.js",
      "assets/ConstantsUtil-Dmg8YACJ.js",
      "assets/index-DHxEdJlO.js",
      "assets/index-D3Z0ZC5f.js",
      "assets/index-WhemnpOd.js",
      "assets/index-Mp9DErNv.js",
      "assets/swaps-DEFkLK3n.js",
      "assets/index-DAejOJsd.js",
      "assets/index-gbuKO-vd.js",
      "assets/index-BFQVdj8N.js",
      "assets/send-DSdN0Cjf.js",
      "assets/index-B40PSvEC.js",
      "assets/index-C6E8v_G-.js",
      "assets/receive-CGDBu_L8.js",
      "assets/index-Df1Eo3-A.js",
      "assets/onramp-dhC80NgT.js",
      "assets/index-CPLLdcyL.js",
      "assets/index-B4puYt1B.js",
      "assets/index-BfBfwj9l.js",
      "assets/transactions-DlTHesjF.js",
      "assets/index-Cr1dngWQ.js",
      "assets/index-DyCZFNHX.js",
      "assets/index-98MT1RZa.js",
      "assets/index-DCYaHz8t.js",
      "assets/index-Ct0FQrX5.js",
      "assets/w3m-modal-BRRiU4tk.js",
    ])
) => i.map((i) => d[i]);
var J4 = Object.defineProperty;
var rT = (t) => {
  throw TypeError(t);
};
var eU = (t, e, n) =>
  e in t
    ? J4(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n })
    : (t[e] = n);
var Cf = (t, e, n) => eU(t, typeof e != "symbol" ? e + "" : e, n),
  F1 = (t, e, n) => e.has(t) || rT("Cannot " + n);
var oe = (t, e, n) => (
    F1(t, e, "read from private field"), n ? n.call(t) : e.get(t)
  ),
  Ct = (t, e, n) =>
    e.has(t)
      ? rT("Cannot add the same private member more than once")
      : e instanceof WeakSet
      ? e.add(t)
      : e.set(t, n),
  tt = (t, e, n, r) => (
    F1(t, e, "write to private field"), r ? r.call(t, n) : e.set(t, n), n
  ),
  Mn = (t, e, n) => (F1(t, e, "access private method"), n);
var Ry = (t, e, n, r) => ({
  set _(i) {
    tt(t, e, i, n);
  },
  get _() {
    return oe(t, e, r);
  },
});
function tU(t, e) {
  for (var n = 0; n < e.length; n++) {
    const r = e[n];
    if (typeof r != "string" && !Array.isArray(r)) {
      for (const i in r)
        if (i !== "default" && !(i in t)) {
          const s = Object.getOwnPropertyDescriptor(r, i);
          s &&
            Object.defineProperty(
              t,
              i,
              s.get ? s : { enumerable: !0, get: () => r[i] }
            );
        }
    }
  }
  return Object.freeze(
    Object.defineProperty(t, Symbol.toStringTag, { value: "Module" })
  );
}
(function () {
  const e = document.createElement("link").relList;
  if (e && e.supports && e.supports("modulepreload")) return;
  for (const i of document.querySelectorAll('link[rel="modulepreload"]')) r(i);
  new MutationObserver((i) => {
    for (const s of i)
      if (s.type === "childList")
        for (const o of s.addedNodes)
          o.tagName === "LINK" && o.rel === "modulepreload" && r(o);
  }).observe(document, { childList: !0, subtree: !0 });
  function n(i) {
    const s = {};
    return (
      i.integrity && (s.integrity = i.integrity),
      i.referrerPolicy && (s.referrerPolicy = i.referrerPolicy),
      i.crossOrigin === "use-credentials"
        ? (s.credentials = "include")
        : i.crossOrigin === "anonymous"
        ? (s.credentials = "omit")
        : (s.credentials = "same-origin"),
      s
    );
  }
  function r(i) {
    if (i.ep) return;
    i.ep = !0;
    const s = n(i);
    fetch(i.href, s);
  }
})();
var Eo =
  typeof globalThis < "u"
    ? globalThis
    : typeof window < "u"
    ? window
    : typeof global < "u"
    ? global
    : typeof self < "u"
    ? self
    : {};
function Hc(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default")
    ? t.default
    : t;
}
function nU(t) {
  if (t.__esModule) return t;
  var e = t.default;
  if (typeof e == "function") {
    var n = function r() {
      return this instanceof r
        ? Reflect.construct(e, arguments, this.constructor)
        : e.apply(this, arguments);
    };
    n.prototype = e.prototype;
  } else n = {};
  return (
    Object.defineProperty(n, "__esModule", { value: !0 }),
    Object.keys(t).forEach(function (r) {
      var i = Object.getOwnPropertyDescriptor(t, r);
      Object.defineProperty(
        n,
        r,
        i.get
          ? i
          : {
              enumerable: !0,
              get: function () {
                return t[r];
              },
            }
      );
    }),
    n
  );
}
var z1 = { exports: {} },
  xf = {},
  W1 = { exports: {} },
  bt = {};
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var iT;
function rU() {
  if (iT) return bt;
  iT = 1;
  var t = Symbol.for("react.element"),
    e = Symbol.for("react.portal"),
    n = Symbol.for("react.fragment"),
    r = Symbol.for("react.strict_mode"),
    i = Symbol.for("react.profiler"),
    s = Symbol.for("react.provider"),
    o = Symbol.for("react.context"),
    a = Symbol.for("react.forward_ref"),
    l = Symbol.for("react.suspense"),
    d = Symbol.for("react.memo"),
    p = Symbol.for("react.lazy"),
    f = Symbol.iterator;
  function m(W) {
    return W === null || typeof W != "object"
      ? null
      : ((W = (f && W[f]) || W["@@iterator"]),
        typeof W == "function" ? W : null);
  }
  var y = {
      isMounted: function () {
        return !1;
      },
      enqueueForceUpdate: function () {},
      enqueueReplaceState: function () {},
      enqueueSetState: function () {},
    },
    g = Object.assign,
    v = {};
  function b(W, Z, ee) {
    (this.props = W),
      (this.context = Z),
      (this.refs = v),
      (this.updater = ee || y);
  }
  (b.prototype.isReactComponent = {}),
    (b.prototype.setState = function (W, Z) {
      if (typeof W != "object" && typeof W != "function" && W != null)
        throw Error(
          "setState(...): takes an object of state variables to update or a function which returns an object of state variables."
        );
      this.updater.enqueueSetState(this, W, Z, "setState");
    }),
    (b.prototype.forceUpdate = function (W) {
      this.updater.enqueueForceUpdate(this, W, "forceUpdate");
    });
  function E() {}
  E.prototype = b.prototype;
  function S(W, Z, ee) {
    (this.props = W),
      (this.context = Z),
      (this.refs = v),
      (this.updater = ee || y);
  }
  var C = (S.prototype = new E());
  (C.constructor = S), g(C, b.prototype), (C.isPureReactComponent = !0);
  var _ = Array.isArray,
    A = Object.prototype.hasOwnProperty,
    I = { current: null },
    R = { key: !0, ref: !0, __self: !0, __source: !0 };
  function D(W, Z, ee) {
    var J,
      se = {},
      re = null,
      fe = null;
    if (Z != null)
      for (J in (Z.ref !== void 0 && (fe = Z.ref),
      Z.key !== void 0 && (re = "" + Z.key),
      Z))
        A.call(Z, J) && !R.hasOwnProperty(J) && (se[J] = Z[J]);
    var ce = arguments.length - 2;
    if (ce === 1) se.children = ee;
    else if (1 < ce) {
      for (var le = Array(ce), Se = 0; Se < ce; Se++)
        le[Se] = arguments[Se + 2];
      se.children = le;
    }
    if (W && W.defaultProps)
      for (J in ((ce = W.defaultProps), ce))
        se[J] === void 0 && (se[J] = ce[J]);
    return {
      $$typeof: t,
      type: W,
      key: re,
      ref: fe,
      props: se,
      _owner: I.current,
    };
  }
  function k(W, Z) {
    return {
      $$typeof: t,
      type: W.type,
      key: Z,
      ref: W.ref,
      props: W.props,
      _owner: W._owner,
    };
  }
  function T(W) {
    return typeof W == "object" && W !== null && W.$$typeof === t;
  }
  function U(W) {
    var Z = { "=": "=0", ":": "=2" };
    return (
      "$" +
      W.replace(/[=:]/g, function (ee) {
        return Z[ee];
      })
    );
  }
  var q = /\/+/g;
  function K(W, Z) {
    return typeof W == "object" && W !== null && W.key != null
      ? U("" + W.key)
      : Z.toString(36);
  }
  function H(W, Z, ee, J, se) {
    var re = typeof W;
    (re === "undefined" || re === "boolean") && (W = null);
    var fe = !1;
    if (W === null) fe = !0;
    else
      switch (re) {
        case "string":
        case "number":
          fe = !0;
          break;
        case "object":
          switch (W.$$typeof) {
            case t:
            case e:
              fe = !0;
          }
      }
    if (fe)
      return (
        (fe = W),
        (se = se(fe)),
        (W = J === "" ? "." + K(fe, 0) : J),
        _(se)
          ? ((ee = ""),
            W != null && (ee = W.replace(q, "$&/") + "/"),
            H(se, Z, ee, "", function (Se) {
              return Se;
            }))
          : se != null &&
            (T(se) &&
              (se = k(
                se,
                ee +
                  (!se.key || (fe && fe.key === se.key)
                    ? ""
                    : ("" + se.key).replace(q, "$&/") + "/") +
                  W
              )),
            Z.push(se)),
        1
      );
    if (((fe = 0), (J = J === "" ? "." : J + ":"), _(W)))
      for (var ce = 0; ce < W.length; ce++) {
        re = W[ce];
        var le = J + K(re, ce);
        fe += H(re, Z, ee, le, se);
      }
    else if (((le = m(W)), typeof le == "function"))
      for (W = le.call(W), ce = 0; !(re = W.next()).done; )
        (re = re.value), (le = J + K(re, ce++)), (fe += H(re, Z, ee, le, se));
    else if (re === "object")
      throw (
        ((Z = String(W)),
        Error(
          "Objects are not valid as a React child (found: " +
            (Z === "[object Object]"
              ? "object with keys {" + Object.keys(W).join(", ") + "}"
              : Z) +
            "). If you meant to render a collection of children, use an array instead."
        ))
      );
    return fe;
  }
  function $(W, Z, ee) {
    if (W == null) return W;
    var J = [],
      se = 0;
    return (
      H(W, J, "", "", function (re) {
        return Z.call(ee, re, se++);
      }),
      J
    );
  }
  function M(W) {
    if (W._status === -1) {
      var Z = W._result;
      (Z = Z()),
        Z.then(
          function (ee) {
            (W._status === 0 || W._status === -1) &&
              ((W._status = 1), (W._result = ee));
          },
          function (ee) {
            (W._status === 0 || W._status === -1) &&
              ((W._status = 2), (W._result = ee));
          }
        ),
        W._status === -1 && ((W._status = 0), (W._result = Z));
    }
    if (W._status === 1) return W._result.default;
    throw W._result;
  }
  var z = { current: null },
    B = { transition: null },
    j = {
      ReactCurrentDispatcher: z,
      ReactCurrentBatchConfig: B,
      ReactCurrentOwner: I,
    };
  function V() {
    throw Error("act(...) is not supported in production builds of React.");
  }
  return (
    (bt.Children = {
      map: $,
      forEach: function (W, Z, ee) {
        $(
          W,
          function () {
            Z.apply(this, arguments);
          },
          ee
        );
      },
      count: function (W) {
        var Z = 0;
        return (
          $(W, function () {
            Z++;
          }),
          Z
        );
      },
      toArray: function (W) {
        return (
          $(W, function (Z) {
            return Z;
          }) || []
        );
      },
      only: function (W) {
        if (!T(W))
          throw Error(
            "React.Children.only expected to receive a single React element child."
          );
        return W;
      },
    }),
    (bt.Component = b),
    (bt.Fragment = n),
    (bt.Profiler = i),
    (bt.PureComponent = S),
    (bt.StrictMode = r),
    (bt.Suspense = l),
    (bt.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = j),
    (bt.act = V),
    (bt.cloneElement = function (W, Z, ee) {
      if (W == null)
        throw Error(
          "React.cloneElement(...): The argument must be a React element, but you passed " +
            W +
            "."
        );
      var J = g({}, W.props),
        se = W.key,
        re = W.ref,
        fe = W._owner;
      if (Z != null) {
        if (
          (Z.ref !== void 0 && ((re = Z.ref), (fe = I.current)),
          Z.key !== void 0 && (se = "" + Z.key),
          W.type && W.type.defaultProps)
        )
          var ce = W.type.defaultProps;
        for (le in Z)
          A.call(Z, le) &&
            !R.hasOwnProperty(le) &&
            (J[le] = Z[le] === void 0 && ce !== void 0 ? ce[le] : Z[le]);
      }
      var le = arguments.length - 2;
      if (le === 1) J.children = ee;
      else if (1 < le) {
        ce = Array(le);
        for (var Se = 0; Se < le; Se++) ce[Se] = arguments[Se + 2];
        J.children = ce;
      }
      return {
        $$typeof: t,
        type: W.type,
        key: se,
        ref: re,
        props: J,
        _owner: fe,
      };
    }),
    (bt.createContext = function (W) {
      return (
        (W = {
          $$typeof: o,
          _currentValue: W,
          _currentValue2: W,
          _threadCount: 0,
          Provider: null,
          Consumer: null,
          _defaultValue: null,
          _globalName: null,
        }),
        (W.Provider = { $$typeof: s, _context: W }),
        (W.Consumer = W)
      );
    }),
    (bt.createElement = D),
    (bt.createFactory = function (W) {
      var Z = D.bind(null, W);
      return (Z.type = W), Z;
    }),
    (bt.createRef = function () {
      return { current: null };
    }),
    (bt.forwardRef = function (W) {
      return { $$typeof: a, render: W };
    }),
    (bt.isValidElement = T),
    (bt.lazy = function (W) {
      return { $$typeof: p, _payload: { _status: -1, _result: W }, _init: M };
    }),
    (bt.memo = function (W, Z) {
      return { $$typeof: d, type: W, compare: Z === void 0 ? null : Z };
    }),
    (bt.startTransition = function (W) {
      var Z = B.transition;
      B.transition = {};
      try {
        W();
      } finally {
        B.transition = Z;
      }
    }),
    (bt.unstable_act = V),
    (bt.useCallback = function (W, Z) {
      return z.current.useCallback(W, Z);
    }),
    (bt.useContext = function (W) {
      return z.current.useContext(W);
    }),
    (bt.useDebugValue = function () {}),
    (bt.useDeferredValue = function (W) {
      return z.current.useDeferredValue(W);
    }),
    (bt.useEffect = function (W, Z) {
      return z.current.useEffect(W, Z);
    }),
    (bt.useId = function () {
      return z.current.useId();
    }),
    (bt.useImperativeHandle = function (W, Z, ee) {
      return z.current.useImperativeHandle(W, Z, ee);
    }),
    (bt.useInsertionEffect = function (W, Z) {
      return z.current.useInsertionEffect(W, Z);
    }),
    (bt.useLayoutEffect = function (W, Z) {
      return z.current.useLayoutEffect(W, Z);
    }),
    (bt.useMemo = function (W, Z) {
      return z.current.useMemo(W, Z);
    }),
    (bt.useReducer = function (W, Z, ee) {
      return z.current.useReducer(W, Z, ee);
    }),
    (bt.useRef = function (W) {
      return z.current.useRef(W);
    }),
    (bt.useState = function (W) {
      return z.current.useState(W);
    }),
    (bt.useSyncExternalStore = function (W, Z, ee) {
      return z.current.useSyncExternalStore(W, Z, ee);
    }),
    (bt.useTransition = function () {
      return z.current.useTransition();
    }),
    (bt.version = "18.3.1"),
    bt
  );
}
var sT;
function wp() {
  return sT || ((sT = 1), (W1.exports = rU())), W1.exports;
}
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var oT;
function iU() {
  if (oT) return xf;
  oT = 1;
  var t = wp(),
    e = Symbol.for("react.element"),
    n = Symbol.for("react.fragment"),
    r = Object.prototype.hasOwnProperty,
    i = t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,
    s = { key: !0, ref: !0, __self: !0, __source: !0 };
  function o(a, l, d) {
    var p,
      f = {},
      m = null,
      y = null;
    d !== void 0 && (m = "" + d),
      l.key !== void 0 && (m = "" + l.key),
      l.ref !== void 0 && (y = l.ref);
    for (p in l) r.call(l, p) && !s.hasOwnProperty(p) && (f[p] = l[p]);
    if (a && a.defaultProps)
      for (p in ((l = a.defaultProps), l)) f[p] === void 0 && (f[p] = l[p]);
    return {
      $$typeof: e,
      type: a,
      key: m,
      ref: y,
      props: f,
      _owner: i.current,
    };
  }
  return (xf.Fragment = n), (xf.jsx = o), (xf.jsxs = o), xf;
}
var aT;
function sU() {
  return aT || ((aT = 1), (z1.exports = iU())), z1.exports;
}
var O = sU(),
  N = wp();
const gt = Hc(N),
  Z0 = tU({ __proto__: null, default: gt }, [N]);
var Ny = {},
  H1 = { exports: {} },
  pi = {},
  q1 = { exports: {} },
  V1 = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var cT;
function oU() {
  return (
    cT ||
      ((cT = 1),
      (function (t) {
        function e(B, j) {
          var V = B.length;
          B.push(j);
          e: for (; 0 < V; ) {
            var W = (V - 1) >>> 1,
              Z = B[W];
            if (0 < i(Z, j)) (B[W] = j), (B[V] = Z), (V = W);
            else break e;
          }
        }
        function n(B) {
          return B.length === 0 ? null : B[0];
        }
        function r(B) {
          if (B.length === 0) return null;
          var j = B[0],
            V = B.pop();
          if (V !== j) {
            B[0] = V;
            e: for (var W = 0, Z = B.length, ee = Z >>> 1; W < ee; ) {
              var J = 2 * (W + 1) - 1,
                se = B[J],
                re = J + 1,
                fe = B[re];
              if (0 > i(se, V))
                re < Z && 0 > i(fe, se)
                  ? ((B[W] = fe), (B[re] = V), (W = re))
                  : ((B[W] = se), (B[J] = V), (W = J));
              else if (re < Z && 0 > i(fe, V))
                (B[W] = fe), (B[re] = V), (W = re);
              else break e;
            }
          }
          return j;
        }
        function i(B, j) {
          var V = B.sortIndex - j.sortIndex;
          return V !== 0 ? V : B.id - j.id;
        }
        if (
          typeof performance == "object" &&
          typeof performance.now == "function"
        ) {
          var s = performance;
          t.unstable_now = function () {
            return s.now();
          };
        } else {
          var o = Date,
            a = o.now();
          t.unstable_now = function () {
            return o.now() - a;
          };
        }
        var l = [],
          d = [],
          p = 1,
          f = null,
          m = 3,
          y = !1,
          g = !1,
          v = !1,
          b = typeof setTimeout == "function" ? setTimeout : null,
          E = typeof clearTimeout == "function" ? clearTimeout : null,
          S = typeof setImmediate < "u" ? setImmediate : null;
        typeof navigator < "u" &&
          navigator.scheduling !== void 0 &&
          navigator.scheduling.isInputPending !== void 0 &&
          navigator.scheduling.isInputPending.bind(navigator.scheduling);
        function C(B) {
          for (var j = n(d); j !== null; ) {
            if (j.callback === null) r(d);
            else if (j.startTime <= B)
              r(d), (j.sortIndex = j.expirationTime), e(l, j);
            else break;
            j = n(d);
          }
        }
        function _(B) {
          if (((v = !1), C(B), !g))
            if (n(l) !== null) (g = !0), M(A);
            else {
              var j = n(d);
              j !== null && z(_, j.startTime - B);
            }
        }
        function A(B, j) {
          (g = !1), v && ((v = !1), E(D), (D = -1)), (y = !0);
          var V = m;
          try {
            for (
              C(j), f = n(l);
              f !== null && (!(f.expirationTime > j) || (B && !U()));

            ) {
              var W = f.callback;
              if (typeof W == "function") {
                (f.callback = null), (m = f.priorityLevel);
                var Z = W(f.expirationTime <= j);
                (j = t.unstable_now()),
                  typeof Z == "function"
                    ? (f.callback = Z)
                    : f === n(l) && r(l),
                  C(j);
              } else r(l);
              f = n(l);
            }
            if (f !== null) var ee = !0;
            else {
              var J = n(d);
              J !== null && z(_, J.startTime - j), (ee = !1);
            }
            return ee;
          } finally {
            (f = null), (m = V), (y = !1);
          }
        }
        var I = !1,
          R = null,
          D = -1,
          k = 5,
          T = -1;
        function U() {
          return !(t.unstable_now() - T < k);
        }
        function q() {
          if (R !== null) {
            var B = t.unstable_now();
            T = B;
            var j = !0;
            try {
              j = R(!0, B);
            } finally {
              j ? K() : ((I = !1), (R = null));
            }
          } else I = !1;
        }
        var K;
        if (typeof S == "function")
          K = function () {
            S(q);
          };
        else if (typeof MessageChannel < "u") {
          var H = new MessageChannel(),
            $ = H.port2;
          (H.port1.onmessage = q),
            (K = function () {
              $.postMessage(null);
            });
        } else
          K = function () {
            b(q, 0);
          };
        function M(B) {
          (R = B), I || ((I = !0), K());
        }
        function z(B, j) {
          D = b(function () {
            B(t.unstable_now());
          }, j);
        }
        (t.unstable_IdlePriority = 5),
          (t.unstable_ImmediatePriority = 1),
          (t.unstable_LowPriority = 4),
          (t.unstable_NormalPriority = 3),
          (t.unstable_Profiling = null),
          (t.unstable_UserBlockingPriority = 2),
          (t.unstable_cancelCallback = function (B) {
            B.callback = null;
          }),
          (t.unstable_continueExecution = function () {
            g || y || ((g = !0), M(A));
          }),
          (t.unstable_forceFrameRate = function (B) {
            0 > B || 125 < B
              ? console.error(
                  "forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"
                )
              : (k = 0 < B ? Math.floor(1e3 / B) : 5);
          }),
          (t.unstable_getCurrentPriorityLevel = function () {
            return m;
          }),
          (t.unstable_getFirstCallbackNode = function () {
            return n(l);
          }),
          (t.unstable_next = function (B) {
            switch (m) {
              case 1:
              case 2:
              case 3:
                var j = 3;
                break;
              default:
                j = m;
            }
            var V = m;
            m = j;
            try {
              return B();
            } finally {
              m = V;
            }
          }),
          (t.unstable_pauseExecution = function () {}),
          (t.unstable_requestPaint = function () {}),
          (t.unstable_runWithPriority = function (B, j) {
            switch (B) {
              case 1:
              case 2:
              case 3:
              case 4:
              case 5:
                break;
              default:
                B = 3;
            }
            var V = m;
            m = B;
            try {
              return j();
            } finally {
              m = V;
            }
          }),
          (t.unstable_scheduleCallback = function (B, j, V) {
            var W = t.unstable_now();
            switch (
              (typeof V == "object" && V !== null
                ? ((V = V.delay),
                  (V = typeof V == "number" && 0 < V ? W + V : W))
                : (V = W),
              B)
            ) {
              case 1:
                var Z = -1;
                break;
              case 2:
                Z = 250;
                break;
              case 5:
                Z = 1073741823;
                break;
              case 4:
                Z = 1e4;
                break;
              default:
                Z = 5e3;
            }
            return (
              (Z = V + Z),
              (B = {
                id: p++,
                callback: j,
                priorityLevel: B,
                startTime: V,
                expirationTime: Z,
                sortIndex: -1,
              }),
              V > W
                ? ((B.sortIndex = V),
                  e(d, B),
                  n(l) === null &&
                    B === n(d) &&
                    (v ? (E(D), (D = -1)) : (v = !0), z(_, V - W)))
                : ((B.sortIndex = Z), e(l, B), g || y || ((g = !0), M(A))),
              B
            );
          }),
          (t.unstable_shouldYield = U),
          (t.unstable_wrapCallback = function (B) {
            var j = m;
            return function () {
              var V = m;
              m = j;
              try {
                return B.apply(this, arguments);
              } finally {
                m = V;
              }
            };
          });
      })(V1)),
    V1
  );
}
var lT;
function aU() {
  return lT || ((lT = 1), (q1.exports = oU())), q1.exports;
}
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var uT;
function cU() {
  if (uT) return pi;
  uT = 1;
  var t = wp(),
    e = aU();
  function n(c) {
    for (
      var u = "https://reactjs.org/docs/error-decoder.html?invariant=" + c,
        h = 1;
      h < arguments.length;
      h++
    )
      u += "&args[]=" + encodeURIComponent(arguments[h]);
    return (
      "Minified React error #" +
      c +
      "; visit " +
      u +
      " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
    );
  }
  var r = new Set(),
    i = {};
  function s(c, u) {
    o(c, u), o(c + "Capture", u);
  }
  function o(c, u) {
    for (i[c] = u, c = 0; c < u.length; c++) r.add(u[c]);
  }
  var a = !(
      typeof window > "u" ||
      typeof window.document > "u" ||
      typeof window.document.createElement > "u"
    ),
    l = Object.prototype.hasOwnProperty,
    d =
      /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,
    p = {},
    f = {};
  function m(c) {
    return l.call(f, c)
      ? !0
      : l.call(p, c)
      ? !1
      : d.test(c)
      ? (f[c] = !0)
      : ((p[c] = !0), !1);
  }
  function y(c, u, h, w) {
    if (h !== null && h.type === 0) return !1;
    switch (typeof u) {
      case "function":
      case "symbol":
        return !0;
      case "boolean":
        return w
          ? !1
          : h !== null
          ? !h.acceptsBooleans
          : ((c = c.toLowerCase().slice(0, 5)), c !== "data-" && c !== "aria-");
      default:
        return !1;
    }
  }
  function g(c, u, h, w) {
    if (u === null || typeof u > "u" || y(c, u, h, w)) return !0;
    if (w) return !1;
    if (h !== null)
      switch (h.type) {
        case 3:
          return !u;
        case 4:
          return u === !1;
        case 5:
          return isNaN(u);
        case 6:
          return isNaN(u) || 1 > u;
      }
    return !1;
  }
  function v(c, u, h, w, x, P, L) {
    (this.acceptsBooleans = u === 2 || u === 3 || u === 4),
      (this.attributeName = w),
      (this.attributeNamespace = x),
      (this.mustUseProperty = h),
      (this.propertyName = c),
      (this.type = u),
      (this.sanitizeURL = P),
      (this.removeEmptyString = L);
  }
  var b = {};
  "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style"
    .split(" ")
    .forEach(function (c) {
      b[c] = new v(c, 0, !1, c, null, !1, !1);
    }),
    [
      ["acceptCharset", "accept-charset"],
      ["className", "class"],
      ["htmlFor", "for"],
      ["httpEquiv", "http-equiv"],
    ].forEach(function (c) {
      var u = c[0];
      b[u] = new v(u, 1, !1, c[1], null, !1, !1);
    }),
    ["contentEditable", "draggable", "spellCheck", "value"].forEach(function (
      c
    ) {
      b[c] = new v(c, 2, !1, c.toLowerCase(), null, !1, !1);
    }),
    [
      "autoReverse",
      "externalResourcesRequired",
      "focusable",
      "preserveAlpha",
    ].forEach(function (c) {
      b[c] = new v(c, 2, !1, c, null, !1, !1);
    }),
    "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope"
      .split(" ")
      .forEach(function (c) {
        b[c] = new v(c, 3, !1, c.toLowerCase(), null, !1, !1);
      }),
    ["checked", "multiple", "muted", "selected"].forEach(function (c) {
      b[c] = new v(c, 3, !0, c, null, !1, !1);
    }),
    ["capture", "download"].forEach(function (c) {
      b[c] = new v(c, 4, !1, c, null, !1, !1);
    }),
    ["cols", "rows", "size", "span"].forEach(function (c) {
      b[c] = new v(c, 6, !1, c, null, !1, !1);
    }),
    ["rowSpan", "start"].forEach(function (c) {
      b[c] = new v(c, 5, !1, c.toLowerCase(), null, !1, !1);
    });
  var E = /[\-:]([a-z])/g;
  function S(c) {
    return c[1].toUpperCase();
  }
  "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height"
    .split(" ")
    .forEach(function (c) {
      var u = c.replace(E, S);
      b[u] = new v(u, 1, !1, c, null, !1, !1);
    }),
    "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type"
      .split(" ")
      .forEach(function (c) {
        var u = c.replace(E, S);
        b[u] = new v(u, 1, !1, c, "http://www.w3.org/1999/xlink", !1, !1);
      }),
    ["xml:base", "xml:lang", "xml:space"].forEach(function (c) {
      var u = c.replace(E, S);
      b[u] = new v(u, 1, !1, c, "http://www.w3.org/XML/1998/namespace", !1, !1);
    }),
    ["tabIndex", "crossOrigin"].forEach(function (c) {
      b[c] = new v(c, 1, !1, c.toLowerCase(), null, !1, !1);
    }),
    (b.xlinkHref = new v(
      "xlinkHref",
      1,
      !1,
      "xlink:href",
      "http://www.w3.org/1999/xlink",
      !0,
      !1
    )),
    ["src", "href", "action", "formAction"].forEach(function (c) {
      b[c] = new v(c, 1, !1, c.toLowerCase(), null, !0, !0);
    });
  function C(c, u, h, w) {
    var x = b.hasOwnProperty(u) ? b[u] : null;
    (x !== null
      ? x.type !== 0
      : w ||
        !(2 < u.length) ||
        (u[0] !== "o" && u[0] !== "O") ||
        (u[1] !== "n" && u[1] !== "N")) &&
      (g(u, h, x, w) && (h = null),
      w || x === null
        ? m(u) &&
          (h === null ? c.removeAttribute(u) : c.setAttribute(u, "" + h))
        : x.mustUseProperty
        ? (c[x.propertyName] = h === null ? (x.type === 3 ? !1 : "") : h)
        : ((u = x.attributeName),
          (w = x.attributeNamespace),
          h === null
            ? c.removeAttribute(u)
            : ((x = x.type),
              (h = x === 3 || (x === 4 && h === !0) ? "" : "" + h),
              w ? c.setAttributeNS(w, u, h) : c.setAttribute(u, h))));
  }
  var _ = t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,
    A = Symbol.for("react.element"),
    I = Symbol.for("react.portal"),
    R = Symbol.for("react.fragment"),
    D = Symbol.for("react.strict_mode"),
    k = Symbol.for("react.profiler"),
    T = Symbol.for("react.provider"),
    U = Symbol.for("react.context"),
    q = Symbol.for("react.forward_ref"),
    K = Symbol.for("react.suspense"),
    H = Symbol.for("react.suspense_list"),
    $ = Symbol.for("react.memo"),
    M = Symbol.for("react.lazy"),
    z = Symbol.for("react.offscreen"),
    B = Symbol.iterator;
  function j(c) {
    return c === null || typeof c != "object"
      ? null
      : ((c = (B && c[B]) || c["@@iterator"]),
        typeof c == "function" ? c : null);
  }
  var V = Object.assign,
    W;
  function Z(c) {
    if (W === void 0)
      try {
        throw Error();
      } catch (h) {
        var u = h.stack.trim().match(/\n( *(at )?)/);
        W = (u && u[1]) || "";
      }
    return (
      `
` +
      W +
      c
    );
  }
  var ee = !1;
  function J(c, u) {
    if (!c || ee) return "";
    ee = !0;
    var h = Error.prepareStackTrace;
    Error.prepareStackTrace = void 0;
    try {
      if (u)
        if (
          ((u = function () {
            throw Error();
          }),
          Object.defineProperty(u.prototype, "props", {
            set: function () {
              throw Error();
            },
          }),
          typeof Reflect == "object" && Reflect.construct)
        ) {
          try {
            Reflect.construct(u, []);
          } catch (ie) {
            var w = ie;
          }
          Reflect.construct(c, [], u);
        } else {
          try {
            u.call();
          } catch (ie) {
            w = ie;
          }
          c.call(u.prototype);
        }
      else {
        try {
          throw Error();
        } catch (ie) {
          w = ie;
        }
        c();
      }
    } catch (ie) {
      if (ie && w && typeof ie.stack == "string") {
        for (
          var x = ie.stack.split(`
`),
            P = w.stack.split(`
`),
            L = x.length - 1,
            G = P.length - 1;
          1 <= L && 0 <= G && x[L] !== P[G];

        )
          G--;
        for (; 1 <= L && 0 <= G; L--, G--)
          if (x[L] !== P[G]) {
            if (L !== 1 || G !== 1)
              do
                if ((L--, G--, 0 > G || x[L] !== P[G])) {
                  var Q =
                    `
` + x[L].replace(" at new ", " at ");
                  return (
                    c.displayName &&
                      Q.includes("<anonymous>") &&
                      (Q = Q.replace("<anonymous>", c.displayName)),
                    Q
                  );
                }
              while (1 <= L && 0 <= G);
            break;
          }
      }
    } finally {
      (ee = !1), (Error.prepareStackTrace = h);
    }
    return (c = c ? c.displayName || c.name : "") ? Z(c) : "";
  }
  function se(c) {
    switch (c.tag) {
      case 5:
        return Z(c.type);
      case 16:
        return Z("Lazy");
      case 13:
        return Z("Suspense");
      case 19:
        return Z("SuspenseList");
      case 0:
      case 2:
      case 15:
        return (c = J(c.type, !1)), c;
      case 11:
        return (c = J(c.type.render, !1)), c;
      case 1:
        return (c = J(c.type, !0)), c;
      default:
        return "";
    }
  }
  function re(c) {
    if (c == null) return null;
    if (typeof c == "function") return c.displayName || c.name || null;
    if (typeof c == "string") return c;
    switch (c) {
      case R:
        return "Fragment";
      case I:
        return "Portal";
      case k:
        return "Profiler";
      case D:
        return "StrictMode";
      case K:
        return "Suspense";
      case H:
        return "SuspenseList";
    }
    if (typeof c == "object")
      switch (c.$$typeof) {
        case U:
          return (c.displayName || "Context") + ".Consumer";
        case T:
          return (c._context.displayName || "Context") + ".Provider";
        case q:
          var u = c.render;
          return (
            (c = c.displayName),
            c ||
              ((c = u.displayName || u.name || ""),
              (c = c !== "" ? "ForwardRef(" + c + ")" : "ForwardRef")),
            c
          );
        case $:
          return (
            (u = c.displayName || null), u !== null ? u : re(c.type) || "Memo"
          );
        case M:
          (u = c._payload), (c = c._init);
          try {
            return re(c(u));
          } catch {}
      }
    return null;
  }
  function fe(c) {
    var u = c.type;
    switch (c.tag) {
      case 24:
        return "Cache";
      case 9:
        return (u.displayName || "Context") + ".Consumer";
      case 10:
        return (u._context.displayName || "Context") + ".Provider";
      case 18:
        return "DehydratedFragment";
      case 11:
        return (
          (c = u.render),
          (c = c.displayName || c.name || ""),
          u.displayName || (c !== "" ? "ForwardRef(" + c + ")" : "ForwardRef")
        );
      case 7:
        return "Fragment";
      case 5:
        return u;
      case 4:
        return "Portal";
      case 3:
        return "Root";
      case 6:
        return "Text";
      case 16:
        return re(u);
      case 8:
        return u === D ? "StrictMode" : "Mode";
      case 22:
        return "Offscreen";
      case 12:
        return "Profiler";
      case 21:
        return "Scope";
      case 13:
        return "Suspense";
      case 19:
        return "SuspenseList";
      case 25:
        return "TracingMarker";
      case 1:
      case 0:
      case 17:
      case 2:
      case 14:
      case 15:
        if (typeof u == "function") return u.displayName || u.name || null;
        if (typeof u == "string") return u;
    }
    return null;
  }
  function ce(c) {
    switch (typeof c) {
      case "boolean":
      case "number":
      case "string":
      case "undefined":
        return c;
      case "object":
        return c;
      default:
        return "";
    }
  }
  function le(c) {
    var u = c.type;
    return (
      (c = c.nodeName) &&
      c.toLowerCase() === "input" &&
      (u === "checkbox" || u === "radio")
    );
  }
  function Se(c) {
    var u = le(c) ? "checked" : "value",
      h = Object.getOwnPropertyDescriptor(c.constructor.prototype, u),
      w = "" + c[u];
    if (
      !c.hasOwnProperty(u) &&
      typeof h < "u" &&
      typeof h.get == "function" &&
      typeof h.set == "function"
    ) {
      var x = h.get,
        P = h.set;
      return (
        Object.defineProperty(c, u, {
          configurable: !0,
          get: function () {
            return x.call(this);
          },
          set: function (L) {
            (w = "" + L), P.call(this, L);
          },
        }),
        Object.defineProperty(c, u, { enumerable: h.enumerable }),
        {
          getValue: function () {
            return w;
          },
          setValue: function (L) {
            w = "" + L;
          },
          stopTracking: function () {
            (c._valueTracker = null), delete c[u];
          },
        }
      );
    }
  }
  function je(c) {
    c._valueTracker || (c._valueTracker = Se(c));
  }
  function Pe(c) {
    if (!c) return !1;
    var u = c._valueTracker;
    if (!u) return !0;
    var h = u.getValue(),
      w = "";
    return (
      c && (w = le(c) ? (c.checked ? "true" : "false") : c.value),
      (c = w),
      c !== h ? (u.setValue(c), !0) : !1
    );
  }
  function We(c) {
    if (
      ((c = c || (typeof document < "u" ? document : void 0)), typeof c > "u")
    )
      return null;
    try {
      return c.activeElement || c.body;
    } catch {
      return c.body;
    }
  }
  function Ne(c, u) {
    var h = u.checked;
    return V({}, u, {
      defaultChecked: void 0,
      defaultValue: void 0,
      value: void 0,
      checked: h ?? c._wrapperState.initialChecked,
    });
  }
  function pt(c, u) {
    var h = u.defaultValue == null ? "" : u.defaultValue,
      w = u.checked != null ? u.checked : u.defaultChecked;
    (h = ce(u.value != null ? u.value : h)),
      (c._wrapperState = {
        initialChecked: w,
        initialValue: h,
        controlled:
          u.type === "checkbox" || u.type === "radio"
            ? u.checked != null
            : u.value != null,
      });
  }
  function hn(c, u) {
    (u = u.checked), u != null && C(c, "checked", u, !1);
  }
  function Wt(c, u) {
    hn(c, u);
    var h = ce(u.value),
      w = u.type;
    if (h != null)
      w === "number"
        ? ((h === 0 && c.value === "") || c.value != h) && (c.value = "" + h)
        : c.value !== "" + h && (c.value = "" + h);
    else if (w === "submit" || w === "reset") {
      c.removeAttribute("value");
      return;
    }
    u.hasOwnProperty("value")
      ? vn(c, u.type, h)
      : u.hasOwnProperty("defaultValue") && vn(c, u.type, ce(u.defaultValue)),
      u.checked == null &&
        u.defaultChecked != null &&
        (c.defaultChecked = !!u.defaultChecked);
  }
  function Lt(c, u, h) {
    if (u.hasOwnProperty("value") || u.hasOwnProperty("defaultValue")) {
      var w = u.type;
      if (
        !(
          (w !== "submit" && w !== "reset") ||
          (u.value !== void 0 && u.value !== null)
        )
      )
        return;
      (u = "" + c._wrapperState.initialValue),
        h || u === c.value || (c.value = u),
        (c.defaultValue = u);
    }
    (h = c.name),
      h !== "" && (c.name = ""),
      (c.defaultChecked = !!c._wrapperState.initialChecked),
      h !== "" && (c.name = h);
  }
  function vn(c, u, h) {
    (u !== "number" || We(c.ownerDocument) !== c) &&
      (h == null
        ? (c.defaultValue = "" + c._wrapperState.initialValue)
        : c.defaultValue !== "" + h && (c.defaultValue = "" + h));
  }
  var At = Array.isArray;
  function vt(c, u, h, w) {
    if (((c = c.options), u)) {
      u = {};
      for (var x = 0; x < h.length; x++) u["$" + h[x]] = !0;
      for (h = 0; h < c.length; h++)
        (x = u.hasOwnProperty("$" + c[h].value)),
          c[h].selected !== x && (c[h].selected = x),
          x && w && (c[h].defaultSelected = !0);
    } else {
      for (h = "" + ce(h), u = null, x = 0; x < c.length; x++) {
        if (c[x].value === h) {
          (c[x].selected = !0), w && (c[x].defaultSelected = !0);
          return;
        }
        u !== null || c[x].disabled || (u = c[x]);
      }
      u !== null && (u.selected = !0);
    }
  }
  function Le(c, u) {
    if (u.dangerouslySetInnerHTML != null) throw Error(n(91));
    return V({}, u, {
      value: void 0,
      defaultValue: void 0,
      children: "" + c._wrapperState.initialValue,
    });
  }
  function nr(c, u) {
    var h = u.value;
    if (h == null) {
      if (((h = u.children), (u = u.defaultValue), h != null)) {
        if (u != null) throw Error(n(92));
        if (At(h)) {
          if (1 < h.length) throw Error(n(93));
          h = h[0];
        }
        u = h;
      }
      u == null && (u = ""), (h = u);
    }
    c._wrapperState = { initialValue: ce(h) };
  }
  function tn(c, u) {
    var h = ce(u.value),
      w = ce(u.defaultValue);
    h != null &&
      ((h = "" + h),
      h !== c.value && (c.value = h),
      u.defaultValue == null && c.defaultValue !== h && (c.defaultValue = h)),
      w != null && (c.defaultValue = "" + w);
  }
  function wr(c) {
    var u = c.textContent;
    u === c._wrapperState.initialValue &&
      u !== "" &&
      u !== null &&
      (c.value = u);
  }
  function Dr(c) {
    switch (c) {
      case "svg":
        return "http://www.w3.org/2000/svg";
      case "math":
        return "http://www.w3.org/1998/Math/MathML";
      default:
        return "http://www.w3.org/1999/xhtml";
    }
  }
  function rr(c, u) {
    return c == null || c === "http://www.w3.org/1999/xhtml"
      ? Dr(u)
      : c === "http://www.w3.org/2000/svg" && u === "foreignObject"
      ? "http://www.w3.org/1999/xhtml"
      : c;
  }
  var ir,
    vr = (function (c) {
      return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction
        ? function (u, h, w, x) {
            MSApp.execUnsafeLocalFunction(function () {
              return c(u, h, w, x);
            });
          }
        : c;
    })(function (c, u) {
      if (c.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML" in c)
        c.innerHTML = u;
      else {
        for (
          ir = ir || document.createElement("div"),
            ir.innerHTML = "<svg>" + u.valueOf().toString() + "</svg>",
            u = ir.firstChild;
          c.firstChild;

        )
          c.removeChild(c.firstChild);
        for (; u.firstChild; ) c.appendChild(u.firstChild);
      }
    });
  function Vn(c, u) {
    if (u) {
      var h = c.firstChild;
      if (h && h === c.lastChild && h.nodeType === 3) {
        h.nodeValue = u;
        return;
      }
    }
    c.textContent = u;
  }
  var ot = {
      animationIterationCount: !0,
      aspectRatio: !0,
      borderImageOutset: !0,
      borderImageSlice: !0,
      borderImageWidth: !0,
      boxFlex: !0,
      boxFlexGroup: !0,
      boxOrdinalGroup: !0,
      columnCount: !0,
      columns: !0,
      flex: !0,
      flexGrow: !0,
      flexPositive: !0,
      flexShrink: !0,
      flexNegative: !0,
      flexOrder: !0,
      gridArea: !0,
      gridRow: !0,
      gridRowEnd: !0,
      gridRowSpan: !0,
      gridRowStart: !0,
      gridColumn: !0,
      gridColumnEnd: !0,
      gridColumnSpan: !0,
      gridColumnStart: !0,
      fontWeight: !0,
      lineClamp: !0,
      lineHeight: !0,
      opacity: !0,
      order: !0,
      orphans: !0,
      tabSize: !0,
      widows: !0,
      zIndex: !0,
      zoom: !0,
      fillOpacity: !0,
      floodOpacity: !0,
      stopOpacity: !0,
      strokeDasharray: !0,
      strokeDashoffset: !0,
      strokeMiterlimit: !0,
      strokeOpacity: !0,
      strokeWidth: !0,
    },
    oi = ["Webkit", "ms", "Moz", "O"];
  Object.keys(ot).forEach(function (c) {
    oi.forEach(function (u) {
      (u = u + c.charAt(0).toUpperCase() + c.substring(1)), (ot[u] = ot[c]);
    });
  });
  function $r(c, u, h) {
    return u == null || typeof u == "boolean" || u === ""
      ? ""
      : h || typeof u != "number" || u === 0 || (ot.hasOwnProperty(c) && ot[c])
      ? ("" + u).trim()
      : u + "px";
  }
  function br(c, u) {
    c = c.style;
    for (var h in u)
      if (u.hasOwnProperty(h)) {
        var w = h.indexOf("--") === 0,
          x = $r(h, u[h], w);
        h === "float" && (h = "cssFloat"), w ? c.setProperty(h, x) : (c[h] = x);
      }
  }
  var Ve = V(
    { menuitem: !0 },
    {
      area: !0,
      base: !0,
      br: !0,
      col: !0,
      embed: !0,
      hr: !0,
      img: !0,
      input: !0,
      keygen: !0,
      link: !0,
      meta: !0,
      param: !0,
      source: !0,
      track: !0,
      wbr: !0,
    }
  );
  function It(c, u) {
    if (u) {
      if (Ve[c] && (u.children != null || u.dangerouslySetInnerHTML != null))
        throw Error(n(137, c));
      if (u.dangerouslySetInnerHTML != null) {
        if (u.children != null) throw Error(n(60));
        if (
          typeof u.dangerouslySetInnerHTML != "object" ||
          !("__html" in u.dangerouslySetInnerHTML)
        )
          throw Error(n(61));
      }
      if (u.style != null && typeof u.style != "object") throw Error(n(62));
    }
  }
  function bn(c, u) {
    if (c.indexOf("-") === -1) return typeof u.is == "string";
    switch (c) {
      case "annotation-xml":
      case "color-profile":
      case "font-face":
      case "font-face-src":
      case "font-face-uri":
      case "font-face-format":
      case "font-face-name":
      case "missing-glyph":
        return !1;
      default:
        return !0;
    }
  }
  var Kr = null;
  function ka(c) {
    return (
      (c = c.target || c.srcElement || window),
      c.correspondingUseElement && (c = c.correspondingUseElement),
      c.nodeType === 3 ? c.parentNode : c
    );
  }
  var Lp = null,
    Da = null,
    $a = null;
  function vg(c) {
    if ((c = af(c))) {
      if (typeof Lp != "function") throw Error(n(280));
      var u = c.stateNode;
      u && ((u = qg(u)), Lp(c.stateNode, c.type, u));
    }
  }
  function bg(c) {
    Da ? ($a ? $a.push(c) : ($a = [c])) : (Da = c);
  }
  function Eg() {
    if (Da) {
      var c = Da,
        u = $a;
      if ((($a = Da = null), vg(c), u)) for (c = 0; c < u.length; c++) vg(u[c]);
    }
  }
  function Cg(c, u) {
    return c(u);
  }
  function at() {}
  var Yr = !1;
  function Up(c, u, h) {
    if (Yr) return c(u, h);
    Yr = !0;
    try {
      return Cg(c, u, h);
    } finally {
      (Yr = !1), (Da !== null || $a !== null) && (at(), Eg());
    }
  }
  function Bp(c, u) {
    var h = c.stateNode;
    if (h === null) return null;
    var w = qg(h);
    if (w === null) return null;
    h = w[u];
    e: switch (u) {
      case "onClick":
      case "onClickCapture":
      case "onDoubleClick":
      case "onDoubleClickCapture":
      case "onMouseDown":
      case "onMouseDownCapture":
      case "onMouseMove":
      case "onMouseMoveCapture":
      case "onMouseUp":
      case "onMouseUpCapture":
      case "onMouseEnter":
        (w = !w.disabled) ||
          ((c = c.type),
          (w = !(
            c === "button" ||
            c === "input" ||
            c === "select" ||
            c === "textarea"
          ))),
          (c = !w);
        break e;
      default:
        c = !1;
    }
    if (c) return null;
    if (h && typeof h != "function") throw Error(n(231, u, typeof h));
    return h;
  }
  var sb = !1;
  if (a)
    try {
      var jp = {};
      Object.defineProperty(jp, "passive", {
        get: function () {
          sb = !0;
        },
      }),
        window.addEventListener("test", jp, jp),
        window.removeEventListener("test", jp, jp);
    } catch {
      sb = !1;
    }
  function o8(c, u, h, w, x, P, L, G, Q) {
    var ie = Array.prototype.slice.call(arguments, 3);
    try {
      u.apply(h, ie);
    } catch (de) {
      this.onError(de);
    }
  }
  var Fp = !1,
    xg = null,
    Sg = !1,
    ob = null,
    a8 = {
      onError: function (c) {
        (Fp = !0), (xg = c);
      },
    };
  function c8(c, u, h, w, x, P, L, G, Q) {
    (Fp = !1), (xg = null), o8.apply(a8, arguments);
  }
  function l8(c, u, h, w, x, P, L, G, Q) {
    if ((c8.apply(this, arguments), Fp)) {
      if (Fp) {
        var ie = xg;
        (Fp = !1), (xg = null);
      } else throw Error(n(198));
      Sg || ((Sg = !0), (ob = ie));
    }
  }
  function Zc(c) {
    var u = c,
      h = c;
    if (c.alternate) for (; u.return; ) u = u.return;
    else {
      c = u;
      do (u = c), u.flags & 4098 && (h = u.return), (c = u.return);
      while (c);
    }
    return u.tag === 3 ? h : null;
  }
  function __(c) {
    if (c.tag === 13) {
      var u = c.memoizedState;
      if (
        (u === null && ((c = c.alternate), c !== null && (u = c.memoizedState)),
        u !== null)
      )
        return u.dehydrated;
    }
    return null;
  }
  function I_(c) {
    if (Zc(c) !== c) throw Error(n(188));
  }
  function u8(c) {
    var u = c.alternate;
    if (!u) {
      if (((u = Zc(c)), u === null)) throw Error(n(188));
      return u !== c ? null : c;
    }
    for (var h = c, w = u; ; ) {
      var x = h.return;
      if (x === null) break;
      var P = x.alternate;
      if (P === null) {
        if (((w = x.return), w !== null)) {
          h = w;
          continue;
        }
        break;
      }
      if (x.child === P.child) {
        for (P = x.child; P; ) {
          if (P === h) return I_(x), c;
          if (P === w) return I_(x), u;
          P = P.sibling;
        }
        throw Error(n(188));
      }
      if (h.return !== w.return) (h = x), (w = P);
      else {
        for (var L = !1, G = x.child; G; ) {
          if (G === h) {
            (L = !0), (h = x), (w = P);
            break;
          }
          if (G === w) {
            (L = !0), (w = x), (h = P);
            break;
          }
          G = G.sibling;
        }
        if (!L) {
          for (G = P.child; G; ) {
            if (G === h) {
              (L = !0), (h = P), (w = x);
              break;
            }
            if (G === w) {
              (L = !0), (w = P), (h = x);
              break;
            }
            G = G.sibling;
          }
          if (!L) throw Error(n(189));
        }
      }
      if (h.alternate !== w) throw Error(n(190));
    }
    if (h.tag !== 3) throw Error(n(188));
    return h.stateNode.current === h ? c : u;
  }
  function T_(c) {
    return (c = u8(c)), c !== null ? P_(c) : null;
  }
  function P_(c) {
    if (c.tag === 5 || c.tag === 6) return c;
    for (c = c.child; c !== null; ) {
      var u = P_(c);
      if (u !== null) return u;
      c = c.sibling;
    }
    return null;
  }
  var R_ = e.unstable_scheduleCallback,
    N_ = e.unstable_cancelCallback,
    d8 = e.unstable_shouldYield,
    p8 = e.unstable_requestPaint,
    Dn = e.unstable_now,
    f8 = e.unstable_getCurrentPriorityLevel,
    ab = e.unstable_ImmediatePriority,
    O_ = e.unstable_UserBlockingPriority,
    Ag = e.unstable_NormalPriority,
    h8 = e.unstable_LowPriority,
    k_ = e.unstable_IdlePriority,
    _g = null,
    no = null;
  function m8(c) {
    if (no && typeof no.onCommitFiberRoot == "function")
      try {
        no.onCommitFiberRoot(_g, c, void 0, (c.current.flags & 128) === 128);
      } catch {}
  }
  var Ts = Math.clz32 ? Math.clz32 : w8,
    g8 = Math.log,
    y8 = Math.LN2;
  function w8(c) {
    return (c >>>= 0), c === 0 ? 32 : (31 - ((g8(c) / y8) | 0)) | 0;
  }
  var Ig = 64,
    Tg = 4194304;
  function zp(c) {
    switch (c & -c) {
      case 1:
        return 1;
      case 2:
        return 2;
      case 4:
        return 4;
      case 8:
        return 8;
      case 16:
        return 16;
      case 32:
        return 32;
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return c & 4194240;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return c & 130023424;
      case 134217728:
        return 134217728;
      case 268435456:
        return 268435456;
      case 536870912:
        return 536870912;
      case 1073741824:
        return 1073741824;
      default:
        return c;
    }
  }
  function Pg(c, u) {
    var h = c.pendingLanes;
    if (h === 0) return 0;
    var w = 0,
      x = c.suspendedLanes,
      P = c.pingedLanes,
      L = h & 268435455;
    if (L !== 0) {
      var G = L & ~x;
      G !== 0 ? (w = zp(G)) : ((P &= L), P !== 0 && (w = zp(P)));
    } else (L = h & ~x), L !== 0 ? (w = zp(L)) : P !== 0 && (w = zp(P));
    if (w === 0) return 0;
    if (
      u !== 0 &&
      u !== w &&
      !(u & x) &&
      ((x = w & -w), (P = u & -u), x >= P || (x === 16 && (P & 4194240) !== 0))
    )
      return u;
    if ((w & 4 && (w |= h & 16), (u = c.entangledLanes), u !== 0))
      for (c = c.entanglements, u &= w; 0 < u; )
        (h = 31 - Ts(u)), (x = 1 << h), (w |= c[h]), (u &= ~x);
    return w;
  }
  function v8(c, u) {
    switch (c) {
      case 1:
      case 2:
      case 4:
        return u + 250;
      case 8:
      case 16:
      case 32:
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return u + 5e3;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return -1;
      case 134217728:
      case 268435456:
      case 536870912:
      case 1073741824:
        return -1;
      default:
        return -1;
    }
  }
  function b8(c, u) {
    for (
      var h = c.suspendedLanes,
        w = c.pingedLanes,
        x = c.expirationTimes,
        P = c.pendingLanes;
      0 < P;

    ) {
      var L = 31 - Ts(P),
        G = 1 << L,
        Q = x[L];
      Q === -1
        ? (!(G & h) || G & w) && (x[L] = v8(G, u))
        : Q <= u && (c.expiredLanes |= G),
        (P &= ~G);
    }
  }
  function cb(c) {
    return (
      (c = c.pendingLanes & -1073741825),
      c !== 0 ? c : c & 1073741824 ? 1073741824 : 0
    );
  }
  function D_() {
    var c = Ig;
    return (Ig <<= 1), !(Ig & 4194240) && (Ig = 64), c;
  }
  function lb(c) {
    for (var u = [], h = 0; 31 > h; h++) u.push(c);
    return u;
  }
  function Wp(c, u, h) {
    (c.pendingLanes |= u),
      u !== 536870912 && ((c.suspendedLanes = 0), (c.pingedLanes = 0)),
      (c = c.eventTimes),
      (u = 31 - Ts(u)),
      (c[u] = h);
  }
  function E8(c, u) {
    var h = c.pendingLanes & ~u;
    (c.pendingLanes = u),
      (c.suspendedLanes = 0),
      (c.pingedLanes = 0),
      (c.expiredLanes &= u),
      (c.mutableReadLanes &= u),
      (c.entangledLanes &= u),
      (u = c.entanglements);
    var w = c.eventTimes;
    for (c = c.expirationTimes; 0 < h; ) {
      var x = 31 - Ts(h),
        P = 1 << x;
      (u[x] = 0), (w[x] = -1), (c[x] = -1), (h &= ~P);
    }
  }
  function ub(c, u) {
    var h = (c.entangledLanes |= u);
    for (c = c.entanglements; h; ) {
      var w = 31 - Ts(h),
        x = 1 << w;
      (x & u) | (c[w] & u) && (c[w] |= u), (h &= ~x);
    }
  }
  var Ht = 0;
  function $_(c) {
    return (
      (c &= -c), 1 < c ? (4 < c ? (c & 268435455 ? 16 : 536870912) : 4) : 1
    );
  }
  var M_,
    db,
    L_,
    U_,
    B_,
    pb = !1,
    Rg = [],
    Ma = null,
    La = null,
    Ua = null,
    Hp = new Map(),
    qp = new Map(),
    Ba = [],
    C8 =
      "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(
        " "
      );
  function j_(c, u) {
    switch (c) {
      case "focusin":
      case "focusout":
        Ma = null;
        break;
      case "dragenter":
      case "dragleave":
        La = null;
        break;
      case "mouseover":
      case "mouseout":
        Ua = null;
        break;
      case "pointerover":
      case "pointerout":
        Hp.delete(u.pointerId);
        break;
      case "gotpointercapture":
      case "lostpointercapture":
        qp.delete(u.pointerId);
    }
  }
  function Vp(c, u, h, w, x, P) {
    return c === null || c.nativeEvent !== P
      ? ((c = {
          blockedOn: u,
          domEventName: h,
          eventSystemFlags: w,
          nativeEvent: P,
          targetContainers: [x],
        }),
        u !== null && ((u = af(u)), u !== null && db(u)),
        c)
      : ((c.eventSystemFlags |= w),
        (u = c.targetContainers),
        x !== null && u.indexOf(x) === -1 && u.push(x),
        c);
  }
  function x8(c, u, h, w, x) {
    switch (u) {
      case "focusin":
        return (Ma = Vp(Ma, c, u, h, w, x)), !0;
      case "dragenter":
        return (La = Vp(La, c, u, h, w, x)), !0;
      case "mouseover":
        return (Ua = Vp(Ua, c, u, h, w, x)), !0;
      case "pointerover":
        var P = x.pointerId;
        return Hp.set(P, Vp(Hp.get(P) || null, c, u, h, w, x)), !0;
      case "gotpointercapture":
        return (
          (P = x.pointerId), qp.set(P, Vp(qp.get(P) || null, c, u, h, w, x)), !0
        );
    }
    return !1;
  }
  function F_(c) {
    var u = Qc(c.target);
    if (u !== null) {
      var h = Zc(u);
      if (h !== null) {
        if (((u = h.tag), u === 13)) {
          if (((u = __(h)), u !== null)) {
            (c.blockedOn = u),
              B_(c.priority, function () {
                L_(h);
              });
            return;
          }
        } else if (u === 3 && h.stateNode.current.memoizedState.isDehydrated) {
          c.blockedOn = h.tag === 3 ? h.stateNode.containerInfo : null;
          return;
        }
      }
    }
    c.blockedOn = null;
  }
  function Ng(c) {
    if (c.blockedOn !== null) return !1;
    for (var u = c.targetContainers; 0 < u.length; ) {
      var h = hb(c.domEventName, c.eventSystemFlags, u[0], c.nativeEvent);
      if (h === null) {
        h = c.nativeEvent;
        var w = new h.constructor(h.type, h);
        (Kr = w), h.target.dispatchEvent(w), (Kr = null);
      } else return (u = af(h)), u !== null && db(u), (c.blockedOn = h), !1;
      u.shift();
    }
    return !0;
  }
  function z_(c, u, h) {
    Ng(c) && h.delete(u);
  }
  function S8() {
    (pb = !1),
      Ma !== null && Ng(Ma) && (Ma = null),
      La !== null && Ng(La) && (La = null),
      Ua !== null && Ng(Ua) && (Ua = null),
      Hp.forEach(z_),
      qp.forEach(z_);
  }
  function Gp(c, u) {
    c.blockedOn === u &&
      ((c.blockedOn = null),
      pb ||
        ((pb = !0),
        e.unstable_scheduleCallback(e.unstable_NormalPriority, S8)));
  }
  function Kp(c) {
    function u(x) {
      return Gp(x, c);
    }
    if (0 < Rg.length) {
      Gp(Rg[0], c);
      for (var h = 1; h < Rg.length; h++) {
        var w = Rg[h];
        w.blockedOn === c && (w.blockedOn = null);
      }
    }
    for (
      Ma !== null && Gp(Ma, c),
        La !== null && Gp(La, c),
        Ua !== null && Gp(Ua, c),
        Hp.forEach(u),
        qp.forEach(u),
        h = 0;
      h < Ba.length;
      h++
    )
      (w = Ba[h]), w.blockedOn === c && (w.blockedOn = null);
    for (; 0 < Ba.length && ((h = Ba[0]), h.blockedOn === null); )
      F_(h), h.blockedOn === null && Ba.shift();
  }
  var wu = _.ReactCurrentBatchConfig,
    Og = !0;
  function A8(c, u, h, w) {
    var x = Ht,
      P = wu.transition;
    wu.transition = null;
    try {
      (Ht = 1), fb(c, u, h, w);
    } finally {
      (Ht = x), (wu.transition = P);
    }
  }
  function _8(c, u, h, w) {
    var x = Ht,
      P = wu.transition;
    wu.transition = null;
    try {
      (Ht = 4), fb(c, u, h, w);
    } finally {
      (Ht = x), (wu.transition = P);
    }
  }
  function fb(c, u, h, w) {
    if (Og) {
      var x = hb(c, u, h, w);
      if (x === null) Nb(c, u, w, kg, h), j_(c, w);
      else if (x8(x, c, u, h, w)) w.stopPropagation();
      else if ((j_(c, w), u & 4 && -1 < C8.indexOf(c))) {
        for (; x !== null; ) {
          var P = af(x);
          if (
            (P !== null && M_(P),
            (P = hb(c, u, h, w)),
            P === null && Nb(c, u, w, kg, h),
            P === x)
          )
            break;
          x = P;
        }
        x !== null && w.stopPropagation();
      } else Nb(c, u, w, null, h);
    }
  }
  var kg = null;
  function hb(c, u, h, w) {
    if (((kg = null), (c = ka(w)), (c = Qc(c)), c !== null))
      if (((u = Zc(c)), u === null)) c = null;
      else if (((h = u.tag), h === 13)) {
        if (((c = __(u)), c !== null)) return c;
        c = null;
      } else if (h === 3) {
        if (u.stateNode.current.memoizedState.isDehydrated)
          return u.tag === 3 ? u.stateNode.containerInfo : null;
        c = null;
      } else u !== c && (c = null);
    return (kg = c), null;
  }
  function W_(c) {
    switch (c) {
      case "cancel":
      case "click":
      case "close":
      case "contextmenu":
      case "copy":
      case "cut":
      case "auxclick":
      case "dblclick":
      case "dragend":
      case "dragstart":
      case "drop":
      case "focusin":
      case "focusout":
      case "input":
      case "invalid":
      case "keydown":
      case "keypress":
      case "keyup":
      case "mousedown":
      case "mouseup":
      case "paste":
      case "pause":
      case "play":
      case "pointercancel":
      case "pointerdown":
      case "pointerup":
      case "ratechange":
      case "reset":
      case "resize":
      case "seeked":
      case "submit":
      case "touchcancel":
      case "touchend":
      case "touchstart":
      case "volumechange":
      case "change":
      case "selectionchange":
      case "textInput":
      case "compositionstart":
      case "compositionend":
      case "compositionupdate":
      case "beforeblur":
      case "afterblur":
      case "beforeinput":
      case "blur":
      case "fullscreenchange":
      case "focus":
      case "hashchange":
      case "popstate":
      case "select":
      case "selectstart":
        return 1;
      case "drag":
      case "dragenter":
      case "dragexit":
      case "dragleave":
      case "dragover":
      case "mousemove":
      case "mouseout":
      case "mouseover":
      case "pointermove":
      case "pointerout":
      case "pointerover":
      case "scroll":
      case "toggle":
      case "touchmove":
      case "wheel":
      case "mouseenter":
      case "mouseleave":
      case "pointerenter":
      case "pointerleave":
        return 4;
      case "message":
        switch (f8()) {
          case ab:
            return 1;
          case O_:
            return 4;
          case Ag:
          case h8:
            return 16;
          case k_:
            return 536870912;
          default:
            return 16;
        }
      default:
        return 16;
    }
  }
  var ja = null,
    mb = null,
    Dg = null;
  function H_() {
    if (Dg) return Dg;
    var c,
      u = mb,
      h = u.length,
      w,
      x = "value" in ja ? ja.value : ja.textContent,
      P = x.length;
    for (c = 0; c < h && u[c] === x[c]; c++);
    var L = h - c;
    for (w = 1; w <= L && u[h - w] === x[P - w]; w++);
    return (Dg = x.slice(c, 1 < w ? 1 - w : void 0));
  }
  function $g(c) {
    var u = c.keyCode;
    return (
      "charCode" in c
        ? ((c = c.charCode), c === 0 && u === 13 && (c = 13))
        : (c = u),
      c === 10 && (c = 13),
      32 <= c || c === 13 ? c : 0
    );
  }
  function Mg() {
    return !0;
  }
  function q_() {
    return !1;
  }
  function Ri(c) {
    function u(h, w, x, P, L) {
      (this._reactName = h),
        (this._targetInst = x),
        (this.type = w),
        (this.nativeEvent = P),
        (this.target = L),
        (this.currentTarget = null);
      for (var G in c)
        c.hasOwnProperty(G) && ((h = c[G]), (this[G] = h ? h(P) : P[G]));
      return (
        (this.isDefaultPrevented = (
          P.defaultPrevented != null ? P.defaultPrevented : P.returnValue === !1
        )
          ? Mg
          : q_),
        (this.isPropagationStopped = q_),
        this
      );
    }
    return (
      V(u.prototype, {
        preventDefault: function () {
          this.defaultPrevented = !0;
          var h = this.nativeEvent;
          h &&
            (h.preventDefault
              ? h.preventDefault()
              : typeof h.returnValue != "unknown" && (h.returnValue = !1),
            (this.isDefaultPrevented = Mg));
        },
        stopPropagation: function () {
          var h = this.nativeEvent;
          h &&
            (h.stopPropagation
              ? h.stopPropagation()
              : typeof h.cancelBubble != "unknown" && (h.cancelBubble = !0),
            (this.isPropagationStopped = Mg));
        },
        persist: function () {},
        isPersistent: Mg,
      }),
      u
    );
  }
  var vu = {
      eventPhase: 0,
      bubbles: 0,
      cancelable: 0,
      timeStamp: function (c) {
        return c.timeStamp || Date.now();
      },
      defaultPrevented: 0,
      isTrusted: 0,
    },
    gb = Ri(vu),
    Yp = V({}, vu, { view: 0, detail: 0 }),
    I8 = Ri(Yp),
    yb,
    wb,
    Zp,
    Lg = V({}, Yp, {
      screenX: 0,
      screenY: 0,
      clientX: 0,
      clientY: 0,
      pageX: 0,
      pageY: 0,
      ctrlKey: 0,
      shiftKey: 0,
      altKey: 0,
      metaKey: 0,
      getModifierState: bb,
      button: 0,
      buttons: 0,
      relatedTarget: function (c) {
        return c.relatedTarget === void 0
          ? c.fromElement === c.srcElement
            ? c.toElement
            : c.fromElement
          : c.relatedTarget;
      },
      movementX: function (c) {
        return "movementX" in c
          ? c.movementX
          : (c !== Zp &&
              (Zp && c.type === "mousemove"
                ? ((yb = c.screenX - Zp.screenX), (wb = c.screenY - Zp.screenY))
                : (wb = yb = 0),
              (Zp = c)),
            yb);
      },
      movementY: function (c) {
        return "movementY" in c ? c.movementY : wb;
      },
    }),
    V_ = Ri(Lg),
    T8 = V({}, Lg, { dataTransfer: 0 }),
    P8 = Ri(T8),
    R8 = V({}, Yp, { relatedTarget: 0 }),
    vb = Ri(R8),
    N8 = V({}, vu, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }),
    O8 = Ri(N8),
    k8 = V({}, vu, {
      clipboardData: function (c) {
        return "clipboardData" in c ? c.clipboardData : window.clipboardData;
      },
    }),
    D8 = Ri(k8),
    $8 = V({}, vu, { data: 0 }),
    G_ = Ri($8),
    M8 = {
      Esc: "Escape",
      Spacebar: " ",
      Left: "ArrowLeft",
      Up: "ArrowUp",
      Right: "ArrowRight",
      Down: "ArrowDown",
      Del: "Delete",
      Win: "OS",
      Menu: "ContextMenu",
      Apps: "ContextMenu",
      Scroll: "ScrollLock",
      MozPrintableKey: "Unidentified",
    },
    L8 = {
      8: "Backspace",
      9: "Tab",
      12: "Clear",
      13: "Enter",
      16: "Shift",
      17: "Control",
      18: "Alt",
      19: "Pause",
      20: "CapsLock",
      27: "Escape",
      32: " ",
      33: "PageUp",
      34: "PageDown",
      35: "End",
      36: "Home",
      37: "ArrowLeft",
      38: "ArrowUp",
      39: "ArrowRight",
      40: "ArrowDown",
      45: "Insert",
      46: "Delete",
      112: "F1",
      113: "F2",
      114: "F3",
      115: "F4",
      116: "F5",
      117: "F6",
      118: "F7",
      119: "F8",
      120: "F9",
      121: "F10",
      122: "F11",
      123: "F12",
      144: "NumLock",
      145: "ScrollLock",
      224: "Meta",
    },
    U8 = {
      Alt: "altKey",
      Control: "ctrlKey",
      Meta: "metaKey",
      Shift: "shiftKey",
    };
  function B8(c) {
    var u = this.nativeEvent;
    return u.getModifierState
      ? u.getModifierState(c)
      : (c = U8[c])
      ? !!u[c]
      : !1;
  }
  function bb() {
    return B8;
  }
  var j8 = V({}, Yp, {
      key: function (c) {
        if (c.key) {
          var u = M8[c.key] || c.key;
          if (u !== "Unidentified") return u;
        }
        return c.type === "keypress"
          ? ((c = $g(c)), c === 13 ? "Enter" : String.fromCharCode(c))
          : c.type === "keydown" || c.type === "keyup"
          ? L8[c.keyCode] || "Unidentified"
          : "";
      },
      code: 0,
      location: 0,
      ctrlKey: 0,
      shiftKey: 0,
      altKey: 0,
      metaKey: 0,
      repeat: 0,
      locale: 0,
      getModifierState: bb,
      charCode: function (c) {
        return c.type === "keypress" ? $g(c) : 0;
      },
      keyCode: function (c) {
        return c.type === "keydown" || c.type === "keyup" ? c.keyCode : 0;
      },
      which: function (c) {
        return c.type === "keypress"
          ? $g(c)
          : c.type === "keydown" || c.type === "keyup"
          ? c.keyCode
          : 0;
      },
    }),
    F8 = Ri(j8),
    z8 = V({}, Lg, {
      pointerId: 0,
      width: 0,
      height: 0,
      pressure: 0,
      tangentialPressure: 0,
      tiltX: 0,
      tiltY: 0,
      twist: 0,
      pointerType: 0,
      isPrimary: 0,
    }),
    K_ = Ri(z8),
    W8 = V({}, Yp, {
      touches: 0,
      targetTouches: 0,
      changedTouches: 0,
      altKey: 0,
      metaKey: 0,
      ctrlKey: 0,
      shiftKey: 0,
      getModifierState: bb,
    }),
    H8 = Ri(W8),
    q8 = V({}, vu, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }),
    V8 = Ri(q8),
    G8 = V({}, Lg, {
      deltaX: function (c) {
        return "deltaX" in c
          ? c.deltaX
          : "wheelDeltaX" in c
          ? -c.wheelDeltaX
          : 0;
      },
      deltaY: function (c) {
        return "deltaY" in c
          ? c.deltaY
          : "wheelDeltaY" in c
          ? -c.wheelDeltaY
          : "wheelDelta" in c
          ? -c.wheelDelta
          : 0;
      },
      deltaZ: 0,
      deltaMode: 0,
    }),
    K8 = Ri(G8),
    Y8 = [9, 13, 27, 32],
    Eb = a && "CompositionEvent" in window,
    Qp = null;
  a && "documentMode" in document && (Qp = document.documentMode);
  var Z8 = a && "TextEvent" in window && !Qp,
    Y_ = a && (!Eb || (Qp && 8 < Qp && 11 >= Qp)),
    Z_ = " ",
    Q_ = !1;
  function X_(c, u) {
    switch (c) {
      case "keyup":
        return Y8.indexOf(u.keyCode) !== -1;
      case "keydown":
        return u.keyCode !== 229;
      case "keypress":
      case "mousedown":
      case "focusout":
        return !0;
      default:
        return !1;
    }
  }
  function J_(c) {
    return (c = c.detail), typeof c == "object" && "data" in c ? c.data : null;
  }
  var bu = !1;
  function Q8(c, u) {
    switch (c) {
      case "compositionend":
        return J_(u);
      case "keypress":
        return u.which !== 32 ? null : ((Q_ = !0), Z_);
      case "textInput":
        return (c = u.data), c === Z_ && Q_ ? null : c;
      default:
        return null;
    }
  }
  function X8(c, u) {
    if (bu)
      return c === "compositionend" || (!Eb && X_(c, u))
        ? ((c = H_()), (Dg = mb = ja = null), (bu = !1), c)
        : null;
    switch (c) {
      case "paste":
        return null;
      case "keypress":
        if (!(u.ctrlKey || u.altKey || u.metaKey) || (u.ctrlKey && u.altKey)) {
          if (u.char && 1 < u.char.length) return u.char;
          if (u.which) return String.fromCharCode(u.which);
        }
        return null;
      case "compositionend":
        return Y_ && u.locale !== "ko" ? null : u.data;
      default:
        return null;
    }
  }
  var J8 = {
    color: !0,
    date: !0,
    datetime: !0,
    "datetime-local": !0,
    email: !0,
    month: !0,
    number: !0,
    password: !0,
    range: !0,
    search: !0,
    tel: !0,
    text: !0,
    time: !0,
    url: !0,
    week: !0,
  };
  function e2(c) {
    var u = c && c.nodeName && c.nodeName.toLowerCase();
    return u === "input" ? !!J8[c.type] : u === "textarea";
  }
  function t2(c, u, h, w) {
    bg(w),
      (u = zg(u, "onChange")),
      0 < u.length &&
        ((h = new gb("onChange", "change", null, h, w)),
        c.push({ event: h, listeners: u }));
  }
  var Xp = null,
    Jp = null;
  function e4(c) {
    v2(c, 0);
  }
  function Ug(c) {
    var u = Au(c);
    if (Pe(u)) return c;
  }
  function t4(c, u) {
    if (c === "change") return u;
  }
  var n2 = !1;
  if (a) {
    var Cb;
    if (a) {
      var xb = "oninput" in document;
      if (!xb) {
        var r2 = document.createElement("div");
        r2.setAttribute("oninput", "return;"),
          (xb = typeof r2.oninput == "function");
      }
      Cb = xb;
    } else Cb = !1;
    n2 = Cb && (!document.documentMode || 9 < document.documentMode);
  }
  function i2() {
    Xp && (Xp.detachEvent("onpropertychange", s2), (Jp = Xp = null));
  }
  function s2(c) {
    if (c.propertyName === "value" && Ug(Jp)) {
      var u = [];
      t2(u, Jp, c, ka(c)), Up(e4, u);
    }
  }
  function n4(c, u, h) {
    c === "focusin"
      ? (i2(), (Xp = u), (Jp = h), Xp.attachEvent("onpropertychange", s2))
      : c === "focusout" && i2();
  }
  function r4(c) {
    if (c === "selectionchange" || c === "keyup" || c === "keydown")
      return Ug(Jp);
  }
  function i4(c, u) {
    if (c === "click") return Ug(u);
  }
  function s4(c, u) {
    if (c === "input" || c === "change") return Ug(u);
  }
  function o4(c, u) {
    return (c === u && (c !== 0 || 1 / c === 1 / u)) || (c !== c && u !== u);
  }
  var Ps = typeof Object.is == "function" ? Object.is : o4;
  function ef(c, u) {
    if (Ps(c, u)) return !0;
    if (
      typeof c != "object" ||
      c === null ||
      typeof u != "object" ||
      u === null
    )
      return !1;
    var h = Object.keys(c),
      w = Object.keys(u);
    if (h.length !== w.length) return !1;
    for (w = 0; w < h.length; w++) {
      var x = h[w];
      if (!l.call(u, x) || !Ps(c[x], u[x])) return !1;
    }
    return !0;
  }
  function o2(c) {
    for (; c && c.firstChild; ) c = c.firstChild;
    return c;
  }
  function a2(c, u) {
    var h = o2(c);
    c = 0;
    for (var w; h; ) {
      if (h.nodeType === 3) {
        if (((w = c + h.textContent.length), c <= u && w >= u))
          return { node: h, offset: u - c };
        c = w;
      }
      e: {
        for (; h; ) {
          if (h.nextSibling) {
            h = h.nextSibling;
            break e;
          }
          h = h.parentNode;
        }
        h = void 0;
      }
      h = o2(h);
    }
  }
  function c2(c, u) {
    return c && u
      ? c === u
        ? !0
        : c && c.nodeType === 3
        ? !1
        : u && u.nodeType === 3
        ? c2(c, u.parentNode)
        : "contains" in c
        ? c.contains(u)
        : c.compareDocumentPosition
        ? !!(c.compareDocumentPosition(u) & 16)
        : !1
      : !1;
  }
  function l2() {
    for (var c = window, u = We(); u instanceof c.HTMLIFrameElement; ) {
      try {
        var h = typeof u.contentWindow.location.href == "string";
      } catch {
        h = !1;
      }
      if (h) c = u.contentWindow;
      else break;
      u = We(c.document);
    }
    return u;
  }
  function Sb(c) {
    var u = c && c.nodeName && c.nodeName.toLowerCase();
    return (
      u &&
      ((u === "input" &&
        (c.type === "text" ||
          c.type === "search" ||
          c.type === "tel" ||
          c.type === "url" ||
          c.type === "password")) ||
        u === "textarea" ||
        c.contentEditable === "true")
    );
  }
  function a4(c) {
    var u = l2(),
      h = c.focusedElem,
      w = c.selectionRange;
    if (
      u !== h &&
      h &&
      h.ownerDocument &&
      c2(h.ownerDocument.documentElement, h)
    ) {
      if (w !== null && Sb(h)) {
        if (
          ((u = w.start),
          (c = w.end),
          c === void 0 && (c = u),
          "selectionStart" in h)
        )
          (h.selectionStart = u),
            (h.selectionEnd = Math.min(c, h.value.length));
        else if (
          ((c = ((u = h.ownerDocument || document) && u.defaultView) || window),
          c.getSelection)
        ) {
          c = c.getSelection();
          var x = h.textContent.length,
            P = Math.min(w.start, x);
          (w = w.end === void 0 ? P : Math.min(w.end, x)),
            !c.extend && P > w && ((x = w), (w = P), (P = x)),
            (x = a2(h, P));
          var L = a2(h, w);
          x &&
            L &&
            (c.rangeCount !== 1 ||
              c.anchorNode !== x.node ||
              c.anchorOffset !== x.offset ||
              c.focusNode !== L.node ||
              c.focusOffset !== L.offset) &&
            ((u = u.createRange()),
            u.setStart(x.node, x.offset),
            c.removeAllRanges(),
            P > w
              ? (c.addRange(u), c.extend(L.node, L.offset))
              : (u.setEnd(L.node, L.offset), c.addRange(u)));
        }
      }
      for (u = [], c = h; (c = c.parentNode); )
        c.nodeType === 1 &&
          u.push({ element: c, left: c.scrollLeft, top: c.scrollTop });
      for (typeof h.focus == "function" && h.focus(), h = 0; h < u.length; h++)
        (c = u[h]),
          (c.element.scrollLeft = c.left),
          (c.element.scrollTop = c.top);
    }
  }
  var c4 = a && "documentMode" in document && 11 >= document.documentMode,
    Eu = null,
    Ab = null,
    tf = null,
    _b = !1;
  function u2(c, u, h) {
    var w =
      h.window === h ? h.document : h.nodeType === 9 ? h : h.ownerDocument;
    _b ||
      Eu == null ||
      Eu !== We(w) ||
      ((w = Eu),
      "selectionStart" in w && Sb(w)
        ? (w = { start: w.selectionStart, end: w.selectionEnd })
        : ((w = (
            (w.ownerDocument && w.ownerDocument.defaultView) ||
            window
          ).getSelection()),
          (w = {
            anchorNode: w.anchorNode,
            anchorOffset: w.anchorOffset,
            focusNode: w.focusNode,
            focusOffset: w.focusOffset,
          })),
      (tf && ef(tf, w)) ||
        ((tf = w),
        (w = zg(Ab, "onSelect")),
        0 < w.length &&
          ((u = new gb("onSelect", "select", null, u, h)),
          c.push({ event: u, listeners: w }),
          (u.target = Eu))));
  }
  function Bg(c, u) {
    var h = {};
    return (
      (h[c.toLowerCase()] = u.toLowerCase()),
      (h["Webkit" + c] = "webkit" + u),
      (h["Moz" + c] = "moz" + u),
      h
    );
  }
  var Cu = {
      animationend: Bg("Animation", "AnimationEnd"),
      animationiteration: Bg("Animation", "AnimationIteration"),
      animationstart: Bg("Animation", "AnimationStart"),
      transitionend: Bg("Transition", "TransitionEnd"),
    },
    Ib = {},
    d2 = {};
  a &&
    ((d2 = document.createElement("div").style),
    "AnimationEvent" in window ||
      (delete Cu.animationend.animation,
      delete Cu.animationiteration.animation,
      delete Cu.animationstart.animation),
    "TransitionEvent" in window || delete Cu.transitionend.transition);
  function jg(c) {
    if (Ib[c]) return Ib[c];
    if (!Cu[c]) return c;
    var u = Cu[c],
      h;
    for (h in u) if (u.hasOwnProperty(h) && h in d2) return (Ib[c] = u[h]);
    return c;
  }
  var p2 = jg("animationend"),
    f2 = jg("animationiteration"),
    h2 = jg("animationstart"),
    m2 = jg("transitionend"),
    g2 = new Map(),
    y2 =
      "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(
        " "
      );
  function Fa(c, u) {
    g2.set(c, u), s(u, [c]);
  }
  for (var Tb = 0; Tb < y2.length; Tb++) {
    var Pb = y2[Tb],
      l4 = Pb.toLowerCase(),
      u4 = Pb[0].toUpperCase() + Pb.slice(1);
    Fa(l4, "on" + u4);
  }
  Fa(p2, "onAnimationEnd"),
    Fa(f2, "onAnimationIteration"),
    Fa(h2, "onAnimationStart"),
    Fa("dblclick", "onDoubleClick"),
    Fa("focusin", "onFocus"),
    Fa("focusout", "onBlur"),
    Fa(m2, "onTransitionEnd"),
    o("onMouseEnter", ["mouseout", "mouseover"]),
    o("onMouseLeave", ["mouseout", "mouseover"]),
    o("onPointerEnter", ["pointerout", "pointerover"]),
    o("onPointerLeave", ["pointerout", "pointerover"]),
    s(
      "onChange",
      "change click focusin focusout input keydown keyup selectionchange".split(
        " "
      )
    ),
    s(
      "onSelect",
      "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(
        " "
      )
    ),
    s("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]),
    s(
      "onCompositionEnd",
      "compositionend focusout keydown keypress keyup mousedown".split(" ")
    ),
    s(
      "onCompositionStart",
      "compositionstart focusout keydown keypress keyup mousedown".split(" ")
    ),
    s(
      "onCompositionUpdate",
      "compositionupdate focusout keydown keypress keyup mousedown".split(" ")
    );
  var nf =
      "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(
        " "
      ),
    d4 = new Set(
      "cancel close invalid load scroll toggle".split(" ").concat(nf)
    );
  function w2(c, u, h) {
    var w = c.type || "unknown-event";
    (c.currentTarget = h), l8(w, u, void 0, c), (c.currentTarget = null);
  }
  function v2(c, u) {
    u = (u & 4) !== 0;
    for (var h = 0; h < c.length; h++) {
      var w = c[h],
        x = w.event;
      w = w.listeners;
      e: {
        var P = void 0;
        if (u)
          for (var L = w.length - 1; 0 <= L; L--) {
            var G = w[L],
              Q = G.instance,
              ie = G.currentTarget;
            if (((G = G.listener), Q !== P && x.isPropagationStopped()))
              break e;
            w2(x, G, ie), (P = Q);
          }
        else
          for (L = 0; L < w.length; L++) {
            if (
              ((G = w[L]),
              (Q = G.instance),
              (ie = G.currentTarget),
              (G = G.listener),
              Q !== P && x.isPropagationStopped())
            )
              break e;
            w2(x, G, ie), (P = Q);
          }
      }
    }
    if (Sg) throw ((c = ob), (Sg = !1), (ob = null), c);
  }
  function cn(c, u) {
    var h = u[Lb];
    h === void 0 && (h = u[Lb] = new Set());
    var w = c + "__bubble";
    h.has(w) || (b2(u, c, 2, !1), h.add(w));
  }
  function Rb(c, u, h) {
    var w = 0;
    u && (w |= 4), b2(h, c, w, u);
  }
  var Fg = "_reactListening" + Math.random().toString(36).slice(2);
  function rf(c) {
    if (!c[Fg]) {
      (c[Fg] = !0),
        r.forEach(function (h) {
          h !== "selectionchange" && (d4.has(h) || Rb(h, !1, c), Rb(h, !0, c));
        });
      var u = c.nodeType === 9 ? c : c.ownerDocument;
      u === null || u[Fg] || ((u[Fg] = !0), Rb("selectionchange", !1, u));
    }
  }
  function b2(c, u, h, w) {
    switch (W_(u)) {
      case 1:
        var x = A8;
        break;
      case 4:
        x = _8;
        break;
      default:
        x = fb;
    }
    (h = x.bind(null, u, h, c)),
      (x = void 0),
      !sb ||
        (u !== "touchstart" && u !== "touchmove" && u !== "wheel") ||
        (x = !0),
      w
        ? x !== void 0
          ? c.addEventListener(u, h, { capture: !0, passive: x })
          : c.addEventListener(u, h, !0)
        : x !== void 0
        ? c.addEventListener(u, h, { passive: x })
        : c.addEventListener(u, h, !1);
  }
  function Nb(c, u, h, w, x) {
    var P = w;
    if (!(u & 1) && !(u & 2) && w !== null)
      e: for (;;) {
        if (w === null) return;
        var L = w.tag;
        if (L === 3 || L === 4) {
          var G = w.stateNode.containerInfo;
          if (G === x || (G.nodeType === 8 && G.parentNode === x)) break;
          if (L === 4)
            for (L = w.return; L !== null; ) {
              var Q = L.tag;
              if (
                (Q === 3 || Q === 4) &&
                ((Q = L.stateNode.containerInfo),
                Q === x || (Q.nodeType === 8 && Q.parentNode === x))
              )
                return;
              L = L.return;
            }
          for (; G !== null; ) {
            if (((L = Qc(G)), L === null)) return;
            if (((Q = L.tag), Q === 5 || Q === 6)) {
              w = P = L;
              continue e;
            }
            G = G.parentNode;
          }
        }
        w = w.return;
      }
    Up(function () {
      var ie = P,
        de = ka(h),
        he = [];
      e: {
        var ue = g2.get(c);
        if (ue !== void 0) {
          var _e = gb,
            Ue = c;
          switch (c) {
            case "keypress":
              if ($g(h) === 0) break e;
            case "keydown":
            case "keyup":
              _e = F8;
              break;
            case "focusin":
              (Ue = "focus"), (_e = vb);
              break;
            case "focusout":
              (Ue = "blur"), (_e = vb);
              break;
            case "beforeblur":
            case "afterblur":
              _e = vb;
              break;
            case "click":
              if (h.button === 2) break e;
            case "auxclick":
            case "dblclick":
            case "mousedown":
            case "mousemove":
            case "mouseup":
            case "mouseout":
            case "mouseover":
            case "contextmenu":
              _e = V_;
              break;
            case "drag":
            case "dragend":
            case "dragenter":
            case "dragexit":
            case "dragleave":
            case "dragover":
            case "dragstart":
            case "drop":
              _e = P8;
              break;
            case "touchcancel":
            case "touchend":
            case "touchmove":
            case "touchstart":
              _e = H8;
              break;
            case p2:
            case f2:
            case h2:
              _e = O8;
              break;
            case m2:
              _e = V8;
              break;
            case "scroll":
              _e = I8;
              break;
            case "wheel":
              _e = K8;
              break;
            case "copy":
            case "cut":
            case "paste":
              _e = D8;
              break;
            case "gotpointercapture":
            case "lostpointercapture":
            case "pointercancel":
            case "pointerdown":
            case "pointermove":
            case "pointerout":
            case "pointerover":
            case "pointerup":
              _e = K_;
          }
          var Fe = (u & 4) !== 0,
            $n = !Fe && c === "scroll",
            te = Fe ? (ue !== null ? ue + "Capture" : null) : ue;
          Fe = [];
          for (var X = ie, ne; X !== null; ) {
            ne = X;
            var we = ne.stateNode;
            if (
              (ne.tag === 5 &&
                we !== null &&
                ((ne = we),
                te !== null &&
                  ((we = Bp(X, te)), we != null && Fe.push(sf(X, we, ne)))),
              $n)
            )
              break;
            X = X.return;
          }
          0 < Fe.length &&
            ((ue = new _e(ue, Ue, null, h, de)),
            he.push({ event: ue, listeners: Fe }));
        }
      }
      if (!(u & 7)) {
        e: {
          if (
            ((ue = c === "mouseover" || c === "pointerover"),
            (_e = c === "mouseout" || c === "pointerout"),
            ue &&
              h !== Kr &&
              (Ue = h.relatedTarget || h.fromElement) &&
              (Qc(Ue) || Ue[Fo]))
          )
            break e;
          if (
            (_e || ue) &&
            ((ue =
              de.window === de
                ? de
                : (ue = de.ownerDocument)
                ? ue.defaultView || ue.parentWindow
                : window),
            _e
              ? ((Ue = h.relatedTarget || h.toElement),
                (_e = ie),
                (Ue = Ue ? Qc(Ue) : null),
                Ue !== null &&
                  (($n = Zc(Ue)),
                  Ue !== $n || (Ue.tag !== 5 && Ue.tag !== 6)) &&
                  (Ue = null))
              : ((_e = null), (Ue = ie)),
            _e !== Ue)
          ) {
            if (
              ((Fe = V_),
              (we = "onMouseLeave"),
              (te = "onMouseEnter"),
              (X = "mouse"),
              (c === "pointerout" || c === "pointerover") &&
                ((Fe = K_),
                (we = "onPointerLeave"),
                (te = "onPointerEnter"),
                (X = "pointer")),
              ($n = _e == null ? ue : Au(_e)),
              (ne = Ue == null ? ue : Au(Ue)),
              (ue = new Fe(we, X + "leave", _e, h, de)),
              (ue.target = $n),
              (ue.relatedTarget = ne),
              (we = null),
              Qc(de) === ie &&
                ((Fe = new Fe(te, X + "enter", Ue, h, de)),
                (Fe.target = ne),
                (Fe.relatedTarget = $n),
                (we = Fe)),
              ($n = we),
              _e && Ue)
            )
              t: {
                for (Fe = _e, te = Ue, X = 0, ne = Fe; ne; ne = xu(ne)) X++;
                for (ne = 0, we = te; we; we = xu(we)) ne++;
                for (; 0 < X - ne; ) (Fe = xu(Fe)), X--;
                for (; 0 < ne - X; ) (te = xu(te)), ne--;
                for (; X--; ) {
                  if (Fe === te || (te !== null && Fe === te.alternate))
                    break t;
                  (Fe = xu(Fe)), (te = xu(te));
                }
                Fe = null;
              }
            else Fe = null;
            _e !== null && E2(he, ue, _e, Fe, !1),
              Ue !== null && $n !== null && E2(he, $n, Ue, Fe, !0);
          }
        }
        e: {
          if (
            ((ue = ie ? Au(ie) : window),
            (_e = ue.nodeName && ue.nodeName.toLowerCase()),
            _e === "select" || (_e === "input" && ue.type === "file"))
          )
            var ze = t4;
          else if (e2(ue))
            if (n2) ze = s4;
            else {
              ze = r4;
              var Ge = n4;
            }
          else
            (_e = ue.nodeName) &&
              _e.toLowerCase() === "input" &&
              (ue.type === "checkbox" || ue.type === "radio") &&
              (ze = i4);
          if (ze && (ze = ze(c, ie))) {
            t2(he, ze, h, de);
            break e;
          }
          Ge && Ge(c, ue, ie),
            c === "focusout" &&
              (Ge = ue._wrapperState) &&
              Ge.controlled &&
              ue.type === "number" &&
              vn(ue, "number", ue.value);
        }
        switch (((Ge = ie ? Au(ie) : window), c)) {
          case "focusin":
            (e2(Ge) || Ge.contentEditable === "true") &&
              ((Eu = Ge), (Ab = ie), (tf = null));
            break;
          case "focusout":
            tf = Ab = Eu = null;
            break;
          case "mousedown":
            _b = !0;
            break;
          case "contextmenu":
          case "mouseup":
          case "dragend":
            (_b = !1), u2(he, h, de);
            break;
          case "selectionchange":
            if (c4) break;
          case "keydown":
          case "keyup":
            u2(he, h, de);
        }
        var Ke;
        if (Eb)
          e: {
            switch (c) {
              case "compositionstart":
                var et = "onCompositionStart";
                break e;
              case "compositionend":
                et = "onCompositionEnd";
                break e;
              case "compositionupdate":
                et = "onCompositionUpdate";
                break e;
            }
            et = void 0;
          }
        else
          bu
            ? X_(c, h) && (et = "onCompositionEnd")
            : c === "keydown" &&
              h.keyCode === 229 &&
              (et = "onCompositionStart");
        et &&
          (Y_ &&
            h.locale !== "ko" &&
            (bu || et !== "onCompositionStart"
              ? et === "onCompositionEnd" && bu && (Ke = H_())
              : ((ja = de),
                (mb = "value" in ja ? ja.value : ja.textContent),
                (bu = !0))),
          (Ge = zg(ie, et)),
          0 < Ge.length &&
            ((et = new G_(et, c, null, h, de)),
            he.push({ event: et, listeners: Ge }),
            Ke
              ? (et.data = Ke)
              : ((Ke = J_(h)), Ke !== null && (et.data = Ke)))),
          (Ke = Z8 ? Q8(c, h) : X8(c, h)) &&
            ((ie = zg(ie, "onBeforeInput")),
            0 < ie.length &&
              ((de = new G_("onBeforeInput", "beforeinput", null, h, de)),
              he.push({ event: de, listeners: ie }),
              (de.data = Ke)));
      }
      v2(he, u);
    });
  }
  function sf(c, u, h) {
    return { instance: c, listener: u, currentTarget: h };
  }
  function zg(c, u) {
    for (var h = u + "Capture", w = []; c !== null; ) {
      var x = c,
        P = x.stateNode;
      x.tag === 5 &&
        P !== null &&
        ((x = P),
        (P = Bp(c, h)),
        P != null && w.unshift(sf(c, P, x)),
        (P = Bp(c, u)),
        P != null && w.push(sf(c, P, x))),
        (c = c.return);
    }
    return w;
  }
  function xu(c) {
    if (c === null) return null;
    do c = c.return;
    while (c && c.tag !== 5);
    return c || null;
  }
  function E2(c, u, h, w, x) {
    for (var P = u._reactName, L = []; h !== null && h !== w; ) {
      var G = h,
        Q = G.alternate,
        ie = G.stateNode;
      if (Q !== null && Q === w) break;
      G.tag === 5 &&
        ie !== null &&
        ((G = ie),
        x
          ? ((Q = Bp(h, P)), Q != null && L.unshift(sf(h, Q, G)))
          : x || ((Q = Bp(h, P)), Q != null && L.push(sf(h, Q, G)))),
        (h = h.return);
    }
    L.length !== 0 && c.push({ event: u, listeners: L });
  }
  var p4 = /\r\n?/g,
    f4 = /\u0000|\uFFFD/g;
  function C2(c) {
    return (typeof c == "string" ? c : "" + c)
      .replace(
        p4,
        `
`
      )
      .replace(f4, "");
  }
  function Wg(c, u, h) {
    if (((u = C2(u)), C2(c) !== u && h)) throw Error(n(425));
  }
  function Hg() {}
  var Ob = null,
    kb = null;
  function Db(c, u) {
    return (
      c === "textarea" ||
      c === "noscript" ||
      typeof u.children == "string" ||
      typeof u.children == "number" ||
      (typeof u.dangerouslySetInnerHTML == "object" &&
        u.dangerouslySetInnerHTML !== null &&
        u.dangerouslySetInnerHTML.__html != null)
    );
  }
  var $b = typeof setTimeout == "function" ? setTimeout : void 0,
    h4 = typeof clearTimeout == "function" ? clearTimeout : void 0,
    x2 = typeof Promise == "function" ? Promise : void 0,
    m4 =
      typeof queueMicrotask == "function"
        ? queueMicrotask
        : typeof x2 < "u"
        ? function (c) {
            return x2.resolve(null).then(c).catch(g4);
          }
        : $b;
  function g4(c) {
    setTimeout(function () {
      throw c;
    });
  }
  function Mb(c, u) {
    var h = u,
      w = 0;
    do {
      var x = h.nextSibling;
      if ((c.removeChild(h), x && x.nodeType === 8))
        if (((h = x.data), h === "/$")) {
          if (w === 0) {
            c.removeChild(x), Kp(u);
            return;
          }
          w--;
        } else (h !== "$" && h !== "$?" && h !== "$!") || w++;
      h = x;
    } while (h);
    Kp(u);
  }
  function za(c) {
    for (; c != null; c = c.nextSibling) {
      var u = c.nodeType;
      if (u === 1 || u === 3) break;
      if (u === 8) {
        if (((u = c.data), u === "$" || u === "$!" || u === "$?")) break;
        if (u === "/$") return null;
      }
    }
    return c;
  }
  function S2(c) {
    c = c.previousSibling;
    for (var u = 0; c; ) {
      if (c.nodeType === 8) {
        var h = c.data;
        if (h === "$" || h === "$!" || h === "$?") {
          if (u === 0) return c;
          u--;
        } else h === "/$" && u++;
      }
      c = c.previousSibling;
    }
    return null;
  }
  var Su = Math.random().toString(36).slice(2),
    ro = "__reactFiber$" + Su,
    of = "__reactProps$" + Su,
    Fo = "__reactContainer$" + Su,
    Lb = "__reactEvents$" + Su,
    y4 = "__reactListeners$" + Su,
    w4 = "__reactHandles$" + Su;
  function Qc(c) {
    var u = c[ro];
    if (u) return u;
    for (var h = c.parentNode; h; ) {
      if ((u = h[Fo] || h[ro])) {
        if (
          ((h = u.alternate),
          u.child !== null || (h !== null && h.child !== null))
        )
          for (c = S2(c); c !== null; ) {
            if ((h = c[ro])) return h;
            c = S2(c);
          }
        return u;
      }
      (c = h), (h = c.parentNode);
    }
    return null;
  }
  function af(c) {
    return (
      (c = c[ro] || c[Fo]),
      !c || (c.tag !== 5 && c.tag !== 6 && c.tag !== 13 && c.tag !== 3)
        ? null
        : c
    );
  }
  function Au(c) {
    if (c.tag === 5 || c.tag === 6) return c.stateNode;
    throw Error(n(33));
  }
  function qg(c) {
    return c[of] || null;
  }
  var Ub = [],
    _u = -1;
  function Wa(c) {
    return { current: c };
  }
  function ln(c) {
    0 > _u || ((c.current = Ub[_u]), (Ub[_u] = null), _u--);
  }
  function nn(c, u) {
    _u++, (Ub[_u] = c.current), (c.current = u);
  }
  var Ha = {},
    Mr = Wa(Ha),
    ai = Wa(!1),
    Xc = Ha;
  function Iu(c, u) {
    var h = c.type.contextTypes;
    if (!h) return Ha;
    var w = c.stateNode;
    if (w && w.__reactInternalMemoizedUnmaskedChildContext === u)
      return w.__reactInternalMemoizedMaskedChildContext;
    var x = {},
      P;
    for (P in h) x[P] = u[P];
    return (
      w &&
        ((c = c.stateNode),
        (c.__reactInternalMemoizedUnmaskedChildContext = u),
        (c.__reactInternalMemoizedMaskedChildContext = x)),
      x
    );
  }
  function ci(c) {
    return (c = c.childContextTypes), c != null;
  }
  function Vg() {
    ln(ai), ln(Mr);
  }
  function A2(c, u, h) {
    if (Mr.current !== Ha) throw Error(n(168));
    nn(Mr, u), nn(ai, h);
  }
  function _2(c, u, h) {
    var w = c.stateNode;
    if (((u = u.childContextTypes), typeof w.getChildContext != "function"))
      return h;
    w = w.getChildContext();
    for (var x in w) if (!(x in u)) throw Error(n(108, fe(c) || "Unknown", x));
    return V({}, h, w);
  }
  function Gg(c) {
    return (
      (c =
        ((c = c.stateNode) && c.__reactInternalMemoizedMergedChildContext) ||
        Ha),
      (Xc = Mr.current),
      nn(Mr, c),
      nn(ai, ai.current),
      !0
    );
  }
  function I2(c, u, h) {
    var w = c.stateNode;
    if (!w) throw Error(n(169));
    h
      ? ((c = _2(c, u, Xc)),
        (w.__reactInternalMemoizedMergedChildContext = c),
        ln(ai),
        ln(Mr),
        nn(Mr, c))
      : ln(ai),
      nn(ai, h);
  }
  var zo = null,
    Kg = !1,
    Bb = !1;
  function T2(c) {
    zo === null ? (zo = [c]) : zo.push(c);
  }
  function v4(c) {
    (Kg = !0), T2(c);
  }
  function qa() {
    if (!Bb && zo !== null) {
      Bb = !0;
      var c = 0,
        u = Ht;
      try {
        var h = zo;
        for (Ht = 1; c < h.length; c++) {
          var w = h[c];
          do w = w(!0);
          while (w !== null);
        }
        (zo = null), (Kg = !1);
      } catch (x) {
        throw (zo !== null && (zo = zo.slice(c + 1)), R_(ab, qa), x);
      } finally {
        (Ht = u), (Bb = !1);
      }
    }
    return null;
  }
  var Tu = [],
    Pu = 0,
    Yg = null,
    Zg = 0,
    Zi = [],
    Qi = 0,
    Jc = null,
    Wo = 1,
    Ho = "";
  function el(c, u) {
    (Tu[Pu++] = Zg), (Tu[Pu++] = Yg), (Yg = c), (Zg = u);
  }
  function P2(c, u, h) {
    (Zi[Qi++] = Wo), (Zi[Qi++] = Ho), (Zi[Qi++] = Jc), (Jc = c);
    var w = Wo;
    c = Ho;
    var x = 32 - Ts(w) - 1;
    (w &= ~(1 << x)), (h += 1);
    var P = 32 - Ts(u) + x;
    if (30 < P) {
      var L = x - (x % 5);
      (P = (w & ((1 << L) - 1)).toString(32)),
        (w >>= L),
        (x -= L),
        (Wo = (1 << (32 - Ts(u) + x)) | (h << x) | w),
        (Ho = P + c);
    } else (Wo = (1 << P) | (h << x) | w), (Ho = c);
  }
  function jb(c) {
    c.return !== null && (el(c, 1), P2(c, 1, 0));
  }
  function Fb(c) {
    for (; c === Yg; )
      (Yg = Tu[--Pu]), (Tu[Pu] = null), (Zg = Tu[--Pu]), (Tu[Pu] = null);
    for (; c === Jc; )
      (Jc = Zi[--Qi]),
        (Zi[Qi] = null),
        (Ho = Zi[--Qi]),
        (Zi[Qi] = null),
        (Wo = Zi[--Qi]),
        (Zi[Qi] = null);
  }
  var Ni = null,
    Oi = null,
    mn = !1,
    Rs = null;
  function R2(c, u) {
    var h = ts(5, null, null, 0);
    (h.elementType = "DELETED"),
      (h.stateNode = u),
      (h.return = c),
      (u = c.deletions),
      u === null ? ((c.deletions = [h]), (c.flags |= 16)) : u.push(h);
  }
  function N2(c, u) {
    switch (c.tag) {
      case 5:
        var h = c.type;
        return (
          (u =
            u.nodeType !== 1 || h.toLowerCase() !== u.nodeName.toLowerCase()
              ? null
              : u),
          u !== null
            ? ((c.stateNode = u), (Ni = c), (Oi = za(u.firstChild)), !0)
            : !1
        );
      case 6:
        return (
          (u = c.pendingProps === "" || u.nodeType !== 3 ? null : u),
          u !== null ? ((c.stateNode = u), (Ni = c), (Oi = null), !0) : !1
        );
      case 13:
        return (
          (u = u.nodeType !== 8 ? null : u),
          u !== null
            ? ((h = Jc !== null ? { id: Wo, overflow: Ho } : null),
              (c.memoizedState = {
                dehydrated: u,
                treeContext: h,
                retryLane: 1073741824,
              }),
              (h = ts(18, null, null, 0)),
              (h.stateNode = u),
              (h.return = c),
              (c.child = h),
              (Ni = c),
              (Oi = null),
              !0)
            : !1
        );
      default:
        return !1;
    }
  }
  function zb(c) {
    return (c.mode & 1) !== 0 && (c.flags & 128) === 0;
  }
  function Wb(c) {
    if (mn) {
      var u = Oi;
      if (u) {
        var h = u;
        if (!N2(c, u)) {
          if (zb(c)) throw Error(n(418));
          u = za(h.nextSibling);
          var w = Ni;
          u && N2(c, u)
            ? R2(w, h)
            : ((c.flags = (c.flags & -4097) | 2), (mn = !1), (Ni = c));
        }
      } else {
        if (zb(c)) throw Error(n(418));
        (c.flags = (c.flags & -4097) | 2), (mn = !1), (Ni = c);
      }
    }
  }
  function O2(c) {
    for (
      c = c.return;
      c !== null && c.tag !== 5 && c.tag !== 3 && c.tag !== 13;

    )
      c = c.return;
    Ni = c;
  }
  function Qg(c) {
    if (c !== Ni) return !1;
    if (!mn) return O2(c), (mn = !0), !1;
    var u;
    if (
      ((u = c.tag !== 3) &&
        !(u = c.tag !== 5) &&
        ((u = c.type),
        (u = u !== "head" && u !== "body" && !Db(c.type, c.memoizedProps))),
      u && (u = Oi))
    ) {
      if (zb(c)) throw (k2(), Error(n(418)));
      for (; u; ) R2(c, u), (u = za(u.nextSibling));
    }
    if ((O2(c), c.tag === 13)) {
      if (((c = c.memoizedState), (c = c !== null ? c.dehydrated : null), !c))
        throw Error(n(317));
      e: {
        for (c = c.nextSibling, u = 0; c; ) {
          if (c.nodeType === 8) {
            var h = c.data;
            if (h === "/$") {
              if (u === 0) {
                Oi = za(c.nextSibling);
                break e;
              }
              u--;
            } else (h !== "$" && h !== "$!" && h !== "$?") || u++;
          }
          c = c.nextSibling;
        }
        Oi = null;
      }
    } else Oi = Ni ? za(c.stateNode.nextSibling) : null;
    return !0;
  }
  function k2() {
    for (var c = Oi; c; ) c = za(c.nextSibling);
  }
  function Ru() {
    (Oi = Ni = null), (mn = !1);
  }
  function Hb(c) {
    Rs === null ? (Rs = [c]) : Rs.push(c);
  }
  var b4 = _.ReactCurrentBatchConfig;
  function cf(c, u, h) {
    if (
      ((c = h.ref),
      c !== null && typeof c != "function" && typeof c != "object")
    ) {
      if (h._owner) {
        if (((h = h._owner), h)) {
          if (h.tag !== 1) throw Error(n(309));
          var w = h.stateNode;
        }
        if (!w) throw Error(n(147, c));
        var x = w,
          P = "" + c;
        return u !== null &&
          u.ref !== null &&
          typeof u.ref == "function" &&
          u.ref._stringRef === P
          ? u.ref
          : ((u = function (L) {
              var G = x.refs;
              L === null ? delete G[P] : (G[P] = L);
            }),
            (u._stringRef = P),
            u);
      }
      if (typeof c != "string") throw Error(n(284));
      if (!h._owner) throw Error(n(290, c));
    }
    return c;
  }
  function Xg(c, u) {
    throw (
      ((c = Object.prototype.toString.call(u)),
      Error(
        n(
          31,
          c === "[object Object]"
            ? "object with keys {" + Object.keys(u).join(", ") + "}"
            : c
        )
      ))
    );
  }
  function D2(c) {
    var u = c._init;
    return u(c._payload);
  }
  function $2(c) {
    function u(te, X) {
      if (c) {
        var ne = te.deletions;
        ne === null ? ((te.deletions = [X]), (te.flags |= 16)) : ne.push(X);
      }
    }
    function h(te, X) {
      if (!c) return null;
      for (; X !== null; ) u(te, X), (X = X.sibling);
      return null;
    }
    function w(te, X) {
      for (te = new Map(); X !== null; )
        X.key !== null ? te.set(X.key, X) : te.set(X.index, X), (X = X.sibling);
      return te;
    }
    function x(te, X) {
      return (te = Ja(te, X)), (te.index = 0), (te.sibling = null), te;
    }
    function P(te, X, ne) {
      return (
        (te.index = ne),
        c
          ? ((ne = te.alternate),
            ne !== null
              ? ((ne = ne.index), ne < X ? ((te.flags |= 2), X) : ne)
              : ((te.flags |= 2), X))
          : ((te.flags |= 1048576), X)
      );
    }
    function L(te) {
      return c && te.alternate === null && (te.flags |= 2), te;
    }
    function G(te, X, ne, we) {
      return X === null || X.tag !== 6
        ? ((X = $1(ne, te.mode, we)), (X.return = te), X)
        : ((X = x(X, ne)), (X.return = te), X);
    }
    function Q(te, X, ne, we) {
      var ze = ne.type;
      return ze === R
        ? de(te, X, ne.props.children, we, ne.key)
        : X !== null &&
          (X.elementType === ze ||
            (typeof ze == "object" &&
              ze !== null &&
              ze.$$typeof === M &&
              D2(ze) === X.type))
        ? ((we = x(X, ne.props)),
          (we.ref = cf(te, X, ne)),
          (we.return = te),
          we)
        : ((we = Cy(ne.type, ne.key, ne.props, null, te.mode, we)),
          (we.ref = cf(te, X, ne)),
          (we.return = te),
          we);
    }
    function ie(te, X, ne, we) {
      return X === null ||
        X.tag !== 4 ||
        X.stateNode.containerInfo !== ne.containerInfo ||
        X.stateNode.implementation !== ne.implementation
        ? ((X = M1(ne, te.mode, we)), (X.return = te), X)
        : ((X = x(X, ne.children || [])), (X.return = te), X);
    }
    function de(te, X, ne, we, ze) {
      return X === null || X.tag !== 7
        ? ((X = cl(ne, te.mode, we, ze)), (X.return = te), X)
        : ((X = x(X, ne)), (X.return = te), X);
    }
    function he(te, X, ne) {
      if ((typeof X == "string" && X !== "") || typeof X == "number")
        return (X = $1("" + X, te.mode, ne)), (X.return = te), X;
      if (typeof X == "object" && X !== null) {
        switch (X.$$typeof) {
          case A:
            return (
              (ne = Cy(X.type, X.key, X.props, null, te.mode, ne)),
              (ne.ref = cf(te, null, X)),
              (ne.return = te),
              ne
            );
          case I:
            return (X = M1(X, te.mode, ne)), (X.return = te), X;
          case M:
            var we = X._init;
            return he(te, we(X._payload), ne);
        }
        if (At(X) || j(X))
          return (X = cl(X, te.mode, ne, null)), (X.return = te), X;
        Xg(te, X);
      }
      return null;
    }
    function ue(te, X, ne, we) {
      var ze = X !== null ? X.key : null;
      if ((typeof ne == "string" && ne !== "") || typeof ne == "number")
        return ze !== null ? null : G(te, X, "" + ne, we);
      if (typeof ne == "object" && ne !== null) {
        switch (ne.$$typeof) {
          case A:
            return ne.key === ze ? Q(te, X, ne, we) : null;
          case I:
            return ne.key === ze ? ie(te, X, ne, we) : null;
          case M:
            return (ze = ne._init), ue(te, X, ze(ne._payload), we);
        }
        if (At(ne) || j(ne))
          return ze !== null ? null : de(te, X, ne, we, null);
        Xg(te, ne);
      }
      return null;
    }
    function _e(te, X, ne, we, ze) {
      if ((typeof we == "string" && we !== "") || typeof we == "number")
        return (te = te.get(ne) || null), G(X, te, "" + we, ze);
      if (typeof we == "object" && we !== null) {
        switch (we.$$typeof) {
          case A:
            return (
              (te = te.get(we.key === null ? ne : we.key) || null),
              Q(X, te, we, ze)
            );
          case I:
            return (
              (te = te.get(we.key === null ? ne : we.key) || null),
              ie(X, te, we, ze)
            );
          case M:
            var Ge = we._init;
            return _e(te, X, ne, Ge(we._payload), ze);
        }
        if (At(we) || j(we))
          return (te = te.get(ne) || null), de(X, te, we, ze, null);
        Xg(X, we);
      }
      return null;
    }
    function Ue(te, X, ne, we) {
      for (
        var ze = null, Ge = null, Ke = X, et = (X = 0), ar = null;
        Ke !== null && et < ne.length;
        et++
      ) {
        Ke.index > et ? ((ar = Ke), (Ke = null)) : (ar = Ke.sibling);
        var Pt = ue(te, Ke, ne[et], we);
        if (Pt === null) {
          Ke === null && (Ke = ar);
          break;
        }
        c && Ke && Pt.alternate === null && u(te, Ke),
          (X = P(Pt, X, et)),
          Ge === null ? (ze = Pt) : (Ge.sibling = Pt),
          (Ge = Pt),
          (Ke = ar);
      }
      if (et === ne.length) return h(te, Ke), mn && el(te, et), ze;
      if (Ke === null) {
        for (; et < ne.length; et++)
          (Ke = he(te, ne[et], we)),
            Ke !== null &&
              ((X = P(Ke, X, et)),
              Ge === null ? (ze = Ke) : (Ge.sibling = Ke),
              (Ge = Ke));
        return mn && el(te, et), ze;
      }
      for (Ke = w(te, Ke); et < ne.length; et++)
        (ar = _e(Ke, te, et, ne[et], we)),
          ar !== null &&
            (c &&
              ar.alternate !== null &&
              Ke.delete(ar.key === null ? et : ar.key),
            (X = P(ar, X, et)),
            Ge === null ? (ze = ar) : (Ge.sibling = ar),
            (Ge = ar));
      return (
        c &&
          Ke.forEach(function (ec) {
            return u(te, ec);
          }),
        mn && el(te, et),
        ze
      );
    }
    function Fe(te, X, ne, we) {
      var ze = j(ne);
      if (typeof ze != "function") throw Error(n(150));
      if (((ne = ze.call(ne)), ne == null)) throw Error(n(151));
      for (
        var Ge = (ze = null), Ke = X, et = (X = 0), ar = null, Pt = ne.next();
        Ke !== null && !Pt.done;
        et++, Pt = ne.next()
      ) {
        Ke.index > et ? ((ar = Ke), (Ke = null)) : (ar = Ke.sibling);
        var ec = ue(te, Ke, Pt.value, we);
        if (ec === null) {
          Ke === null && (Ke = ar);
          break;
        }
        c && Ke && ec.alternate === null && u(te, Ke),
          (X = P(ec, X, et)),
          Ge === null ? (ze = ec) : (Ge.sibling = ec),
          (Ge = ec),
          (Ke = ar);
      }
      if (Pt.done) return h(te, Ke), mn && el(te, et), ze;
      if (Ke === null) {
        for (; !Pt.done; et++, Pt = ne.next())
          (Pt = he(te, Pt.value, we)),
            Pt !== null &&
              ((X = P(Pt, X, et)),
              Ge === null ? (ze = Pt) : (Ge.sibling = Pt),
              (Ge = Pt));
        return mn && el(te, et), ze;
      }
      for (Ke = w(te, Ke); !Pt.done; et++, Pt = ne.next())
        (Pt = _e(Ke, te, et, Pt.value, we)),
          Pt !== null &&
            (c &&
              Pt.alternate !== null &&
              Ke.delete(Pt.key === null ? et : Pt.key),
            (X = P(Pt, X, et)),
            Ge === null ? (ze = Pt) : (Ge.sibling = Pt),
            (Ge = Pt));
      return (
        c &&
          Ke.forEach(function (X4) {
            return u(te, X4);
          }),
        mn && el(te, et),
        ze
      );
    }
    function $n(te, X, ne, we) {
      if (
        (typeof ne == "object" &&
          ne !== null &&
          ne.type === R &&
          ne.key === null &&
          (ne = ne.props.children),
        typeof ne == "object" && ne !== null)
      ) {
        switch (ne.$$typeof) {
          case A:
            e: {
              for (var ze = ne.key, Ge = X; Ge !== null; ) {
                if (Ge.key === ze) {
                  if (((ze = ne.type), ze === R)) {
                    if (Ge.tag === 7) {
                      h(te, Ge.sibling),
                        (X = x(Ge, ne.props.children)),
                        (X.return = te),
                        (te = X);
                      break e;
                    }
                  } else if (
                    Ge.elementType === ze ||
                    (typeof ze == "object" &&
                      ze !== null &&
                      ze.$$typeof === M &&
                      D2(ze) === Ge.type)
                  ) {
                    h(te, Ge.sibling),
                      (X = x(Ge, ne.props)),
                      (X.ref = cf(te, Ge, ne)),
                      (X.return = te),
                      (te = X);
                    break e;
                  }
                  h(te, Ge);
                  break;
                } else u(te, Ge);
                Ge = Ge.sibling;
              }
              ne.type === R
                ? ((X = cl(ne.props.children, te.mode, we, ne.key)),
                  (X.return = te),
                  (te = X))
                : ((we = Cy(ne.type, ne.key, ne.props, null, te.mode, we)),
                  (we.ref = cf(te, X, ne)),
                  (we.return = te),
                  (te = we));
            }
            return L(te);
          case I:
            e: {
              for (Ge = ne.key; X !== null; ) {
                if (X.key === Ge)
                  if (
                    X.tag === 4 &&
                    X.stateNode.containerInfo === ne.containerInfo &&
                    X.stateNode.implementation === ne.implementation
                  ) {
                    h(te, X.sibling),
                      (X = x(X, ne.children || [])),
                      (X.return = te),
                      (te = X);
                    break e;
                  } else {
                    h(te, X);
                    break;
                  }
                else u(te, X);
                X = X.sibling;
              }
              (X = M1(ne, te.mode, we)), (X.return = te), (te = X);
            }
            return L(te);
          case M:
            return (Ge = ne._init), $n(te, X, Ge(ne._payload), we);
        }
        if (At(ne)) return Ue(te, X, ne, we);
        if (j(ne)) return Fe(te, X, ne, we);
        Xg(te, ne);
      }
      return (typeof ne == "string" && ne !== "") || typeof ne == "number"
        ? ((ne = "" + ne),
          X !== null && X.tag === 6
            ? (h(te, X.sibling), (X = x(X, ne)), (X.return = te), (te = X))
            : (h(te, X), (X = $1(ne, te.mode, we)), (X.return = te), (te = X)),
          L(te))
        : h(te, X);
    }
    return $n;
  }
  var Nu = $2(!0),
    M2 = $2(!1),
    Jg = Wa(null),
    ey = null,
    Ou = null,
    qb = null;
  function Vb() {
    qb = Ou = ey = null;
  }
  function Gb(c) {
    var u = Jg.current;
    ln(Jg), (c._currentValue = u);
  }
  function Kb(c, u, h) {
    for (; c !== null; ) {
      var w = c.alternate;
      if (
        ((c.childLanes & u) !== u
          ? ((c.childLanes |= u), w !== null && (w.childLanes |= u))
          : w !== null && (w.childLanes & u) !== u && (w.childLanes |= u),
        c === h)
      )
        break;
      c = c.return;
    }
  }
  function ku(c, u) {
    (ey = c),
      (qb = Ou = null),
      (c = c.dependencies),
      c !== null &&
        c.firstContext !== null &&
        (c.lanes & u && (li = !0), (c.firstContext = null));
  }
  function Xi(c) {
    var u = c._currentValue;
    if (qb !== c)
      if (((c = { context: c, memoizedValue: u, next: null }), Ou === null)) {
        if (ey === null) throw Error(n(308));
        (Ou = c), (ey.dependencies = { lanes: 0, firstContext: c });
      } else Ou = Ou.next = c;
    return u;
  }
  var tl = null;
  function Yb(c) {
    tl === null ? (tl = [c]) : tl.push(c);
  }
  function L2(c, u, h, w) {
    var x = u.interleaved;
    return (
      x === null ? ((h.next = h), Yb(u)) : ((h.next = x.next), (x.next = h)),
      (u.interleaved = h),
      qo(c, w)
    );
  }
  function qo(c, u) {
    c.lanes |= u;
    var h = c.alternate;
    for (h !== null && (h.lanes |= u), h = c, c = c.return; c !== null; )
      (c.childLanes |= u),
        (h = c.alternate),
        h !== null && (h.childLanes |= u),
        (h = c),
        (c = c.return);
    return h.tag === 3 ? h.stateNode : null;
  }
  var Va = !1;
  function Zb(c) {
    c.updateQueue = {
      baseState: c.memoizedState,
      firstBaseUpdate: null,
      lastBaseUpdate: null,
      shared: { pending: null, interleaved: null, lanes: 0 },
      effects: null,
    };
  }
  function U2(c, u) {
    (c = c.updateQueue),
      u.updateQueue === c &&
        (u.updateQueue = {
          baseState: c.baseState,
          firstBaseUpdate: c.firstBaseUpdate,
          lastBaseUpdate: c.lastBaseUpdate,
          shared: c.shared,
          effects: c.effects,
        });
  }
  function Vo(c, u) {
    return {
      eventTime: c,
      lane: u,
      tag: 0,
      payload: null,
      callback: null,
      next: null,
    };
  }
  function Ga(c, u, h) {
    var w = c.updateQueue;
    if (w === null) return null;
    if (((w = w.shared), Tt & 2)) {
      var x = w.pending;
      return (
        x === null ? (u.next = u) : ((u.next = x.next), (x.next = u)),
        (w.pending = u),
        qo(c, h)
      );
    }
    return (
      (x = w.interleaved),
      x === null ? ((u.next = u), Yb(w)) : ((u.next = x.next), (x.next = u)),
      (w.interleaved = u),
      qo(c, h)
    );
  }
  function ty(c, u, h) {
    if (
      ((u = u.updateQueue), u !== null && ((u = u.shared), (h & 4194240) !== 0))
    ) {
      var w = u.lanes;
      (w &= c.pendingLanes), (h |= w), (u.lanes = h), ub(c, h);
    }
  }
  function B2(c, u) {
    var h = c.updateQueue,
      w = c.alternate;
    if (w !== null && ((w = w.updateQueue), h === w)) {
      var x = null,
        P = null;
      if (((h = h.firstBaseUpdate), h !== null)) {
        do {
          var L = {
            eventTime: h.eventTime,
            lane: h.lane,
            tag: h.tag,
            payload: h.payload,
            callback: h.callback,
            next: null,
          };
          P === null ? (x = P = L) : (P = P.next = L), (h = h.next);
        } while (h !== null);
        P === null ? (x = P = u) : (P = P.next = u);
      } else x = P = u;
      (h = {
        baseState: w.baseState,
        firstBaseUpdate: x,
        lastBaseUpdate: P,
        shared: w.shared,
        effects: w.effects,
      }),
        (c.updateQueue = h);
      return;
    }
    (c = h.lastBaseUpdate),
      c === null ? (h.firstBaseUpdate = u) : (c.next = u),
      (h.lastBaseUpdate = u);
  }
  function ny(c, u, h, w) {
    var x = c.updateQueue;
    Va = !1;
    var P = x.firstBaseUpdate,
      L = x.lastBaseUpdate,
      G = x.shared.pending;
    if (G !== null) {
      x.shared.pending = null;
      var Q = G,
        ie = Q.next;
      (Q.next = null), L === null ? (P = ie) : (L.next = ie), (L = Q);
      var de = c.alternate;
      de !== null &&
        ((de = de.updateQueue),
        (G = de.lastBaseUpdate),
        G !== L &&
          (G === null ? (de.firstBaseUpdate = ie) : (G.next = ie),
          (de.lastBaseUpdate = Q)));
    }
    if (P !== null) {
      var he = x.baseState;
      (L = 0), (de = ie = Q = null), (G = P);
      do {
        var ue = G.lane,
          _e = G.eventTime;
        if ((w & ue) === ue) {
          de !== null &&
            (de = de.next =
              {
                eventTime: _e,
                lane: 0,
                tag: G.tag,
                payload: G.payload,
                callback: G.callback,
                next: null,
              });
          e: {
            var Ue = c,
              Fe = G;
            switch (((ue = u), (_e = h), Fe.tag)) {
              case 1:
                if (((Ue = Fe.payload), typeof Ue == "function")) {
                  he = Ue.call(_e, he, ue);
                  break e;
                }
                he = Ue;
                break e;
              case 3:
                Ue.flags = (Ue.flags & -65537) | 128;
              case 0:
                if (
                  ((Ue = Fe.payload),
                  (ue = typeof Ue == "function" ? Ue.call(_e, he, ue) : Ue),
                  ue == null)
                )
                  break e;
                he = V({}, he, ue);
                break e;
              case 2:
                Va = !0;
            }
          }
          G.callback !== null &&
            G.lane !== 0 &&
            ((c.flags |= 64),
            (ue = x.effects),
            ue === null ? (x.effects = [G]) : ue.push(G));
        } else
          (_e = {
            eventTime: _e,
            lane: ue,
            tag: G.tag,
            payload: G.payload,
            callback: G.callback,
            next: null,
          }),
            de === null ? ((ie = de = _e), (Q = he)) : (de = de.next = _e),
            (L |= ue);
        if (((G = G.next), G === null)) {
          if (((G = x.shared.pending), G === null)) break;
          (ue = G),
            (G = ue.next),
            (ue.next = null),
            (x.lastBaseUpdate = ue),
            (x.shared.pending = null);
        }
      } while (!0);
      if (
        (de === null && (Q = he),
        (x.baseState = Q),
        (x.firstBaseUpdate = ie),
        (x.lastBaseUpdate = de),
        (u = x.shared.interleaved),
        u !== null)
      ) {
        x = u;
        do (L |= x.lane), (x = x.next);
        while (x !== u);
      } else P === null && (x.shared.lanes = 0);
      (il |= L), (c.lanes = L), (c.memoizedState = he);
    }
  }
  function j2(c, u, h) {
    if (((c = u.effects), (u.effects = null), c !== null))
      for (u = 0; u < c.length; u++) {
        var w = c[u],
          x = w.callback;
        if (x !== null) {
          if (((w.callback = null), (w = h), typeof x != "function"))
            throw Error(n(191, x));
          x.call(w);
        }
      }
  }
  var lf = {},
    io = Wa(lf),
    uf = Wa(lf),
    df = Wa(lf);
  function nl(c) {
    if (c === lf) throw Error(n(174));
    return c;
  }
  function Qb(c, u) {
    switch ((nn(df, u), nn(uf, c), nn(io, lf), (c = u.nodeType), c)) {
      case 9:
      case 11:
        u = (u = u.documentElement) ? u.namespaceURI : rr(null, "");
        break;
      default:
        (c = c === 8 ? u.parentNode : u),
          (u = c.namespaceURI || null),
          (c = c.tagName),
          (u = rr(u, c));
    }
    ln(io), nn(io, u);
  }
  function Du() {
    ln(io), ln(uf), ln(df);
  }
  function F2(c) {
    nl(df.current);
    var u = nl(io.current),
      h = rr(u, c.type);
    u !== h && (nn(uf, c), nn(io, h));
  }
  function Xb(c) {
    uf.current === c && (ln(io), ln(uf));
  }
  var En = Wa(0);
  function ry(c) {
    for (var u = c; u !== null; ) {
      if (u.tag === 13) {
        var h = u.memoizedState;
        if (
          h !== null &&
          ((h = h.dehydrated), h === null || h.data === "$?" || h.data === "$!")
        )
          return u;
      } else if (u.tag === 19 && u.memoizedProps.revealOrder !== void 0) {
        if (u.flags & 128) return u;
      } else if (u.child !== null) {
        (u.child.return = u), (u = u.child);
        continue;
      }
      if (u === c) break;
      for (; u.sibling === null; ) {
        if (u.return === null || u.return === c) return null;
        u = u.return;
      }
      (u.sibling.return = u.return), (u = u.sibling);
    }
    return null;
  }
  var Jb = [];
  function e1() {
    for (var c = 0; c < Jb.length; c++)
      Jb[c]._workInProgressVersionPrimary = null;
    Jb.length = 0;
  }
  var iy = _.ReactCurrentDispatcher,
    t1 = _.ReactCurrentBatchConfig,
    rl = 0,
    Cn = null,
    Gn = null,
    sr = null,
    sy = !1,
    pf = !1,
    ff = 0,
    E4 = 0;
  function Lr() {
    throw Error(n(321));
  }
  function n1(c, u) {
    if (u === null) return !1;
    for (var h = 0; h < u.length && h < c.length; h++)
      if (!Ps(c[h], u[h])) return !1;
    return !0;
  }
  function r1(c, u, h, w, x, P) {
    if (
      ((rl = P),
      (Cn = u),
      (u.memoizedState = null),
      (u.updateQueue = null),
      (u.lanes = 0),
      (iy.current = c === null || c.memoizedState === null ? A4 : _4),
      (c = h(w, x)),
      pf)
    ) {
      P = 0;
      do {
        if (((pf = !1), (ff = 0), 25 <= P)) throw Error(n(301));
        (P += 1),
          (sr = Gn = null),
          (u.updateQueue = null),
          (iy.current = I4),
          (c = h(w, x));
      } while (pf);
    }
    if (
      ((iy.current = cy),
      (u = Gn !== null && Gn.next !== null),
      (rl = 0),
      (sr = Gn = Cn = null),
      (sy = !1),
      u)
    )
      throw Error(n(300));
    return c;
  }
  function i1() {
    var c = ff !== 0;
    return (ff = 0), c;
  }
  function so() {
    var c = {
      memoizedState: null,
      baseState: null,
      baseQueue: null,
      queue: null,
      next: null,
    };
    return sr === null ? (Cn.memoizedState = sr = c) : (sr = sr.next = c), sr;
  }
  function Ji() {
    if (Gn === null) {
      var c = Cn.alternate;
      c = c !== null ? c.memoizedState : null;
    } else c = Gn.next;
    var u = sr === null ? Cn.memoizedState : sr.next;
    if (u !== null) (sr = u), (Gn = c);
    else {
      if (c === null) throw Error(n(310));
      (Gn = c),
        (c = {
          memoizedState: Gn.memoizedState,
          baseState: Gn.baseState,
          baseQueue: Gn.baseQueue,
          queue: Gn.queue,
          next: null,
        }),
        sr === null ? (Cn.memoizedState = sr = c) : (sr = sr.next = c);
    }
    return sr;
  }
  function hf(c, u) {
    return typeof u == "function" ? u(c) : u;
  }
  function s1(c) {
    var u = Ji(),
      h = u.queue;
    if (h === null) throw Error(n(311));
    h.lastRenderedReducer = c;
    var w = Gn,
      x = w.baseQueue,
      P = h.pending;
    if (P !== null) {
      if (x !== null) {
        var L = x.next;
        (x.next = P.next), (P.next = L);
      }
      (w.baseQueue = x = P), (h.pending = null);
    }
    if (x !== null) {
      (P = x.next), (w = w.baseState);
      var G = (L = null),
        Q = null,
        ie = P;
      do {
        var de = ie.lane;
        if ((rl & de) === de)
          Q !== null &&
            (Q = Q.next =
              {
                lane: 0,
                action: ie.action,
                hasEagerState: ie.hasEagerState,
                eagerState: ie.eagerState,
                next: null,
              }),
            (w = ie.hasEagerState ? ie.eagerState : c(w, ie.action));
        else {
          var he = {
            lane: de,
            action: ie.action,
            hasEagerState: ie.hasEagerState,
            eagerState: ie.eagerState,
            next: null,
          };
          Q === null ? ((G = Q = he), (L = w)) : (Q = Q.next = he),
            (Cn.lanes |= de),
            (il |= de);
        }
        ie = ie.next;
      } while (ie !== null && ie !== P);
      Q === null ? (L = w) : (Q.next = G),
        Ps(w, u.memoizedState) || (li = !0),
        (u.memoizedState = w),
        (u.baseState = L),
        (u.baseQueue = Q),
        (h.lastRenderedState = w);
    }
    if (((c = h.interleaved), c !== null)) {
      x = c;
      do (P = x.lane), (Cn.lanes |= P), (il |= P), (x = x.next);
      while (x !== c);
    } else x === null && (h.lanes = 0);
    return [u.memoizedState, h.dispatch];
  }
  function o1(c) {
    var u = Ji(),
      h = u.queue;
    if (h === null) throw Error(n(311));
    h.lastRenderedReducer = c;
    var w = h.dispatch,
      x = h.pending,
      P = u.memoizedState;
    if (x !== null) {
      h.pending = null;
      var L = (x = x.next);
      do (P = c(P, L.action)), (L = L.next);
      while (L !== x);
      Ps(P, u.memoizedState) || (li = !0),
        (u.memoizedState = P),
        u.baseQueue === null && (u.baseState = P),
        (h.lastRenderedState = P);
    }
    return [P, w];
  }
  function z2() {}
  function W2(c, u) {
    var h = Cn,
      w = Ji(),
      x = u(),
      P = !Ps(w.memoizedState, x);
    if (
      (P && ((w.memoizedState = x), (li = !0)),
      (w = w.queue),
      a1(V2.bind(null, h, w, c), [c]),
      w.getSnapshot !== u || P || (sr !== null && sr.memoizedState.tag & 1))
    ) {
      if (
        ((h.flags |= 2048),
        mf(9, q2.bind(null, h, w, x, u), void 0, null),
        or === null)
      )
        throw Error(n(349));
      rl & 30 || H2(h, u, x);
    }
    return x;
  }
  function H2(c, u, h) {
    (c.flags |= 16384),
      (c = { getSnapshot: u, value: h }),
      (u = Cn.updateQueue),
      u === null
        ? ((u = { lastEffect: null, stores: null }),
          (Cn.updateQueue = u),
          (u.stores = [c]))
        : ((h = u.stores), h === null ? (u.stores = [c]) : h.push(c));
  }
  function q2(c, u, h, w) {
    (u.value = h), (u.getSnapshot = w), G2(u) && K2(c);
  }
  function V2(c, u, h) {
    return h(function () {
      G2(u) && K2(c);
    });
  }
  function G2(c) {
    var u = c.getSnapshot;
    c = c.value;
    try {
      var h = u();
      return !Ps(c, h);
    } catch {
      return !0;
    }
  }
  function K2(c) {
    var u = qo(c, 1);
    u !== null && Ds(u, c, 1, -1);
  }
  function Y2(c) {
    var u = so();
    return (
      typeof c == "function" && (c = c()),
      (u.memoizedState = u.baseState = c),
      (c = {
        pending: null,
        interleaved: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: hf,
        lastRenderedState: c,
      }),
      (u.queue = c),
      (c = c.dispatch = S4.bind(null, Cn, c)),
      [u.memoizedState, c]
    );
  }
  function mf(c, u, h, w) {
    return (
      (c = { tag: c, create: u, destroy: h, deps: w, next: null }),
      (u = Cn.updateQueue),
      u === null
        ? ((u = { lastEffect: null, stores: null }),
          (Cn.updateQueue = u),
          (u.lastEffect = c.next = c))
        : ((h = u.lastEffect),
          h === null
            ? (u.lastEffect = c.next = c)
            : ((w = h.next), (h.next = c), (c.next = w), (u.lastEffect = c))),
      c
    );
  }
  function Z2() {
    return Ji().memoizedState;
  }
  function oy(c, u, h, w) {
    var x = so();
    (Cn.flags |= c),
      (x.memoizedState = mf(1 | u, h, void 0, w === void 0 ? null : w));
  }
  function ay(c, u, h, w) {
    var x = Ji();
    w = w === void 0 ? null : w;
    var P = void 0;
    if (Gn !== null) {
      var L = Gn.memoizedState;
      if (((P = L.destroy), w !== null && n1(w, L.deps))) {
        x.memoizedState = mf(u, h, P, w);
        return;
      }
    }
    (Cn.flags |= c), (x.memoizedState = mf(1 | u, h, P, w));
  }
  function Q2(c, u) {
    return oy(8390656, 8, c, u);
  }
  function a1(c, u) {
    return ay(2048, 8, c, u);
  }
  function X2(c, u) {
    return ay(4, 2, c, u);
  }
  function J2(c, u) {
    return ay(4, 4, c, u);
  }
  function eI(c, u) {
    if (typeof u == "function")
      return (
        (c = c()),
        u(c),
        function () {
          u(null);
        }
      );
    if (u != null)
      return (
        (c = c()),
        (u.current = c),
        function () {
          u.current = null;
        }
      );
  }
  function tI(c, u, h) {
    return (
      (h = h != null ? h.concat([c]) : null), ay(4, 4, eI.bind(null, u, c), h)
    );
  }
  function c1() {}
  function nI(c, u) {
    var h = Ji();
    u = u === void 0 ? null : u;
    var w = h.memoizedState;
    return w !== null && u !== null && n1(u, w[1])
      ? w[0]
      : ((h.memoizedState = [c, u]), c);
  }
  function rI(c, u) {
    var h = Ji();
    u = u === void 0 ? null : u;
    var w = h.memoizedState;
    return w !== null && u !== null && n1(u, w[1])
      ? w[0]
      : ((c = c()), (h.memoizedState = [c, u]), c);
  }
  function iI(c, u, h) {
    return rl & 21
      ? (Ps(h, u) ||
          ((h = D_()), (Cn.lanes |= h), (il |= h), (c.baseState = !0)),
        u)
      : (c.baseState && ((c.baseState = !1), (li = !0)), (c.memoizedState = h));
  }
  function C4(c, u) {
    var h = Ht;
    (Ht = h !== 0 && 4 > h ? h : 4), c(!0);
    var w = t1.transition;
    t1.transition = {};
    try {
      c(!1), u();
    } finally {
      (Ht = h), (t1.transition = w);
    }
  }
  function sI() {
    return Ji().memoizedState;
  }
  function x4(c, u, h) {
    var w = Qa(c);
    if (
      ((h = {
        lane: w,
        action: h,
        hasEagerState: !1,
        eagerState: null,
        next: null,
      }),
      oI(c))
    )
      aI(u, h);
    else if (((h = L2(c, u, h, w)), h !== null)) {
      var x = Qr();
      Ds(h, c, w, x), cI(h, u, w);
    }
  }
  function S4(c, u, h) {
    var w = Qa(c),
      x = {
        lane: w,
        action: h,
        hasEagerState: !1,
        eagerState: null,
        next: null,
      };
    if (oI(c)) aI(u, x);
    else {
      var P = c.alternate;
      if (
        c.lanes === 0 &&
        (P === null || P.lanes === 0) &&
        ((P = u.lastRenderedReducer), P !== null)
      )
        try {
          var L = u.lastRenderedState,
            G = P(L, h);
          if (((x.hasEagerState = !0), (x.eagerState = G), Ps(G, L))) {
            var Q = u.interleaved;
            Q === null
              ? ((x.next = x), Yb(u))
              : ((x.next = Q.next), (Q.next = x)),
              (u.interleaved = x);
            return;
          }
        } catch {
        } finally {
        }
      (h = L2(c, u, x, w)),
        h !== null && ((x = Qr()), Ds(h, c, w, x), cI(h, u, w));
    }
  }
  function oI(c) {
    var u = c.alternate;
    return c === Cn || (u !== null && u === Cn);
  }
  function aI(c, u) {
    pf = sy = !0;
    var h = c.pending;
    h === null ? (u.next = u) : ((u.next = h.next), (h.next = u)),
      (c.pending = u);
  }
  function cI(c, u, h) {
    if (h & 4194240) {
      var w = u.lanes;
      (w &= c.pendingLanes), (h |= w), (u.lanes = h), ub(c, h);
    }
  }
  var cy = {
      readContext: Xi,
      useCallback: Lr,
      useContext: Lr,
      useEffect: Lr,
      useImperativeHandle: Lr,
      useInsertionEffect: Lr,
      useLayoutEffect: Lr,
      useMemo: Lr,
      useReducer: Lr,
      useRef: Lr,
      useState: Lr,
      useDebugValue: Lr,
      useDeferredValue: Lr,
      useTransition: Lr,
      useMutableSource: Lr,
      useSyncExternalStore: Lr,
      useId: Lr,
      unstable_isNewReconciler: !1,
    },
    A4 = {
      readContext: Xi,
      useCallback: function (c, u) {
        return (so().memoizedState = [c, u === void 0 ? null : u]), c;
      },
      useContext: Xi,
      useEffect: Q2,
      useImperativeHandle: function (c, u, h) {
        return (
          (h = h != null ? h.concat([c]) : null),
          oy(4194308, 4, eI.bind(null, u, c), h)
        );
      },
      useLayoutEffect: function (c, u) {
        return oy(4194308, 4, c, u);
      },
      useInsertionEffect: function (c, u) {
        return oy(4, 2, c, u);
      },
      useMemo: function (c, u) {
        var h = so();
        return (
          (u = u === void 0 ? null : u),
          (c = c()),
          (h.memoizedState = [c, u]),
          c
        );
      },
      useReducer: function (c, u, h) {
        var w = so();
        return (
          (u = h !== void 0 ? h(u) : u),
          (w.memoizedState = w.baseState = u),
          (c = {
            pending: null,
            interleaved: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: c,
            lastRenderedState: u,
          }),
          (w.queue = c),
          (c = c.dispatch = x4.bind(null, Cn, c)),
          [w.memoizedState, c]
        );
      },
      useRef: function (c) {
        var u = so();
        return (c = { current: c }), (u.memoizedState = c);
      },
      useState: Y2,
      useDebugValue: c1,
      useDeferredValue: function (c) {
        return (so().memoizedState = c);
      },
      useTransition: function () {
        var c = Y2(!1),
          u = c[0];
        return (c = C4.bind(null, c[1])), (so().memoizedState = c), [u, c];
      },
      useMutableSource: function () {},
      useSyncExternalStore: function (c, u, h) {
        var w = Cn,
          x = so();
        if (mn) {
          if (h === void 0) throw Error(n(407));
          h = h();
        } else {
          if (((h = u()), or === null)) throw Error(n(349));
          rl & 30 || H2(w, u, h);
        }
        x.memoizedState = h;
        var P = { value: h, getSnapshot: u };
        return (
          (x.queue = P),
          Q2(V2.bind(null, w, P, c), [c]),
          (w.flags |= 2048),
          mf(9, q2.bind(null, w, P, h, u), void 0, null),
          h
        );
      },
      useId: function () {
        var c = so(),
          u = or.identifierPrefix;
        if (mn) {
          var h = Ho,
            w = Wo;
          (h = (w & ~(1 << (32 - Ts(w) - 1))).toString(32) + h),
            (u = ":" + u + "R" + h),
            (h = ff++),
            0 < h && (u += "H" + h.toString(32)),
            (u += ":");
        } else (h = E4++), (u = ":" + u + "r" + h.toString(32) + ":");
        return (c.memoizedState = u);
      },
      unstable_isNewReconciler: !1,
    },
    _4 = {
      readContext: Xi,
      useCallback: nI,
      useContext: Xi,
      useEffect: a1,
      useImperativeHandle: tI,
      useInsertionEffect: X2,
      useLayoutEffect: J2,
      useMemo: rI,
      useReducer: s1,
      useRef: Z2,
      useState: function () {
        return s1(hf);
      },
      useDebugValue: c1,
      useDeferredValue: function (c) {
        var u = Ji();
        return iI(u, Gn.memoizedState, c);
      },
      useTransition: function () {
        var c = s1(hf)[0],
          u = Ji().memoizedState;
        return [c, u];
      },
      useMutableSource: z2,
      useSyncExternalStore: W2,
      useId: sI,
      unstable_isNewReconciler: !1,
    },
    I4 = {
      readContext: Xi,
      useCallback: nI,
      useContext: Xi,
      useEffect: a1,
      useImperativeHandle: tI,
      useInsertionEffect: X2,
      useLayoutEffect: J2,
      useMemo: rI,
      useReducer: o1,
      useRef: Z2,
      useState: function () {
        return o1(hf);
      },
      useDebugValue: c1,
      useDeferredValue: function (c) {
        var u = Ji();
        return Gn === null ? (u.memoizedState = c) : iI(u, Gn.memoizedState, c);
      },
      useTransition: function () {
        var c = o1(hf)[0],
          u = Ji().memoizedState;
        return [c, u];
      },
      useMutableSource: z2,
      useSyncExternalStore: W2,
      useId: sI,
      unstable_isNewReconciler: !1,
    };
  function Ns(c, u) {
    if (c && c.defaultProps) {
      (u = V({}, u)), (c = c.defaultProps);
      for (var h in c) u[h] === void 0 && (u[h] = c[h]);
      return u;
    }
    return u;
  }
  function l1(c, u, h, w) {
    (u = c.memoizedState),
      (h = h(w, u)),
      (h = h == null ? u : V({}, u, h)),
      (c.memoizedState = h),
      c.lanes === 0 && (c.updateQueue.baseState = h);
  }
  var ly = {
    isMounted: function (c) {
      return (c = c._reactInternals) ? Zc(c) === c : !1;
    },
    enqueueSetState: function (c, u, h) {
      c = c._reactInternals;
      var w = Qr(),
        x = Qa(c),
        P = Vo(w, x);
      (P.payload = u),
        h != null && (P.callback = h),
        (u = Ga(c, P, x)),
        u !== null && (Ds(u, c, x, w), ty(u, c, x));
    },
    enqueueReplaceState: function (c, u, h) {
      c = c._reactInternals;
      var w = Qr(),
        x = Qa(c),
        P = Vo(w, x);
      (P.tag = 1),
        (P.payload = u),
        h != null && (P.callback = h),
        (u = Ga(c, P, x)),
        u !== null && (Ds(u, c, x, w), ty(u, c, x));
    },
    enqueueForceUpdate: function (c, u) {
      c = c._reactInternals;
      var h = Qr(),
        w = Qa(c),
        x = Vo(h, w);
      (x.tag = 2),
        u != null && (x.callback = u),
        (u = Ga(c, x, w)),
        u !== null && (Ds(u, c, w, h), ty(u, c, w));
    },
  };
  function lI(c, u, h, w, x, P, L) {
    return (
      (c = c.stateNode),
      typeof c.shouldComponentUpdate == "function"
        ? c.shouldComponentUpdate(w, P, L)
        : u.prototype && u.prototype.isPureReactComponent
        ? !ef(h, w) || !ef(x, P)
        : !0
    );
  }
  function uI(c, u, h) {
    var w = !1,
      x = Ha,
      P = u.contextType;
    return (
      typeof P == "object" && P !== null
        ? (P = Xi(P))
        : ((x = ci(u) ? Xc : Mr.current),
          (w = u.contextTypes),
          (P = (w = w != null) ? Iu(c, x) : Ha)),
      (u = new u(h, P)),
      (c.memoizedState =
        u.state !== null && u.state !== void 0 ? u.state : null),
      (u.updater = ly),
      (c.stateNode = u),
      (u._reactInternals = c),
      w &&
        ((c = c.stateNode),
        (c.__reactInternalMemoizedUnmaskedChildContext = x),
        (c.__reactInternalMemoizedMaskedChildContext = P)),
      u
    );
  }
  function dI(c, u, h, w) {
    (c = u.state),
      typeof u.componentWillReceiveProps == "function" &&
        u.componentWillReceiveProps(h, w),
      typeof u.UNSAFE_componentWillReceiveProps == "function" &&
        u.UNSAFE_componentWillReceiveProps(h, w),
      u.state !== c && ly.enqueueReplaceState(u, u.state, null);
  }
  function u1(c, u, h, w) {
    var x = c.stateNode;
    (x.props = h), (x.state = c.memoizedState), (x.refs = {}), Zb(c);
    var P = u.contextType;
    typeof P == "object" && P !== null
      ? (x.context = Xi(P))
      : ((P = ci(u) ? Xc : Mr.current), (x.context = Iu(c, P))),
      (x.state = c.memoizedState),
      (P = u.getDerivedStateFromProps),
      typeof P == "function" && (l1(c, u, P, h), (x.state = c.memoizedState)),
      typeof u.getDerivedStateFromProps == "function" ||
        typeof x.getSnapshotBeforeUpdate == "function" ||
        (typeof x.UNSAFE_componentWillMount != "function" &&
          typeof x.componentWillMount != "function") ||
        ((u = x.state),
        typeof x.componentWillMount == "function" && x.componentWillMount(),
        typeof x.UNSAFE_componentWillMount == "function" &&
          x.UNSAFE_componentWillMount(),
        u !== x.state && ly.enqueueReplaceState(x, x.state, null),
        ny(c, h, x, w),
        (x.state = c.memoizedState)),
      typeof x.componentDidMount == "function" && (c.flags |= 4194308);
  }
  function $u(c, u) {
    try {
      var h = "",
        w = u;
      do (h += se(w)), (w = w.return);
      while (w);
      var x = h;
    } catch (P) {
      x =
        `
Error generating stack: ` +
        P.message +
        `
` +
        P.stack;
    }
    return { value: c, source: u, stack: x, digest: null };
  }
  function d1(c, u, h) {
    return { value: c, source: null, stack: h ?? null, digest: u ?? null };
  }
  function p1(c, u) {
    try {
      console.error(u.value);
    } catch (h) {
      setTimeout(function () {
        throw h;
      });
    }
  }
  var T4 = typeof WeakMap == "function" ? WeakMap : Map;
  function pI(c, u, h) {
    (h = Vo(-1, h)), (h.tag = 3), (h.payload = { element: null });
    var w = u.value;
    return (
      (h.callback = function () {
        gy || ((gy = !0), (I1 = w)), p1(c, u);
      }),
      h
    );
  }
  function fI(c, u, h) {
    (h = Vo(-1, h)), (h.tag = 3);
    var w = c.type.getDerivedStateFromError;
    if (typeof w == "function") {
      var x = u.value;
      (h.payload = function () {
        return w(x);
      }),
        (h.callback = function () {
          p1(c, u);
        });
    }
    var P = c.stateNode;
    return (
      P !== null &&
        typeof P.componentDidCatch == "function" &&
        (h.callback = function () {
          p1(c, u),
            typeof w != "function" &&
              (Ya === null ? (Ya = new Set([this])) : Ya.add(this));
          var L = u.stack;
          this.componentDidCatch(u.value, {
            componentStack: L !== null ? L : "",
          });
        }),
      h
    );
  }
  function hI(c, u, h) {
    var w = c.pingCache;
    if (w === null) {
      w = c.pingCache = new T4();
      var x = new Set();
      w.set(u, x);
    } else (x = w.get(u)), x === void 0 && ((x = new Set()), w.set(u, x));
    x.has(h) || (x.add(h), (c = z4.bind(null, c, u, h)), u.then(c, c));
  }
  function mI(c) {
    do {
      var u;
      if (
        ((u = c.tag === 13) &&
          ((u = c.memoizedState),
          (u = u !== null ? u.dehydrated !== null : !0)),
        u)
      )
        return c;
      c = c.return;
    } while (c !== null);
    return null;
  }
  function gI(c, u, h, w, x) {
    return c.mode & 1
      ? ((c.flags |= 65536), (c.lanes = x), c)
      : (c === u
          ? (c.flags |= 65536)
          : ((c.flags |= 128),
            (h.flags |= 131072),
            (h.flags &= -52805),
            h.tag === 1 &&
              (h.alternate === null
                ? (h.tag = 17)
                : ((u = Vo(-1, 1)), (u.tag = 2), Ga(h, u, 1))),
            (h.lanes |= 1)),
        c);
  }
  var P4 = _.ReactCurrentOwner,
    li = !1;
  function Zr(c, u, h, w) {
    u.child = c === null ? M2(u, null, h, w) : Nu(u, c.child, h, w);
  }
  function yI(c, u, h, w, x) {
    h = h.render;
    var P = u.ref;
    return (
      ku(u, x),
      (w = r1(c, u, h, w, P, x)),
      (h = i1()),
      c !== null && !li
        ? ((u.updateQueue = c.updateQueue),
          (u.flags &= -2053),
          (c.lanes &= ~x),
          Go(c, u, x))
        : (mn && h && jb(u), (u.flags |= 1), Zr(c, u, w, x), u.child)
    );
  }
  function wI(c, u, h, w, x) {
    if (c === null) {
      var P = h.type;
      return typeof P == "function" &&
        !D1(P) &&
        P.defaultProps === void 0 &&
        h.compare === null &&
        h.defaultProps === void 0
        ? ((u.tag = 15), (u.type = P), vI(c, u, P, w, x))
        : ((c = Cy(h.type, null, w, u, u.mode, x)),
          (c.ref = u.ref),
          (c.return = u),
          (u.child = c));
    }
    if (((P = c.child), !(c.lanes & x))) {
      var L = P.memoizedProps;
      if (
        ((h = h.compare), (h = h !== null ? h : ef), h(L, w) && c.ref === u.ref)
      )
        return Go(c, u, x);
    }
    return (
      (u.flags |= 1),
      (c = Ja(P, w)),
      (c.ref = u.ref),
      (c.return = u),
      (u.child = c)
    );
  }
  function vI(c, u, h, w, x) {
    if (c !== null) {
      var P = c.memoizedProps;
      if (ef(P, w) && c.ref === u.ref)
        if (((li = !1), (u.pendingProps = w = P), (c.lanes & x) !== 0))
          c.flags & 131072 && (li = !0);
        else return (u.lanes = c.lanes), Go(c, u, x);
    }
    return f1(c, u, h, w, x);
  }
  function bI(c, u, h) {
    var w = u.pendingProps,
      x = w.children,
      P = c !== null ? c.memoizedState : null;
    if (w.mode === "hidden")
      if (!(u.mode & 1))
        (u.memoizedState = {
          baseLanes: 0,
          cachePool: null,
          transitions: null,
        }),
          nn(Lu, ki),
          (ki |= h);
      else {
        if (!(h & 1073741824))
          return (
            (c = P !== null ? P.baseLanes | h : h),
            (u.lanes = u.childLanes = 1073741824),
            (u.memoizedState = {
              baseLanes: c,
              cachePool: null,
              transitions: null,
            }),
            (u.updateQueue = null),
            nn(Lu, ki),
            (ki |= c),
            null
          );
        (u.memoizedState = {
          baseLanes: 0,
          cachePool: null,
          transitions: null,
        }),
          (w = P !== null ? P.baseLanes : h),
          nn(Lu, ki),
          (ki |= w);
      }
    else
      P !== null ? ((w = P.baseLanes | h), (u.memoizedState = null)) : (w = h),
        nn(Lu, ki),
        (ki |= w);
    return Zr(c, u, x, h), u.child;
  }
  function EI(c, u) {
    var h = u.ref;
    ((c === null && h !== null) || (c !== null && c.ref !== h)) &&
      ((u.flags |= 512), (u.flags |= 2097152));
  }
  function f1(c, u, h, w, x) {
    var P = ci(h) ? Xc : Mr.current;
    return (
      (P = Iu(u, P)),
      ku(u, x),
      (h = r1(c, u, h, w, P, x)),
      (w = i1()),
      c !== null && !li
        ? ((u.updateQueue = c.updateQueue),
          (u.flags &= -2053),
          (c.lanes &= ~x),
          Go(c, u, x))
        : (mn && w && jb(u), (u.flags |= 1), Zr(c, u, h, x), u.child)
    );
  }
  function CI(c, u, h, w, x) {
    if (ci(h)) {
      var P = !0;
      Gg(u);
    } else P = !1;
    if ((ku(u, x), u.stateNode === null))
      dy(c, u), uI(u, h, w), u1(u, h, w, x), (w = !0);
    else if (c === null) {
      var L = u.stateNode,
        G = u.memoizedProps;
      L.props = G;
      var Q = L.context,
        ie = h.contextType;
      typeof ie == "object" && ie !== null
        ? (ie = Xi(ie))
        : ((ie = ci(h) ? Xc : Mr.current), (ie = Iu(u, ie)));
      var de = h.getDerivedStateFromProps,
        he =
          typeof de == "function" ||
          typeof L.getSnapshotBeforeUpdate == "function";
      he ||
        (typeof L.UNSAFE_componentWillReceiveProps != "function" &&
          typeof L.componentWillReceiveProps != "function") ||
        ((G !== w || Q !== ie) && dI(u, L, w, ie)),
        (Va = !1);
      var ue = u.memoizedState;
      (L.state = ue),
        ny(u, w, L, x),
        (Q = u.memoizedState),
        G !== w || ue !== Q || ai.current || Va
          ? (typeof de == "function" &&
              (l1(u, h, de, w), (Q = u.memoizedState)),
            (G = Va || lI(u, h, G, w, ue, Q, ie))
              ? (he ||
                  (typeof L.UNSAFE_componentWillMount != "function" &&
                    typeof L.componentWillMount != "function") ||
                  (typeof L.componentWillMount == "function" &&
                    L.componentWillMount(),
                  typeof L.UNSAFE_componentWillMount == "function" &&
                    L.UNSAFE_componentWillMount()),
                typeof L.componentDidMount == "function" &&
                  (u.flags |= 4194308))
              : (typeof L.componentDidMount == "function" &&
                  (u.flags |= 4194308),
                (u.memoizedProps = w),
                (u.memoizedState = Q)),
            (L.props = w),
            (L.state = Q),
            (L.context = ie),
            (w = G))
          : (typeof L.componentDidMount == "function" && (u.flags |= 4194308),
            (w = !1));
    } else {
      (L = u.stateNode),
        U2(c, u),
        (G = u.memoizedProps),
        (ie = u.type === u.elementType ? G : Ns(u.type, G)),
        (L.props = ie),
        (he = u.pendingProps),
        (ue = L.context),
        (Q = h.contextType),
        typeof Q == "object" && Q !== null
          ? (Q = Xi(Q))
          : ((Q = ci(h) ? Xc : Mr.current), (Q = Iu(u, Q)));
      var _e = h.getDerivedStateFromProps;
      (de =
        typeof _e == "function" ||
        typeof L.getSnapshotBeforeUpdate == "function") ||
        (typeof L.UNSAFE_componentWillReceiveProps != "function" &&
          typeof L.componentWillReceiveProps != "function") ||
        ((G !== he || ue !== Q) && dI(u, L, w, Q)),
        (Va = !1),
        (ue = u.memoizedState),
        (L.state = ue),
        ny(u, w, L, x);
      var Ue = u.memoizedState;
      G !== he || ue !== Ue || ai.current || Va
        ? (typeof _e == "function" && (l1(u, h, _e, w), (Ue = u.memoizedState)),
          (ie = Va || lI(u, h, ie, w, ue, Ue, Q) || !1)
            ? (de ||
                (typeof L.UNSAFE_componentWillUpdate != "function" &&
                  typeof L.componentWillUpdate != "function") ||
                (typeof L.componentWillUpdate == "function" &&
                  L.componentWillUpdate(w, Ue, Q),
                typeof L.UNSAFE_componentWillUpdate == "function" &&
                  L.UNSAFE_componentWillUpdate(w, Ue, Q)),
              typeof L.componentDidUpdate == "function" && (u.flags |= 4),
              typeof L.getSnapshotBeforeUpdate == "function" &&
                (u.flags |= 1024))
            : (typeof L.componentDidUpdate != "function" ||
                (G === c.memoizedProps && ue === c.memoizedState) ||
                (u.flags |= 4),
              typeof L.getSnapshotBeforeUpdate != "function" ||
                (G === c.memoizedProps && ue === c.memoizedState) ||
                (u.flags |= 1024),
              (u.memoizedProps = w),
              (u.memoizedState = Ue)),
          (L.props = w),
          (L.state = Ue),
          (L.context = Q),
          (w = ie))
        : (typeof L.componentDidUpdate != "function" ||
            (G === c.memoizedProps && ue === c.memoizedState) ||
            (u.flags |= 4),
          typeof L.getSnapshotBeforeUpdate != "function" ||
            (G === c.memoizedProps && ue === c.memoizedState) ||
            (u.flags |= 1024),
          (w = !1));
    }
    return h1(c, u, h, w, P, x);
  }
  function h1(c, u, h, w, x, P) {
    EI(c, u);
    var L = (u.flags & 128) !== 0;
    if (!w && !L) return x && I2(u, h, !1), Go(c, u, P);
    (w = u.stateNode), (P4.current = u);
    var G =
      L && typeof h.getDerivedStateFromError != "function" ? null : w.render();
    return (
      (u.flags |= 1),
      c !== null && L
        ? ((u.child = Nu(u, c.child, null, P)), (u.child = Nu(u, null, G, P)))
        : Zr(c, u, G, P),
      (u.memoizedState = w.state),
      x && I2(u, h, !0),
      u.child
    );
  }
  function xI(c) {
    var u = c.stateNode;
    u.pendingContext
      ? A2(c, u.pendingContext, u.pendingContext !== u.context)
      : u.context && A2(c, u.context, !1),
      Qb(c, u.containerInfo);
  }
  function SI(c, u, h, w, x) {
    return Ru(), Hb(x), (u.flags |= 256), Zr(c, u, h, w), u.child;
  }
  var m1 = { dehydrated: null, treeContext: null, retryLane: 0 };
  function g1(c) {
    return { baseLanes: c, cachePool: null, transitions: null };
  }
  function AI(c, u, h) {
    var w = u.pendingProps,
      x = En.current,
      P = !1,
      L = (u.flags & 128) !== 0,
      G;
    if (
      ((G = L) ||
        (G = c !== null && c.memoizedState === null ? !1 : (x & 2) !== 0),
      G
        ? ((P = !0), (u.flags &= -129))
        : (c === null || c.memoizedState !== null) && (x |= 1),
      nn(En, x & 1),
      c === null)
    )
      return (
        Wb(u),
        (c = u.memoizedState),
        c !== null && ((c = c.dehydrated), c !== null)
          ? (u.mode & 1
              ? c.data === "$!"
                ? (u.lanes = 8)
                : (u.lanes = 1073741824)
              : (u.lanes = 1),
            null)
          : ((L = w.children),
            (c = w.fallback),
            P
              ? ((w = u.mode),
                (P = u.child),
                (L = { mode: "hidden", children: L }),
                !(w & 1) && P !== null
                  ? ((P.childLanes = 0), (P.pendingProps = L))
                  : (P = xy(L, w, 0, null)),
                (c = cl(c, w, h, null)),
                (P.return = u),
                (c.return = u),
                (P.sibling = c),
                (u.child = P),
                (u.child.memoizedState = g1(h)),
                (u.memoizedState = m1),
                c)
              : y1(u, L))
      );
    if (((x = c.memoizedState), x !== null && ((G = x.dehydrated), G !== null)))
      return R4(c, u, L, w, G, x, h);
    if (P) {
      (P = w.fallback), (L = u.mode), (x = c.child), (G = x.sibling);
      var Q = { mode: "hidden", children: w.children };
      return (
        !(L & 1) && u.child !== x
          ? ((w = u.child),
            (w.childLanes = 0),
            (w.pendingProps = Q),
            (u.deletions = null))
          : ((w = Ja(x, Q)), (w.subtreeFlags = x.subtreeFlags & 14680064)),
        G !== null ? (P = Ja(G, P)) : ((P = cl(P, L, h, null)), (P.flags |= 2)),
        (P.return = u),
        (w.return = u),
        (w.sibling = P),
        (u.child = w),
        (w = P),
        (P = u.child),
        (L = c.child.memoizedState),
        (L =
          L === null
            ? g1(h)
            : {
                baseLanes: L.baseLanes | h,
                cachePool: null,
                transitions: L.transitions,
              }),
        (P.memoizedState = L),
        (P.childLanes = c.childLanes & ~h),
        (u.memoizedState = m1),
        w
      );
    }
    return (
      (P = c.child),
      (c = P.sibling),
      (w = Ja(P, { mode: "visible", children: w.children })),
      !(u.mode & 1) && (w.lanes = h),
      (w.return = u),
      (w.sibling = null),
      c !== null &&
        ((h = u.deletions),
        h === null ? ((u.deletions = [c]), (u.flags |= 16)) : h.push(c)),
      (u.child = w),
      (u.memoizedState = null),
      w
    );
  }
  function y1(c, u) {
    return (
      (u = xy({ mode: "visible", children: u }, c.mode, 0, null)),
      (u.return = c),
      (c.child = u)
    );
  }
  function uy(c, u, h, w) {
    return (
      w !== null && Hb(w),
      Nu(u, c.child, null, h),
      (c = y1(u, u.pendingProps.children)),
      (c.flags |= 2),
      (u.memoizedState = null),
      c
    );
  }
  function R4(c, u, h, w, x, P, L) {
    if (h)
      return u.flags & 256
        ? ((u.flags &= -257), (w = d1(Error(n(422)))), uy(c, u, L, w))
        : u.memoizedState !== null
        ? ((u.child = c.child), (u.flags |= 128), null)
        : ((P = w.fallback),
          (x = u.mode),
          (w = xy({ mode: "visible", children: w.children }, x, 0, null)),
          (P = cl(P, x, L, null)),
          (P.flags |= 2),
          (w.return = u),
          (P.return = u),
          (w.sibling = P),
          (u.child = w),
          u.mode & 1 && Nu(u, c.child, null, L),
          (u.child.memoizedState = g1(L)),
          (u.memoizedState = m1),
          P);
    if (!(u.mode & 1)) return uy(c, u, L, null);
    if (x.data === "$!") {
      if (((w = x.nextSibling && x.nextSibling.dataset), w)) var G = w.dgst;
      return (
        (w = G), (P = Error(n(419))), (w = d1(P, w, void 0)), uy(c, u, L, w)
      );
    }
    if (((G = (L & c.childLanes) !== 0), li || G)) {
      if (((w = or), w !== null)) {
        switch (L & -L) {
          case 4:
            x = 2;
            break;
          case 16:
            x = 8;
            break;
          case 64:
          case 128:
          case 256:
          case 512:
          case 1024:
          case 2048:
          case 4096:
          case 8192:
          case 16384:
          case 32768:
          case 65536:
          case 131072:
          case 262144:
          case 524288:
          case 1048576:
          case 2097152:
          case 4194304:
          case 8388608:
          case 16777216:
          case 33554432:
          case 67108864:
            x = 32;
            break;
          case 536870912:
            x = 268435456;
            break;
          default:
            x = 0;
        }
        (x = x & (w.suspendedLanes | L) ? 0 : x),
          x !== 0 &&
            x !== P.retryLane &&
            ((P.retryLane = x), qo(c, x), Ds(w, c, x, -1));
      }
      return k1(), (w = d1(Error(n(421)))), uy(c, u, L, w);
    }
    return x.data === "$?"
      ? ((u.flags |= 128),
        (u.child = c.child),
        (u = W4.bind(null, c)),
        (x._reactRetry = u),
        null)
      : ((c = P.treeContext),
        (Oi = za(x.nextSibling)),
        (Ni = u),
        (mn = !0),
        (Rs = null),
        c !== null &&
          ((Zi[Qi++] = Wo),
          (Zi[Qi++] = Ho),
          (Zi[Qi++] = Jc),
          (Wo = c.id),
          (Ho = c.overflow),
          (Jc = u)),
        (u = y1(u, w.children)),
        (u.flags |= 4096),
        u);
  }
  function _I(c, u, h) {
    c.lanes |= u;
    var w = c.alternate;
    w !== null && (w.lanes |= u), Kb(c.return, u, h);
  }
  function w1(c, u, h, w, x) {
    var P = c.memoizedState;
    P === null
      ? (c.memoizedState = {
          isBackwards: u,
          rendering: null,
          renderingStartTime: 0,
          last: w,
          tail: h,
          tailMode: x,
        })
      : ((P.isBackwards = u),
        (P.rendering = null),
        (P.renderingStartTime = 0),
        (P.last = w),
        (P.tail = h),
        (P.tailMode = x));
  }
  function II(c, u, h) {
    var w = u.pendingProps,
      x = w.revealOrder,
      P = w.tail;
    if ((Zr(c, u, w.children, h), (w = En.current), w & 2))
      (w = (w & 1) | 2), (u.flags |= 128);
    else {
      if (c !== null && c.flags & 128)
        e: for (c = u.child; c !== null; ) {
          if (c.tag === 13) c.memoizedState !== null && _I(c, h, u);
          else if (c.tag === 19) _I(c, h, u);
          else if (c.child !== null) {
            (c.child.return = c), (c = c.child);
            continue;
          }
          if (c === u) break e;
          for (; c.sibling === null; ) {
            if (c.return === null || c.return === u) break e;
            c = c.return;
          }
          (c.sibling.return = c.return), (c = c.sibling);
        }
      w &= 1;
    }
    if ((nn(En, w), !(u.mode & 1))) u.memoizedState = null;
    else
      switch (x) {
        case "forwards":
          for (h = u.child, x = null; h !== null; )
            (c = h.alternate),
              c !== null && ry(c) === null && (x = h),
              (h = h.sibling);
          (h = x),
            h === null
              ? ((x = u.child), (u.child = null))
              : ((x = h.sibling), (h.sibling = null)),
            w1(u, !1, x, h, P);
          break;
        case "backwards":
          for (h = null, x = u.child, u.child = null; x !== null; ) {
            if (((c = x.alternate), c !== null && ry(c) === null)) {
              u.child = x;
              break;
            }
            (c = x.sibling), (x.sibling = h), (h = x), (x = c);
          }
          w1(u, !0, h, null, P);
          break;
        case "together":
          w1(u, !1, null, null, void 0);
          break;
        default:
          u.memoizedState = null;
      }
    return u.child;
  }
  function dy(c, u) {
    !(u.mode & 1) &&
      c !== null &&
      ((c.alternate = null), (u.alternate = null), (u.flags |= 2));
  }
  function Go(c, u, h) {
    if (
      (c !== null && (u.dependencies = c.dependencies),
      (il |= u.lanes),
      !(h & u.childLanes))
    )
      return null;
    if (c !== null && u.child !== c.child) throw Error(n(153));
    if (u.child !== null) {
      for (
        c = u.child, h = Ja(c, c.pendingProps), u.child = h, h.return = u;
        c.sibling !== null;

      )
        (c = c.sibling),
          (h = h.sibling = Ja(c, c.pendingProps)),
          (h.return = u);
      h.sibling = null;
    }
    return u.child;
  }
  function N4(c, u, h) {
    switch (u.tag) {
      case 3:
        xI(u), Ru();
        break;
      case 5:
        F2(u);
        break;
      case 1:
        ci(u.type) && Gg(u);
        break;
      case 4:
        Qb(u, u.stateNode.containerInfo);
        break;
      case 10:
        var w = u.type._context,
          x = u.memoizedProps.value;
        nn(Jg, w._currentValue), (w._currentValue = x);
        break;
      case 13:
        if (((w = u.memoizedState), w !== null))
          return w.dehydrated !== null
            ? (nn(En, En.current & 1), (u.flags |= 128), null)
            : h & u.child.childLanes
            ? AI(c, u, h)
            : (nn(En, En.current & 1),
              (c = Go(c, u, h)),
              c !== null ? c.sibling : null);
        nn(En, En.current & 1);
        break;
      case 19:
        if (((w = (h & u.childLanes) !== 0), c.flags & 128)) {
          if (w) return II(c, u, h);
          u.flags |= 128;
        }
        if (
          ((x = u.memoizedState),
          x !== null &&
            ((x.rendering = null), (x.tail = null), (x.lastEffect = null)),
          nn(En, En.current),
          w)
        )
          break;
        return null;
      case 22:
      case 23:
        return (u.lanes = 0), bI(c, u, h);
    }
    return Go(c, u, h);
  }
  var TI, v1, PI, RI;
  (TI = function (c, u) {
    for (var h = u.child; h !== null; ) {
      if (h.tag === 5 || h.tag === 6) c.appendChild(h.stateNode);
      else if (h.tag !== 4 && h.child !== null) {
        (h.child.return = h), (h = h.child);
        continue;
      }
      if (h === u) break;
      for (; h.sibling === null; ) {
        if (h.return === null || h.return === u) return;
        h = h.return;
      }
      (h.sibling.return = h.return), (h = h.sibling);
    }
  }),
    (v1 = function () {}),
    (PI = function (c, u, h, w) {
      var x = c.memoizedProps;
      if (x !== w) {
        (c = u.stateNode), nl(io.current);
        var P = null;
        switch (h) {
          case "input":
            (x = Ne(c, x)), (w = Ne(c, w)), (P = []);
            break;
          case "select":
            (x = V({}, x, { value: void 0 })),
              (w = V({}, w, { value: void 0 })),
              (P = []);
            break;
          case "textarea":
            (x = Le(c, x)), (w = Le(c, w)), (P = []);
            break;
          default:
            typeof x.onClick != "function" &&
              typeof w.onClick == "function" &&
              (c.onclick = Hg);
        }
        It(h, w);
        var L;
        h = null;
        for (ie in x)
          if (!w.hasOwnProperty(ie) && x.hasOwnProperty(ie) && x[ie] != null)
            if (ie === "style") {
              var G = x[ie];
              for (L in G) G.hasOwnProperty(L) && (h || (h = {}), (h[L] = ""));
            } else
              ie !== "dangerouslySetInnerHTML" &&
                ie !== "children" &&
                ie !== "suppressContentEditableWarning" &&
                ie !== "suppressHydrationWarning" &&
                ie !== "autoFocus" &&
                (i.hasOwnProperty(ie)
                  ? P || (P = [])
                  : (P = P || []).push(ie, null));
        for (ie in w) {
          var Q = w[ie];
          if (
            ((G = x != null ? x[ie] : void 0),
            w.hasOwnProperty(ie) && Q !== G && (Q != null || G != null))
          )
            if (ie === "style")
              if (G) {
                for (L in G)
                  !G.hasOwnProperty(L) ||
                    (Q && Q.hasOwnProperty(L)) ||
                    (h || (h = {}), (h[L] = ""));
                for (L in Q)
                  Q.hasOwnProperty(L) &&
                    G[L] !== Q[L] &&
                    (h || (h = {}), (h[L] = Q[L]));
              } else h || (P || (P = []), P.push(ie, h)), (h = Q);
            else
              ie === "dangerouslySetInnerHTML"
                ? ((Q = Q ? Q.__html : void 0),
                  (G = G ? G.__html : void 0),
                  Q != null && G !== Q && (P = P || []).push(ie, Q))
                : ie === "children"
                ? (typeof Q != "string" && typeof Q != "number") ||
                  (P = P || []).push(ie, "" + Q)
                : ie !== "suppressContentEditableWarning" &&
                  ie !== "suppressHydrationWarning" &&
                  (i.hasOwnProperty(ie)
                    ? (Q != null && ie === "onScroll" && cn("scroll", c),
                      P || G === Q || (P = []))
                    : (P = P || []).push(ie, Q));
        }
        h && (P = P || []).push("style", h);
        var ie = P;
        (u.updateQueue = ie) && (u.flags |= 4);
      }
    }),
    (RI = function (c, u, h, w) {
      h !== w && (u.flags |= 4);
    });
  function gf(c, u) {
    if (!mn)
      switch (c.tailMode) {
        case "hidden":
          u = c.tail;
          for (var h = null; u !== null; )
            u.alternate !== null && (h = u), (u = u.sibling);
          h === null ? (c.tail = null) : (h.sibling = null);
          break;
        case "collapsed":
          h = c.tail;
          for (var w = null; h !== null; )
            h.alternate !== null && (w = h), (h = h.sibling);
          w === null
            ? u || c.tail === null
              ? (c.tail = null)
              : (c.tail.sibling = null)
            : (w.sibling = null);
      }
  }
  function Ur(c) {
    var u = c.alternate !== null && c.alternate.child === c.child,
      h = 0,
      w = 0;
    if (u)
      for (var x = c.child; x !== null; )
        (h |= x.lanes | x.childLanes),
          (w |= x.subtreeFlags & 14680064),
          (w |= x.flags & 14680064),
          (x.return = c),
          (x = x.sibling);
    else
      for (x = c.child; x !== null; )
        (h |= x.lanes | x.childLanes),
          (w |= x.subtreeFlags),
          (w |= x.flags),
          (x.return = c),
          (x = x.sibling);
    return (c.subtreeFlags |= w), (c.childLanes = h), u;
  }
  function O4(c, u, h) {
    var w = u.pendingProps;
    switch ((Fb(u), u.tag)) {
      case 2:
      case 16:
      case 15:
      case 0:
      case 11:
      case 7:
      case 8:
      case 12:
      case 9:
      case 14:
        return Ur(u), null;
      case 1:
        return ci(u.type) && Vg(), Ur(u), null;
      case 3:
        return (
          (w = u.stateNode),
          Du(),
          ln(ai),
          ln(Mr),
          e1(),
          w.pendingContext &&
            ((w.context = w.pendingContext), (w.pendingContext = null)),
          (c === null || c.child === null) &&
            (Qg(u)
              ? (u.flags |= 4)
              : c === null ||
                (c.memoizedState.isDehydrated && !(u.flags & 256)) ||
                ((u.flags |= 1024), Rs !== null && (R1(Rs), (Rs = null)))),
          v1(c, u),
          Ur(u),
          null
        );
      case 5:
        Xb(u);
        var x = nl(df.current);
        if (((h = u.type), c !== null && u.stateNode != null))
          PI(c, u, h, w, x),
            c.ref !== u.ref && ((u.flags |= 512), (u.flags |= 2097152));
        else {
          if (!w) {
            if (u.stateNode === null) throw Error(n(166));
            return Ur(u), null;
          }
          if (((c = nl(io.current)), Qg(u))) {
            (w = u.stateNode), (h = u.type);
            var P = u.memoizedProps;
            switch (((w[ro] = u), (w[of] = P), (c = (u.mode & 1) !== 0), h)) {
              case "dialog":
                cn("cancel", w), cn("close", w);
                break;
              case "iframe":
              case "object":
              case "embed":
                cn("load", w);
                break;
              case "video":
              case "audio":
                for (x = 0; x < nf.length; x++) cn(nf[x], w);
                break;
              case "source":
                cn("error", w);
                break;
              case "img":
              case "image":
              case "link":
                cn("error", w), cn("load", w);
                break;
              case "details":
                cn("toggle", w);
                break;
              case "input":
                pt(w, P), cn("invalid", w);
                break;
              case "select":
                (w._wrapperState = { wasMultiple: !!P.multiple }),
                  cn("invalid", w);
                break;
              case "textarea":
                nr(w, P), cn("invalid", w);
            }
            It(h, P), (x = null);
            for (var L in P)
              if (P.hasOwnProperty(L)) {
                var G = P[L];
                L === "children"
                  ? typeof G == "string"
                    ? w.textContent !== G &&
                      (P.suppressHydrationWarning !== !0 &&
                        Wg(w.textContent, G, c),
                      (x = ["children", G]))
                    : typeof G == "number" &&
                      w.textContent !== "" + G &&
                      (P.suppressHydrationWarning !== !0 &&
                        Wg(w.textContent, G, c),
                      (x = ["children", "" + G]))
                  : i.hasOwnProperty(L) &&
                    G != null &&
                    L === "onScroll" &&
                    cn("scroll", w);
              }
            switch (h) {
              case "input":
                je(w), Lt(w, P, !0);
                break;
              case "textarea":
                je(w), wr(w);
                break;
              case "select":
              case "option":
                break;
              default:
                typeof P.onClick == "function" && (w.onclick = Hg);
            }
            (w = x), (u.updateQueue = w), w !== null && (u.flags |= 4);
          } else {
            (L = x.nodeType === 9 ? x : x.ownerDocument),
              c === "http://www.w3.org/1999/xhtml" && (c = Dr(h)),
              c === "http://www.w3.org/1999/xhtml"
                ? h === "script"
                  ? ((c = L.createElement("div")),
                    (c.innerHTML = "<script></script>"),
                    (c = c.removeChild(c.firstChild)))
                  : typeof w.is == "string"
                  ? (c = L.createElement(h, { is: w.is }))
                  : ((c = L.createElement(h)),
                    h === "select" &&
                      ((L = c),
                      w.multiple
                        ? (L.multiple = !0)
                        : w.size && (L.size = w.size)))
                : (c = L.createElementNS(c, h)),
              (c[ro] = u),
              (c[of] = w),
              TI(c, u, !1, !1),
              (u.stateNode = c);
            e: {
              switch (((L = bn(h, w)), h)) {
                case "dialog":
                  cn("cancel", c), cn("close", c), (x = w);
                  break;
                case "iframe":
                case "object":
                case "embed":
                  cn("load", c), (x = w);
                  break;
                case "video":
                case "audio":
                  for (x = 0; x < nf.length; x++) cn(nf[x], c);
                  x = w;
                  break;
                case "source":
                  cn("error", c), (x = w);
                  break;
                case "img":
                case "image":
                case "link":
                  cn("error", c), cn("load", c), (x = w);
                  break;
                case "details":
                  cn("toggle", c), (x = w);
                  break;
                case "input":
                  pt(c, w), (x = Ne(c, w)), cn("invalid", c);
                  break;
                case "option":
                  x = w;
                  break;
                case "select":
                  (c._wrapperState = { wasMultiple: !!w.multiple }),
                    (x = V({}, w, { value: void 0 })),
                    cn("invalid", c);
                  break;
                case "textarea":
                  nr(c, w), (x = Le(c, w)), cn("invalid", c);
                  break;
                default:
                  x = w;
              }
              It(h, x), (G = x);
              for (P in G)
                if (G.hasOwnProperty(P)) {
                  var Q = G[P];
                  P === "style"
                    ? br(c, Q)
                    : P === "dangerouslySetInnerHTML"
                    ? ((Q = Q ? Q.__html : void 0), Q != null && vr(c, Q))
                    : P === "children"
                    ? typeof Q == "string"
                      ? (h !== "textarea" || Q !== "") && Vn(c, Q)
                      : typeof Q == "number" && Vn(c, "" + Q)
                    : P !== "suppressContentEditableWarning" &&
                      P !== "suppressHydrationWarning" &&
                      P !== "autoFocus" &&
                      (i.hasOwnProperty(P)
                        ? Q != null && P === "onScroll" && cn("scroll", c)
                        : Q != null && C(c, P, Q, L));
                }
              switch (h) {
                case "input":
                  je(c), Lt(c, w, !1);
                  break;
                case "textarea":
                  je(c), wr(c);
                  break;
                case "option":
                  w.value != null && c.setAttribute("value", "" + ce(w.value));
                  break;
                case "select":
                  (c.multiple = !!w.multiple),
                    (P = w.value),
                    P != null
                      ? vt(c, !!w.multiple, P, !1)
                      : w.defaultValue != null &&
                        vt(c, !!w.multiple, w.defaultValue, !0);
                  break;
                default:
                  typeof x.onClick == "function" && (c.onclick = Hg);
              }
              switch (h) {
                case "button":
                case "input":
                case "select":
                case "textarea":
                  w = !!w.autoFocus;
                  break e;
                case "img":
                  w = !0;
                  break e;
                default:
                  w = !1;
              }
            }
            w && (u.flags |= 4);
          }
          u.ref !== null && ((u.flags |= 512), (u.flags |= 2097152));
        }
        return Ur(u), null;
      case 6:
        if (c && u.stateNode != null) RI(c, u, c.memoizedProps, w);
        else {
          if (typeof w != "string" && u.stateNode === null) throw Error(n(166));
          if (((h = nl(df.current)), nl(io.current), Qg(u))) {
            if (
              ((w = u.stateNode),
              (h = u.memoizedProps),
              (w[ro] = u),
              (P = w.nodeValue !== h) && ((c = Ni), c !== null))
            )
              switch (c.tag) {
                case 3:
                  Wg(w.nodeValue, h, (c.mode & 1) !== 0);
                  break;
                case 5:
                  c.memoizedProps.suppressHydrationWarning !== !0 &&
                    Wg(w.nodeValue, h, (c.mode & 1) !== 0);
              }
            P && (u.flags |= 4);
          } else
            (w = (h.nodeType === 9 ? h : h.ownerDocument).createTextNode(w)),
              (w[ro] = u),
              (u.stateNode = w);
        }
        return Ur(u), null;
      case 13:
        if (
          (ln(En),
          (w = u.memoizedState),
          c === null ||
            (c.memoizedState !== null && c.memoizedState.dehydrated !== null))
        ) {
          if (mn && Oi !== null && u.mode & 1 && !(u.flags & 128))
            k2(), Ru(), (u.flags |= 98560), (P = !1);
          else if (((P = Qg(u)), w !== null && w.dehydrated !== null)) {
            if (c === null) {
              if (!P) throw Error(n(318));
              if (
                ((P = u.memoizedState),
                (P = P !== null ? P.dehydrated : null),
                !P)
              )
                throw Error(n(317));
              P[ro] = u;
            } else
              Ru(),
                !(u.flags & 128) && (u.memoizedState = null),
                (u.flags |= 4);
            Ur(u), (P = !1);
          } else Rs !== null && (R1(Rs), (Rs = null)), (P = !0);
          if (!P) return u.flags & 65536 ? u : null;
        }
        return u.flags & 128
          ? ((u.lanes = h), u)
          : ((w = w !== null),
            w !== (c !== null && c.memoizedState !== null) &&
              w &&
              ((u.child.flags |= 8192),
              u.mode & 1 &&
                (c === null || En.current & 1 ? Kn === 0 && (Kn = 3) : k1())),
            u.updateQueue !== null && (u.flags |= 4),
            Ur(u),
            null);
      case 4:
        return (
          Du(),
          v1(c, u),
          c === null && rf(u.stateNode.containerInfo),
          Ur(u),
          null
        );
      case 10:
        return Gb(u.type._context), Ur(u), null;
      case 17:
        return ci(u.type) && Vg(), Ur(u), null;
      case 19:
        if ((ln(En), (P = u.memoizedState), P === null)) return Ur(u), null;
        if (((w = (u.flags & 128) !== 0), (L = P.rendering), L === null))
          if (w) gf(P, !1);
          else {
            if (Kn !== 0 || (c !== null && c.flags & 128))
              for (c = u.child; c !== null; ) {
                if (((L = ry(c)), L !== null)) {
                  for (
                    u.flags |= 128,
                      gf(P, !1),
                      w = L.updateQueue,
                      w !== null && ((u.updateQueue = w), (u.flags |= 4)),
                      u.subtreeFlags = 0,
                      w = h,
                      h = u.child;
                    h !== null;

                  )
                    (P = h),
                      (c = w),
                      (P.flags &= 14680066),
                      (L = P.alternate),
                      L === null
                        ? ((P.childLanes = 0),
                          (P.lanes = c),
                          (P.child = null),
                          (P.subtreeFlags = 0),
                          (P.memoizedProps = null),
                          (P.memoizedState = null),
                          (P.updateQueue = null),
                          (P.dependencies = null),
                          (P.stateNode = null))
                        : ((P.childLanes = L.childLanes),
                          (P.lanes = L.lanes),
                          (P.child = L.child),
                          (P.subtreeFlags = 0),
                          (P.deletions = null),
                          (P.memoizedProps = L.memoizedProps),
                          (P.memoizedState = L.memoizedState),
                          (P.updateQueue = L.updateQueue),
                          (P.type = L.type),
                          (c = L.dependencies),
                          (P.dependencies =
                            c === null
                              ? null
                              : {
                                  lanes: c.lanes,
                                  firstContext: c.firstContext,
                                })),
                      (h = h.sibling);
                  return nn(En, (En.current & 1) | 2), u.child;
                }
                c = c.sibling;
              }
            P.tail !== null &&
              Dn() > Uu &&
              ((u.flags |= 128), (w = !0), gf(P, !1), (u.lanes = 4194304));
          }
        else {
          if (!w)
            if (((c = ry(L)), c !== null)) {
              if (
                ((u.flags |= 128),
                (w = !0),
                (h = c.updateQueue),
                h !== null && ((u.updateQueue = h), (u.flags |= 4)),
                gf(P, !0),
                P.tail === null &&
                  P.tailMode === "hidden" &&
                  !L.alternate &&
                  !mn)
              )
                return Ur(u), null;
            } else
              2 * Dn() - P.renderingStartTime > Uu &&
                h !== 1073741824 &&
                ((u.flags |= 128), (w = !0), gf(P, !1), (u.lanes = 4194304));
          P.isBackwards
            ? ((L.sibling = u.child), (u.child = L))
            : ((h = P.last),
              h !== null ? (h.sibling = L) : (u.child = L),
              (P.last = L));
        }
        return P.tail !== null
          ? ((u = P.tail),
            (P.rendering = u),
            (P.tail = u.sibling),
            (P.renderingStartTime = Dn()),
            (u.sibling = null),
            (h = En.current),
            nn(En, w ? (h & 1) | 2 : h & 1),
            u)
          : (Ur(u), null);
      case 22:
      case 23:
        return (
          O1(),
          (w = u.memoizedState !== null),
          c !== null && (c.memoizedState !== null) !== w && (u.flags |= 8192),
          w && u.mode & 1
            ? ki & 1073741824 &&
              (Ur(u), u.subtreeFlags & 6 && (u.flags |= 8192))
            : Ur(u),
          null
        );
      case 24:
        return null;
      case 25:
        return null;
    }
    throw Error(n(156, u.tag));
  }
  function k4(c, u) {
    switch ((Fb(u), u.tag)) {
      case 1:
        return (
          ci(u.type) && Vg(),
          (c = u.flags),
          c & 65536 ? ((u.flags = (c & -65537) | 128), u) : null
        );
      case 3:
        return (
          Du(),
          ln(ai),
          ln(Mr),
          e1(),
          (c = u.flags),
          c & 65536 && !(c & 128) ? ((u.flags = (c & -65537) | 128), u) : null
        );
      case 5:
        return Xb(u), null;
      case 13:
        if (
          (ln(En), (c = u.memoizedState), c !== null && c.dehydrated !== null)
        ) {
          if (u.alternate === null) throw Error(n(340));
          Ru();
        }
        return (
          (c = u.flags), c & 65536 ? ((u.flags = (c & -65537) | 128), u) : null
        );
      case 19:
        return ln(En), null;
      case 4:
        return Du(), null;
      case 10:
        return Gb(u.type._context), null;
      case 22:
      case 23:
        return O1(), null;
      case 24:
        return null;
      default:
        return null;
    }
  }
  var py = !1,
    Br = !1,
    D4 = typeof WeakSet == "function" ? WeakSet : Set,
    $e = null;
  function Mu(c, u) {
    var h = c.ref;
    if (h !== null)
      if (typeof h == "function")
        try {
          h(null);
        } catch (w) {
          Tn(c, u, w);
        }
      else h.current = null;
  }
  function b1(c, u, h) {
    try {
      h();
    } catch (w) {
      Tn(c, u, w);
    }
  }
  var NI = !1;
  function $4(c, u) {
    if (((Ob = Og), (c = l2()), Sb(c))) {
      if ("selectionStart" in c)
        var h = { start: c.selectionStart, end: c.selectionEnd };
      else
        e: {
          h = ((h = c.ownerDocument) && h.defaultView) || window;
          var w = h.getSelection && h.getSelection();
          if (w && w.rangeCount !== 0) {
            h = w.anchorNode;
            var x = w.anchorOffset,
              P = w.focusNode;
            w = w.focusOffset;
            try {
              h.nodeType, P.nodeType;
            } catch {
              h = null;
              break e;
            }
            var L = 0,
              G = -1,
              Q = -1,
              ie = 0,
              de = 0,
              he = c,
              ue = null;
            t: for (;;) {
              for (
                var _e;
                he !== h || (x !== 0 && he.nodeType !== 3) || (G = L + x),
                  he !== P || (w !== 0 && he.nodeType !== 3) || (Q = L + w),
                  he.nodeType === 3 && (L += he.nodeValue.length),
                  (_e = he.firstChild) !== null;

              )
                (ue = he), (he = _e);
              for (;;) {
                if (he === c) break t;
                if (
                  (ue === h && ++ie === x && (G = L),
                  ue === P && ++de === w && (Q = L),
                  (_e = he.nextSibling) !== null)
                )
                  break;
                (he = ue), (ue = he.parentNode);
              }
              he = _e;
            }
            h = G === -1 || Q === -1 ? null : { start: G, end: Q };
          } else h = null;
        }
      h = h || { start: 0, end: 0 };
    } else h = null;
    for (
      kb = { focusedElem: c, selectionRange: h }, Og = !1, $e = u;
      $e !== null;

    )
      if (
        ((u = $e), (c = u.child), (u.subtreeFlags & 1028) !== 0 && c !== null)
      )
        (c.return = u), ($e = c);
      else
        for (; $e !== null; ) {
          u = $e;
          try {
            var Ue = u.alternate;
            if (u.flags & 1024)
              switch (u.tag) {
                case 0:
                case 11:
                case 15:
                  break;
                case 1:
                  if (Ue !== null) {
                    var Fe = Ue.memoizedProps,
                      $n = Ue.memoizedState,
                      te = u.stateNode,
                      X = te.getSnapshotBeforeUpdate(
                        u.elementType === u.type ? Fe : Ns(u.type, Fe),
                        $n
                      );
                    te.__reactInternalSnapshotBeforeUpdate = X;
                  }
                  break;
                case 3:
                  var ne = u.stateNode.containerInfo;
                  ne.nodeType === 1
                    ? (ne.textContent = "")
                    : ne.nodeType === 9 &&
                      ne.documentElement &&
                      ne.removeChild(ne.documentElement);
                  break;
                case 5:
                case 6:
                case 4:
                case 17:
                  break;
                default:
                  throw Error(n(163));
              }
          } catch (we) {
            Tn(u, u.return, we);
          }
          if (((c = u.sibling), c !== null)) {
            (c.return = u.return), ($e = c);
            break;
          }
          $e = u.return;
        }
    return (Ue = NI), (NI = !1), Ue;
  }
  function yf(c, u, h) {
    var w = u.updateQueue;
    if (((w = w !== null ? w.lastEffect : null), w !== null)) {
      var x = (w = w.next);
      do {
        if ((x.tag & c) === c) {
          var P = x.destroy;
          (x.destroy = void 0), P !== void 0 && b1(u, h, P);
        }
        x = x.next;
      } while (x !== w);
    }
  }
  function fy(c, u) {
    if (
      ((u = u.updateQueue), (u = u !== null ? u.lastEffect : null), u !== null)
    ) {
      var h = (u = u.next);
      do {
        if ((h.tag & c) === c) {
          var w = h.create;
          h.destroy = w();
        }
        h = h.next;
      } while (h !== u);
    }
  }
  function E1(c) {
    var u = c.ref;
    if (u !== null) {
      var h = c.stateNode;
      switch (c.tag) {
        case 5:
          c = h;
          break;
        default:
          c = h;
      }
      typeof u == "function" ? u(c) : (u.current = c);
    }
  }
  function OI(c) {
    var u = c.alternate;
    u !== null && ((c.alternate = null), OI(u)),
      (c.child = null),
      (c.deletions = null),
      (c.sibling = null),
      c.tag === 5 &&
        ((u = c.stateNode),
        u !== null &&
          (delete u[ro],
          delete u[of],
          delete u[Lb],
          delete u[y4],
          delete u[w4])),
      (c.stateNode = null),
      (c.return = null),
      (c.dependencies = null),
      (c.memoizedProps = null),
      (c.memoizedState = null),
      (c.pendingProps = null),
      (c.stateNode = null),
      (c.updateQueue = null);
  }
  function kI(c) {
    return c.tag === 5 || c.tag === 3 || c.tag === 4;
  }
  function DI(c) {
    e: for (;;) {
      for (; c.sibling === null; ) {
        if (c.return === null || kI(c.return)) return null;
        c = c.return;
      }
      for (
        c.sibling.return = c.return, c = c.sibling;
        c.tag !== 5 && c.tag !== 6 && c.tag !== 18;

      ) {
        if (c.flags & 2 || c.child === null || c.tag === 4) continue e;
        (c.child.return = c), (c = c.child);
      }
      if (!(c.flags & 2)) return c.stateNode;
    }
  }
  function C1(c, u, h) {
    var w = c.tag;
    if (w === 5 || w === 6)
      (c = c.stateNode),
        u
          ? h.nodeType === 8
            ? h.parentNode.insertBefore(c, u)
            : h.insertBefore(c, u)
          : (h.nodeType === 8
              ? ((u = h.parentNode), u.insertBefore(c, h))
              : ((u = h), u.appendChild(c)),
            (h = h._reactRootContainer),
            h != null || u.onclick !== null || (u.onclick = Hg));
    else if (w !== 4 && ((c = c.child), c !== null))
      for (C1(c, u, h), c = c.sibling; c !== null; )
        C1(c, u, h), (c = c.sibling);
  }
  function x1(c, u, h) {
    var w = c.tag;
    if (w === 5 || w === 6)
      (c = c.stateNode), u ? h.insertBefore(c, u) : h.appendChild(c);
    else if (w !== 4 && ((c = c.child), c !== null))
      for (x1(c, u, h), c = c.sibling; c !== null; )
        x1(c, u, h), (c = c.sibling);
  }
  var Er = null,
    Os = !1;
  function Ka(c, u, h) {
    for (h = h.child; h !== null; ) $I(c, u, h), (h = h.sibling);
  }
  function $I(c, u, h) {
    if (no && typeof no.onCommitFiberUnmount == "function")
      try {
        no.onCommitFiberUnmount(_g, h);
      } catch {}
    switch (h.tag) {
      case 5:
        Br || Mu(h, u);
      case 6:
        var w = Er,
          x = Os;
        (Er = null),
          Ka(c, u, h),
          (Er = w),
          (Os = x),
          Er !== null &&
            (Os
              ? ((c = Er),
                (h = h.stateNode),
                c.nodeType === 8
                  ? c.parentNode.removeChild(h)
                  : c.removeChild(h))
              : Er.removeChild(h.stateNode));
        break;
      case 18:
        Er !== null &&
          (Os
            ? ((c = Er),
              (h = h.stateNode),
              c.nodeType === 8
                ? Mb(c.parentNode, h)
                : c.nodeType === 1 && Mb(c, h),
              Kp(c))
            : Mb(Er, h.stateNode));
        break;
      case 4:
        (w = Er),
          (x = Os),
          (Er = h.stateNode.containerInfo),
          (Os = !0),
          Ka(c, u, h),
          (Er = w),
          (Os = x);
        break;
      case 0:
      case 11:
      case 14:
      case 15:
        if (
          !Br &&
          ((w = h.updateQueue), w !== null && ((w = w.lastEffect), w !== null))
        ) {
          x = w = w.next;
          do {
            var P = x,
              L = P.destroy;
            (P = P.tag),
              L !== void 0 && (P & 2 || P & 4) && b1(h, u, L),
              (x = x.next);
          } while (x !== w);
        }
        Ka(c, u, h);
        break;
      case 1:
        if (
          !Br &&
          (Mu(h, u),
          (w = h.stateNode),
          typeof w.componentWillUnmount == "function")
        )
          try {
            (w.props = h.memoizedProps),
              (w.state = h.memoizedState),
              w.componentWillUnmount();
          } catch (G) {
            Tn(h, u, G);
          }
        Ka(c, u, h);
        break;
      case 21:
        Ka(c, u, h);
        break;
      case 22:
        h.mode & 1
          ? ((Br = (w = Br) || h.memoizedState !== null), Ka(c, u, h), (Br = w))
          : Ka(c, u, h);
        break;
      default:
        Ka(c, u, h);
    }
  }
  function MI(c) {
    var u = c.updateQueue;
    if (u !== null) {
      c.updateQueue = null;
      var h = c.stateNode;
      h === null && (h = c.stateNode = new D4()),
        u.forEach(function (w) {
          var x = H4.bind(null, c, w);
          h.has(w) || (h.add(w), w.then(x, x));
        });
    }
  }
  function ks(c, u) {
    var h = u.deletions;
    if (h !== null)
      for (var w = 0; w < h.length; w++) {
        var x = h[w];
        try {
          var P = c,
            L = u,
            G = L;
          e: for (; G !== null; ) {
            switch (G.tag) {
              case 5:
                (Er = G.stateNode), (Os = !1);
                break e;
              case 3:
                (Er = G.stateNode.containerInfo), (Os = !0);
                break e;
              case 4:
                (Er = G.stateNode.containerInfo), (Os = !0);
                break e;
            }
            G = G.return;
          }
          if (Er === null) throw Error(n(160));
          $I(P, L, x), (Er = null), (Os = !1);
          var Q = x.alternate;
          Q !== null && (Q.return = null), (x.return = null);
        } catch (ie) {
          Tn(x, u, ie);
        }
      }
    if (u.subtreeFlags & 12854)
      for (u = u.child; u !== null; ) LI(u, c), (u = u.sibling);
  }
  function LI(c, u) {
    var h = c.alternate,
      w = c.flags;
    switch (c.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        if ((ks(u, c), oo(c), w & 4)) {
          try {
            yf(3, c, c.return), fy(3, c);
          } catch (Fe) {
            Tn(c, c.return, Fe);
          }
          try {
            yf(5, c, c.return);
          } catch (Fe) {
            Tn(c, c.return, Fe);
          }
        }
        break;
      case 1:
        ks(u, c), oo(c), w & 512 && h !== null && Mu(h, h.return);
        break;
      case 5:
        if (
          (ks(u, c),
          oo(c),
          w & 512 && h !== null && Mu(h, h.return),
          c.flags & 32)
        ) {
          var x = c.stateNode;
          try {
            Vn(x, "");
          } catch (Fe) {
            Tn(c, c.return, Fe);
          }
        }
        if (w & 4 && ((x = c.stateNode), x != null)) {
          var P = c.memoizedProps,
            L = h !== null ? h.memoizedProps : P,
            G = c.type,
            Q = c.updateQueue;
          if (((c.updateQueue = null), Q !== null))
            try {
              G === "input" && P.type === "radio" && P.name != null && hn(x, P),
                bn(G, L);
              var ie = bn(G, P);
              for (L = 0; L < Q.length; L += 2) {
                var de = Q[L],
                  he = Q[L + 1];
                de === "style"
                  ? br(x, he)
                  : de === "dangerouslySetInnerHTML"
                  ? vr(x, he)
                  : de === "children"
                  ? Vn(x, he)
                  : C(x, de, he, ie);
              }
              switch (G) {
                case "input":
                  Wt(x, P);
                  break;
                case "textarea":
                  tn(x, P);
                  break;
                case "select":
                  var ue = x._wrapperState.wasMultiple;
                  x._wrapperState.wasMultiple = !!P.multiple;
                  var _e = P.value;
                  _e != null
                    ? vt(x, !!P.multiple, _e, !1)
                    : ue !== !!P.multiple &&
                      (P.defaultValue != null
                        ? vt(x, !!P.multiple, P.defaultValue, !0)
                        : vt(x, !!P.multiple, P.multiple ? [] : "", !1));
              }
              x[of] = P;
            } catch (Fe) {
              Tn(c, c.return, Fe);
            }
        }
        break;
      case 6:
        if ((ks(u, c), oo(c), w & 4)) {
          if (c.stateNode === null) throw Error(n(162));
          (x = c.stateNode), (P = c.memoizedProps);
          try {
            x.nodeValue = P;
          } catch (Fe) {
            Tn(c, c.return, Fe);
          }
        }
        break;
      case 3:
        if (
          (ks(u, c), oo(c), w & 4 && h !== null && h.memoizedState.isDehydrated)
        )
          try {
            Kp(u.containerInfo);
          } catch (Fe) {
            Tn(c, c.return, Fe);
          }
        break;
      case 4:
        ks(u, c), oo(c);
        break;
      case 13:
        ks(u, c),
          oo(c),
          (x = c.child),
          x.flags & 8192 &&
            ((P = x.memoizedState !== null),
            (x.stateNode.isHidden = P),
            !P ||
              (x.alternate !== null && x.alternate.memoizedState !== null) ||
              (_1 = Dn())),
          w & 4 && MI(c);
        break;
      case 22:
        if (
          ((de = h !== null && h.memoizedState !== null),
          c.mode & 1 ? ((Br = (ie = Br) || de), ks(u, c), (Br = ie)) : ks(u, c),
          oo(c),
          w & 8192)
        ) {
          if (
            ((ie = c.memoizedState !== null),
            (c.stateNode.isHidden = ie) && !de && c.mode & 1)
          )
            for ($e = c, de = c.child; de !== null; ) {
              for (he = $e = de; $e !== null; ) {
                switch (((ue = $e), (_e = ue.child), ue.tag)) {
                  case 0:
                  case 11:
                  case 14:
                  case 15:
                    yf(4, ue, ue.return);
                    break;
                  case 1:
                    Mu(ue, ue.return);
                    var Ue = ue.stateNode;
                    if (typeof Ue.componentWillUnmount == "function") {
                      (w = ue), (h = ue.return);
                      try {
                        (u = w),
                          (Ue.props = u.memoizedProps),
                          (Ue.state = u.memoizedState),
                          Ue.componentWillUnmount();
                      } catch (Fe) {
                        Tn(w, h, Fe);
                      }
                    }
                    break;
                  case 5:
                    Mu(ue, ue.return);
                    break;
                  case 22:
                    if (ue.memoizedState !== null) {
                      jI(he);
                      continue;
                    }
                }
                _e !== null ? ((_e.return = ue), ($e = _e)) : jI(he);
              }
              de = de.sibling;
            }
          e: for (de = null, he = c; ; ) {
            if (he.tag === 5) {
              if (de === null) {
                de = he;
                try {
                  (x = he.stateNode),
                    ie
                      ? ((P = x.style),
                        typeof P.setProperty == "function"
                          ? P.setProperty("display", "none", "important")
                          : (P.display = "none"))
                      : ((G = he.stateNode),
                        (Q = he.memoizedProps.style),
                        (L =
                          Q != null && Q.hasOwnProperty("display")
                            ? Q.display
                            : null),
                        (G.style.display = $r("display", L)));
                } catch (Fe) {
                  Tn(c, c.return, Fe);
                }
              }
            } else if (he.tag === 6) {
              if (de === null)
                try {
                  he.stateNode.nodeValue = ie ? "" : he.memoizedProps;
                } catch (Fe) {
                  Tn(c, c.return, Fe);
                }
            } else if (
              ((he.tag !== 22 && he.tag !== 23) ||
                he.memoizedState === null ||
                he === c) &&
              he.child !== null
            ) {
              (he.child.return = he), (he = he.child);
              continue;
            }
            if (he === c) break e;
            for (; he.sibling === null; ) {
              if (he.return === null || he.return === c) break e;
              de === he && (de = null), (he = he.return);
            }
            de === he && (de = null),
              (he.sibling.return = he.return),
              (he = he.sibling);
          }
        }
        break;
      case 19:
        ks(u, c), oo(c), w & 4 && MI(c);
        break;
      case 21:
        break;
      default:
        ks(u, c), oo(c);
    }
  }
  function oo(c) {
    var u = c.flags;
    if (u & 2) {
      try {
        e: {
          for (var h = c.return; h !== null; ) {
            if (kI(h)) {
              var w = h;
              break e;
            }
            h = h.return;
          }
          throw Error(n(160));
        }
        switch (w.tag) {
          case 5:
            var x = w.stateNode;
            w.flags & 32 && (Vn(x, ""), (w.flags &= -33));
            var P = DI(c);
            x1(c, P, x);
            break;
          case 3:
          case 4:
            var L = w.stateNode.containerInfo,
              G = DI(c);
            C1(c, G, L);
            break;
          default:
            throw Error(n(161));
        }
      } catch (Q) {
        Tn(c, c.return, Q);
      }
      c.flags &= -3;
    }
    u & 4096 && (c.flags &= -4097);
  }
  function M4(c, u, h) {
    ($e = c), UI(c);
  }
  function UI(c, u, h) {
    for (var w = (c.mode & 1) !== 0; $e !== null; ) {
      var x = $e,
        P = x.child;
      if (x.tag === 22 && w) {
        var L = x.memoizedState !== null || py;
        if (!L) {
          var G = x.alternate,
            Q = (G !== null && G.memoizedState !== null) || Br;
          G = py;
          var ie = Br;
          if (((py = L), (Br = Q) && !ie))
            for ($e = x; $e !== null; )
              (L = $e),
                (Q = L.child),
                L.tag === 22 && L.memoizedState !== null
                  ? FI(x)
                  : Q !== null
                  ? ((Q.return = L), ($e = Q))
                  : FI(x);
          for (; P !== null; ) ($e = P), UI(P), (P = P.sibling);
          ($e = x), (py = G), (Br = ie);
        }
        BI(c);
      } else
        x.subtreeFlags & 8772 && P !== null
          ? ((P.return = x), ($e = P))
          : BI(c);
    }
  }
  function BI(c) {
    for (; $e !== null; ) {
      var u = $e;
      if (u.flags & 8772) {
        var h = u.alternate;
        try {
          if (u.flags & 8772)
            switch (u.tag) {
              case 0:
              case 11:
              case 15:
                Br || fy(5, u);
                break;
              case 1:
                var w = u.stateNode;
                if (u.flags & 4 && !Br)
                  if (h === null) w.componentDidMount();
                  else {
                    var x =
                      u.elementType === u.type
                        ? h.memoizedProps
                        : Ns(u.type, h.memoizedProps);
                    w.componentDidUpdate(
                      x,
                      h.memoizedState,
                      w.__reactInternalSnapshotBeforeUpdate
                    );
                  }
                var P = u.updateQueue;
                P !== null && j2(u, P, w);
                break;
              case 3:
                var L = u.updateQueue;
                if (L !== null) {
                  if (((h = null), u.child !== null))
                    switch (u.child.tag) {
                      case 5:
                        h = u.child.stateNode;
                        break;
                      case 1:
                        h = u.child.stateNode;
                    }
                  j2(u, L, h);
                }
                break;
              case 5:
                var G = u.stateNode;
                if (h === null && u.flags & 4) {
                  h = G;
                  var Q = u.memoizedProps;
                  switch (u.type) {
                    case "button":
                    case "input":
                    case "select":
                    case "textarea":
                      Q.autoFocus && h.focus();
                      break;
                    case "img":
                      Q.src && (h.src = Q.src);
                  }
                }
                break;
              case 6:
                break;
              case 4:
                break;
              case 12:
                break;
              case 13:
                if (u.memoizedState === null) {
                  var ie = u.alternate;
                  if (ie !== null) {
                    var de = ie.memoizedState;
                    if (de !== null) {
                      var he = de.dehydrated;
                      he !== null && Kp(he);
                    }
                  }
                }
                break;
              case 19:
              case 17:
              case 21:
              case 22:
              case 23:
              case 25:
                break;
              default:
                throw Error(n(163));
            }
          Br || (u.flags & 512 && E1(u));
        } catch (ue) {
          Tn(u, u.return, ue);
        }
      }
      if (u === c) {
        $e = null;
        break;
      }
      if (((h = u.sibling), h !== null)) {
        (h.return = u.return), ($e = h);
        break;
      }
      $e = u.return;
    }
  }
  function jI(c) {
    for (; $e !== null; ) {
      var u = $e;
      if (u === c) {
        $e = null;
        break;
      }
      var h = u.sibling;
      if (h !== null) {
        (h.return = u.return), ($e = h);
        break;
      }
      $e = u.return;
    }
  }
  function FI(c) {
    for (; $e !== null; ) {
      var u = $e;
      try {
        switch (u.tag) {
          case 0:
          case 11:
          case 15:
            var h = u.return;
            try {
              fy(4, u);
            } catch (Q) {
              Tn(u, h, Q);
            }
            break;
          case 1:
            var w = u.stateNode;
            if (typeof w.componentDidMount == "function") {
              var x = u.return;
              try {
                w.componentDidMount();
              } catch (Q) {
                Tn(u, x, Q);
              }
            }
            var P = u.return;
            try {
              E1(u);
            } catch (Q) {
              Tn(u, P, Q);
            }
            break;
          case 5:
            var L = u.return;
            try {
              E1(u);
            } catch (Q) {
              Tn(u, L, Q);
            }
        }
      } catch (Q) {
        Tn(u, u.return, Q);
      }
      if (u === c) {
        $e = null;
        break;
      }
      var G = u.sibling;
      if (G !== null) {
        (G.return = u.return), ($e = G);
        break;
      }
      $e = u.return;
    }
  }
  var L4 = Math.ceil,
    hy = _.ReactCurrentDispatcher,
    S1 = _.ReactCurrentOwner,
    es = _.ReactCurrentBatchConfig,
    Tt = 0,
    or = null,
    zn = null,
    Cr = 0,
    ki = 0,
    Lu = Wa(0),
    Kn = 0,
    wf = null,
    il = 0,
    my = 0,
    A1 = 0,
    vf = null,
    ui = null,
    _1 = 0,
    Uu = 1 / 0,
    Ko = null,
    gy = !1,
    I1 = null,
    Ya = null,
    yy = !1,
    Za = null,
    wy = 0,
    bf = 0,
    T1 = null,
    vy = -1,
    by = 0;
  function Qr() {
    return Tt & 6 ? Dn() : vy !== -1 ? vy : (vy = Dn());
  }
  function Qa(c) {
    return c.mode & 1
      ? Tt & 2 && Cr !== 0
        ? Cr & -Cr
        : b4.transition !== null
        ? (by === 0 && (by = D_()), by)
        : ((c = Ht),
          c !== 0 || ((c = window.event), (c = c === void 0 ? 16 : W_(c.type))),
          c)
      : 1;
  }
  function Ds(c, u, h, w) {
    if (50 < bf) throw ((bf = 0), (T1 = null), Error(n(185)));
    Wp(c, h, w),
      (!(Tt & 2) || c !== or) &&
        (c === or && (!(Tt & 2) && (my |= h), Kn === 4 && Xa(c, Cr)),
        di(c, w),
        h === 1 &&
          Tt === 0 &&
          !(u.mode & 1) &&
          ((Uu = Dn() + 500), Kg && qa()));
  }
  function di(c, u) {
    var h = c.callbackNode;
    b8(c, u);
    var w = Pg(c, c === or ? Cr : 0);
    if (w === 0)
      h !== null && N_(h), (c.callbackNode = null), (c.callbackPriority = 0);
    else if (((u = w & -w), c.callbackPriority !== u)) {
      if ((h != null && N_(h), u === 1))
        c.tag === 0 ? v4(WI.bind(null, c)) : T2(WI.bind(null, c)),
          m4(function () {
            !(Tt & 6) && qa();
          }),
          (h = null);
      else {
        switch ($_(w)) {
          case 1:
            h = ab;
            break;
          case 4:
            h = O_;
            break;
          case 16:
            h = Ag;
            break;
          case 536870912:
            h = k_;
            break;
          default:
            h = Ag;
        }
        h = QI(h, zI.bind(null, c));
      }
      (c.callbackPriority = u), (c.callbackNode = h);
    }
  }
  function zI(c, u) {
    if (((vy = -1), (by = 0), Tt & 6)) throw Error(n(327));
    var h = c.callbackNode;
    if (Bu() && c.callbackNode !== h) return null;
    var w = Pg(c, c === or ? Cr : 0);
    if (w === 0) return null;
    if (w & 30 || w & c.expiredLanes || u) u = Ey(c, w);
    else {
      u = w;
      var x = Tt;
      Tt |= 2;
      var P = qI();
      (or !== c || Cr !== u) && ((Ko = null), (Uu = Dn() + 500), ol(c, u));
      do
        try {
          j4();
          break;
        } catch (G) {
          HI(c, G);
        }
      while (!0);
      Vb(),
        (hy.current = P),
        (Tt = x),
        zn !== null ? (u = 0) : ((or = null), (Cr = 0), (u = Kn));
    }
    if (u !== 0) {
      if (
        (u === 2 && ((x = cb(c)), x !== 0 && ((w = x), (u = P1(c, x)))),
        u === 1)
      )
        throw ((h = wf), ol(c, 0), Xa(c, w), di(c, Dn()), h);
      if (u === 6) Xa(c, w);
      else {
        if (
          ((x = c.current.alternate),
          !(w & 30) &&
            !U4(x) &&
            ((u = Ey(c, w)),
            u === 2 && ((P = cb(c)), P !== 0 && ((w = P), (u = P1(c, P)))),
            u === 1))
        )
          throw ((h = wf), ol(c, 0), Xa(c, w), di(c, Dn()), h);
        switch (((c.finishedWork = x), (c.finishedLanes = w), u)) {
          case 0:
          case 1:
            throw Error(n(345));
          case 2:
            al(c, ui, Ko);
            break;
          case 3:
            if (
              (Xa(c, w),
              (w & 130023424) === w && ((u = _1 + 500 - Dn()), 10 < u))
            ) {
              if (Pg(c, 0) !== 0) break;
              if (((x = c.suspendedLanes), (x & w) !== w)) {
                Qr(), (c.pingedLanes |= c.suspendedLanes & x);
                break;
              }
              c.timeoutHandle = $b(al.bind(null, c, ui, Ko), u);
              break;
            }
            al(c, ui, Ko);
            break;
          case 4:
            if ((Xa(c, w), (w & 4194240) === w)) break;
            for (u = c.eventTimes, x = -1; 0 < w; ) {
              var L = 31 - Ts(w);
              (P = 1 << L), (L = u[L]), L > x && (x = L), (w &= ~P);
            }
            if (
              ((w = x),
              (w = Dn() - w),
              (w =
                (120 > w
                  ? 120
                  : 480 > w
                  ? 480
                  : 1080 > w
                  ? 1080
                  : 1920 > w
                  ? 1920
                  : 3e3 > w
                  ? 3e3
                  : 4320 > w
                  ? 4320
                  : 1960 * L4(w / 1960)) - w),
              10 < w)
            ) {
              c.timeoutHandle = $b(al.bind(null, c, ui, Ko), w);
              break;
            }
            al(c, ui, Ko);
            break;
          case 5:
            al(c, ui, Ko);
            break;
          default:
            throw Error(n(329));
        }
      }
    }
    return di(c, Dn()), c.callbackNode === h ? zI.bind(null, c) : null;
  }
  function P1(c, u) {
    var h = vf;
    return (
      c.current.memoizedState.isDehydrated && (ol(c, u).flags |= 256),
      (c = Ey(c, u)),
      c !== 2 && ((u = ui), (ui = h), u !== null && R1(u)),
      c
    );
  }
  function R1(c) {
    ui === null ? (ui = c) : ui.push.apply(ui, c);
  }
  function U4(c) {
    for (var u = c; ; ) {
      if (u.flags & 16384) {
        var h = u.updateQueue;
        if (h !== null && ((h = h.stores), h !== null))
          for (var w = 0; w < h.length; w++) {
            var x = h[w],
              P = x.getSnapshot;
            x = x.value;
            try {
              if (!Ps(P(), x)) return !1;
            } catch {
              return !1;
            }
          }
      }
      if (((h = u.child), u.subtreeFlags & 16384 && h !== null))
        (h.return = u), (u = h);
      else {
        if (u === c) break;
        for (; u.sibling === null; ) {
          if (u.return === null || u.return === c) return !0;
          u = u.return;
        }
        (u.sibling.return = u.return), (u = u.sibling);
      }
    }
    return !0;
  }
  function Xa(c, u) {
    for (
      u &= ~A1,
        u &= ~my,
        c.suspendedLanes |= u,
        c.pingedLanes &= ~u,
        c = c.expirationTimes;
      0 < u;

    ) {
      var h = 31 - Ts(u),
        w = 1 << h;
      (c[h] = -1), (u &= ~w);
    }
  }
  function WI(c) {
    if (Tt & 6) throw Error(n(327));
    Bu();
    var u = Pg(c, 0);
    if (!(u & 1)) return di(c, Dn()), null;
    var h = Ey(c, u);
    if (c.tag !== 0 && h === 2) {
      var w = cb(c);
      w !== 0 && ((u = w), (h = P1(c, w)));
    }
    if (h === 1) throw ((h = wf), ol(c, 0), Xa(c, u), di(c, Dn()), h);
    if (h === 6) throw Error(n(345));
    return (
      (c.finishedWork = c.current.alternate),
      (c.finishedLanes = u),
      al(c, ui, Ko),
      di(c, Dn()),
      null
    );
  }
  function N1(c, u) {
    var h = Tt;
    Tt |= 1;
    try {
      return c(u);
    } finally {
      (Tt = h), Tt === 0 && ((Uu = Dn() + 500), Kg && qa());
    }
  }
  function sl(c) {
    Za !== null && Za.tag === 0 && !(Tt & 6) && Bu();
    var u = Tt;
    Tt |= 1;
    var h = es.transition,
      w = Ht;
    try {
      if (((es.transition = null), (Ht = 1), c)) return c();
    } finally {
      (Ht = w), (es.transition = h), (Tt = u), !(Tt & 6) && qa();
    }
  }
  function O1() {
    (ki = Lu.current), ln(Lu);
  }
  function ol(c, u) {
    (c.finishedWork = null), (c.finishedLanes = 0);
    var h = c.timeoutHandle;
    if ((h !== -1 && ((c.timeoutHandle = -1), h4(h)), zn !== null))
      for (h = zn.return; h !== null; ) {
        var w = h;
        switch ((Fb(w), w.tag)) {
          case 1:
            (w = w.type.childContextTypes), w != null && Vg();
            break;
          case 3:
            Du(), ln(ai), ln(Mr), e1();
            break;
          case 5:
            Xb(w);
            break;
          case 4:
            Du();
            break;
          case 13:
            ln(En);
            break;
          case 19:
            ln(En);
            break;
          case 10:
            Gb(w.type._context);
            break;
          case 22:
          case 23:
            O1();
        }
        h = h.return;
      }
    if (
      ((or = c),
      (zn = c = Ja(c.current, null)),
      (Cr = ki = u),
      (Kn = 0),
      (wf = null),
      (A1 = my = il = 0),
      (ui = vf = null),
      tl !== null)
    ) {
      for (u = 0; u < tl.length; u++)
        if (((h = tl[u]), (w = h.interleaved), w !== null)) {
          h.interleaved = null;
          var x = w.next,
            P = h.pending;
          if (P !== null) {
            var L = P.next;
            (P.next = x), (w.next = L);
          }
          h.pending = w;
        }
      tl = null;
    }
    return c;
  }
  function HI(c, u) {
    do {
      var h = zn;
      try {
        if ((Vb(), (iy.current = cy), sy)) {
          for (var w = Cn.memoizedState; w !== null; ) {
            var x = w.queue;
            x !== null && (x.pending = null), (w = w.next);
          }
          sy = !1;
        }
        if (
          ((rl = 0),
          (sr = Gn = Cn = null),
          (pf = !1),
          (ff = 0),
          (S1.current = null),
          h === null || h.return === null)
        ) {
          (Kn = 1), (wf = u), (zn = null);
          break;
        }
        e: {
          var P = c,
            L = h.return,
            G = h,
            Q = u;
          if (
            ((u = Cr),
            (G.flags |= 32768),
            Q !== null && typeof Q == "object" && typeof Q.then == "function")
          ) {
            var ie = Q,
              de = G,
              he = de.tag;
            if (!(de.mode & 1) && (he === 0 || he === 11 || he === 15)) {
              var ue = de.alternate;
              ue
                ? ((de.updateQueue = ue.updateQueue),
                  (de.memoizedState = ue.memoizedState),
                  (de.lanes = ue.lanes))
                : ((de.updateQueue = null), (de.memoizedState = null));
            }
            var _e = mI(L);
            if (_e !== null) {
              (_e.flags &= -257),
                gI(_e, L, G, P, u),
                _e.mode & 1 && hI(P, ie, u),
                (u = _e),
                (Q = ie);
              var Ue = u.updateQueue;
              if (Ue === null) {
                var Fe = new Set();
                Fe.add(Q), (u.updateQueue = Fe);
              } else Ue.add(Q);
              break e;
            } else {
              if (!(u & 1)) {
                hI(P, ie, u), k1();
                break e;
              }
              Q = Error(n(426));
            }
          } else if (mn && G.mode & 1) {
            var $n = mI(L);
            if ($n !== null) {
              !($n.flags & 65536) && ($n.flags |= 256),
                gI($n, L, G, P, u),
                Hb($u(Q, G));
              break e;
            }
          }
          (P = Q = $u(Q, G)),
            Kn !== 4 && (Kn = 2),
            vf === null ? (vf = [P]) : vf.push(P),
            (P = L);
          do {
            switch (P.tag) {
              case 3:
                (P.flags |= 65536), (u &= -u), (P.lanes |= u);
                var te = pI(P, Q, u);
                B2(P, te);
                break e;
              case 1:
                G = Q;
                var X = P.type,
                  ne = P.stateNode;
                if (
                  !(P.flags & 128) &&
                  (typeof X.getDerivedStateFromError == "function" ||
                    (ne !== null &&
                      typeof ne.componentDidCatch == "function" &&
                      (Ya === null || !Ya.has(ne))))
                ) {
                  (P.flags |= 65536), (u &= -u), (P.lanes |= u);
                  var we = fI(P, G, u);
                  B2(P, we);
                  break e;
                }
            }
            P = P.return;
          } while (P !== null);
        }
        GI(h);
      } catch (ze) {
        (u = ze), zn === h && h !== null && (zn = h = h.return);
        continue;
      }
      break;
    } while (!0);
  }
  function qI() {
    var c = hy.current;
    return (hy.current = cy), c === null ? cy : c;
  }
  function k1() {
    (Kn === 0 || Kn === 3 || Kn === 2) && (Kn = 4),
      or === null || (!(il & 268435455) && !(my & 268435455)) || Xa(or, Cr);
  }
  function Ey(c, u) {
    var h = Tt;
    Tt |= 2;
    var w = qI();
    (or !== c || Cr !== u) && ((Ko = null), ol(c, u));
    do
      try {
        B4();
        break;
      } catch (x) {
        HI(c, x);
      }
    while (!0);
    if ((Vb(), (Tt = h), (hy.current = w), zn !== null)) throw Error(n(261));
    return (or = null), (Cr = 0), Kn;
  }
  function B4() {
    for (; zn !== null; ) VI(zn);
  }
  function j4() {
    for (; zn !== null && !d8(); ) VI(zn);
  }
  function VI(c) {
    var u = ZI(c.alternate, c, ki);
    (c.memoizedProps = c.pendingProps),
      u === null ? GI(c) : (zn = u),
      (S1.current = null);
  }
  function GI(c) {
    var u = c;
    do {
      var h = u.alternate;
      if (((c = u.return), u.flags & 32768)) {
        if (((h = k4(h, u)), h !== null)) {
          (h.flags &= 32767), (zn = h);
          return;
        }
        if (c !== null)
          (c.flags |= 32768), (c.subtreeFlags = 0), (c.deletions = null);
        else {
          (Kn = 6), (zn = null);
          return;
        }
      } else if (((h = O4(h, u, ki)), h !== null)) {
        zn = h;
        return;
      }
      if (((u = u.sibling), u !== null)) {
        zn = u;
        return;
      }
      zn = u = c;
    } while (u !== null);
    Kn === 0 && (Kn = 5);
  }
  function al(c, u, h) {
    var w = Ht,
      x = es.transition;
    try {
      (es.transition = null), (Ht = 1), F4(c, u, h, w);
    } finally {
      (es.transition = x), (Ht = w);
    }
    return null;
  }
  function F4(c, u, h, w) {
    do Bu();
    while (Za !== null);
    if (Tt & 6) throw Error(n(327));
    h = c.finishedWork;
    var x = c.finishedLanes;
    if (h === null) return null;
    if (((c.finishedWork = null), (c.finishedLanes = 0), h === c.current))
      throw Error(n(177));
    (c.callbackNode = null), (c.callbackPriority = 0);
    var P = h.lanes | h.childLanes;
    if (
      (E8(c, P),
      c === or && ((zn = or = null), (Cr = 0)),
      (!(h.subtreeFlags & 2064) && !(h.flags & 2064)) ||
        yy ||
        ((yy = !0),
        QI(Ag, function () {
          return Bu(), null;
        })),
      (P = (h.flags & 15990) !== 0),
      h.subtreeFlags & 15990 || P)
    ) {
      (P = es.transition), (es.transition = null);
      var L = Ht;
      Ht = 1;
      var G = Tt;
      (Tt |= 4),
        (S1.current = null),
        $4(c, h),
        LI(h, c),
        a4(kb),
        (Og = !!Ob),
        (kb = Ob = null),
        (c.current = h),
        M4(h),
        p8(),
        (Tt = G),
        (Ht = L),
        (es.transition = P);
    } else c.current = h;
    if (
      (yy && ((yy = !1), (Za = c), (wy = x)),
      (P = c.pendingLanes),
      P === 0 && (Ya = null),
      m8(h.stateNode),
      di(c, Dn()),
      u !== null)
    )
      for (w = c.onRecoverableError, h = 0; h < u.length; h++)
        (x = u[h]), w(x.value, { componentStack: x.stack, digest: x.digest });
    if (gy) throw ((gy = !1), (c = I1), (I1 = null), c);
    return (
      wy & 1 && c.tag !== 0 && Bu(),
      (P = c.pendingLanes),
      P & 1 ? (c === T1 ? bf++ : ((bf = 0), (T1 = c))) : (bf = 0),
      qa(),
      null
    );
  }
  function Bu() {
    if (Za !== null) {
      var c = $_(wy),
        u = es.transition,
        h = Ht;
      try {
        if (((es.transition = null), (Ht = 16 > c ? 16 : c), Za === null))
          var w = !1;
        else {
          if (((c = Za), (Za = null), (wy = 0), Tt & 6)) throw Error(n(331));
          var x = Tt;
          for (Tt |= 4, $e = c.current; $e !== null; ) {
            var P = $e,
              L = P.child;
            if ($e.flags & 16) {
              var G = P.deletions;
              if (G !== null) {
                for (var Q = 0; Q < G.length; Q++) {
                  var ie = G[Q];
                  for ($e = ie; $e !== null; ) {
                    var de = $e;
                    switch (de.tag) {
                      case 0:
                      case 11:
                      case 15:
                        yf(8, de, P);
                    }
                    var he = de.child;
                    if (he !== null) (he.return = de), ($e = he);
                    else
                      for (; $e !== null; ) {
                        de = $e;
                        var ue = de.sibling,
                          _e = de.return;
                        if ((OI(de), de === ie)) {
                          $e = null;
                          break;
                        }
                        if (ue !== null) {
                          (ue.return = _e), ($e = ue);
                          break;
                        }
                        $e = _e;
                      }
                  }
                }
                var Ue = P.alternate;
                if (Ue !== null) {
                  var Fe = Ue.child;
                  if (Fe !== null) {
                    Ue.child = null;
                    do {
                      var $n = Fe.sibling;
                      (Fe.sibling = null), (Fe = $n);
                    } while (Fe !== null);
                  }
                }
                $e = P;
              }
            }
            if (P.subtreeFlags & 2064 && L !== null) (L.return = P), ($e = L);
            else
              e: for (; $e !== null; ) {
                if (((P = $e), P.flags & 2048))
                  switch (P.tag) {
                    case 0:
                    case 11:
                    case 15:
                      yf(9, P, P.return);
                  }
                var te = P.sibling;
                if (te !== null) {
                  (te.return = P.return), ($e = te);
                  break e;
                }
                $e = P.return;
              }
          }
          var X = c.current;
          for ($e = X; $e !== null; ) {
            L = $e;
            var ne = L.child;
            if (L.subtreeFlags & 2064 && ne !== null)
              (ne.return = L), ($e = ne);
            else
              e: for (L = X; $e !== null; ) {
                if (((G = $e), G.flags & 2048))
                  try {
                    switch (G.tag) {
                      case 0:
                      case 11:
                      case 15:
                        fy(9, G);
                    }
                  } catch (ze) {
                    Tn(G, G.return, ze);
                  }
                if (G === L) {
                  $e = null;
                  break e;
                }
                var we = G.sibling;
                if (we !== null) {
                  (we.return = G.return), ($e = we);
                  break e;
                }
                $e = G.return;
              }
          }
          if (
            ((Tt = x),
            qa(),
            no && typeof no.onPostCommitFiberRoot == "function")
          )
            try {
              no.onPostCommitFiberRoot(_g, c);
            } catch {}
          w = !0;
        }
        return w;
      } finally {
        (Ht = h), (es.transition = u);
      }
    }
    return !1;
  }
  function KI(c, u, h) {
    (u = $u(h, u)),
      (u = pI(c, u, 1)),
      (c = Ga(c, u, 1)),
      (u = Qr()),
      c !== null && (Wp(c, 1, u), di(c, u));
  }
  function Tn(c, u, h) {
    if (c.tag === 3) KI(c, c, h);
    else
      for (; u !== null; ) {
        if (u.tag === 3) {
          KI(u, c, h);
          break;
        } else if (u.tag === 1) {
          var w = u.stateNode;
          if (
            typeof u.type.getDerivedStateFromError == "function" ||
            (typeof w.componentDidCatch == "function" &&
              (Ya === null || !Ya.has(w)))
          ) {
            (c = $u(h, c)),
              (c = fI(u, c, 1)),
              (u = Ga(u, c, 1)),
              (c = Qr()),
              u !== null && (Wp(u, 1, c), di(u, c));
            break;
          }
        }
        u = u.return;
      }
  }
  function z4(c, u, h) {
    var w = c.pingCache;
    w !== null && w.delete(u),
      (u = Qr()),
      (c.pingedLanes |= c.suspendedLanes & h),
      or === c &&
        (Cr & h) === h &&
        (Kn === 4 || (Kn === 3 && (Cr & 130023424) === Cr && 500 > Dn() - _1)
          ? ol(c, 0)
          : (A1 |= h)),
      di(c, u);
  }
  function YI(c, u) {
    u === 0 &&
      (c.mode & 1
        ? ((u = Tg), (Tg <<= 1), !(Tg & 130023424) && (Tg = 4194304))
        : (u = 1));
    var h = Qr();
    (c = qo(c, u)), c !== null && (Wp(c, u, h), di(c, h));
  }
  function W4(c) {
    var u = c.memoizedState,
      h = 0;
    u !== null && (h = u.retryLane), YI(c, h);
  }
  function H4(c, u) {
    var h = 0;
    switch (c.tag) {
      case 13:
        var w = c.stateNode,
          x = c.memoizedState;
        x !== null && (h = x.retryLane);
        break;
      case 19:
        w = c.stateNode;
        break;
      default:
        throw Error(n(314));
    }
    w !== null && w.delete(u), YI(c, h);
  }
  var ZI;
  ZI = function (c, u, h) {
    if (c !== null)
      if (c.memoizedProps !== u.pendingProps || ai.current) li = !0;
      else {
        if (!(c.lanes & h) && !(u.flags & 128)) return (li = !1), N4(c, u, h);
        li = !!(c.flags & 131072);
      }
    else (li = !1), mn && u.flags & 1048576 && P2(u, Zg, u.index);
    switch (((u.lanes = 0), u.tag)) {
      case 2:
        var w = u.type;
        dy(c, u), (c = u.pendingProps);
        var x = Iu(u, Mr.current);
        ku(u, h), (x = r1(null, u, w, c, x, h));
        var P = i1();
        return (
          (u.flags |= 1),
          typeof x == "object" &&
          x !== null &&
          typeof x.render == "function" &&
          x.$$typeof === void 0
            ? ((u.tag = 1),
              (u.memoizedState = null),
              (u.updateQueue = null),
              ci(w) ? ((P = !0), Gg(u)) : (P = !1),
              (u.memoizedState =
                x.state !== null && x.state !== void 0 ? x.state : null),
              Zb(u),
              (x.updater = ly),
              (u.stateNode = x),
              (x._reactInternals = u),
              u1(u, w, c, h),
              (u = h1(null, u, w, !0, P, h)))
            : ((u.tag = 0), mn && P && jb(u), Zr(null, u, x, h), (u = u.child)),
          u
        );
      case 16:
        w = u.elementType;
        e: {
          switch (
            (dy(c, u),
            (c = u.pendingProps),
            (x = w._init),
            (w = x(w._payload)),
            (u.type = w),
            (x = u.tag = V4(w)),
            (c = Ns(w, c)),
            x)
          ) {
            case 0:
              u = f1(null, u, w, c, h);
              break e;
            case 1:
              u = CI(null, u, w, c, h);
              break e;
            case 11:
              u = yI(null, u, w, c, h);
              break e;
            case 14:
              u = wI(null, u, w, Ns(w.type, c), h);
              break e;
          }
          throw Error(n(306, w, ""));
        }
        return u;
      case 0:
        return (
          (w = u.type),
          (x = u.pendingProps),
          (x = u.elementType === w ? x : Ns(w, x)),
          f1(c, u, w, x, h)
        );
      case 1:
        return (
          (w = u.type),
          (x = u.pendingProps),
          (x = u.elementType === w ? x : Ns(w, x)),
          CI(c, u, w, x, h)
        );
      case 3:
        e: {
          if ((xI(u), c === null)) throw Error(n(387));
          (w = u.pendingProps),
            (P = u.memoizedState),
            (x = P.element),
            U2(c, u),
            ny(u, w, null, h);
          var L = u.memoizedState;
          if (((w = L.element), P.isDehydrated))
            if (
              ((P = {
                element: w,
                isDehydrated: !1,
                cache: L.cache,
                pendingSuspenseBoundaries: L.pendingSuspenseBoundaries,
                transitions: L.transitions,
              }),
              (u.updateQueue.baseState = P),
              (u.memoizedState = P),
              u.flags & 256)
            ) {
              (x = $u(Error(n(423)), u)), (u = SI(c, u, w, h, x));
              break e;
            } else if (w !== x) {
              (x = $u(Error(n(424)), u)), (u = SI(c, u, w, h, x));
              break e;
            } else
              for (
                Oi = za(u.stateNode.containerInfo.firstChild),
                  Ni = u,
                  mn = !0,
                  Rs = null,
                  h = M2(u, null, w, h),
                  u.child = h;
                h;

              )
                (h.flags = (h.flags & -3) | 4096), (h = h.sibling);
          else {
            if ((Ru(), w === x)) {
              u = Go(c, u, h);
              break e;
            }
            Zr(c, u, w, h);
          }
          u = u.child;
        }
        return u;
      case 5:
        return (
          F2(u),
          c === null && Wb(u),
          (w = u.type),
          (x = u.pendingProps),
          (P = c !== null ? c.memoizedProps : null),
          (L = x.children),
          Db(w, x) ? (L = null) : P !== null && Db(w, P) && (u.flags |= 32),
          EI(c, u),
          Zr(c, u, L, h),
          u.child
        );
      case 6:
        return c === null && Wb(u), null;
      case 13:
        return AI(c, u, h);
      case 4:
        return (
          Qb(u, u.stateNode.containerInfo),
          (w = u.pendingProps),
          c === null ? (u.child = Nu(u, null, w, h)) : Zr(c, u, w, h),
          u.child
        );
      case 11:
        return (
          (w = u.type),
          (x = u.pendingProps),
          (x = u.elementType === w ? x : Ns(w, x)),
          yI(c, u, w, x, h)
        );
      case 7:
        return Zr(c, u, u.pendingProps, h), u.child;
      case 8:
        return Zr(c, u, u.pendingProps.children, h), u.child;
      case 12:
        return Zr(c, u, u.pendingProps.children, h), u.child;
      case 10:
        e: {
          if (
            ((w = u.type._context),
            (x = u.pendingProps),
            (P = u.memoizedProps),
            (L = x.value),
            nn(Jg, w._currentValue),
            (w._currentValue = L),
            P !== null)
          )
            if (Ps(P.value, L)) {
              if (P.children === x.children && !ai.current) {
                u = Go(c, u, h);
                break e;
              }
            } else
              for (P = u.child, P !== null && (P.return = u); P !== null; ) {
                var G = P.dependencies;
                if (G !== null) {
                  L = P.child;
                  for (var Q = G.firstContext; Q !== null; ) {
                    if (Q.context === w) {
                      if (P.tag === 1) {
                        (Q = Vo(-1, h & -h)), (Q.tag = 2);
                        var ie = P.updateQueue;
                        if (ie !== null) {
                          ie = ie.shared;
                          var de = ie.pending;
                          de === null
                            ? (Q.next = Q)
                            : ((Q.next = de.next), (de.next = Q)),
                            (ie.pending = Q);
                        }
                      }
                      (P.lanes |= h),
                        (Q = P.alternate),
                        Q !== null && (Q.lanes |= h),
                        Kb(P.return, h, u),
                        (G.lanes |= h);
                      break;
                    }
                    Q = Q.next;
                  }
                } else if (P.tag === 10) L = P.type === u.type ? null : P.child;
                else if (P.tag === 18) {
                  if (((L = P.return), L === null)) throw Error(n(341));
                  (L.lanes |= h),
                    (G = L.alternate),
                    G !== null && (G.lanes |= h),
                    Kb(L, h, u),
                    (L = P.sibling);
                } else L = P.child;
                if (L !== null) L.return = P;
                else
                  for (L = P; L !== null; ) {
                    if (L === u) {
                      L = null;
                      break;
                    }
                    if (((P = L.sibling), P !== null)) {
                      (P.return = L.return), (L = P);
                      break;
                    }
                    L = L.return;
                  }
                P = L;
              }
          Zr(c, u, x.children, h), (u = u.child);
        }
        return u;
      case 9:
        return (
          (x = u.type),
          (w = u.pendingProps.children),
          ku(u, h),
          (x = Xi(x)),
          (w = w(x)),
          (u.flags |= 1),
          Zr(c, u, w, h),
          u.child
        );
      case 14:
        return (
          (w = u.type),
          (x = Ns(w, u.pendingProps)),
          (x = Ns(w.type, x)),
          wI(c, u, w, x, h)
        );
      case 15:
        return vI(c, u, u.type, u.pendingProps, h);
      case 17:
        return (
          (w = u.type),
          (x = u.pendingProps),
          (x = u.elementType === w ? x : Ns(w, x)),
          dy(c, u),
          (u.tag = 1),
          ci(w) ? ((c = !0), Gg(u)) : (c = !1),
          ku(u, h),
          uI(u, w, x),
          u1(u, w, x, h),
          h1(null, u, w, !0, c, h)
        );
      case 19:
        return II(c, u, h);
      case 22:
        return bI(c, u, h);
    }
    throw Error(n(156, u.tag));
  };
  function QI(c, u) {
    return R_(c, u);
  }
  function q4(c, u, h, w) {
    (this.tag = c),
      (this.key = h),
      (this.sibling =
        this.child =
        this.return =
        this.stateNode =
        this.type =
        this.elementType =
          null),
      (this.index = 0),
      (this.ref = null),
      (this.pendingProps = u),
      (this.dependencies =
        this.memoizedState =
        this.updateQueue =
        this.memoizedProps =
          null),
      (this.mode = w),
      (this.subtreeFlags = this.flags = 0),
      (this.deletions = null),
      (this.childLanes = this.lanes = 0),
      (this.alternate = null);
  }
  function ts(c, u, h, w) {
    return new q4(c, u, h, w);
  }
  function D1(c) {
    return (c = c.prototype), !(!c || !c.isReactComponent);
  }
  function V4(c) {
    if (typeof c == "function") return D1(c) ? 1 : 0;
    if (c != null) {
      if (((c = c.$$typeof), c === q)) return 11;
      if (c === $) return 14;
    }
    return 2;
  }
  function Ja(c, u) {
    var h = c.alternate;
    return (
      h === null
        ? ((h = ts(c.tag, u, c.key, c.mode)),
          (h.elementType = c.elementType),
          (h.type = c.type),
          (h.stateNode = c.stateNode),
          (h.alternate = c),
          (c.alternate = h))
        : ((h.pendingProps = u),
          (h.type = c.type),
          (h.flags = 0),
          (h.subtreeFlags = 0),
          (h.deletions = null)),
      (h.flags = c.flags & 14680064),
      (h.childLanes = c.childLanes),
      (h.lanes = c.lanes),
      (h.child = c.child),
      (h.memoizedProps = c.memoizedProps),
      (h.memoizedState = c.memoizedState),
      (h.updateQueue = c.updateQueue),
      (u = c.dependencies),
      (h.dependencies =
        u === null ? null : { lanes: u.lanes, firstContext: u.firstContext }),
      (h.sibling = c.sibling),
      (h.index = c.index),
      (h.ref = c.ref),
      h
    );
  }
  function Cy(c, u, h, w, x, P) {
    var L = 2;
    if (((w = c), typeof c == "function")) D1(c) && (L = 1);
    else if (typeof c == "string") L = 5;
    else
      e: switch (c) {
        case R:
          return cl(h.children, x, P, u);
        case D:
          (L = 8), (x |= 8);
          break;
        case k:
          return (
            (c = ts(12, h, u, x | 2)), (c.elementType = k), (c.lanes = P), c
          );
        case K:
          return (c = ts(13, h, u, x)), (c.elementType = K), (c.lanes = P), c;
        case H:
          return (c = ts(19, h, u, x)), (c.elementType = H), (c.lanes = P), c;
        case z:
          return xy(h, x, P, u);
        default:
          if (typeof c == "object" && c !== null)
            switch (c.$$typeof) {
              case T:
                L = 10;
                break e;
              case U:
                L = 9;
                break e;
              case q:
                L = 11;
                break e;
              case $:
                L = 14;
                break e;
              case M:
                (L = 16), (w = null);
                break e;
            }
          throw Error(n(130, c == null ? c : typeof c, ""));
      }
    return (
      (u = ts(L, h, u, x)), (u.elementType = c), (u.type = w), (u.lanes = P), u
    );
  }
  function cl(c, u, h, w) {
    return (c = ts(7, c, w, u)), (c.lanes = h), c;
  }
  function xy(c, u, h, w) {
    return (
      (c = ts(22, c, w, u)),
      (c.elementType = z),
      (c.lanes = h),
      (c.stateNode = { isHidden: !1 }),
      c
    );
  }
  function $1(c, u, h) {
    return (c = ts(6, c, null, u)), (c.lanes = h), c;
  }
  function M1(c, u, h) {
    return (
      (u = ts(4, c.children !== null ? c.children : [], c.key, u)),
      (u.lanes = h),
      (u.stateNode = {
        containerInfo: c.containerInfo,
        pendingChildren: null,
        implementation: c.implementation,
      }),
      u
    );
  }
  function G4(c, u, h, w, x) {
    (this.tag = u),
      (this.containerInfo = c),
      (this.finishedWork =
        this.pingCache =
        this.current =
        this.pendingChildren =
          null),
      (this.timeoutHandle = -1),
      (this.callbackNode = this.pendingContext = this.context = null),
      (this.callbackPriority = 0),
      (this.eventTimes = lb(0)),
      (this.expirationTimes = lb(-1)),
      (this.entangledLanes =
        this.finishedLanes =
        this.mutableReadLanes =
        this.expiredLanes =
        this.pingedLanes =
        this.suspendedLanes =
        this.pendingLanes =
          0),
      (this.entanglements = lb(0)),
      (this.identifierPrefix = w),
      (this.onRecoverableError = x),
      (this.mutableSourceEagerHydrationData = null);
  }
  function L1(c, u, h, w, x, P, L, G, Q) {
    return (
      (c = new G4(c, u, h, G, Q)),
      u === 1 ? ((u = 1), P === !0 && (u |= 8)) : (u = 0),
      (P = ts(3, null, null, u)),
      (c.current = P),
      (P.stateNode = c),
      (P.memoizedState = {
        element: w,
        isDehydrated: h,
        cache: null,
        transitions: null,
        pendingSuspenseBoundaries: null,
      }),
      Zb(P),
      c
    );
  }
  function K4(c, u, h) {
    var w =
      3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
    return {
      $$typeof: I,
      key: w == null ? null : "" + w,
      children: c,
      containerInfo: u,
      implementation: h,
    };
  }
  function XI(c) {
    if (!c) return Ha;
    c = c._reactInternals;
    e: {
      if (Zc(c) !== c || c.tag !== 1) throw Error(n(170));
      var u = c;
      do {
        switch (u.tag) {
          case 3:
            u = u.stateNode.context;
            break e;
          case 1:
            if (ci(u.type)) {
              u = u.stateNode.__reactInternalMemoizedMergedChildContext;
              break e;
            }
        }
        u = u.return;
      } while (u !== null);
      throw Error(n(171));
    }
    if (c.tag === 1) {
      var h = c.type;
      if (ci(h)) return _2(c, h, u);
    }
    return u;
  }
  function JI(c, u, h, w, x, P, L, G, Q) {
    return (
      (c = L1(h, w, !0, c, x, P, L, G, Q)),
      (c.context = XI(null)),
      (h = c.current),
      (w = Qr()),
      (x = Qa(h)),
      (P = Vo(w, x)),
      (P.callback = u ?? null),
      Ga(h, P, x),
      (c.current.lanes = x),
      Wp(c, x, w),
      di(c, w),
      c
    );
  }
  function Sy(c, u, h, w) {
    var x = u.current,
      P = Qr(),
      L = Qa(x);
    return (
      (h = XI(h)),
      u.context === null ? (u.context = h) : (u.pendingContext = h),
      (u = Vo(P, L)),
      (u.payload = { element: c }),
      (w = w === void 0 ? null : w),
      w !== null && (u.callback = w),
      (c = Ga(x, u, L)),
      c !== null && (Ds(c, x, L, P), ty(c, x, L)),
      L
    );
  }
  function Ay(c) {
    if (((c = c.current), !c.child)) return null;
    switch (c.child.tag) {
      case 5:
        return c.child.stateNode;
      default:
        return c.child.stateNode;
    }
  }
  function eT(c, u) {
    if (((c = c.memoizedState), c !== null && c.dehydrated !== null)) {
      var h = c.retryLane;
      c.retryLane = h !== 0 && h < u ? h : u;
    }
  }
  function U1(c, u) {
    eT(c, u), (c = c.alternate) && eT(c, u);
  }
  var tT =
    typeof reportError == "function"
      ? reportError
      : function (c) {
          console.error(c);
        };
  function B1(c) {
    this._internalRoot = c;
  }
  (_y.prototype.render = B1.prototype.render =
    function (c) {
      var u = this._internalRoot;
      if (u === null) throw Error(n(409));
      Sy(c, u, null, null);
    }),
    (_y.prototype.unmount = B1.prototype.unmount =
      function () {
        var c = this._internalRoot;
        if (c !== null) {
          this._internalRoot = null;
          var u = c.containerInfo;
          sl(function () {
            Sy(null, c, null, null);
          }),
            (u[Fo] = null);
        }
      });
  function _y(c) {
    this._internalRoot = c;
  }
  _y.prototype.unstable_scheduleHydration = function (c) {
    if (c) {
      var u = U_();
      c = { blockedOn: null, target: c, priority: u };
      for (var h = 0; h < Ba.length && u !== 0 && u < Ba[h].priority; h++);
      Ba.splice(h, 0, c), h === 0 && F_(c);
    }
  };
  function j1(c) {
    return !(!c || (c.nodeType !== 1 && c.nodeType !== 9 && c.nodeType !== 11));
  }
  function Iy(c) {
    return !(
      !c ||
      (c.nodeType !== 1 &&
        c.nodeType !== 9 &&
        c.nodeType !== 11 &&
        (c.nodeType !== 8 || c.nodeValue !== " react-mount-point-unstable "))
    );
  }
  function nT() {}
  function Y4(c, u, h, w, x) {
    if (x) {
      if (typeof w == "function") {
        var P = w;
        w = function () {
          var ie = Ay(L);
          P.call(ie);
        };
      }
      var L = JI(u, w, c, 0, null, !1, !1, "", nT);
      return (
        (c._reactRootContainer = L),
        (c[Fo] = L.current),
        rf(c.nodeType === 8 ? c.parentNode : c),
        sl(),
        L
      );
    }
    for (; (x = c.lastChild); ) c.removeChild(x);
    if (typeof w == "function") {
      var G = w;
      w = function () {
        var ie = Ay(Q);
        G.call(ie);
      };
    }
    var Q = L1(c, 0, !1, null, null, !1, !1, "", nT);
    return (
      (c._reactRootContainer = Q),
      (c[Fo] = Q.current),
      rf(c.nodeType === 8 ? c.parentNode : c),
      sl(function () {
        Sy(u, Q, h, w);
      }),
      Q
    );
  }
  function Ty(c, u, h, w, x) {
    var P = h._reactRootContainer;
    if (P) {
      var L = P;
      if (typeof x == "function") {
        var G = x;
        x = function () {
          var Q = Ay(L);
          G.call(Q);
        };
      }
      Sy(u, L, c, x);
    } else L = Y4(h, u, c, x, w);
    return Ay(L);
  }
  (M_ = function (c) {
    switch (c.tag) {
      case 3:
        var u = c.stateNode;
        if (u.current.memoizedState.isDehydrated) {
          var h = zp(u.pendingLanes);
          h !== 0 &&
            (ub(u, h | 1), di(u, Dn()), !(Tt & 6) && ((Uu = Dn() + 500), qa()));
        }
        break;
      case 13:
        sl(function () {
          var w = qo(c, 1);
          if (w !== null) {
            var x = Qr();
            Ds(w, c, 1, x);
          }
        }),
          U1(c, 1);
    }
  }),
    (db = function (c) {
      if (c.tag === 13) {
        var u = qo(c, 134217728);
        if (u !== null) {
          var h = Qr();
          Ds(u, c, 134217728, h);
        }
        U1(c, 134217728);
      }
    }),
    (L_ = function (c) {
      if (c.tag === 13) {
        var u = Qa(c),
          h = qo(c, u);
        if (h !== null) {
          var w = Qr();
          Ds(h, c, u, w);
        }
        U1(c, u);
      }
    }),
    (U_ = function () {
      return Ht;
    }),
    (B_ = function (c, u) {
      var h = Ht;
      try {
        return (Ht = c), u();
      } finally {
        Ht = h;
      }
    }),
    (Lp = function (c, u, h) {
      switch (u) {
        case "input":
          if ((Wt(c, h), (u = h.name), h.type === "radio" && u != null)) {
            for (h = c; h.parentNode; ) h = h.parentNode;
            for (
              h = h.querySelectorAll(
                "input[name=" + JSON.stringify("" + u) + '][type="radio"]'
              ),
                u = 0;
              u < h.length;
              u++
            ) {
              var w = h[u];
              if (w !== c && w.form === c.form) {
                var x = qg(w);
                if (!x) throw Error(n(90));
                Pe(w), Wt(w, x);
              }
            }
          }
          break;
        case "textarea":
          tn(c, h);
          break;
        case "select":
          (u = h.value), u != null && vt(c, !!h.multiple, u, !1);
      }
    }),
    (Cg = N1),
    (at = sl);
  var Z4 = { usingClientEntryPoint: !1, Events: [af, Au, qg, bg, Eg, N1] },
    Ef = {
      findFiberByHostInstance: Qc,
      bundleType: 0,
      version: "18.3.1",
      rendererPackageName: "react-dom",
    },
    Q4 = {
      bundleType: Ef.bundleType,
      version: Ef.version,
      rendererPackageName: Ef.rendererPackageName,
      rendererConfig: Ef.rendererConfig,
      overrideHookState: null,
      overrideHookStateDeletePath: null,
      overrideHookStateRenamePath: null,
      overrideProps: null,
      overridePropsDeletePath: null,
      overridePropsRenamePath: null,
      setErrorHandler: null,
      setSuspenseHandler: null,
      scheduleUpdate: null,
      currentDispatcherRef: _.ReactCurrentDispatcher,
      findHostInstanceByFiber: function (c) {
        return (c = T_(c)), c === null ? null : c.stateNode;
      },
      findFiberByHostInstance: Ef.findFiberByHostInstance,
      findHostInstancesForRefresh: null,
      scheduleRefresh: null,
      scheduleRoot: null,
      setRefreshHandler: null,
      getCurrentFiber: null,
      reconcilerVersion: "18.3.1-next-f1338f8080-20240426",
    };
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
    var Py = __REACT_DEVTOOLS_GLOBAL_HOOK__;
    if (!Py.isDisabled && Py.supportsFiber)
      try {
        (_g = Py.inject(Q4)), (no = Py);
      } catch {}
  }
  return (
    (pi.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = Z4),
    (pi.createPortal = function (c, u) {
      var h =
        2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
      if (!j1(u)) throw Error(n(200));
      return K4(c, u, null, h);
    }),
    (pi.createRoot = function (c, u) {
      if (!j1(c)) throw Error(n(299));
      var h = !1,
        w = "",
        x = tT;
      return (
        u != null &&
          (u.unstable_strictMode === !0 && (h = !0),
          u.identifierPrefix !== void 0 && (w = u.identifierPrefix),
          u.onRecoverableError !== void 0 && (x = u.onRecoverableError)),
        (u = L1(c, 1, !1, null, null, h, !1, w, x)),
        (c[Fo] = u.current),
        rf(c.nodeType === 8 ? c.parentNode : c),
        new B1(u)
      );
    }),
    (pi.findDOMNode = function (c) {
      if (c == null) return null;
      if (c.nodeType === 1) return c;
      var u = c._reactInternals;
      if (u === void 0)
        throw typeof c.render == "function"
          ? Error(n(188))
          : ((c = Object.keys(c).join(",")), Error(n(268, c)));
      return (c = T_(u)), (c = c === null ? null : c.stateNode), c;
    }),
    (pi.flushSync = function (c) {
      return sl(c);
    }),
    (pi.hydrate = function (c, u, h) {
      if (!Iy(u)) throw Error(n(200));
      return Ty(null, c, u, !0, h);
    }),
    (pi.hydrateRoot = function (c, u, h) {
      if (!j1(c)) throw Error(n(405));
      var w = (h != null && h.hydratedSources) || null,
        x = !1,
        P = "",
        L = tT;
      if (
        (h != null &&
          (h.unstable_strictMode === !0 && (x = !0),
          h.identifierPrefix !== void 0 && (P = h.identifierPrefix),
          h.onRecoverableError !== void 0 && (L = h.onRecoverableError)),
        (u = JI(u, null, c, 1, h ?? null, x, !1, P, L)),
        (c[Fo] = u.current),
        rf(c),
        w)
      )
        for (c = 0; c < w.length; c++)
          (h = w[c]),
            (x = h._getVersion),
            (x = x(h._source)),
            u.mutableSourceEagerHydrationData == null
              ? (u.mutableSourceEagerHydrationData = [h, x])
              : u.mutableSourceEagerHydrationData.push(h, x);
      return new _y(u);
    }),
    (pi.render = function (c, u, h) {
      if (!Iy(u)) throw Error(n(200));
      return Ty(null, c, u, !1, h);
    }),
    (pi.unmountComponentAtNode = function (c) {
      if (!Iy(c)) throw Error(n(40));
      return c._reactRootContainer
        ? (sl(function () {
            Ty(null, null, c, !1, function () {
              (c._reactRootContainer = null), (c[Fo] = null);
            });
          }),
          !0)
        : !1;
    }),
    (pi.unstable_batchedUpdates = N1),
    (pi.unstable_renderSubtreeIntoContainer = function (c, u, h, w) {
      if (!Iy(h)) throw Error(n(200));
      if (c == null || c._reactInternals === void 0) throw Error(n(38));
      return Ty(c, u, h, !1, w);
    }),
    (pi.version = "18.3.1-next-f1338f8080-20240426"),
    pi
  );
}
var dT;
function T5() {
  if (dT) return H1.exports;
  dT = 1;
  function t() {
    if (
      !(
        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" ||
        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function"
      )
    )
      try {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(t);
      } catch (e) {
        console.error(e);
      }
  }
  return t(), (H1.exports = cU()), H1.exports;
}
var pT;
function lU() {
  if (pT) return Ny;
  pT = 1;
  var t = T5();
  return (Ny.createRoot = t.createRoot), (Ny.hydrateRoot = t.hydrateRoot), Ny;
}
var uU = lU();
const Rh = { black: "#000", white: "#fff" },
  ju = {
    50: "#ffebee",
    100: "#ffcdd2",
    200: "#ef9a9a",
    300: "#e57373",
    400: "#ef5350",
    500: "#f44336",
    600: "#e53935",
    700: "#d32f2f",
    800: "#c62828",
    900: "#b71c1c",
    A100: "#ff8a80",
    A200: "#ff5252",
    A400: "#ff1744",
    A700: "#d50000",
  },
  Fu = {
    50: "#f3e5f5",
    100: "#e1bee7",
    200: "#ce93d8",
    300: "#ba68c8",
    400: "#ab47bc",
    500: "#9c27b0",
    600: "#8e24aa",
    700: "#7b1fa2",
    800: "#6a1b9a",
    900: "#4a148c",
    A100: "#ea80fc",
    A200: "#e040fb",
    A400: "#d500f9",
    A700: "#aa00ff",
  },
  zu = {
    50: "#e3f2fd",
    100: "#bbdefb",
    200: "#90caf9",
    300: "#64b5f6",
    400: "#42a5f5",
    500: "#2196f3",
    600: "#1e88e5",
    700: "#1976d2",
    800: "#1565c0",
    900: "#0d47a1",
    A100: "#82b1ff",
    A200: "#448aff",
    A400: "#2979ff",
    A700: "#2962ff",
  },
  Wu = {
    50: "#e1f5fe",
    100: "#b3e5fc",
    200: "#81d4fa",
    300: "#4fc3f7",
    400: "#29b6f6",
    500: "#03a9f4",
    600: "#039be5",
    700: "#0288d1",
    800: "#0277bd",
    900: "#01579b",
    A100: "#80d8ff",
    A200: "#40c4ff",
    A400: "#00b0ff",
    A700: "#0091ea",
  },
  Hu = {
    50: "#e8f5e9",
    100: "#c8e6c9",
    200: "#a5d6a7",
    300: "#81c784",
    400: "#66bb6a",
    500: "#4caf50",
    600: "#43a047",
    700: "#388e3c",
    800: "#2e7d32",
    900: "#1b5e20",
    A100: "#b9f6ca",
    A200: "#69f0ae",
    A400: "#00e676",
    A700: "#00c853",
  },
  Sf = {
    50: "#fff3e0",
    100: "#ffe0b2",
    200: "#ffcc80",
    300: "#ffb74d",
    400: "#ffa726",
    500: "#ff9800",
    600: "#fb8c00",
    700: "#f57c00",
    800: "#ef6c00",
    900: "#e65100",
    A100: "#ffd180",
    A200: "#ffab40",
    A400: "#ff9100",
    A700: "#ff6d00",
  },
  dU = {
    50: "#fafafa",
    100: "#f5f5f5",
    200: "#eeeeee",
    300: "#e0e0e0",
    400: "#bdbdbd",
    500: "#9e9e9e",
    600: "#757575",
    700: "#616161",
    800: "#424242",
    900: "#212121",
    A100: "#f5f5f5",
    A200: "#eeeeee",
    A400: "#bdbdbd",
    A700: "#616161",
  };
function xa(t, ...e) {
  const n = new URL(`https://mui.com/production-error/?code=${t}`);
  return (
    e.forEach((r) => n.searchParams.append("args[]", r)),
    `Minified MUI error #${t}; visit ${n} for the full message.`
  );
}
const Mm = "$$material";
function Q0() {
  return (
    (Q0 = Object.assign
      ? Object.assign.bind()
      : function (t) {
          for (var e = 1; e < arguments.length; e++) {
            var n = arguments[e];
            for (var r in n) ({}.hasOwnProperty.call(n, r) && (t[r] = n[r]));
          }
          return t;
        }),
    Q0.apply(null, arguments)
  );
}
var pU = !1;
function fU(t) {
  if (t.sheet) return t.sheet;
  for (var e = 0; e < document.styleSheets.length; e++)
    if (document.styleSheets[e].ownerNode === t) return document.styleSheets[e];
}
function hU(t) {
  var e = document.createElement("style");
  return (
    e.setAttribute("data-emotion", t.key),
    t.nonce !== void 0 && e.setAttribute("nonce", t.nonce),
    e.appendChild(document.createTextNode("")),
    e.setAttribute("data-s", ""),
    e
  );
}
var mU = (function () {
    function t(n) {
      var r = this;
      (this._insertTag = function (i) {
        var s;
        r.tags.length === 0
          ? r.insertionPoint
            ? (s = r.insertionPoint.nextSibling)
            : r.prepend
            ? (s = r.container.firstChild)
            : (s = r.before)
          : (s = r.tags[r.tags.length - 1].nextSibling),
          r.container.insertBefore(i, s),
          r.tags.push(i);
      }),
        (this.isSpeedy = n.speedy === void 0 ? !pU : n.speedy),
        (this.tags = []),
        (this.ctr = 0),
        (this.nonce = n.nonce),
        (this.key = n.key),
        (this.container = n.container),
        (this.prepend = n.prepend),
        (this.insertionPoint = n.insertionPoint),
        (this.before = null);
    }
    var e = t.prototype;
    return (
      (e.hydrate = function (r) {
        r.forEach(this._insertTag);
      }),
      (e.insert = function (r) {
        this.ctr % (this.isSpeedy ? 65e3 : 1) === 0 &&
          this._insertTag(hU(this));
        var i = this.tags[this.tags.length - 1];
        if (this.isSpeedy) {
          var s = fU(i);
          try {
            s.insertRule(r, s.cssRules.length);
          } catch {}
        } else i.appendChild(document.createTextNode(r));
        this.ctr++;
      }),
      (e.flush = function () {
        this.tags.forEach(function (r) {
          var i;
          return (i = r.parentNode) == null ? void 0 : i.removeChild(r);
        }),
          (this.tags = []),
          (this.ctr = 0);
      }),
      t
    );
  })(),
  zr = "-ms-",
  X0 = "-moz-",
  $t = "-webkit-",
  P5 = "comm",
  OS = "rule",
  kS = "decl",
  gU = "@import",
  R5 = "@keyframes",
  yU = "@layer",
  wU = Math.abs,
  Hw = String.fromCharCode,
  vU = Object.assign;
function bU(t, e) {
  return Ir(t, 0) ^ 45
    ? (((((((e << 2) ^ Ir(t, 0)) << 2) ^ Ir(t, 1)) << 2) ^ Ir(t, 2)) << 2) ^
        Ir(t, 3)
    : 0;
}
function N5(t) {
  return t.trim();
}
function EU(t, e) {
  return (t = e.exec(t)) ? t[0] : t;
}
function Mt(t, e, n) {
  return t.replace(e, n);
}
function WC(t, e) {
  return t.indexOf(e);
}
function Ir(t, e) {
  return t.charCodeAt(e) | 0;
}
function Nh(t, e, n) {
  return t.slice(e, n);
}
function Co(t) {
  return t.length;
}
function DS(t) {
  return t.length;
}
function Oy(t, e) {
  return e.push(t), t;
}
function CU(t, e) {
  return t.map(e).join("");
}
var qw = 1,
  Vd = 1,
  O5 = 0,
  Ai = 0,
  qn = 0,
  vp = "";
function Vw(t, e, n, r, i, s, o) {
  return {
    value: t,
    root: e,
    parent: n,
    type: r,
    props: i,
    children: s,
    line: qw,
    column: Vd,
    length: o,
    return: "",
  };
}
function Af(t, e) {
  return vU(Vw("", null, null, "", null, null, 0), t, { length: -t.length }, e);
}
function xU() {
  return qn;
}
function SU() {
  return (
    (qn = Ai > 0 ? Ir(vp, --Ai) : 0), Vd--, qn === 10 && ((Vd = 1), qw--), qn
  );
}
function Hi() {
  return (
    (qn = Ai < O5 ? Ir(vp, Ai++) : 0), Vd++, qn === 10 && ((Vd = 1), qw++), qn
  );
}
function Io() {
  return Ir(vp, Ai);
}
function _0() {
  return Ai;
}
function Lm(t, e) {
  return Nh(vp, t, e);
}
function Oh(t) {
  switch (t) {
    case 0:
    case 9:
    case 10:
    case 13:
    case 32:
      return 5;
    case 33:
    case 43:
    case 44:
    case 47:
    case 62:
    case 64:
    case 126:
    case 59:
    case 123:
    case 125:
      return 4;
    case 58:
      return 3;
    case 34:
    case 39:
    case 40:
    case 91:
      return 2;
    case 41:
    case 93:
      return 1;
  }
  return 0;
}
function k5(t) {
  return (qw = Vd = 1), (O5 = Co((vp = t))), (Ai = 0), [];
}
function D5(t) {
  return (vp = ""), t;
}
function I0(t) {
  return N5(Lm(Ai - 1, HC(t === 91 ? t + 2 : t === 40 ? t + 1 : t)));
}
function AU(t) {
  for (; (qn = Io()) && qn < 33; ) Hi();
  return Oh(t) > 2 || Oh(qn) > 3 ? "" : " ";
}
function _U(t, e) {
  for (
    ;
    --e &&
    Hi() &&
    !(qn < 48 || qn > 102 || (qn > 57 && qn < 65) || (qn > 70 && qn < 97));

  );
  return Lm(t, _0() + (e < 6 && Io() == 32 && Hi() == 32));
}
function HC(t) {
  for (; Hi(); )
    switch (qn) {
      case t:
        return Ai;
      case 34:
      case 39:
        t !== 34 && t !== 39 && HC(qn);
        break;
      case 40:
        t === 41 && HC(t);
        break;
      case 92:
        Hi();
        break;
    }
  return Ai;
}
function IU(t, e) {
  for (; Hi() && t + qn !== 57; ) if (t + qn === 84 && Io() === 47) break;
  return "/*" + Lm(e, Ai - 1) + "*" + Hw(t === 47 ? t : Hi());
}
function TU(t) {
  for (; !Oh(Io()); ) Hi();
  return Lm(t, Ai);
}
function PU(t) {
  return D5(T0("", null, null, null, [""], (t = k5(t)), 0, [0], t));
}
function T0(t, e, n, r, i, s, o, a, l) {
  for (
    var d = 0,
      p = 0,
      f = o,
      m = 0,
      y = 0,
      g = 0,
      v = 1,
      b = 1,
      E = 1,
      S = 0,
      C = "",
      _ = i,
      A = s,
      I = r,
      R = C;
    b;

  )
    switch (((g = S), (S = Hi()))) {
      case 40:
        if (g != 108 && Ir(R, f - 1) == 58) {
          WC((R += Mt(I0(S), "&", "&\f")), "&\f") != -1 && (E = -1);
          break;
        }
      case 34:
      case 39:
      case 91:
        R += I0(S);
        break;
      case 9:
      case 10:
      case 13:
      case 32:
        R += AU(g);
        break;
      case 92:
        R += _U(_0() - 1, 7);
        continue;
      case 47:
        switch (Io()) {
          case 42:
          case 47:
            Oy(RU(IU(Hi(), _0()), e, n), l);
            break;
          default:
            R += "/";
        }
        break;
      case 123 * v:
        a[d++] = Co(R) * E;
      case 125 * v:
      case 59:
      case 0:
        switch (S) {
          case 0:
          case 125:
            b = 0;
          case 59 + p:
            E == -1 && (R = Mt(R, /\f/g, "")),
              y > 0 &&
                Co(R) - f &&
                Oy(
                  y > 32
                    ? hT(R + ";", r, n, f - 1)
                    : hT(Mt(R, " ", "") + ";", r, n, f - 2),
                  l
                );
            break;
          case 59:
            R += ";";
          default:
            if (
              (Oy((I = fT(R, e, n, d, p, i, a, C, (_ = []), (A = []), f)), s),
              S === 123)
            )
              if (p === 0) T0(R, e, I, I, _, s, f, a, A);
              else
                switch (m === 99 && Ir(R, 3) === 110 ? 100 : m) {
                  case 100:
                  case 108:
                  case 109:
                  case 115:
                    T0(
                      t,
                      I,
                      I,
                      r && Oy(fT(t, I, I, 0, 0, i, a, C, i, (_ = []), f), A),
                      i,
                      A,
                      f,
                      a,
                      r ? _ : A
                    );
                    break;
                  default:
                    T0(R, I, I, I, [""], A, 0, a, A);
                }
        }
        (d = p = y = 0), (v = E = 1), (C = R = ""), (f = o);
        break;
      case 58:
        (f = 1 + Co(R)), (y = g);
      default:
        if (v < 1) {
          if (S == 123) --v;
          else if (S == 125 && v++ == 0 && SU() == 125) continue;
        }
        switch (((R += Hw(S)), S * v)) {
          case 38:
            E = p > 0 ? 1 : ((R += "\f"), -1);
            break;
          case 44:
            (a[d++] = (Co(R) - 1) * E), (E = 1);
            break;
          case 64:
            Io() === 45 && (R += I0(Hi())),
              (m = Io()),
              (p = f = Co((C = R += TU(_0())))),
              S++;
            break;
          case 45:
            g === 45 && Co(R) == 2 && (v = 0);
        }
    }
  return s;
}
function fT(t, e, n, r, i, s, o, a, l, d, p) {
  for (
    var f = i - 1, m = i === 0 ? s : [""], y = DS(m), g = 0, v = 0, b = 0;
    g < r;
    ++g
  )
    for (var E = 0, S = Nh(t, f + 1, (f = wU((v = o[g])))), C = t; E < y; ++E)
      (C = N5(v > 0 ? m[E] + " " + S : Mt(S, /&\f/g, m[E]))) && (l[b++] = C);
  return Vw(t, e, n, i === 0 ? OS : a, l, d, p);
}
function RU(t, e, n) {
  return Vw(t, e, n, P5, Hw(xU()), Nh(t, 2, -2), 0);
}
function hT(t, e, n, r) {
  return Vw(t, e, n, kS, Nh(t, 0, r), Nh(t, r + 1, -1), r);
}
function Td(t, e) {
  for (var n = "", r = DS(t), i = 0; i < r; i++) n += e(t[i], i, t, e) || "";
  return n;
}
function NU(t, e, n, r) {
  switch (t.type) {
    case yU:
      if (t.children.length) break;
    case gU:
    case kS:
      return (t.return = t.return || t.value);
    case P5:
      return "";
    case R5:
      return (t.return = t.value + "{" + Td(t.children, r) + "}");
    case OS:
      t.value = t.props.join(",");
  }
  return Co((n = Td(t.children, r)))
    ? (t.return = t.value + "{" + n + "}")
    : "";
}
function OU(t) {
  var e = DS(t);
  return function (n, r, i, s) {
    for (var o = "", a = 0; a < e; a++) o += t[a](n, r, i, s) || "";
    return o;
  };
}
function kU(t) {
  return function (e) {
    e.root || ((e = e.return) && t(e));
  };
}
function $5(t) {
  var e = Object.create(null);
  return function (n) {
    return e[n] === void 0 && (e[n] = t(n)), e[n];
  };
}
var DU = function (e, n, r) {
    for (
      var i = 0, s = 0;
      (i = s), (s = Io()), i === 38 && s === 12 && (n[r] = 1), !Oh(s);

    )
      Hi();
    return Lm(e, Ai);
  },
  $U = function (e, n) {
    var r = -1,
      i = 44;
    do
      switch (Oh(i)) {
        case 0:
          i === 38 && Io() === 12 && (n[r] = 1), (e[r] += DU(Ai - 1, n, r));
          break;
        case 2:
          e[r] += I0(i);
          break;
        case 4:
          if (i === 44) {
            (e[++r] = Io() === 58 ? "&\f" : ""), (n[r] = e[r].length);
            break;
          }
        default:
          e[r] += Hw(i);
      }
    while ((i = Hi()));
    return e;
  },
  MU = function (e, n) {
    return D5($U(k5(e), n));
  },
  mT = new WeakMap(),
  LU = function (e) {
    if (!(e.type !== "rule" || !e.parent || e.length < 1)) {
      for (
        var n = e.value,
          r = e.parent,
          i = e.column === r.column && e.line === r.line;
        r.type !== "rule";

      )
        if (((r = r.parent), !r)) return;
      if (
        !(e.props.length === 1 && n.charCodeAt(0) !== 58 && !mT.get(r)) &&
        !i
      ) {
        mT.set(e, !0);
        for (
          var s = [], o = MU(n, s), a = r.props, l = 0, d = 0;
          l < o.length;
          l++
        )
          for (var p = 0; p < a.length; p++, d++)
            e.props[d] = s[l] ? o[l].replace(/&\f/g, a[p]) : a[p] + " " + o[l];
      }
    }
  },
  UU = function (e) {
    if (e.type === "decl") {
      var n = e.value;
      n.charCodeAt(0) === 108 &&
        n.charCodeAt(2) === 98 &&
        ((e.return = ""), (e.value = ""));
    }
  };
function M5(t, e) {
  switch (bU(t, e)) {
    case 5103:
      return $t + "print-" + t + t;
    case 5737:
    case 4201:
    case 3177:
    case 3433:
    case 1641:
    case 4457:
    case 2921:
    case 5572:
    case 6356:
    case 5844:
    case 3191:
    case 6645:
    case 3005:
    case 6391:
    case 5879:
    case 5623:
    case 6135:
    case 4599:
    case 4855:
    case 4215:
    case 6389:
    case 5109:
    case 5365:
    case 5621:
    case 3829:
      return $t + t + t;
    case 5349:
    case 4246:
    case 4810:
    case 6968:
    case 2756:
      return $t + t + X0 + t + zr + t + t;
    case 6828:
    case 4268:
      return $t + t + zr + t + t;
    case 6165:
      return $t + t + zr + "flex-" + t + t;
    case 5187:
      return (
        $t + t + Mt(t, /(\w+).+(:[^]+)/, $t + "box-$1$2" + zr + "flex-$1$2") + t
      );
    case 5443:
      return $t + t + zr + "flex-item-" + Mt(t, /flex-|-self/, "") + t;
    case 4675:
      return (
        $t +
        t +
        zr +
        "flex-line-pack" +
        Mt(t, /align-content|flex-|-self/, "") +
        t
      );
    case 5548:
      return $t + t + zr + Mt(t, "shrink", "negative") + t;
    case 5292:
      return $t + t + zr + Mt(t, "basis", "preferred-size") + t;
    case 6060:
      return (
        $t +
        "box-" +
        Mt(t, "-grow", "") +
        $t +
        t +
        zr +
        Mt(t, "grow", "positive") +
        t
      );
    case 4554:
      return $t + Mt(t, /([^-])(transform)/g, "$1" + $t + "$2") + t;
    case 6187:
      return (
        Mt(
          Mt(Mt(t, /(zoom-|grab)/, $t + "$1"), /(image-set)/, $t + "$1"),
          t,
          ""
        ) + t
      );
    case 5495:
    case 3959:
      return Mt(t, /(image-set\([^]*)/, $t + "$1$`$1");
    case 4968:
      return (
        Mt(
          Mt(t, /(.+:)(flex-)?(.*)/, $t + "box-pack:$3" + zr + "flex-pack:$3"),
          /s.+-b[^;]+/,
          "justify"
        ) +
        $t +
        t +
        t
      );
    case 4095:
    case 3583:
    case 4068:
    case 2532:
      return Mt(t, /(.+)-inline(.+)/, $t + "$1$2") + t;
    case 8116:
    case 7059:
    case 5753:
    case 5535:
    case 5445:
    case 5701:
    case 4933:
    case 4677:
    case 5533:
    case 5789:
    case 5021:
    case 4765:
      if (Co(t) - 1 - e > 6)
        switch (Ir(t, e + 1)) {
          case 109:
            if (Ir(t, e + 4) !== 45) break;
          case 102:
            return (
              Mt(
                t,
                /(.+:)(.+)-([^]+)/,
                "$1" +
                  $t +
                  "$2-$3$1" +
                  X0 +
                  (Ir(t, e + 3) == 108 ? "$3" : "$2-$3")
              ) + t
            );
          case 115:
            return ~WC(t, "stretch")
              ? M5(Mt(t, "stretch", "fill-available"), e) + t
              : t;
        }
      break;
    case 4949:
      if (Ir(t, e + 1) !== 115) break;
    case 6444:
      switch (Ir(t, Co(t) - 3 - (~WC(t, "!important") && 10))) {
        case 107:
          return Mt(t, ":", ":" + $t) + t;
        case 101:
          return (
            Mt(
              t,
              /(.+:)([^;!]+)(;|!.+)?/,
              "$1" +
                $t +
                (Ir(t, 14) === 45 ? "inline-" : "") +
                "box$3$1" +
                $t +
                "$2$3$1" +
                zr +
                "$2box$3"
            ) + t
          );
      }
      break;
    case 5936:
      switch (Ir(t, e + 11)) {
        case 114:
          return $t + t + zr + Mt(t, /[svh]\w+-[tblr]{2}/, "tb") + t;
        case 108:
          return $t + t + zr + Mt(t, /[svh]\w+-[tblr]{2}/, "tb-rl") + t;
        case 45:
          return $t + t + zr + Mt(t, /[svh]\w+-[tblr]{2}/, "lr") + t;
      }
      return $t + t + zr + t + t;
  }
  return t;
}
var BU = function (e, n, r, i) {
    if (e.length > -1 && !e.return)
      switch (e.type) {
        case kS:
          e.return = M5(e.value, e.length);
          break;
        case R5:
          return Td([Af(e, { value: Mt(e.value, "@", "@" + $t) })], i);
        case OS:
          if (e.length)
            return CU(e.props, function (s) {
              switch (EU(s, /(::plac\w+|:read-\w+)/)) {
                case ":read-only":
                case ":read-write":
                  return Td(
                    [Af(e, { props: [Mt(s, /:(read-\w+)/, ":" + X0 + "$1")] })],
                    i
                  );
                case "::placeholder":
                  return Td(
                    [
                      Af(e, {
                        props: [Mt(s, /:(plac\w+)/, ":" + $t + "input-$1")],
                      }),
                      Af(e, { props: [Mt(s, /:(plac\w+)/, ":" + X0 + "$1")] }),
                      Af(e, { props: [Mt(s, /:(plac\w+)/, zr + "input-$1")] }),
                    ],
                    i
                  );
              }
              return "";
            });
      }
  },
  jU = [BU],
  FU = function (e) {
    var n = e.key;
    if (n === "css") {
      var r = document.querySelectorAll("style[data-emotion]:not([data-s])");
      Array.prototype.forEach.call(r, function (v) {
        var b = v.getAttribute("data-emotion");
        b.indexOf(" ") !== -1 &&
          (document.head.appendChild(v), v.setAttribute("data-s", ""));
      });
    }
    var i = e.stylisPlugins || jU,
      s = {},
      o,
      a = [];
    (o = e.container || document.head),
      Array.prototype.forEach.call(
        document.querySelectorAll('style[data-emotion^="' + n + ' "]'),
        function (v) {
          for (
            var b = v.getAttribute("data-emotion").split(" "), E = 1;
            E < b.length;
            E++
          )
            s[b[E]] = !0;
          a.push(v);
        }
      );
    var l,
      d = [LU, UU];
    {
      var p,
        f = [
          NU,
          kU(function (v) {
            p.insert(v);
          }),
        ],
        m = OU(d.concat(i, f)),
        y = function (b) {
          return Td(PU(b), m);
        };
      l = function (b, E, S, C) {
        (p = S),
          y(b ? b + "{" + E.styles + "}" : E.styles),
          C && (g.inserted[E.name] = !0);
      };
    }
    var g = {
      key: n,
      sheet: new mU({
        key: n,
        container: o,
        nonce: e.nonce,
        speedy: e.speedy,
        prepend: e.prepend,
        insertionPoint: e.insertionPoint,
      }),
      nonce: e.nonce,
      inserted: s,
      registered: {},
      insert: l,
    };
    return g.sheet.hydrate(a), g;
  },
  G1 = { exports: {} },
  Ut = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var gT;
function zU() {
  if (gT) return Ut;
  gT = 1;
  var t = typeof Symbol == "function" && Symbol.for,
    e = t ? Symbol.for("react.element") : 60103,
    n = t ? Symbol.for("react.portal") : 60106,
    r = t ? Symbol.for("react.fragment") : 60107,
    i = t ? Symbol.for("react.strict_mode") : 60108,
    s = t ? Symbol.for("react.profiler") : 60114,
    o = t ? Symbol.for("react.provider") : 60109,
    a = t ? Symbol.for("react.context") : 60110,
    l = t ? Symbol.for("react.async_mode") : 60111,
    d = t ? Symbol.for("react.concurrent_mode") : 60111,
    p = t ? Symbol.for("react.forward_ref") : 60112,
    f = t ? Symbol.for("react.suspense") : 60113,
    m = t ? Symbol.for("react.suspense_list") : 60120,
    y = t ? Symbol.for("react.memo") : 60115,
    g = t ? Symbol.for("react.lazy") : 60116,
    v = t ? Symbol.for("react.block") : 60121,
    b = t ? Symbol.for("react.fundamental") : 60117,
    E = t ? Symbol.for("react.responder") : 60118,
    S = t ? Symbol.for("react.scope") : 60119;
  function C(A) {
    if (typeof A == "object" && A !== null) {
      var I = A.$$typeof;
      switch (I) {
        case e:
          switch (((A = A.type), A)) {
            case l:
            case d:
            case r:
            case s:
            case i:
            case f:
              return A;
            default:
              switch (((A = A && A.$$typeof), A)) {
                case a:
                case p:
                case g:
                case y:
                case o:
                  return A;
                default:
                  return I;
              }
          }
        case n:
          return I;
      }
    }
  }
  function _(A) {
    return C(A) === d;
  }
  return (
    (Ut.AsyncMode = l),
    (Ut.ConcurrentMode = d),
    (Ut.ContextConsumer = a),
    (Ut.ContextProvider = o),
    (Ut.Element = e),
    (Ut.ForwardRef = p),
    (Ut.Fragment = r),
    (Ut.Lazy = g),
    (Ut.Memo = y),
    (Ut.Portal = n),
    (Ut.Profiler = s),
    (Ut.StrictMode = i),
    (Ut.Suspense = f),
    (Ut.isAsyncMode = function (A) {
      return _(A) || C(A) === l;
    }),
    (Ut.isConcurrentMode = _),
    (Ut.isContextConsumer = function (A) {
      return C(A) === a;
    }),
    (Ut.isContextProvider = function (A) {
      return C(A) === o;
    }),
    (Ut.isElement = function (A) {
      return typeof A == "object" && A !== null && A.$$typeof === e;
    }),
    (Ut.isForwardRef = function (A) {
      return C(A) === p;
    }),
    (Ut.isFragment = function (A) {
      return C(A) === r;
    }),
    (Ut.isLazy = function (A) {
      return C(A) === g;
    }),
    (Ut.isMemo = function (A) {
      return C(A) === y;
    }),
    (Ut.isPortal = function (A) {
      return C(A) === n;
    }),
    (Ut.isProfiler = function (A) {
      return C(A) === s;
    }),
    (Ut.isStrictMode = function (A) {
      return C(A) === i;
    }),
    (Ut.isSuspense = function (A) {
      return C(A) === f;
    }),
    (Ut.isValidElementType = function (A) {
      return (
        typeof A == "string" ||
        typeof A == "function" ||
        A === r ||
        A === d ||
        A === s ||
        A === i ||
        A === f ||
        A === m ||
        (typeof A == "object" &&
          A !== null &&
          (A.$$typeof === g ||
            A.$$typeof === y ||
            A.$$typeof === o ||
            A.$$typeof === a ||
            A.$$typeof === p ||
            A.$$typeof === b ||
            A.$$typeof === E ||
            A.$$typeof === S ||
            A.$$typeof === v))
      );
    }),
    (Ut.typeOf = C),
    Ut
  );
}
var yT;
function WU() {
  return yT || ((yT = 1), (G1.exports = zU())), G1.exports;
}
var K1, wT;
function HU() {
  if (wT) return K1;
  wT = 1;
  var t = WU(),
    e = {
      childContextTypes: !0,
      contextType: !0,
      contextTypes: !0,
      defaultProps: !0,
      displayName: !0,
      getDefaultProps: !0,
      getDerivedStateFromError: !0,
      getDerivedStateFromProps: !0,
      mixins: !0,
      propTypes: !0,
      type: !0,
    },
    n = {
      name: !0,
      length: !0,
      prototype: !0,
      caller: !0,
      callee: !0,
      arguments: !0,
      arity: !0,
    },
    r = {
      $$typeof: !0,
      render: !0,
      defaultProps: !0,
      displayName: !0,
      propTypes: !0,
    },
    i = {
      $$typeof: !0,
      compare: !0,
      defaultProps: !0,
      displayName: !0,
      propTypes: !0,
      type: !0,
    },
    s = {};
  (s[t.ForwardRef] = r), (s[t.Memo] = i);
  function o(g) {
    return t.isMemo(g) ? i : s[g.$$typeof] || e;
  }
  var a = Object.defineProperty,
    l = Object.getOwnPropertyNames,
    d = Object.getOwnPropertySymbols,
    p = Object.getOwnPropertyDescriptor,
    f = Object.getPrototypeOf,
    m = Object.prototype;
  function y(g, v, b) {
    if (typeof v != "string") {
      if (m) {
        var E = f(v);
        E && E !== m && y(g, E, b);
      }
      var S = l(v);
      d && (S = S.concat(d(v)));
      for (var C = o(g), _ = o(v), A = 0; A < S.length; ++A) {
        var I = S[A];
        if (!n[I] && !(b && b[I]) && !(_ && _[I]) && !(C && C[I])) {
          var R = p(v, I);
          try {
            a(g, I, R);
          } catch {}
        }
      }
    }
    return g;
  }
  return (K1 = y), K1;
}
HU();
var qU = !0;
function L5(t, e, n) {
  var r = "";
  return (
    n.split(" ").forEach(function (i) {
      t[i] !== void 0 ? e.push(t[i] + ";") : i && (r += i + " ");
    }),
    r
  );
}
var $S = function (e, n, r) {
    var i = e.key + "-" + n.name;
    (r === !1 || qU === !1) &&
      e.registered[i] === void 0 &&
      (e.registered[i] = n.styles);
  },
  MS = function (e, n, r) {
    $S(e, n, r);
    var i = e.key + "-" + n.name;
    if (e.inserted[n.name] === void 0) {
      var s = n;
      do e.insert(n === s ? "." + i : "", s, e.sheet, !0), (s = s.next);
      while (s !== void 0);
    }
  };
function VU(t) {
  for (var e = 0, n, r = 0, i = t.length; i >= 4; ++r, i -= 4)
    (n =
      (t.charCodeAt(r) & 255) |
      ((t.charCodeAt(++r) & 255) << 8) |
      ((t.charCodeAt(++r) & 255) << 16) |
      ((t.charCodeAt(++r) & 255) << 24)),
      (n = (n & 65535) * 1540483477 + (((n >>> 16) * 59797) << 16)),
      (n ^= n >>> 24),
      (e =
        ((n & 65535) * 1540483477 + (((n >>> 16) * 59797) << 16)) ^
        ((e & 65535) * 1540483477 + (((e >>> 16) * 59797) << 16)));
  switch (i) {
    case 3:
      e ^= (t.charCodeAt(r + 2) & 255) << 16;
    case 2:
      e ^= (t.charCodeAt(r + 1) & 255) << 8;
    case 1:
      (e ^= t.charCodeAt(r) & 255),
        (e = (e & 65535) * 1540483477 + (((e >>> 16) * 59797) << 16));
  }
  return (
    (e ^= e >>> 13),
    (e = (e & 65535) * 1540483477 + (((e >>> 16) * 59797) << 16)),
    ((e ^ (e >>> 15)) >>> 0).toString(36)
  );
}
var GU = {
    animationIterationCount: 1,
    aspectRatio: 1,
    borderImageOutset: 1,
    borderImageSlice: 1,
    borderImageWidth: 1,
    boxFlex: 1,
    boxFlexGroup: 1,
    boxOrdinalGroup: 1,
    columnCount: 1,
    columns: 1,
    flex: 1,
    flexGrow: 1,
    flexPositive: 1,
    flexShrink: 1,
    flexNegative: 1,
    flexOrder: 1,
    gridRow: 1,
    gridRowEnd: 1,
    gridRowSpan: 1,
    gridRowStart: 1,
    gridColumn: 1,
    gridColumnEnd: 1,
    gridColumnSpan: 1,
    gridColumnStart: 1,
    msGridRow: 1,
    msGridRowSpan: 1,
    msGridColumn: 1,
    msGridColumnSpan: 1,
    fontWeight: 1,
    lineHeight: 1,
    opacity: 1,
    order: 1,
    orphans: 1,
    scale: 1,
    tabSize: 1,
    widows: 1,
    zIndex: 1,
    zoom: 1,
    WebkitLineClamp: 1,
    fillOpacity: 1,
    floodOpacity: 1,
    stopOpacity: 1,
    strokeDasharray: 1,
    strokeDashoffset: 1,
    strokeMiterlimit: 1,
    strokeOpacity: 1,
    strokeWidth: 1,
  },
  KU = /[A-Z]|^ms/g,
  YU = /_EMO_([^_]+?)_([^]*?)_EMO_/g,
  U5 = function (e) {
    return e.charCodeAt(1) === 45;
  },
  vT = function (e) {
    return e != null && typeof e != "boolean";
  },
  Y1 = $5(function (t) {
    return U5(t) ? t : t.replace(KU, "-$&").toLowerCase();
  }),
  bT = function (e, n) {
    switch (e) {
      case "animation":
      case "animationName":
        if (typeof n == "string")
          return n.replace(YU, function (r, i, s) {
            return (xo = { name: i, styles: s, next: xo }), i;
          });
    }
    return GU[e] !== 1 && !U5(e) && typeof n == "number" && n !== 0
      ? n + "px"
      : n;
  };
function kh(t, e, n) {
  if (n == null) return "";
  var r = n;
  if (r.__emotion_styles !== void 0) return r;
  switch (typeof n) {
    case "boolean":
      return "";
    case "object": {
      var i = n;
      if (i.anim === 1)
        return (xo = { name: i.name, styles: i.styles, next: xo }), i.name;
      var s = n;
      if (s.styles !== void 0) {
        var o = s.next;
        if (o !== void 0)
          for (; o !== void 0; )
            (xo = { name: o.name, styles: o.styles, next: xo }), (o = o.next);
        var a = s.styles + ";";
        return a;
      }
      return ZU(t, e, n);
    }
    case "function": {
      if (t !== void 0) {
        var l = xo,
          d = n(t);
        return (xo = l), kh(t, e, d);
      }
      break;
    }
  }
  var p = n;
  if (e == null) return p;
  var f = e[p];
  return f !== void 0 ? f : p;
}
function ZU(t, e, n) {
  var r = "";
  if (Array.isArray(n))
    for (var i = 0; i < n.length; i++) r += kh(t, e, n[i]) + ";";
  else
    for (var s in n) {
      var o = n[s];
      if (typeof o != "object") {
        var a = o;
        e != null && e[a] !== void 0
          ? (r += s + "{" + e[a] + "}")
          : vT(a) && (r += Y1(s) + ":" + bT(s, a) + ";");
      } else if (
        Array.isArray(o) &&
        typeof o[0] == "string" &&
        (e == null || e[o[0]] === void 0)
      )
        for (var l = 0; l < o.length; l++)
          vT(o[l]) && (r += Y1(s) + ":" + bT(s, o[l]) + ";");
      else {
        var d = kh(t, e, o);
        switch (s) {
          case "animation":
          case "animationName": {
            r += Y1(s) + ":" + d + ";";
            break;
          }
          default:
            r += s + "{" + d + "}";
        }
      }
    }
  return r;
}
var ET = /label:\s*([^\s;{]+)\s*(;|$)/g,
  xo;
function Um(t, e, n) {
  if (
    t.length === 1 &&
    typeof t[0] == "object" &&
    t[0] !== null &&
    t[0].styles !== void 0
  )
    return t[0];
  var r = !0,
    i = "";
  xo = void 0;
  var s = t[0];
  if (s == null || s.raw === void 0) (r = !1), (i += kh(n, e, s));
  else {
    var o = s;
    i += o[0];
  }
  for (var a = 1; a < t.length; a++)
    if (((i += kh(n, e, t[a])), r)) {
      var l = s;
      i += l[a];
    }
  ET.lastIndex = 0;
  for (var d = "", p; (p = ET.exec(i)) !== null; ) d += "-" + p[1];
  var f = VU(i) + d;
  return { name: f, styles: i, next: xo };
}
var QU = function (e) {
    return e();
  },
  B5 = Z0.useInsertionEffect ? Z0.useInsertionEffect : !1,
  j5 = B5 || QU,
  CT = B5 || N.useLayoutEffect,
  XU = !1,
  F5 = N.createContext(typeof HTMLElement < "u" ? FU({ key: "css" }) : null);
F5.Provider;
var LS = function (e) {
    return N.forwardRef(function (n, r) {
      var i = N.useContext(F5);
      return e(n, i, r);
    });
  },
  Gw = N.createContext({}),
  US = {}.hasOwnProperty,
  qC = "__EMOTION_TYPE_PLEASE_DO_NOT_USE__",
  JU = function (e, n) {
    var r = {};
    for (var i in n) US.call(n, i) && (r[i] = n[i]);
    return (r[qC] = e), r;
  },
  eB = function (e) {
    var n = e.cache,
      r = e.serialized,
      i = e.isStringTag;
    return (
      $S(n, r, i),
      j5(function () {
        return MS(n, r, i);
      }),
      null
    );
  },
  tB = LS(function (t, e, n) {
    var r = t.css;
    typeof r == "string" && e.registered[r] !== void 0 && (r = e.registered[r]);
    var i = t[qC],
      s = [r],
      o = "";
    typeof t.className == "string"
      ? (o = L5(e.registered, s, t.className))
      : t.className != null && (o = t.className + " ");
    var a = Um(s, void 0, N.useContext(Gw));
    o += e.key + "-" + a.name;
    var l = {};
    for (var d in t)
      US.call(t, d) && d !== "css" && d !== qC && !XU && (l[d] = t[d]);
    return (
      (l.className = o),
      n && (l.ref = n),
      N.createElement(
        N.Fragment,
        null,
        N.createElement(eB, {
          cache: e,
          serialized: a,
          isStringTag: typeof i == "string",
        }),
        N.createElement(i, l)
      )
    );
  }),
  nB = tB,
  rB = function (e, n) {
    var r = arguments;
    if (n == null || !US.call(n, "css"))
      return N.createElement.apply(void 0, r);
    var i = r.length,
      s = new Array(i);
    (s[0] = nB), (s[1] = JU(e, n));
    for (var o = 2; o < i; o++) s[o] = r[o];
    return N.createElement.apply(null, s);
  };
(function (t) {
  var e;
  e || (e = t.JSX || (t.JSX = {}));
})(rB);
var iB = LS(function (t, e) {
  var n = t.styles,
    r = Um([n], void 0, N.useContext(Gw)),
    i = N.useRef();
  return (
    CT(
      function () {
        var s = e.key + "-global",
          o = new e.sheet.constructor({
            key: s,
            nonce: e.sheet.nonce,
            container: e.sheet.container,
            speedy: e.sheet.isSpeedy,
          }),
          a = !1,
          l = document.querySelector(
            'style[data-emotion="' + s + " " + r.name + '"]'
          );
        return (
          e.sheet.tags.length && (o.before = e.sheet.tags[0]),
          l !== null &&
            ((a = !0), l.setAttribute("data-emotion", s), o.hydrate([l])),
          (i.current = [o, a]),
          function () {
            o.flush();
          }
        );
      },
      [e]
    ),
    CT(
      function () {
        var s = i.current,
          o = s[0],
          a = s[1];
        if (a) {
          s[1] = !1;
          return;
        }
        if ((r.next !== void 0 && MS(e, r.next, !0), o.tags.length)) {
          var l = o.tags[o.tags.length - 1].nextElementSibling;
          (o.before = l), o.flush();
        }
        e.insert("", r, o, !1);
      },
      [e, r.name]
    ),
    null
  );
});
function sB() {
  for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++)
    e[n] = arguments[n];
  return Um(e);
}
function bp() {
  var t = sB.apply(void 0, arguments),
    e = "animation-" + t.name;
  return {
    name: e,
    styles: "@keyframes " + e + "{" + t.styles + "}",
    anim: 1,
    toString: function () {
      return "_EMO_" + this.name + "_" + this.styles + "_EMO_";
    },
  };
}
var oB =
    /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|disableRemotePlayback|download|draggable|encType|enterKeyHint|fetchpriority|fetchPriority|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/,
  aB = $5(function (t) {
    return (
      oB.test(t) ||
      (t.charCodeAt(0) === 111 &&
        t.charCodeAt(1) === 110 &&
        t.charCodeAt(2) < 91)
    );
  }),
  cB = aB,
  lB = function (e) {
    return e !== "theme";
  },
  xT = function (e) {
    return typeof e == "string" && e.charCodeAt(0) > 96 ? cB : lB;
  },
  ST = function (e, n, r) {
    var i;
    if (n) {
      var s = n.shouldForwardProp;
      i =
        e.__emotion_forwardProp && s
          ? function (o) {
              return e.__emotion_forwardProp(o) && s(o);
            }
          : s;
    }
    return typeof i != "function" && r && (i = e.__emotion_forwardProp), i;
  },
  uB = function (e) {
    var n = e.cache,
      r = e.serialized,
      i = e.isStringTag;
    return (
      $S(n, r, i),
      j5(function () {
        return MS(n, r, i);
      }),
      null
    );
  },
  dB = function t(e, n) {
    var r = e.__emotion_real === e,
      i = (r && e.__emotion_base) || e,
      s,
      o;
    n !== void 0 && ((s = n.label), (o = n.target));
    var a = ST(e, n, r),
      l = a || xT(i),
      d = !l("as");
    return function () {
      var p = arguments,
        f =
          r && e.__emotion_styles !== void 0 ? e.__emotion_styles.slice(0) : [];
      if (
        (s !== void 0 && f.push("label:" + s + ";"),
        p[0] == null || p[0].raw === void 0)
      )
        f.push.apply(f, p);
      else {
        var m = p[0];
        f.push(m[0]);
        for (var y = p.length, g = 1; g < y; g++) f.push(p[g], m[g]);
      }
      var v = LS(function (b, E, S) {
        var C = (d && b.as) || i,
          _ = "",
          A = [],
          I = b;
        if (b.theme == null) {
          I = {};
          for (var R in b) I[R] = b[R];
          I.theme = N.useContext(Gw);
        }
        typeof b.className == "string"
          ? (_ = L5(E.registered, A, b.className))
          : b.className != null && (_ = b.className + " ");
        var D = Um(f.concat(A), E.registered, I);
        (_ += E.key + "-" + D.name), o !== void 0 && (_ += " " + o);
        var k = d && a === void 0 ? xT(C) : l,
          T = {};
        for (var U in b) (d && U === "as") || (k(U) && (T[U] = b[U]));
        return (
          (T.className = _),
          S && (T.ref = S),
          N.createElement(
            N.Fragment,
            null,
            N.createElement(uB, {
              cache: E,
              serialized: D,
              isStringTag: typeof C == "string",
            }),
            N.createElement(C, T)
          )
        );
      });
      return (
        (v.displayName =
          s !== void 0
            ? s
            : "Styled(" +
              (typeof i == "string"
                ? i
                : i.displayName || i.name || "Component") +
              ")"),
        (v.defaultProps = e.defaultProps),
        (v.__emotion_real = v),
        (v.__emotion_base = i),
        (v.__emotion_styles = f),
        (v.__emotion_forwardProp = a),
        Object.defineProperty(v, "toString", {
          value: function () {
            return "." + o;
          },
        }),
        (v.withComponent = function (b, E) {
          var S = t(b, Q0({}, n, E, { shouldForwardProp: ST(v, E, !0) }));
          return S.apply(void 0, f);
        }),
        v
      );
    };
  },
  pB = [
    "a",
    "abbr",
    "address",
    "area",
    "article",
    "aside",
    "audio",
    "b",
    "base",
    "bdi",
    "bdo",
    "big",
    "blockquote",
    "body",
    "br",
    "button",
    "canvas",
    "caption",
    "cite",
    "code",
    "col",
    "colgroup",
    "data",
    "datalist",
    "dd",
    "del",
    "details",
    "dfn",
    "dialog",
    "div",
    "dl",
    "dt",
    "em",
    "embed",
    "fieldset",
    "figcaption",
    "figure",
    "footer",
    "form",
    "h1",
    "h2",
    "h3",
    "h4",
    "h5",
    "h6",
    "head",
    "header",
    "hgroup",
    "hr",
    "html",
    "i",
    "iframe",
    "img",
    "input",
    "ins",
    "kbd",
    "keygen",
    "label",
    "legend",
    "li",
    "link",
    "main",
    "map",
    "mark",
    "marquee",
    "menu",
    "menuitem",
    "meta",
    "meter",
    "nav",
    "noscript",
    "object",
    "ol",
    "optgroup",
    "option",
    "output",
    "p",
    "param",
    "picture",
    "pre",
    "progress",
    "q",
    "rp",
    "rt",
    "ruby",
    "s",
    "samp",
    "script",
    "section",
    "select",
    "small",
    "source",
    "span",
    "strong",
    "style",
    "sub",
    "summary",
    "sup",
    "table",
    "tbody",
    "td",
    "textarea",
    "tfoot",
    "th",
    "thead",
    "time",
    "title",
    "tr",
    "track",
    "u",
    "ul",
    "var",
    "video",
    "wbr",
    "circle",
    "clipPath",
    "defs",
    "ellipse",
    "foreignObject",
    "g",
    "image",
    "line",
    "linearGradient",
    "mask",
    "path",
    "pattern",
    "polygon",
    "polyline",
    "radialGradient",
    "rect",
    "stop",
    "svg",
    "text",
    "tspan",
  ],
  VC = dB.bind(null);
pB.forEach(function (t) {
  VC[t] = VC(t);
});
var Z1 = { exports: {} },
  Q1,
  AT;
function fB() {
  if (AT) return Q1;
  AT = 1;
  var t = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  return (Q1 = t), Q1;
}
var X1, _T;
function hB() {
  if (_T) return X1;
  _T = 1;
  var t = fB();
  function e() {}
  function n() {}
  return (
    (n.resetWarningCache = e),
    (X1 = function () {
      function r(o, a, l, d, p, f) {
        if (f !== t) {
          var m = new Error(
            "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
          );
          throw ((m.name = "Invariant Violation"), m);
        }
      }
      r.isRequired = r;
      function i() {
        return r;
      }
      var s = {
        array: r,
        bigint: r,
        bool: r,
        func: r,
        number: r,
        object: r,
        string: r,
        symbol: r,
        any: r,
        arrayOf: i,
        element: r,
        elementType: r,
        instanceOf: i,
        node: r,
        objectOf: i,
        oneOf: i,
        oneOfType: i,
        shape: i,
        exact: i,
        checkPropTypes: n,
        resetWarningCache: e,
      };
      return (s.PropTypes = s), s;
    }),
    X1
  );
}
var IT;
function mB() {
  return IT || ((IT = 1), (Z1.exports = hB()())), Z1.exports;
}
var gB = mB();
const jr = Hc(gB);
function yB(t) {
  return t == null || Object.keys(t).length === 0;
}
function wB(t) {
  const { styles: e, defaultTheme: n = {} } = t,
    r = typeof e == "function" ? (i) => e(yB(i) ? n : i) : e;
  return O.jsx(iB, { styles: r });
}
/**
 * @mui/styled-engine v6.3.0
 *
 * @license MIT
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ function z5(t, e) {
  return VC(t, e);
}
function vB(t, e) {
  Array.isArray(t.__emotion_styles) &&
    (t.__emotion_styles = e(t.__emotion_styles));
}
const TT = [];
function PT(t) {
  return (TT[0] = t), Um(TT);
}
function Ao(t) {
  if (typeof t != "object" || t === null) return !1;
  const e = Object.getPrototypeOf(t);
  return (
    (e === null ||
      e === Object.prototype ||
      Object.getPrototypeOf(e) === null) &&
    !(Symbol.toStringTag in t) &&
    !(Symbol.iterator in t)
  );
}
function W5(t) {
  if (N.isValidElement(t) || !Ao(t)) return t;
  const e = {};
  return (
    Object.keys(t).forEach((n) => {
      e[n] = W5(t[n]);
    }),
    e
  );
}
function yr(t, e, n = { clone: !0 }) {
  const r = n.clone ? { ...t } : t;
  return (
    Ao(t) &&
      Ao(e) &&
      Object.keys(e).forEach((i) => {
        N.isValidElement(e[i])
          ? (r[i] = e[i])
          : Ao(e[i]) && Object.prototype.hasOwnProperty.call(t, i) && Ao(t[i])
          ? (r[i] = yr(t[i], e[i], n))
          : n.clone
          ? (r[i] = Ao(e[i]) ? W5(e[i]) : e[i])
          : (r[i] = e[i]);
      }),
    r
  );
}
const bB = (t) => {
  const e = Object.keys(t).map((n) => ({ key: n, val: t[n] })) || [];
  return (
    e.sort((n, r) => n.val - r.val),
    e.reduce((n, r) => ({ ...n, [r.key]: r.val }), {})
  );
};
function EB(t) {
  const {
      values: e = { xs: 0, sm: 600, md: 900, lg: 1200, xl: 1536 },
      unit: n = "px",
      step: r = 5,
      ...i
    } = t,
    s = bB(e),
    o = Object.keys(s);
  function a(m) {
    return `@media (min-width:${typeof e[m] == "number" ? e[m] : m}${n})`;
  }
  function l(m) {
    return `@media (max-width:${
      (typeof e[m] == "number" ? e[m] : m) - r / 100
    }${n})`;
  }
  function d(m, y) {
    const g = o.indexOf(y);
    return `@media (min-width:${
      typeof e[m] == "number" ? e[m] : m
    }${n}) and (max-width:${
      (g !== -1 && typeof e[o[g]] == "number" ? e[o[g]] : y) - r / 100
    }${n})`;
  }
  function p(m) {
    return o.indexOf(m) + 1 < o.length ? d(m, o[o.indexOf(m) + 1]) : a(m);
  }
  function f(m) {
    const y = o.indexOf(m);
    return y === 0
      ? a(o[1])
      : y === o.length - 1
      ? l(o[y])
      : d(m, o[o.indexOf(m) + 1]).replace("@media", "@media not all and");
  }
  return {
    keys: o,
    values: s,
    up: a,
    down: l,
    between: d,
    only: p,
    not: f,
    unit: n,
    ...i,
  };
}
function CB(t, e) {
  if (!t.containerQueries) return e;
  const n = Object.keys(e)
    .filter((r) => r.startsWith("@container"))
    .sort((r, i) => {
      var o, a;
      const s = /min-width:\s*([0-9.]+)/;
      return (
        +(((o = r.match(s)) == null ? void 0 : o[1]) || 0) -
        +(((a = i.match(s)) == null ? void 0 : a[1]) || 0)
      );
    });
  return n.length
    ? n.reduce(
        (r, i) => {
          const s = e[i];
          return delete r[i], (r[i] = s), r;
        },
        { ...e }
      )
    : e;
}
function xB(t, e) {
  return (
    e === "@" ||
    (e.startsWith("@") &&
      (t.some((n) => e.startsWith(`@${n}`)) || !!e.match(/^@\d/)))
  );
}
function SB(t, e) {
  const n = e.match(/^@([^/]+)?\/?(.+)?$/);
  if (!n) return null;
  const [, r, i] = n,
    s = Number.isNaN(+r) ? r || 0 : +r;
  return t.containerQueries(i).up(s);
}
function AB(t) {
  const e = (s, o) => s.replace("@media", o ? `@container ${o}` : "@container");
  function n(s, o) {
    (s.up = (...a) => e(t.breakpoints.up(...a), o)),
      (s.down = (...a) => e(t.breakpoints.down(...a), o)),
      (s.between = (...a) => e(t.breakpoints.between(...a), o)),
      (s.only = (...a) => e(t.breakpoints.only(...a), o)),
      (s.not = (...a) => {
        const l = e(t.breakpoints.not(...a), o);
        return l.includes("not all and")
          ? l
              .replace("not all and ", "")
              .replace("min-width:", "width<")
              .replace("max-width:", "width>")
              .replace("and", "or")
          : l;
      });
  }
  const r = {},
    i = (s) => (n(r, s), r);
  return n(i), { ...t, containerQueries: i };
}
const _B = { borderRadius: 4 };
function ph(t, e) {
  return e ? yr(t, e, { clone: !1 }) : t;
}
const Kw = { xs: 0, sm: 600, md: 900, lg: 1200, xl: 1536 },
  RT = {
    keys: ["xs", "sm", "md", "lg", "xl"],
    up: (t) => `@media (min-width:${Kw[t]}px)`,
  },
  IB = {
    containerQueries: (t) => ({
      up: (e) => {
        let n = typeof e == "number" ? e : Kw[e] || e;
        return (
          typeof n == "number" && (n = `${n}px`),
          t ? `@container ${t} (min-width:${n})` : `@container (min-width:${n})`
        );
      },
    }),
  };
function Qs(t, e, n) {
  const r = t.theme || {};
  if (Array.isArray(e)) {
    const s = r.breakpoints || RT;
    return e.reduce((o, a, l) => ((o[s.up(s.keys[l])] = n(e[l])), o), {});
  }
  if (typeof e == "object") {
    const s = r.breakpoints || RT;
    return Object.keys(e).reduce((o, a) => {
      if (xB(s.keys, a)) {
        const l = SB(r.containerQueries ? r : IB, a);
        l && (o[l] = n(e[a], a));
      } else if (Object.keys(s.values || Kw).includes(a)) {
        const l = s.up(a);
        o[l] = n(e[a], a);
      } else {
        const l = a;
        o[l] = e[l];
      }
      return o;
    }, {});
  }
  return n(e);
}
function H5(t = {}) {
  var n;
  return (
    ((n = t.keys) == null
      ? void 0
      : n.reduce((r, i) => {
          const s = t.up(i);
          return (r[s] = {}), r;
        }, {})) || {}
  );
}
function q5(t, e) {
  return t.reduce((n, r) => {
    const i = n[r];
    return (!i || Object.keys(i).length === 0) && delete n[r], n;
  }, e);
}
function TB(t, ...e) {
  const n = H5(t),
    r = [n, ...e].reduce((i, s) => yr(i, s), {});
  return q5(Object.keys(n), r);
}
function PB(t, e) {
  if (typeof t != "object") return {};
  const n = {},
    r = Object.keys(e);
  return (
    Array.isArray(t)
      ? r.forEach((i, s) => {
          s < t.length && (n[i] = !0);
        })
      : r.forEach((i) => {
          t[i] != null && (n[i] = !0);
        }),
    n
  );
}
function J1({ values: t, breakpoints: e, base: n }) {
  const r = n || PB(t, e),
    i = Object.keys(r);
  if (i.length === 0) return t;
  let s;
  return i.reduce(
    (o, a, l) => (
      Array.isArray(t)
        ? ((o[a] = t[l] != null ? t[l] : t[s]), (s = l))
        : typeof t == "object"
        ? ((o[a] = t[a] != null ? t[a] : t[s]), (s = a))
        : (o[a] = t),
      o
    ),
    {}
  );
}
function Re(t) {
  if (typeof t != "string") throw new Error(xa(7));
  return t.charAt(0).toUpperCase() + t.slice(1);
}
function Yw(t, e, n = !0) {
  if (!e || typeof e != "string") return null;
  if (t && t.vars && n) {
    const r = `vars.${e}`
      .split(".")
      .reduce((i, s) => (i && i[s] ? i[s] : null), t);
    if (r != null) return r;
  }
  return e.split(".").reduce((r, i) => (r && r[i] != null ? r[i] : null), t);
}
function J0(t, e, n, r = n) {
  let i;
  return (
    typeof t == "function"
      ? (i = t(n))
      : Array.isArray(t)
      ? (i = t[n] || r)
      : (i = Yw(t, n) || r),
    e && (i = e(i, r, t)),
    i
  );
}
function Fn(t) {
  const { prop: e, cssProperty: n = t.prop, themeKey: r, transform: i } = t,
    s = (o) => {
      if (o[e] == null) return null;
      const a = o[e],
        l = o.theme,
        d = Yw(l, r) || {};
      return Qs(o, a, (f) => {
        let m = J0(d, i, f);
        return (
          f === m &&
            typeof f == "string" &&
            (m = J0(d, i, `${e}${f === "default" ? "" : Re(f)}`, f)),
          n === !1 ? m : { [n]: m }
        );
      });
    };
  return (s.propTypes = {}), (s.filterProps = [e]), s;
}
function RB(t) {
  const e = {};
  return (n) => (e[n] === void 0 && (e[n] = t(n)), e[n]);
}
const NB = { m: "margin", p: "padding" },
  OB = {
    t: "Top",
    r: "Right",
    b: "Bottom",
    l: "Left",
    x: ["Left", "Right"],
    y: ["Top", "Bottom"],
  },
  NT = { marginX: "mx", marginY: "my", paddingX: "px", paddingY: "py" },
  kB = RB((t) => {
    if (t.length > 2)
      if (NT[t]) t = NT[t];
      else return [t];
    const [e, n] = t.split(""),
      r = NB[e],
      i = OB[n] || "";
    return Array.isArray(i) ? i.map((s) => r + s) : [r + i];
  }),
  BS = [
    "m",
    "mt",
    "mr",
    "mb",
    "ml",
    "mx",
    "my",
    "margin",
    "marginTop",
    "marginRight",
    "marginBottom",
    "marginLeft",
    "marginX",
    "marginY",
    "marginInline",
    "marginInlineStart",
    "marginInlineEnd",
    "marginBlock",
    "marginBlockStart",
    "marginBlockEnd",
  ],
  jS = [
    "p",
    "pt",
    "pr",
    "pb",
    "pl",
    "px",
    "py",
    "padding",
    "paddingTop",
    "paddingRight",
    "paddingBottom",
    "paddingLeft",
    "paddingX",
    "paddingY",
    "paddingInline",
    "paddingInlineStart",
    "paddingInlineEnd",
    "paddingBlock",
    "paddingBlockStart",
    "paddingBlockEnd",
  ];
[...BS, ...jS];
function Bm(t, e, n, r) {
  const i = Yw(t, e, !0) ?? n;
  return typeof i == "number" || typeof i == "string"
    ? (s) =>
        typeof s == "string"
          ? s
          : typeof i == "string"
          ? `calc(${s} * ${i})`
          : i * s
    : Array.isArray(i)
    ? (s) => {
        if (typeof s == "string") return s;
        const o = Math.abs(s),
          a = i[o];
        return s >= 0 ? a : typeof a == "number" ? -a : `-${a}`;
      }
    : typeof i == "function"
    ? i
    : () => {};
}
function Zw(t) {
  return Bm(t, "spacing", 8);
}
function ql(t, e) {
  return typeof e == "string" || e == null ? e : t(e);
}
function DB(t, e) {
  return (n) => t.reduce((r, i) => ((r[i] = ql(e, n)), r), {});
}
function $B(t, e, n, r) {
  if (!e.includes(n)) return null;
  const i = kB(n),
    s = DB(i, r),
    o = t[n];
  return Qs(t, o, s);
}
function V5(t, e) {
  const n = Zw(t.theme);
  return Object.keys(t)
    .map((r) => $B(t, e, r, n))
    .reduce(ph, {});
}
function Rn(t) {
  return V5(t, BS);
}
Rn.propTypes = {};
Rn.filterProps = BS;
function Nn(t) {
  return V5(t, jS);
}
Nn.propTypes = {};
Nn.filterProps = jS;
function G5(t = 8, e = Zw({ spacing: t })) {
  if (t.mui) return t;
  const n = (...r) =>
    (r.length === 0 ? [1] : r)
      .map((s) => {
        const o = e(s);
        return typeof o == "number" ? `${o}px` : o;
      })
      .join(" ");
  return (n.mui = !0), n;
}
function Qw(...t) {
  const e = t.reduce(
      (r, i) => (
        i.filterProps.forEach((s) => {
          r[s] = i;
        }),
        r
      ),
      {}
    ),
    n = (r) => Object.keys(r).reduce((i, s) => (e[s] ? ph(i, e[s](r)) : i), {});
  return (
    (n.propTypes = {}),
    (n.filterProps = t.reduce((r, i) => r.concat(i.filterProps), [])),
    n
  );
}
function ps(t) {
  return typeof t != "number" ? t : `${t}px solid`;
}
function Es(t, e) {
  return Fn({ prop: t, themeKey: "borders", transform: e });
}
const MB = Es("border", ps),
  LB = Es("borderTop", ps),
  UB = Es("borderRight", ps),
  BB = Es("borderBottom", ps),
  jB = Es("borderLeft", ps),
  FB = Es("borderColor"),
  zB = Es("borderTopColor"),
  WB = Es("borderRightColor"),
  HB = Es("borderBottomColor"),
  qB = Es("borderLeftColor"),
  VB = Es("outline", ps),
  GB = Es("outlineColor"),
  Xw = (t) => {
    if (t.borderRadius !== void 0 && t.borderRadius !== null) {
      const e = Bm(t.theme, "shape.borderRadius", 4),
        n = (r) => ({ borderRadius: ql(e, r) });
      return Qs(t, t.borderRadius, n);
    }
    return null;
  };
Xw.propTypes = {};
Xw.filterProps = ["borderRadius"];
Qw(MB, LB, UB, BB, jB, FB, zB, WB, HB, qB, Xw, VB, GB);
const Jw = (t) => {
  if (t.gap !== void 0 && t.gap !== null) {
    const e = Bm(t.theme, "spacing", 8),
      n = (r) => ({ gap: ql(e, r) });
    return Qs(t, t.gap, n);
  }
  return null;
};
Jw.propTypes = {};
Jw.filterProps = ["gap"];
const ev = (t) => {
  if (t.columnGap !== void 0 && t.columnGap !== null) {
    const e = Bm(t.theme, "spacing", 8),
      n = (r) => ({ columnGap: ql(e, r) });
    return Qs(t, t.columnGap, n);
  }
  return null;
};
ev.propTypes = {};
ev.filterProps = ["columnGap"];
const tv = (t) => {
  if (t.rowGap !== void 0 && t.rowGap !== null) {
    const e = Bm(t.theme, "spacing", 8),
      n = (r) => ({ rowGap: ql(e, r) });
    return Qs(t, t.rowGap, n);
  }
  return null;
};
tv.propTypes = {};
tv.filterProps = ["rowGap"];
const KB = Fn({ prop: "gridColumn" }),
  YB = Fn({ prop: "gridRow" }),
  ZB = Fn({ prop: "gridAutoFlow" }),
  QB = Fn({ prop: "gridAutoColumns" }),
  XB = Fn({ prop: "gridAutoRows" }),
  JB = Fn({ prop: "gridTemplateColumns" }),
  ej = Fn({ prop: "gridTemplateRows" }),
  tj = Fn({ prop: "gridTemplateAreas" }),
  nj = Fn({ prop: "gridArea" });
Qw(Jw, ev, tv, KB, YB, ZB, QB, XB, JB, ej, tj, nj);
function Pd(t, e) {
  return e === "grey" ? e : t;
}
const rj = Fn({ prop: "color", themeKey: "palette", transform: Pd }),
  ij = Fn({
    prop: "bgcolor",
    cssProperty: "backgroundColor",
    themeKey: "palette",
    transform: Pd,
  }),
  sj = Fn({ prop: "backgroundColor", themeKey: "palette", transform: Pd });
Qw(rj, ij, sj);
function zi(t) {
  return t <= 1 && t !== 0 ? `${t * 100}%` : t;
}
const oj = Fn({ prop: "width", transform: zi }),
  FS = (t) => {
    if (t.maxWidth !== void 0 && t.maxWidth !== null) {
      const e = (n) => {
        var i, s, o, a, l;
        const r =
          ((o =
            (s = (i = t.theme) == null ? void 0 : i.breakpoints) == null
              ? void 0
              : s.values) == null
            ? void 0
            : o[n]) || Kw[n];
        return r
          ? ((l = (a = t.theme) == null ? void 0 : a.breakpoints) == null
              ? void 0
              : l.unit) !== "px"
            ? { maxWidth: `${r}${t.theme.breakpoints.unit}` }
            : { maxWidth: r }
          : { maxWidth: zi(n) };
      };
      return Qs(t, t.maxWidth, e);
    }
    return null;
  };
FS.filterProps = ["maxWidth"];
const aj = Fn({ prop: "minWidth", transform: zi }),
  cj = Fn({ prop: "height", transform: zi }),
  lj = Fn({ prop: "maxHeight", transform: zi }),
  uj = Fn({ prop: "minHeight", transform: zi });
Fn({ prop: "size", cssProperty: "width", transform: zi });
Fn({ prop: "size", cssProperty: "height", transform: zi });
const dj = Fn({ prop: "boxSizing" });
Qw(oj, FS, aj, cj, lj, uj, dj);
const jm = {
  border: { themeKey: "borders", transform: ps },
  borderTop: { themeKey: "borders", transform: ps },
  borderRight: { themeKey: "borders", transform: ps },
  borderBottom: { themeKey: "borders", transform: ps },
  borderLeft: { themeKey: "borders", transform: ps },
  borderColor: { themeKey: "palette" },
  borderTopColor: { themeKey: "palette" },
  borderRightColor: { themeKey: "palette" },
  borderBottomColor: { themeKey: "palette" },
  borderLeftColor: { themeKey: "palette" },
  outline: { themeKey: "borders", transform: ps },
  outlineColor: { themeKey: "palette" },
  borderRadius: { themeKey: "shape.borderRadius", style: Xw },
  color: { themeKey: "palette", transform: Pd },
  bgcolor: {
    themeKey: "palette",
    cssProperty: "backgroundColor",
    transform: Pd,
  },
  backgroundColor: { themeKey: "palette", transform: Pd },
  p: { style: Nn },
  pt: { style: Nn },
  pr: { style: Nn },
  pb: { style: Nn },
  pl: { style: Nn },
  px: { style: Nn },
  py: { style: Nn },
  padding: { style: Nn },
  paddingTop: { style: Nn },
  paddingRight: { style: Nn },
  paddingBottom: { style: Nn },
  paddingLeft: { style: Nn },
  paddingX: { style: Nn },
  paddingY: { style: Nn },
  paddingInline: { style: Nn },
  paddingInlineStart: { style: Nn },
  paddingInlineEnd: { style: Nn },
  paddingBlock: { style: Nn },
  paddingBlockStart: { style: Nn },
  paddingBlockEnd: { style: Nn },
  m: { style: Rn },
  mt: { style: Rn },
  mr: { style: Rn },
  mb: { style: Rn },
  ml: { style: Rn },
  mx: { style: Rn },
  my: { style: Rn },
  margin: { style: Rn },
  marginTop: { style: Rn },
  marginRight: { style: Rn },
  marginBottom: { style: Rn },
  marginLeft: { style: Rn },
  marginX: { style: Rn },
  marginY: { style: Rn },
  marginInline: { style: Rn },
  marginInlineStart: { style: Rn },
  marginInlineEnd: { style: Rn },
  marginBlock: { style: Rn },
  marginBlockStart: { style: Rn },
  marginBlockEnd: { style: Rn },
  displayPrint: {
    cssProperty: !1,
    transform: (t) => ({ "@media print": { display: t } }),
  },
  display: {},
  overflow: {},
  textOverflow: {},
  visibility: {},
  whiteSpace: {},
  flexBasis: {},
  flexDirection: {},
  flexWrap: {},
  justifyContent: {},
  alignItems: {},
  alignContent: {},
  order: {},
  flex: {},
  flexGrow: {},
  flexShrink: {},
  alignSelf: {},
  justifyItems: {},
  justifySelf: {},
  gap: { style: Jw },
  rowGap: { style: tv },
  columnGap: { style: ev },
  gridColumn: {},
  gridRow: {},
  gridAutoFlow: {},
  gridAutoColumns: {},
  gridAutoRows: {},
  gridTemplateColumns: {},
  gridTemplateRows: {},
  gridTemplateAreas: {},
  gridArea: {},
  position: {},
  zIndex: { themeKey: "zIndex" },
  top: {},
  right: {},
  bottom: {},
  left: {},
  boxShadow: { themeKey: "shadows" },
  width: { transform: zi },
  maxWidth: { style: FS },
  minWidth: { transform: zi },
  height: { transform: zi },
  maxHeight: { transform: zi },
  minHeight: { transform: zi },
  boxSizing: {},
  font: { themeKey: "font" },
  fontFamily: { themeKey: "typography" },
  fontSize: { themeKey: "typography" },
  fontStyle: { themeKey: "typography" },
  fontWeight: { themeKey: "typography" },
  letterSpacing: {},
  textTransform: {},
  lineHeight: {},
  textAlign: {},
  typography: { cssProperty: !1, themeKey: "typography" },
};
function pj(...t) {
  const e = t.reduce((r, i) => r.concat(Object.keys(i)), []),
    n = new Set(e);
  return t.every((r) => n.size === Object.keys(r).length);
}
function fj(t, e) {
  return typeof t == "function" ? t(e) : t;
}
function hj() {
  function t(n, r, i, s) {
    const o = { [n]: r, theme: i },
      a = s[n];
    if (!a) return { [n]: r };
    const { cssProperty: l = n, themeKey: d, transform: p, style: f } = a;
    if (r == null) return null;
    if (d === "typography" && r === "inherit") return { [n]: r };
    const m = Yw(i, d) || {};
    return f
      ? f(o)
      : Qs(o, r, (g) => {
          let v = J0(m, p, g);
          return (
            g === v &&
              typeof g == "string" &&
              (v = J0(m, p, `${n}${g === "default" ? "" : Re(g)}`, g)),
            l === !1 ? v : { [l]: v }
          );
        });
  }
  function e(n) {
    const { sx: r, theme: i = {} } = n || {};
    if (!r) return null;
    const s = i.unstable_sxConfig ?? jm;
    function o(a) {
      let l = a;
      if (typeof a == "function") l = a(i);
      else if (typeof a != "object") return a;
      if (!l) return null;
      const d = H5(i.breakpoints),
        p = Object.keys(d);
      let f = d;
      return (
        Object.keys(l).forEach((m) => {
          const y = fj(l[m], i);
          if (y != null)
            if (typeof y == "object")
              if (s[m]) f = ph(f, t(m, y, i, s));
              else {
                const g = Qs({ theme: i }, y, (v) => ({ [m]: v }));
                pj(g, y) ? (f[m] = e({ sx: y, theme: i })) : (f = ph(f, g));
              }
            else f = ph(f, t(m, y, i, s));
        }),
        CB(i, q5(p, f))
      );
    }
    return Array.isArray(r) ? r.map(o) : o(r);
  }
  return e;
}
const Vl = hj();
Vl.filterProps = ["sx"];
function mj(t, e) {
  var r;
  const n = this;
  if (n.vars) {
    if (
      !((r = n.colorSchemes) != null && r[t]) ||
      typeof n.getColorSchemeSelector != "function"
    )
      return {};
    let i = n.getColorSchemeSelector(t);
    return i === "&"
      ? e
      : ((i.includes("data-") || i.includes(".")) &&
          (i = `*:where(${i.replace(/\s*&$/, "")}) &`),
        { [i]: e });
  }
  return n.palette.mode === t ? e : {};
}
function Ep(t = {}, ...e) {
  const {
      breakpoints: n = {},
      palette: r = {},
      spacing: i,
      shape: s = {},
      ...o
    } = t,
    a = EB(n),
    l = G5(i);
  let d = yr(
    {
      breakpoints: a,
      direction: "ltr",
      components: {},
      palette: { mode: "light", ...r },
      spacing: l,
      shape: { ..._B, ...s },
    },
    o
  );
  return (
    (d = AB(d)),
    (d.applyStyles = mj),
    (d = e.reduce((p, f) => yr(p, f), d)),
    (d.unstable_sxConfig = {
      ...jm,
      ...(o == null ? void 0 : o.unstable_sxConfig),
    }),
    (d.unstable_sx = function (f) {
      return Vl({ sx: f, theme: this });
    }),
    d
  );
}
function gj(t) {
  return Object.keys(t).length === 0;
}
function K5(t = null) {
  const e = N.useContext(Gw);
  return !e || gj(e) ? t : e;
}
const yj = Ep();
function Fm(t = yj) {
  return K5(t);
}
function wj({ styles: t, themeId: e, defaultTheme: n = {} }) {
  const r = Fm(n),
    i = typeof t == "function" ? t((e && r[e]) || r) : t;
  return O.jsx(wB, { styles: i });
}
const vj = (t) => {
  var r;
  const e = { systemProps: {}, otherProps: {} },
    n =
      ((r = t == null ? void 0 : t.theme) == null
        ? void 0
        : r.unstable_sxConfig) ?? jm;
  return (
    Object.keys(t).forEach((i) => {
      n[i] ? (e.systemProps[i] = t[i]) : (e.otherProps[i] = t[i]);
    }),
    e
  );
};
function nv(t) {
  const { sx: e, ...n } = t,
    { systemProps: r, otherProps: i } = vj(n);
  let s;
  return (
    Array.isArray(e)
      ? (s = [r, ...e])
      : typeof e == "function"
      ? (s = (...o) => {
          const a = e(...o);
          return Ao(a) ? { ...r, ...a } : r;
        })
      : (s = { ...r, ...e }),
    { ...i, sx: s }
  );
}
const OT = (t) => t,
  bj = () => {
    let t = OT;
    return {
      configure(e) {
        t = e;
      },
      generate(e) {
        return t(e);
      },
      reset() {
        t = OT;
      },
    };
  },
  Y5 = bj();
function Z5(t) {
  var e,
    n,
    r = "";
  if (typeof t == "string" || typeof t == "number") r += t;
  else if (typeof t == "object")
    if (Array.isArray(t)) {
      var i = t.length;
      for (e = 0; e < i; e++)
        t[e] && (n = Z5(t[e])) && (r && (r += " "), (r += n));
    } else for (n in t) t[n] && (r && (r += " "), (r += n));
  return r;
}
function rv() {
  for (var t, e, n = 0, r = "", i = arguments.length; n < i; n++)
    (t = arguments[n]) && (e = Z5(t)) && (r && (r += " "), (r += e));
  return r;
}
function Ej(t = {}) {
  const {
      themeId: e,
      defaultTheme: n,
      defaultClassName: r = "MuiBox-root",
      generateClassName: i,
    } = t,
    s = z5("div", {
      shouldForwardProp: (a) => a !== "theme" && a !== "sx" && a !== "as",
    })(Vl);
  return N.forwardRef(function (l, d) {
    const p = Fm(n),
      { className: f, component: m = "div", ...y } = nv(l);
    return O.jsx(s, {
      as: m,
      ref: d,
      className: rv(f, i ? i(r) : r),
      theme: (e && p[e]) || p,
      ...y,
    });
  });
}
const Cj = {
  active: "active",
  checked: "checked",
  completed: "completed",
  disabled: "disabled",
  error: "error",
  expanded: "expanded",
  focused: "focused",
  focusVisible: "focusVisible",
  open: "open",
  readOnly: "readOnly",
  required: "required",
  selected: "selected",
};
function st(t, e, n = "Mui") {
  const r = Cj[e];
  return r ? `${n}-${r}` : `${Y5.generate(t)}-${e}`;
}
function ut(t, e, n = "Mui") {
  const r = {};
  return (
    e.forEach((i) => {
      r[i] = st(t, i, n);
    }),
    r
  );
}
function Q5(t) {
  const { variants: e, ...n } = t,
    r = { variants: e, style: PT(n), isProcessed: !0 };
  return (
    r.style === n ||
      (e &&
        e.forEach((i) => {
          typeof i.style != "function" && (i.style = PT(i.style));
        })),
    r
  );
}
const xj = Ep();
function eE(t) {
  return t !== "ownerState" && t !== "theme" && t !== "sx" && t !== "as";
}
function Sj(t) {
  return t ? (e, n) => n[t] : null;
}
function Aj(t, e, n) {
  t.theme = Ij(t.theme) ? n : t.theme[e] || t.theme;
}
function P0(t, e) {
  const n = typeof e == "function" ? e(t) : e;
  if (Array.isArray(n)) return n.flatMap((r) => P0(t, r));
  if (Array.isArray(n == null ? void 0 : n.variants)) {
    let r;
    if (n.isProcessed) r = n.style;
    else {
      const { variants: i, ...s } = n;
      r = s;
    }
    return X5(t, n.variants, [r]);
  }
  return n != null && n.isProcessed ? n.style : n;
}
function X5(t, e, n = []) {
  var i;
  let r;
  e: for (let s = 0; s < e.length; s += 1) {
    const o = e[s];
    if (typeof o.props == "function") {
      if (
        (r ?? (r = { ...t, ...t.ownerState, ownerState: t.ownerState }),
        !o.props(r))
      )
        continue;
    } else
      for (const a in o.props)
        if (
          t[a] !== o.props[a] &&
          ((i = t.ownerState) == null ? void 0 : i[a]) !== o.props[a]
        )
          continue e;
    typeof o.style == "function"
      ? (r ?? (r = { ...t, ...t.ownerState, ownerState: t.ownerState }),
        n.push(o.style(r)))
      : n.push(o.style);
  }
  return n;
}
function J5(t = {}) {
  const {
    themeId: e,
    defaultTheme: n = xj,
    rootShouldForwardProp: r = eE,
    slotShouldForwardProp: i = eE,
  } = t;
  function s(a) {
    Aj(a, e, n);
  }
  return (a, l = {}) => {
    vB(a, (A) => A.filter((I) => I !== Vl));
    const {
        name: d,
        slot: p,
        skipVariantsResolver: f,
        skipSx: m,
        overridesResolver: y = Sj(Pj(p)),
        ...g
      } = l,
      v = f !== void 0 ? f : (p && p !== "Root" && p !== "root") || !1,
      b = m || !1;
    let E = eE;
    p === "Root" || p === "root"
      ? (E = r)
      : p
      ? (E = i)
      : Tj(a) && (E = void 0);
    const S = z5(a, { shouldForwardProp: E, label: _j(), ...g }),
      C = (A) => {
        if (typeof A == "function" && A.__emotion_real !== A)
          return function (R) {
            return P0(R, A);
          };
        if (Ao(A)) {
          const I = Q5(A);
          return I.variants
            ? function (D) {
                return P0(D, I);
              }
            : I.style;
        }
        return A;
      },
      _ = (...A) => {
        const I = [],
          R = A.map(C),
          D = [];
        if (
          (I.push(s),
          d &&
            y &&
            D.push(function (q) {
              var M, z;
              const H =
                (z = (M = q.theme.components) == null ? void 0 : M[d]) == null
                  ? void 0
                  : z.styleOverrides;
              if (!H) return null;
              const $ = {};
              for (const B in H) $[B] = P0(q, H[B]);
              return y(q, $);
            }),
          d &&
            !v &&
            D.push(function (q) {
              var $, M;
              const K = q.theme,
                H =
                  (M =
                    ($ = K == null ? void 0 : K.components) == null
                      ? void 0
                      : $[d]) == null
                    ? void 0
                    : M.variants;
              return H ? X5(q, H) : null;
            }),
          b || D.push(Vl),
          Array.isArray(R[0]))
        ) {
          const U = R.shift(),
            q = new Array(I.length).fill(""),
            K = new Array(D.length).fill("");
          let H;
          (H = [...q, ...U, ...K]),
            (H.raw = [...q, ...U.raw, ...K]),
            I.unshift(H);
        }
        const k = [...I, ...R, ...D],
          T = S(...k);
        return a.muiName && (T.muiName = a.muiName), T;
      };
    return S.withConfig && (_.withConfig = S.withConfig), _;
  };
}
function _j(t, e) {
  return void 0;
}
function Ij(t) {
  for (const e in t) return !1;
  return !0;
}
function Tj(t) {
  return typeof t == "string" && t.charCodeAt(0) > 96;
}
function Pj(t) {
  return t && t.charAt(0).toLowerCase() + t.slice(1);
}
const zm = J5();
function Gd(t, e) {
  const n = { ...e };
  for (const r in t)
    if (Object.prototype.hasOwnProperty.call(t, r)) {
      const i = r;
      if (i === "components" || i === "slots") n[i] = { ...t[i], ...n[i] };
      else if (i === "componentsProps" || i === "slotProps") {
        const s = t[i],
          o = e[i];
        if (!o) n[i] = s || {};
        else if (!s) n[i] = o;
        else {
          n[i] = { ...o };
          for (const a in s)
            if (Object.prototype.hasOwnProperty.call(s, a)) {
              const l = a;
              n[i][l] = Gd(s[l], o[l]);
            }
        }
      } else n[i] === void 0 && (n[i] = t[i]);
    }
  return n;
}
function zS(t) {
  const { theme: e, name: n, props: r } = t;
  return !e ||
    !e.components ||
    !e.components[n] ||
    !e.components[n].defaultProps
    ? r
    : Gd(e.components[n].defaultProps, r);
}
function WS({ props: t, name: e, defaultTheme: n, themeId: r }) {
  let i = Fm(n);
  return r && (i = i[r] || i), zS({ theme: i, name: e, props: t });
}
const ws = typeof window < "u" ? N.useLayoutEffect : N.useEffect;
function Rj(t, e, n, r, i) {
  const [s, o] = N.useState(() =>
    i && n ? n(t).matches : r ? r(t).matches : e
  );
  return (
    ws(() => {
      if (!n) return;
      const a = n(t),
        l = () => {
          o(a.matches);
        };
      return (
        l(),
        a.addEventListener("change", l),
        () => {
          a.removeEventListener("change", l);
        }
      );
    }, [t, n]),
    s
  );
}
const Nj = { ...Z0 },
  e3 = Nj.useSyncExternalStore;
function Oj(t, e, n, r, i) {
  const s = N.useCallback(() => e, [e]),
    o = N.useMemo(() => {
      if (i && n) return () => n(t).matches;
      if (r !== null) {
        const { matches: p } = r(t);
        return () => p;
      }
      return s;
    }, [s, t, r, i, n]),
    [a, l] = N.useMemo(() => {
      if (n === null) return [s, () => () => {}];
      const p = n(t);
      return [
        () => p.matches,
        (f) => (
          p.addEventListener("change", f),
          () => {
            p.removeEventListener("change", f);
          }
        ),
      ];
    }, [s, n, t]);
  return e3(l, a, o);
}
function kj(t = {}) {
  const { themeId: e } = t;
  return function (r, i = {}) {
    let s = K5();
    s && e && (s = s[e] || s);
    const o = typeof window < "u" && typeof window.matchMedia < "u",
      {
        defaultMatches: a = !1,
        matchMedia: l = o ? window.matchMedia : null,
        ssrMatchMedia: d = null,
        noSsr: p = !1,
      } = zS({ name: "MuiUseMediaQuery", props: i, theme: s });
    let f = typeof r == "function" ? r(s) : r;
    return (
      (f = f.replace(/^@media( ?)/m, "")),
      (e3 !== void 0 ? Oj : Rj)(f, a, l, d, p)
    );
  };
}
function Dj(t, e = Number.MIN_SAFE_INTEGER, n = Number.MAX_SAFE_INTEGER) {
  return Math.max(e, Math.min(t, n));
}
function HS(t, e = 0, n = 1) {
  return Dj(t, e, n);
}
function $j(t) {
  t = t.slice(1);
  const e = new RegExp(`.{1,${t.length >= 6 ? 2 : 1}}`, "g");
  let n = t.match(e);
  return (
    n && n[0].length === 1 && (n = n.map((r) => r + r)),
    n
      ? `rgb${n.length === 4 ? "a" : ""}(${n
          .map((r, i) =>
            i < 3
              ? parseInt(r, 16)
              : Math.round((parseInt(r, 16) / 255) * 1e3) / 1e3
          )
          .join(", ")})`
      : ""
  );
}
function Lc(t) {
  if (t.type) return t;
  if (t.charAt(0) === "#") return Lc($j(t));
  const e = t.indexOf("("),
    n = t.substring(0, e);
  if (!["rgb", "rgba", "hsl", "hsla", "color"].includes(n))
    throw new Error(xa(9, t));
  let r = t.substring(e + 1, t.length - 1),
    i;
  if (n === "color") {
    if (
      ((r = r.split(" ")),
      (i = r.shift()),
      r.length === 4 && r[3].charAt(0) === "/" && (r[3] = r[3].slice(1)),
      !["srgb", "display-p3", "a98-rgb", "prophoto-rgb", "rec-2020"].includes(
        i
      ))
    )
      throw new Error(xa(10, i));
  } else r = r.split(",");
  return (
    (r = r.map((s) => parseFloat(s))), { type: n, values: r, colorSpace: i }
  );
}
const Mj = (t) => {
    const e = Lc(t);
    return e.values
      .slice(0, 3)
      .map((n, r) => (e.type.includes("hsl") && r !== 0 ? `${n}%` : n))
      .join(" ");
  },
  rh = (t, e) => {
    try {
      return Mj(t);
    } catch {
      return t;
    }
  };
function iv(t) {
  const { type: e, colorSpace: n } = t;
  let { values: r } = t;
  return (
    e.includes("rgb")
      ? (r = r.map((i, s) => (s < 3 ? parseInt(i, 10) : i)))
      : e.includes("hsl") && ((r[1] = `${r[1]}%`), (r[2] = `${r[2]}%`)),
    e.includes("color") ? (r = `${n} ${r.join(" ")}`) : (r = `${r.join(", ")}`),
    `${e}(${r})`
  );
}
function t3(t) {
  t = Lc(t);
  const { values: e } = t,
    n = e[0],
    r = e[1] / 100,
    i = e[2] / 100,
    s = r * Math.min(i, 1 - i),
    o = (d, p = (d + n / 30) % 12) =>
      i - s * Math.max(Math.min(p - 3, 9 - p, 1), -1);
  let a = "rgb";
  const l = [
    Math.round(o(0) * 255),
    Math.round(o(8) * 255),
    Math.round(o(4) * 255),
  ];
  return (
    t.type === "hsla" && ((a += "a"), l.push(e[3])), iv({ type: a, values: l })
  );
}
function GC(t) {
  t = Lc(t);
  let e = t.type === "hsl" || t.type === "hsla" ? Lc(t3(t)).values : t.values;
  return (
    (e = e.map(
      (n) => (
        t.type !== "color" && (n /= 255),
        n <= 0.03928 ? n / 12.92 : ((n + 0.055) / 1.055) ** 2.4
      )
    )),
    Number((0.2126 * e[0] + 0.7152 * e[1] + 0.0722 * e[2]).toFixed(3))
  );
}
function Lj(t, e) {
  const n = GC(t),
    r = GC(e);
  return (Math.max(n, r) + 0.05) / (Math.min(n, r) + 0.05);
}
function An(t, e) {
  return (
    (t = Lc(t)),
    (e = HS(e)),
    (t.type === "rgb" || t.type === "hsl") && (t.type += "a"),
    t.type === "color" ? (t.values[3] = `/${e}`) : (t.values[3] = e),
    iv(t)
  );
}
function ky(t, e, n) {
  try {
    return An(t, e);
  } catch {
    return t;
  }
}
function Dh(t, e) {
  if (((t = Lc(t)), (e = HS(e)), t.type.includes("hsl"))) t.values[2] *= 1 - e;
  else if (t.type.includes("rgb") || t.type.includes("color"))
    for (let n = 0; n < 3; n += 1) t.values[n] *= 1 - e;
  return iv(t);
}
function Zt(t, e, n) {
  try {
    return Dh(t, e);
  } catch {
    return t;
  }
}
function $h(t, e) {
  if (((t = Lc(t)), (e = HS(e)), t.type.includes("hsl")))
    t.values[2] += (100 - t.values[2]) * e;
  else if (t.type.includes("rgb"))
    for (let n = 0; n < 3; n += 1) t.values[n] += (255 - t.values[n]) * e;
  else if (t.type.includes("color"))
    for (let n = 0; n < 3; n += 1) t.values[n] += (1 - t.values[n]) * e;
  return iv(t);
}
function Qt(t, e, n) {
  try {
    return $h(t, e);
  } catch {
    return t;
  }
}
function n3(t, e = 0.15) {
  return GC(t) > 0.5 ? Dh(t, e) : $h(t, e);
}
function Dy(t, e, n) {
  try {
    return n3(t, e);
  } catch {
    return t;
  }
}
function kT(...t) {
  return t.reduce(
    (e, n) =>
      n == null
        ? e
        : function (...i) {
            e.apply(this, i), n.apply(this, i);
          },
    () => {}
  );
}
function qS(t, e = 166) {
  let n;
  function r(...i) {
    const s = () => {
      t.apply(this, i);
    };
    clearTimeout(n), (n = setTimeout(s, e));
  }
  return (
    (r.clear = () => {
      clearTimeout(n);
    }),
    r
  );
}
function R0(t, e) {
  var n, r, i;
  return (
    N.isValidElement(t) &&
    e.indexOf(
      t.type.muiName ??
        ((i =
          (r = (n = t.type) == null ? void 0 : n._payload) == null
            ? void 0
            : r.value) == null
          ? void 0
          : i.muiName)
    ) !== -1
  );
}
function qr(t) {
  return (t && t.ownerDocument) || document;
}
function Xs(t) {
  return qr(t).defaultView || window;
}
function KC(t, e) {
  typeof t == "function" ? t(e) : t && (t.current = e);
}
let DT = 0;
function Uj(t) {
  const [e, n] = N.useState(t),
    r = t || e;
  return (
    N.useEffect(() => {
      e == null && ((DT += 1), n(`mui-${DT}`));
    }, [e]),
    r
  );
}
const Bj = { ...Z0 },
  $T = Bj.useId;
function sv(t) {
  if ($T !== void 0) {
    const e = $T();
    return t ?? e;
  }
  return Uj(t);
}
function ew({ controlled: t, default: e, name: n, state: r = "value" }) {
  const { current: i } = N.useRef(t !== void 0),
    [s, o] = N.useState(e),
    a = i ? t : s,
    l = N.useCallback((d) => {
      i || o(d);
    }, []);
  return [a, l];
}
function Ks(t) {
  const e = N.useRef(t);
  return (
    ws(() => {
      e.current = t;
    }),
    N.useRef((...n) => (0, e.current)(...n)).current
  );
}
function In(...t) {
  return N.useMemo(
    () =>
      t.every((e) => e == null)
        ? null
        : (e) => {
            t.forEach((n) => {
              KC(n, e);
            });
          },
    t
  );
}
const MT = {};
function r3(t, e) {
  const n = N.useRef(MT);
  return n.current === MT && (n.current = t(e)), n;
}
const jj = [];
function Fj(t) {
  N.useEffect(t, jj);
}
class ov {
  constructor() {
    Cf(this, "currentId", null);
    Cf(this, "clear", () => {
      this.currentId !== null &&
        (clearTimeout(this.currentId), (this.currentId = null));
    });
    Cf(this, "disposeEffect", () => this.clear);
  }
  static create() {
    return new ov();
  }
  start(e, n) {
    this.clear(),
      (this.currentId = setTimeout(() => {
        (this.currentId = null), n();
      }, e));
  }
}
function Ac() {
  const t = r3(ov.create).current;
  return Fj(t.disposeEffect), t;
}
function tw(t) {
  try {
    return t.matches(":focus-visible");
  } catch {}
  return !1;
}
function i3(t = window) {
  const e = t.document.documentElement.clientWidth;
  return t.innerWidth - e;
}
function zj(t) {
  return N.Children.toArray(t).filter((e) => N.isValidElement(e));
}
function dt(t, e, n = void 0) {
  const r = {};
  for (const i in t) {
    const s = t[i];
    let o = "",
      a = !0;
    for (let l = 0; l < s.length; l += 1) {
      const d = s[l];
      d &&
        ((o += (a === !0 ? "" : " ") + e(d)),
        (a = !1),
        n && n[d] && (o += " " + n[d]));
    }
    r[i] = o;
  }
  return r;
}
function Wj(t) {
  return typeof t == "string";
}
function s3(t, e, n) {
  return t === void 0 || Wj(t)
    ? e
    : { ...e, ownerState: { ...e.ownerState, ...n } };
}
function o3(t) {
  var e,
    n,
    r = "";
  if (typeof t == "string" || typeof t == "number") r += t;
  else if (typeof t == "object")
    if (Array.isArray(t)) {
      var i = t.length;
      for (e = 0; e < i; e++)
        t[e] && (n = o3(t[e])) && (r && (r += " "), (r += n));
    } else for (n in t) t[n] && (r && (r += " "), (r += n));
  return r;
}
function LT() {
  for (var t, e, n = 0, r = "", i = arguments.length; n < i; n++)
    (t = arguments[n]) && (e = o3(t)) && (r && (r += " "), (r += e));
  return r;
}
function nw(t, e = []) {
  if (t === void 0) return {};
  const n = {};
  return (
    Object.keys(t)
      .filter(
        (r) =>
          r.match(/^on[A-Z]/) && typeof t[r] == "function" && !e.includes(r)
      )
      .forEach((r) => {
        n[r] = t[r];
      }),
    n
  );
}
function UT(t) {
  if (t === void 0) return {};
  const e = {};
  return (
    Object.keys(t)
      .filter((n) => !(n.match(/^on[A-Z]/) && typeof t[n] == "function"))
      .forEach((n) => {
        e[n] = t[n];
      }),
    e
  );
}
function a3(t) {
  const {
    getSlotProps: e,
    additionalProps: n,
    externalSlotProps: r,
    externalForwardedProps: i,
    className: s,
  } = t;
  if (!e) {
    const y = LT(
        n == null ? void 0 : n.className,
        s,
        i == null ? void 0 : i.className,
        r == null ? void 0 : r.className
      ),
      g = {
        ...(n == null ? void 0 : n.style),
        ...(i == null ? void 0 : i.style),
        ...(r == null ? void 0 : r.style),
      },
      v = { ...n, ...i, ...r };
    return (
      y.length > 0 && (v.className = y),
      Object.keys(g).length > 0 && (v.style = g),
      { props: v, internalRef: void 0 }
    );
  }
  const o = nw({ ...i, ...r }),
    a = UT(r),
    l = UT(i),
    d = e(o),
    p = LT(
      d == null ? void 0 : d.className,
      n == null ? void 0 : n.className,
      s,
      i == null ? void 0 : i.className,
      r == null ? void 0 : r.className
    ),
    f = {
      ...(d == null ? void 0 : d.style),
      ...(n == null ? void 0 : n.style),
      ...(i == null ? void 0 : i.style),
      ...(r == null ? void 0 : r.style),
    },
    m = { ...d, ...n, ...l, ...a };
  return (
    p.length > 0 && (m.className = p),
    Object.keys(f).length > 0 && (m.style = f),
    { props: m, internalRef: d.ref }
  );
}
function c3(t, e, n) {
  return typeof t == "function" ? t(e, n) : t;
}
function rw(t) {
  var f;
  const {
      elementType: e,
      externalSlotProps: n,
      ownerState: r,
      skipResolvingSlotProps: i = !1,
      ...s
    } = t,
    o = i ? {} : c3(n, r),
    { props: a, internalRef: l } = a3({ ...s, externalSlotProps: o }),
    d = In(
      l,
      o == null ? void 0 : o.ref,
      (f = t.additionalProps) == null ? void 0 : f.ref
    );
  return s3(e, { ...a, ref: d }, r);
}
function qc(t) {
  var e;
  return parseInt(N.version, 10) >= 19
    ? ((e = t == null ? void 0 : t.props) == null ? void 0 : e.ref) || null
    : (t == null ? void 0 : t.ref) || null;
}
const Hj = N.createContext(),
  av = () => N.useContext(Hj) ?? !1,
  qj = N.createContext(void 0);
function Vj(t) {
  const { theme: e, name: n, props: r } = t;
  if (!e || !e.components || !e.components[n]) return r;
  const i = e.components[n];
  return i.defaultProps
    ? Gd(i.defaultProps, r)
    : !i.styleOverrides && !i.variants
    ? Gd(i, r)
    : r;
}
function Gj({ props: t, name: e }) {
  const n = N.useContext(qj);
  return Vj({ props: t, name: e, theme: { components: n } });
}
const BT = { theme: void 0 };
function Kj(t) {
  let e, n;
  return function (i) {
    let s = e;
    return (
      (s === void 0 || i.theme !== n) &&
        ((BT.theme = i.theme), (s = Q5(t(BT))), (e = s), (n = i.theme)),
      s
    );
  };
}
function Yj(t = "") {
  function e(...r) {
    if (!r.length) return "";
    const i = r[0];
    return typeof i == "string" &&
      !i.match(
        /(#|\(|\)|(-?(\d*\.)?\d+)(px|em|%|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc))|^(-?(\d*\.)?\d+)$|(\d+ \d+ \d+)/
      )
      ? `, var(--${t ? `${t}-` : ""}${i}${e(...r.slice(1))})`
      : `, ${i}`;
  }
  return (r, ...i) => `var(--${t ? `${t}-` : ""}${r}${e(...i)})`;
}
const jT = (t, e, n, r = []) => {
    let i = t;
    e.forEach((s, o) => {
      o === e.length - 1
        ? Array.isArray(i)
          ? (i[Number(s)] = n)
          : i && typeof i == "object" && (i[s] = n)
        : i &&
          typeof i == "object" &&
          (i[s] || (i[s] = r.includes(s) ? [] : {}), (i = i[s]));
    });
  },
  Zj = (t, e, n) => {
    function r(i, s = [], o = []) {
      Object.entries(i).forEach(([a, l]) => {
        (!n || !n([...s, a])) &&
          l != null &&
          (typeof l == "object" && Object.keys(l).length > 0
            ? r(l, [...s, a], Array.isArray(l) ? [...o, a] : o)
            : e([...s, a], l, o));
      });
    }
    r(t);
  },
  Qj = (t, e) =>
    typeof e == "number"
      ? ["lineHeight", "fontWeight", "opacity", "zIndex"].some((r) =>
          t.includes(r)
        ) || t[t.length - 1].toLowerCase().includes("opacity")
        ? e
        : `${e}px`
      : e;
function tE(t, e) {
  const { prefix: n, shouldSkipGeneratingVar: r } = e || {},
    i = {},
    s = {},
    o = {};
  return (
    Zj(
      t,
      (a, l, d) => {
        if (
          (typeof l == "string" || typeof l == "number") &&
          (!r || !r(a, l))
        ) {
          const p = `--${n ? `${n}-` : ""}${a.join("-")}`,
            f = Qj(a, l);
          Object.assign(i, { [p]: f }),
            jT(s, a, `var(${p})`, d),
            jT(o, a, `var(${p}, ${f})`, d);
        }
      },
      (a) => a[0] === "vars"
    ),
    { css: i, vars: s, varsWithDefaults: o }
  );
}
function Xj(t, e = {}) {
  const {
      getSelector: n = b,
      disableCssColorScheme: r,
      colorSchemeSelector: i,
    } = e,
    {
      colorSchemes: s = {},
      components: o,
      defaultColorScheme: a = "light",
      ...l
    } = t,
    { vars: d, css: p, varsWithDefaults: f } = tE(l, e);
  let m = f;
  const y = {},
    { [a]: g, ...v } = s;
  if (
    (Object.entries(v || {}).forEach(([C, _]) => {
      const { vars: A, css: I, varsWithDefaults: R } = tE(_, e);
      (m = yr(m, R)), (y[C] = { css: I, vars: A });
    }),
    g)
  ) {
    const { css: C, vars: _, varsWithDefaults: A } = tE(g, e);
    (m = yr(m, A)), (y[a] = { css: C, vars: _ });
  }
  function b(C, _) {
    var I, R;
    let A = i;
    if (
      (i === "class" && (A = ".%s"),
      i === "data" && (A = "[data-%s]"),
      i != null &&
        i.startsWith("data-") &&
        !i.includes("%s") &&
        (A = `[${i}="%s"]`),
      C)
    ) {
      if (A === "media")
        return t.defaultColorScheme === C
          ? ":root"
          : {
              [`@media (prefers-color-scheme: ${
                ((R = (I = s[C]) == null ? void 0 : I.palette) == null
                  ? void 0
                  : R.mode) || C
              })`]: { ":root": _ },
            };
      if (A)
        return t.defaultColorScheme === C
          ? `:root, ${A.replace("%s", String(C))}`
          : A.replace("%s", String(C));
    }
    return ":root";
  }
  return {
    vars: m,
    generateThemeVars: () => {
      let C = { ...d };
      return (
        Object.entries(y).forEach(([, { vars: _ }]) => {
          C = yr(C, _);
        }),
        C
      );
    },
    generateStyleSheets: () => {
      var D, k;
      const C = [],
        _ = t.defaultColorScheme || "light";
      function A(T, U) {
        Object.keys(U).length &&
          C.push(typeof T == "string" ? { [T]: { ...U } } : T);
      }
      A(n(void 0, { ...p }), p);
      const { [_]: I, ...R } = y;
      if (I) {
        const { css: T } = I,
          U =
            (k = (D = s[_]) == null ? void 0 : D.palette) == null
              ? void 0
              : k.mode,
          q = !r && U ? { colorScheme: U, ...T } : { ...T };
        A(n(_, { ...q }), q);
      }
      return (
        Object.entries(R).forEach(([T, { css: U }]) => {
          var H, $;
          const q =
              ($ = (H = s[T]) == null ? void 0 : H.palette) == null
                ? void 0
                : $.mode,
            K = !r && q ? { colorScheme: q, ...U } : { ...U };
          A(n(T, { ...K }), K);
        }),
        C
      );
    },
  };
}
function Jj(t) {
  return function (n) {
    return t === "media"
      ? `@media (prefers-color-scheme: ${n})`
      : t
      ? t.startsWith("data-") && !t.includes("%s")
        ? `[${t}="${n}"] &`
        : t === "class"
        ? `.${n} &`
        : t === "data"
        ? `[data-${n}] &`
        : `${t.replace("%s", n)} &`
      : "&";
  };
}
const eF = Ep(),
  tF = zm("div", {
    name: "MuiContainer",
    slot: "Root",
    overridesResolver: (t, e) => {
      const { ownerState: n } = t;
      return [
        e.root,
        e[`maxWidth${Re(String(n.maxWidth))}`],
        n.fixed && e.fixed,
        n.disableGutters && e.disableGutters,
      ];
    },
  }),
  nF = (t) => WS({ props: t, name: "MuiContainer", defaultTheme: eF }),
  rF = (t, e) => {
    const n = (l) => st(e, l),
      { classes: r, fixed: i, disableGutters: s, maxWidth: o } = t,
      a = {
        root: [
          "root",
          o && `maxWidth${Re(String(o))}`,
          i && "fixed",
          s && "disableGutters",
        ],
      };
    return dt(a, n, r);
  };
function iF(t = {}) {
  const {
      createStyledComponent: e = tF,
      useThemeProps: n = nF,
      componentName: r = "MuiContainer",
    } = t,
    i = e(
      ({ theme: o, ownerState: a }) => ({
        width: "100%",
        marginLeft: "auto",
        boxSizing: "border-box",
        marginRight: "auto",
        ...(!a.disableGutters && {
          paddingLeft: o.spacing(2),
          paddingRight: o.spacing(2),
          [o.breakpoints.up("sm")]: {
            paddingLeft: o.spacing(3),
            paddingRight: o.spacing(3),
          },
        }),
      }),
      ({ theme: o, ownerState: a }) =>
        a.fixed &&
        Object.keys(o.breakpoints.values).reduce((l, d) => {
          const p = d,
            f = o.breakpoints.values[p];
          return (
            f !== 0 &&
              (l[o.breakpoints.up(p)] = {
                maxWidth: `${f}${o.breakpoints.unit}`,
              }),
            l
          );
        }, {}),
      ({ theme: o, ownerState: a }) => ({
        ...(a.maxWidth === "xs" && {
          [o.breakpoints.up("xs")]: {
            maxWidth: Math.max(o.breakpoints.values.xs, 444),
          },
        }),
        ...(a.maxWidth &&
          a.maxWidth !== "xs" && {
            [o.breakpoints.up(a.maxWidth)]: {
              maxWidth: `${o.breakpoints.values[a.maxWidth]}${
                o.breakpoints.unit
              }`,
            },
          }),
      })
    );
  return N.forwardRef(function (a, l) {
    const d = n(a),
      {
        className: p,
        component: f = "div",
        disableGutters: m = !1,
        fixed: y = !1,
        maxWidth: g = "lg",
        classes: v,
        ...b
      } = d,
      E = { ...d, component: f, disableGutters: m, fixed: y, maxWidth: g },
      S = rF(E, r);
    return O.jsx(i, {
      as: f,
      ownerState: E,
      className: rv(S.root, p),
      ref: l,
      ...b,
    });
  });
}
const sF = (t, e) => t.filter((n) => e.includes(n)),
  Cp = (t, e, n) => {
    const r = t.keys[0];
    Array.isArray(e)
      ? e.forEach((i, s) => {
          n((o, a) => {
            s <= t.keys.length - 1 &&
              (s === 0 ? Object.assign(o, a) : (o[t.up(t.keys[s])] = a));
          }, i);
        })
      : e && typeof e == "object"
      ? (Object.keys(e).length > t.keys.length
          ? t.keys
          : sF(t.keys, Object.keys(e))
        ).forEach((s) => {
          if (t.keys.includes(s)) {
            const o = e[s];
            o !== void 0 &&
              n((a, l) => {
                r === s ? Object.assign(a, l) : (a[t.up(s)] = l);
              }, o);
          }
        })
      : (typeof e == "number" || typeof e == "string") &&
        n((i, s) => {
          Object.assign(i, s);
        }, e);
  };
function iw(t) {
  return `--Grid-${t}Spacing`;
}
function cv(t) {
  return `--Grid-parent-${t}Spacing`;
}
const FT = "--Grid-columns",
  Rd = "--Grid-parent-columns",
  oF = ({ theme: t, ownerState: e }) => {
    const n = {};
    return (
      Cp(t.breakpoints, e.size, (r, i) => {
        let s = {};
        i === "grow" && (s = { flexBasis: 0, flexGrow: 1, maxWidth: "100%" }),
          i === "auto" &&
            (s = {
              flexBasis: "auto",
              flexGrow: 0,
              flexShrink: 0,
              maxWidth: "none",
              width: "auto",
            }),
          typeof i == "number" &&
            (s = {
              flexGrow: 0,
              flexBasis: "auto",
              width: `calc(100% * ${i} / var(${Rd}) - (var(${Rd}) - ${i}) * (var(${cv(
                "column"
              )}) / var(${Rd})))`,
            }),
          r(n, s);
      }),
      n
    );
  },
  aF = ({ theme: t, ownerState: e }) => {
    const n = {};
    return (
      Cp(t.breakpoints, e.offset, (r, i) => {
        let s = {};
        i === "auto" && (s = { marginLeft: "auto" }),
          typeof i == "number" &&
            (s = {
              marginLeft:
                i === 0
                  ? "0px"
                  : `calc(100% * ${i} / var(${Rd}) + var(${cv(
                      "column"
                    )}) * ${i} / var(${Rd}))`,
            }),
          r(n, s);
      }),
      n
    );
  },
  cF = ({ theme: t, ownerState: e }) => {
    if (!e.container) return {};
    const n = { [FT]: 12 };
    return (
      Cp(t.breakpoints, e.columns, (r, i) => {
        const s = i ?? 12;
        r(n, { [FT]: s, "> *": { [Rd]: s } });
      }),
      n
    );
  },
  lF = ({ theme: t, ownerState: e }) => {
    if (!e.container) return {};
    const n = {};
    return (
      Cp(t.breakpoints, e.rowSpacing, (r, i) => {
        var o;
        const s =
          typeof i == "string"
            ? i
            : (o = t.spacing) == null
            ? void 0
            : o.call(t, i);
        r(n, { [iw("row")]: s, "> *": { [cv("row")]: s } });
      }),
      n
    );
  },
  uF = ({ theme: t, ownerState: e }) => {
    if (!e.container) return {};
    const n = {};
    return (
      Cp(t.breakpoints, e.columnSpacing, (r, i) => {
        var o;
        const s =
          typeof i == "string"
            ? i
            : (o = t.spacing) == null
            ? void 0
            : o.call(t, i);
        r(n, { [iw("column")]: s, "> *": { [cv("column")]: s } });
      }),
      n
    );
  },
  dF = ({ theme: t, ownerState: e }) => {
    if (!e.container) return {};
    const n = {};
    return (
      Cp(t.breakpoints, e.direction, (r, i) => {
        r(n, { flexDirection: i });
      }),
      n
    );
  },
  pF = ({ ownerState: t }) => ({
    minWidth: 0,
    boxSizing: "border-box",
    ...(t.container && {
      display: "flex",
      flexWrap: "wrap",
      ...(t.wrap && t.wrap !== "wrap" && { flexWrap: t.wrap }),
      gap: `var(${iw("row")}) var(${iw("column")})`,
    }),
  }),
  fF = (t) => {
    const e = [];
    return (
      Object.entries(t).forEach(([n, r]) => {
        r !== !1 && r !== void 0 && e.push(`grid-${n}-${String(r)}`);
      }),
      e
    );
  },
  hF = (t, e = "xs") => {
    function n(r) {
      return r === void 0
        ? !1
        : (typeof r == "string" && !Number.isNaN(Number(r))) ||
            (typeof r == "number" && r > 0);
    }
    if (n(t)) return [`spacing-${e}-${String(t)}`];
    if (typeof t == "object" && !Array.isArray(t)) {
      const r = [];
      return (
        Object.entries(t).forEach(([i, s]) => {
          n(s) && r.push(`spacing-${i}-${String(s)}`);
        }),
        r
      );
    }
    return [];
  },
  mF = (t) =>
    t === void 0
      ? []
      : typeof t == "object"
      ? Object.entries(t).map(([e, n]) => `direction-${e}-${n}`)
      : [`direction-xs-${String(t)}`],
  gF = Ep(),
  yF = zm("div", {
    name: "MuiGrid",
    slot: "Root",
    overridesResolver: (t, e) => e.root,
  });
function wF(t) {
  return WS({ props: t, name: "MuiGrid", defaultTheme: gF });
}
function vF(t = {}) {
  const {
      createStyledComponent: e = yF,
      useThemeProps: n = wF,
      useTheme: r = Fm,
      componentName: i = "MuiGrid",
    } = t,
    s = (d, p) => {
      const { container: f, direction: m, spacing: y, wrap: g, size: v } = d,
        b = {
          root: [
            "root",
            f && "container",
            g !== "wrap" && `wrap-xs-${String(g)}`,
            ...mF(m),
            ...fF(v),
            ...(f ? hF(y, p.breakpoints.keys[0]) : []),
          ],
        };
      return dt(b, (E) => st(i, E), {});
    };
  function o(d, p, f = () => !0) {
    const m = {};
    return (
      d === null ||
        (Array.isArray(d)
          ? d.forEach((y, g) => {
              y !== null && f(y) && p.keys[g] && (m[p.keys[g]] = y);
            })
          : typeof d == "object"
          ? Object.keys(d).forEach((y) => {
              const g = d[y];
              g != null && f(g) && (m[y] = g);
            })
          : (m[p.keys[0]] = d)),
      m
    );
  }
  const a = e(cF, uF, lF, oF, dF, pF, aF),
    l = N.forwardRef(function (p, f) {
      const m = r(),
        y = n(p),
        g = nv(y),
        {
          className: v,
          children: b,
          columns: E = 12,
          container: S = !1,
          component: C = "div",
          direction: _ = "row",
          wrap: A = "wrap",
          size: I = {},
          offset: R = {},
          spacing: D = 0,
          rowSpacing: k = D,
          columnSpacing: T = D,
          unstable_level: U = 0,
          ...q
        } = g,
        K = o(I, m.breakpoints, (W) => W !== !1),
        H = o(R, m.breakpoints),
        $ = p.columns ?? (U ? void 0 : E),
        M = p.spacing ?? (U ? void 0 : D),
        z = p.rowSpacing ?? p.spacing ?? (U ? void 0 : k),
        B = p.columnSpacing ?? p.spacing ?? (U ? void 0 : T),
        j = {
          ...g,
          level: U,
          columns: $,
          container: S,
          direction: _,
          wrap: A,
          spacing: M,
          rowSpacing: z,
          columnSpacing: B,
          size: K,
          offset: H,
        },
        V = s(j, m);
      return O.jsx(a, {
        ref: f,
        as: C,
        ownerState: j,
        className: rv(V.root, v),
        ...q,
        children: N.Children.map(b, (W) => {
          var Z;
          return N.isValidElement(W) &&
            R0(W, ["Grid"]) &&
            S &&
            W.props.container
            ? N.cloneElement(W, {
                unstable_level:
                  ((Z = W.props) == null ? void 0 : Z.unstable_level) ?? U + 1,
              })
            : W;
        }),
      });
    });
  return (l.muiName = "Grid"), l;
}
const bF = Ep(),
  EF = zm("div", {
    name: "MuiStack",
    slot: "Root",
    overridesResolver: (t, e) => e.root,
  });
function CF(t) {
  return WS({ props: t, name: "MuiStack", defaultTheme: bF });
}
function xF(t, e) {
  const n = N.Children.toArray(t).filter(Boolean);
  return n.reduce(
    (r, i, s) => (
      r.push(i),
      s < n.length - 1 && r.push(N.cloneElement(e, { key: `separator-${s}` })),
      r
    ),
    []
  );
}
const SF = (t) =>
    ({
      row: "Left",
      "row-reverse": "Right",
      column: "Top",
      "column-reverse": "Bottom",
    }[t]),
  AF = ({ ownerState: t, theme: e }) => {
    let n = {
      display: "flex",
      flexDirection: "column",
      ...Qs(
        { theme: e },
        J1({ values: t.direction, breakpoints: e.breakpoints.values }),
        (r) => ({ flexDirection: r })
      ),
    };
    if (t.spacing) {
      const r = Zw(e),
        i = Object.keys(e.breakpoints.values).reduce(
          (l, d) => (
            ((typeof t.spacing == "object" && t.spacing[d] != null) ||
              (typeof t.direction == "object" && t.direction[d] != null)) &&
              (l[d] = !0),
            l
          ),
          {}
        ),
        s = J1({ values: t.direction, base: i }),
        o = J1({ values: t.spacing, base: i });
      typeof s == "object" &&
        Object.keys(s).forEach((l, d, p) => {
          if (!s[l]) {
            const m = d > 0 ? s[p[d - 1]] : "column";
            s[l] = m;
          }
        }),
        (n = yr(
          n,
          Qs({ theme: e }, o, (l, d) =>
            t.useFlexGap
              ? { gap: ql(r, l) }
              : {
                  "& > :not(style):not(style)": { margin: 0 },
                  "& > :not(style) ~ :not(style)": {
                    [`margin${SF(d ? s[d] : t.direction)}`]: ql(r, l),
                  },
                }
          )
        ));
    }
    return (n = TB(e.breakpoints, n)), n;
  };
function _F(t = {}) {
  const {
      createStyledComponent: e = EF,
      useThemeProps: n = CF,
      componentName: r = "MuiStack",
    } = t,
    i = () => dt({ root: ["root"] }, (l) => st(r, l), {}),
    s = e(AF);
  return N.forwardRef(function (l, d) {
    const p = n(l),
      f = nv(p),
      {
        component: m = "div",
        direction: y = "column",
        spacing: g = 0,
        divider: v,
        children: b,
        className: E,
        useFlexGap: S = !1,
        ...C
      } = f,
      _ = { direction: y, spacing: g, useFlexGap: S },
      A = i();
    return O.jsx(s, {
      as: m,
      ownerState: _,
      ref: d,
      className: rv(A.root, E),
      ...C,
      children: v ? xF(b, v) : b,
    });
  });
}
function l3() {
  return {
    text: {
      primary: "rgba(0, 0, 0, 0.87)",
      secondary: "rgba(0, 0, 0, 0.6)",
      disabled: "rgba(0, 0, 0, 0.38)",
    },
    divider: "rgba(0, 0, 0, 0.12)",
    background: { paper: Rh.white, default: Rh.white },
    action: {
      active: "rgba(0, 0, 0, 0.54)",
      hover: "rgba(0, 0, 0, 0.04)",
      hoverOpacity: 0.04,
      selected: "rgba(0, 0, 0, 0.08)",
      selectedOpacity: 0.08,
      disabled: "rgba(0, 0, 0, 0.26)",
      disabledBackground: "rgba(0, 0, 0, 0.12)",
      disabledOpacity: 0.38,
      focus: "rgba(0, 0, 0, 0.12)",
      focusOpacity: 0.12,
      activatedOpacity: 0.12,
    },
  };
}
const IF = l3();
function u3() {
  return {
    text: {
      primary: Rh.white,
      secondary: "rgba(255, 255, 255, 0.7)",
      disabled: "rgba(255, 255, 255, 0.5)",
      icon: "rgba(255, 255, 255, 0.5)",
    },
    divider: "rgba(255, 255, 255, 0.12)",
    background: { paper: "#121212", default: "#121212" },
    action: {
      active: Rh.white,
      hover: "rgba(255, 255, 255, 0.08)",
      hoverOpacity: 0.08,
      selected: "rgba(255, 255, 255, 0.16)",
      selectedOpacity: 0.16,
      disabled: "rgba(255, 255, 255, 0.3)",
      disabledBackground: "rgba(255, 255, 255, 0.12)",
      disabledOpacity: 0.38,
      focus: "rgba(255, 255, 255, 0.12)",
      focusOpacity: 0.12,
      activatedOpacity: 0.24,
    },
  };
}
const zT = u3();
function WT(t, e, n, r) {
  const i = r.light || r,
    s = r.dark || r * 1.5;
  t[e] ||
    (t.hasOwnProperty(n)
      ? (t[e] = t[n])
      : e === "light"
      ? (t.light = $h(t.main, i))
      : e === "dark" && (t.dark = Dh(t.main, s)));
}
function TF(t = "light") {
  return t === "dark"
    ? { main: zu[200], light: zu[50], dark: zu[400] }
    : { main: zu[700], light: zu[400], dark: zu[800] };
}
function PF(t = "light") {
  return t === "dark"
    ? { main: Fu[200], light: Fu[50], dark: Fu[400] }
    : { main: Fu[500], light: Fu[300], dark: Fu[700] };
}
function RF(t = "light") {
  return t === "dark"
    ? { main: ju[500], light: ju[300], dark: ju[700] }
    : { main: ju[700], light: ju[400], dark: ju[800] };
}
function NF(t = "light") {
  return t === "dark"
    ? { main: Wu[400], light: Wu[300], dark: Wu[700] }
    : { main: Wu[700], light: Wu[500], dark: Wu[900] };
}
function OF(t = "light") {
  return t === "dark"
    ? { main: Hu[400], light: Hu[300], dark: Hu[700] }
    : { main: Hu[800], light: Hu[500], dark: Hu[900] };
}
function kF(t = "light") {
  return t === "dark"
    ? { main: Sf[400], light: Sf[300], dark: Sf[700] }
    : { main: "#ed6c02", light: Sf[500], dark: Sf[900] };
}
function VS(t) {
  const {
      mode: e = "light",
      contrastThreshold: n = 3,
      tonalOffset: r = 0.2,
      ...i
    } = t,
    s = t.primary || TF(e),
    o = t.secondary || PF(e),
    a = t.error || RF(e),
    l = t.info || NF(e),
    d = t.success || OF(e),
    p = t.warning || kF(e);
  function f(v) {
    return Lj(v, zT.text.primary) >= n ? zT.text.primary : IF.text.primary;
  }
  const m = ({
    color: v,
    name: b,
    mainShade: E = 500,
    lightShade: S = 300,
    darkShade: C = 700,
  }) => {
    if (
      ((v = { ...v }),
      !v.main && v[E] && (v.main = v[E]),
      !v.hasOwnProperty("main"))
    )
      throw new Error(xa(11, b ? ` (${b})` : "", E));
    if (typeof v.main != "string")
      throw new Error(xa(12, b ? ` (${b})` : "", JSON.stringify(v.main)));
    return (
      WT(v, "light", S, r),
      WT(v, "dark", C, r),
      v.contrastText || (v.contrastText = f(v.main)),
      v
    );
  };
  let y;
  return (
    e === "light" ? (y = l3()) : e === "dark" && (y = u3()),
    yr(
      {
        common: { ...Rh },
        mode: e,
        primary: m({ color: s, name: "primary" }),
        secondary: m({
          color: o,
          name: "secondary",
          mainShade: "A400",
          lightShade: "A200",
          darkShade: "A700",
        }),
        error: m({ color: a, name: "error" }),
        warning: m({ color: p, name: "warning" }),
        info: m({ color: l, name: "info" }),
        success: m({ color: d, name: "success" }),
        grey: dU,
        contrastThreshold: n,
        getContrastText: f,
        augmentColor: m,
        tonalOffset: r,
        ...y,
      },
      i
    )
  );
}
function DF(t) {
  const e = {};
  return (
    Object.entries(t).forEach((r) => {
      const [i, s] = r;
      typeof s == "object" &&
        (e[i] = `${s.fontStyle ? `${s.fontStyle} ` : ""}${
          s.fontVariant ? `${s.fontVariant} ` : ""
        }${s.fontWeight ? `${s.fontWeight} ` : ""}${
          s.fontStretch ? `${s.fontStretch} ` : ""
        }${s.fontSize || ""}${s.lineHeight ? `/${s.lineHeight} ` : ""}${
          s.fontFamily || ""
        }`);
    }),
    e
  );
}
function $F(t, e) {
  return {
    toolbar: {
      minHeight: 56,
      [t.up("xs")]: { "@media (orientation: landscape)": { minHeight: 48 } },
      [t.up("sm")]: { minHeight: 64 },
    },
    ...e,
  };
}
function MF(t) {
  return Math.round(t * 1e5) / 1e5;
}
const HT = { textTransform: "uppercase" },
  qT = '"Roboto", "Helvetica", "Arial", sans-serif';
function LF(t, e) {
  const {
      fontFamily: n = qT,
      fontSize: r = 14,
      fontWeightLight: i = 300,
      fontWeightRegular: s = 400,
      fontWeightMedium: o = 500,
      fontWeightBold: a = 700,
      htmlFontSize: l = 16,
      allVariants: d,
      pxToRem: p,
      ...f
    } = typeof e == "function" ? e(t) : e,
    m = r / 14,
    y = p || ((b) => `${(b / l) * m}rem`),
    g = (b, E, S, C, _) => ({
      fontFamily: n,
      fontWeight: b,
      fontSize: y(E),
      lineHeight: S,
      ...(n === qT ? { letterSpacing: `${MF(C / E)}em` } : {}),
      ..._,
      ...d,
    }),
    v = {
      h1: g(i, 96, 1.167, -1.5),
      h2: g(i, 60, 1.2, -0.5),
      h3: g(s, 48, 1.167, 0),
      h4: g(s, 34, 1.235, 0.25),
      h5: g(s, 24, 1.334, 0),
      h6: g(o, 20, 1.6, 0.15),
      subtitle1: g(s, 16, 1.75, 0.15),
      subtitle2: g(o, 14, 1.57, 0.1),
      body1: g(s, 16, 1.5, 0.15),
      body2: g(s, 14, 1.43, 0.15),
      button: g(o, 14, 1.75, 0.4, HT),
      caption: g(s, 12, 1.66, 0.4),
      overline: g(s, 12, 2.66, 1, HT),
      inherit: {
        fontFamily: "inherit",
        fontWeight: "inherit",
        fontSize: "inherit",
        lineHeight: "inherit",
        letterSpacing: "inherit",
      },
    };
  return yr(
    {
      htmlFontSize: l,
      pxToRem: y,
      fontFamily: n,
      fontSize: r,
      fontWeightLight: i,
      fontWeightRegular: s,
      fontWeightMedium: o,
      fontWeightBold: a,
      ...v,
    },
    f,
    { clone: !1 }
  );
}
const UF = 0.2,
  BF = 0.14,
  jF = 0.12;
function gn(...t) {
  return [
    `${t[0]}px ${t[1]}px ${t[2]}px ${t[3]}px rgba(0,0,0,${UF})`,
    `${t[4]}px ${t[5]}px ${t[6]}px ${t[7]}px rgba(0,0,0,${BF})`,
    `${t[8]}px ${t[9]}px ${t[10]}px ${t[11]}px rgba(0,0,0,${jF})`,
  ].join(",");
}
const FF = [
    "none",
    gn(0, 2, 1, -1, 0, 1, 1, 0, 0, 1, 3, 0),
    gn(0, 3, 1, -2, 0, 2, 2, 0, 0, 1, 5, 0),
    gn(0, 3, 3, -2, 0, 3, 4, 0, 0, 1, 8, 0),
    gn(0, 2, 4, -1, 0, 4, 5, 0, 0, 1, 10, 0),
    gn(0, 3, 5, -1, 0, 5, 8, 0, 0, 1, 14, 0),
    gn(0, 3, 5, -1, 0, 6, 10, 0, 0, 1, 18, 0),
    gn(0, 4, 5, -2, 0, 7, 10, 1, 0, 2, 16, 1),
    gn(0, 5, 5, -3, 0, 8, 10, 1, 0, 3, 14, 2),
    gn(0, 5, 6, -3, 0, 9, 12, 1, 0, 3, 16, 2),
    gn(0, 6, 6, -3, 0, 10, 14, 1, 0, 4, 18, 3),
    gn(0, 6, 7, -4, 0, 11, 15, 1, 0, 4, 20, 3),
    gn(0, 7, 8, -4, 0, 12, 17, 2, 0, 5, 22, 4),
    gn(0, 7, 8, -4, 0, 13, 19, 2, 0, 5, 24, 4),
    gn(0, 7, 9, -4, 0, 14, 21, 2, 0, 5, 26, 4),
    gn(0, 8, 9, -5, 0, 15, 22, 2, 0, 6, 28, 5),
    gn(0, 8, 10, -5, 0, 16, 24, 2, 0, 6, 30, 5),
    gn(0, 8, 11, -5, 0, 17, 26, 2, 0, 6, 32, 5),
    gn(0, 9, 11, -5, 0, 18, 28, 2, 0, 7, 34, 6),
    gn(0, 9, 12, -6, 0, 19, 29, 2, 0, 7, 36, 6),
    gn(0, 10, 13, -6, 0, 20, 31, 3, 0, 8, 38, 7),
    gn(0, 10, 13, -6, 0, 21, 33, 3, 0, 8, 40, 7),
    gn(0, 10, 14, -6, 0, 22, 35, 3, 0, 8, 42, 7),
    gn(0, 11, 14, -7, 0, 23, 36, 3, 0, 9, 44, 8),
    gn(0, 11, 15, -7, 0, 24, 38, 3, 0, 9, 46, 8),
  ],
  zF = {
    easeInOut: "cubic-bezier(0.4, 0, 0.2, 1)",
    easeOut: "cubic-bezier(0.0, 0, 0.2, 1)",
    easeIn: "cubic-bezier(0.4, 0, 1, 1)",
    sharp: "cubic-bezier(0.4, 0, 0.6, 1)",
  },
  d3 = {
    shortest: 150,
    shorter: 200,
    short: 250,
    standard: 300,
    complex: 375,
    enteringScreen: 225,
    leavingScreen: 195,
  };
function VT(t) {
  return `${Math.round(t)}ms`;
}
function WF(t) {
  if (!t) return 0;
  const e = t / 36;
  return Math.min(Math.round((4 + 15 * e ** 0.25 + e / 5) * 10), 3e3);
}
function HF(t) {
  const e = { ...zF, ...t.easing },
    n = { ...d3, ...t.duration };
  return {
    getAutoHeightDuration: WF,
    create: (i = ["all"], s = {}) => {
      const {
        duration: o = n.standard,
        easing: a = e.easeInOut,
        delay: l = 0,
        ...d
      } = s;
      return (Array.isArray(i) ? i : [i])
        .map(
          (p) =>
            `${p} ${typeof o == "string" ? o : VT(o)} ${a} ${
              typeof l == "string" ? l : VT(l)
            }`
        )
        .join(",");
    },
    ...t,
    easing: e,
    duration: n,
  };
}
const qF = {
  mobileStepper: 1e3,
  fab: 1050,
  speedDial: 1050,
  appBar: 1100,
  drawer: 1200,
  modal: 1300,
  snackbar: 1400,
  tooltip: 1500,
};
function VF(t) {
  return (
    Ao(t) ||
    typeof t > "u" ||
    typeof t == "string" ||
    typeof t == "boolean" ||
    typeof t == "number" ||
    Array.isArray(t)
  );
}
function p3(t = {}) {
  const e = { ...t };
  function n(r) {
    const i = Object.entries(r);
    for (let s = 0; s < i.length; s++) {
      const [o, a] = i[s];
      !VF(a) || o.startsWith("unstable_")
        ? delete r[o]
        : Ao(a) && ((r[o] = { ...a }), n(r[o]));
    }
  }
  return (
    n(e),
    `import { unstable_createBreakpoints as createBreakpoints, createTransitions } from '@mui/material/styles';

const theme = ${JSON.stringify(e, null, 2)};

theme.breakpoints = createBreakpoints(theme.breakpoints || {});
theme.transitions = createTransitions(theme.transitions || {});

export default theme;`
  );
}
function YC(t = {}, ...e) {
  const {
    breakpoints: n,
    mixins: r = {},
    spacing: i,
    palette: s = {},
    transitions: o = {},
    typography: a = {},
    shape: l,
    ...d
  } = t;
  if (t.vars) throw new Error(xa(20));
  const p = VS(s),
    f = Ep(t);
  let m = yr(f, {
    mixins: $F(f.breakpoints, r),
    palette: p,
    shadows: FF.slice(),
    typography: LF(p, a),
    transitions: HF(o),
    zIndex: { ...qF },
  });
  return (
    (m = yr(m, d)),
    (m = e.reduce((y, g) => yr(y, g), m)),
    (m.unstable_sxConfig = {
      ...jm,
      ...(d == null ? void 0 : d.unstable_sxConfig),
    }),
    (m.unstable_sx = function (g) {
      return Vl({ sx: g, theme: this });
    }),
    (m.toRuntimeSource = p3),
    m
  );
}
function ZC(t) {
  let e;
  return (
    t < 1 ? (e = 5.11916 * t ** 2) : (e = 4.5 * Math.log(t + 1) + 2),
    Math.round(e * 10) / 1e3
  );
}
const GF = [...Array(25)].map((t, e) => {
  if (e === 0) return "none";
  const n = ZC(e);
  return `linear-gradient(rgba(255 255 255 / ${n}), rgba(255 255 255 / ${n}))`;
});
function f3(t) {
  return {
    inputPlaceholder: t === "dark" ? 0.5 : 0.42,
    inputUnderline: t === "dark" ? 0.7 : 0.42,
    switchTrackDisabled: t === "dark" ? 0.2 : 0.12,
    switchTrack: t === "dark" ? 0.3 : 0.38,
  };
}
function h3(t) {
  return t === "dark" ? GF : [];
}
function KF(t) {
  const { palette: e = { mode: "light" }, opacity: n, overlays: r, ...i } = t,
    s = VS(e);
  return {
    palette: s,
    opacity: { ...f3(s.mode), ...n },
    overlays: r || h3(s.mode),
    ...i,
  };
}
function YF(t) {
  var e;
  return (
    !!t[0].match(
      /(cssVarPrefix|colorSchemeSelector|rootSelector|typography|mixins|breakpoints|direction|transitions)/
    ) ||
    !!t[0].match(/sxConfig$/) ||
    (t[0] === "palette" &&
      !!((e = t[1]) != null && e.match(/(mode|contrastThreshold|tonalOffset)/)))
  );
}
const ZF = (t) => [
    ...[...Array(25)].map((e, n) => `--${t ? `${t}-` : ""}overlays-${n}`),
    `--${t ? `${t}-` : ""}palette-AppBar-darkBg`,
    `--${t ? `${t}-` : ""}palette-AppBar-darkColor`,
  ],
  QF = (t) => (e, n) => {
    const r = t.rootSelector || ":root",
      i = t.colorSchemeSelector;
    let s = i;
    if (
      (i === "class" && (s = ".%s"),
      i === "data" && (s = "[data-%s]"),
      i != null &&
        i.startsWith("data-") &&
        !i.includes("%s") &&
        (s = `[${i}="%s"]`),
      t.defaultColorScheme === e)
    ) {
      if (e === "dark") {
        const o = {};
        return (
          ZF(t.cssVarPrefix).forEach((a) => {
            (o[a] = n[a]), delete n[a];
          }),
          s === "media"
            ? { [r]: n, "@media (prefers-color-scheme: dark)": { [r]: o } }
            : s
            ? { [s.replace("%s", e)]: o, [`${r}, ${s.replace("%s", e)}`]: n }
            : { [r]: { ...n, ...o } }
        );
      }
      if (s && s !== "media") return `${r}, ${s.replace("%s", String(e))}`;
    } else if (e) {
      if (s === "media")
        return { [`@media (prefers-color-scheme: ${String(e)})`]: { [r]: n } };
      if (s) return s.replace("%s", String(e));
    }
    return r;
  };
function XF(t, e) {
  e.forEach((n) => {
    t[n] || (t[n] = {});
  });
}
function ae(t, e, n) {
  !t[e] && n && (t[e] = n);
}
function ih(t) {
  return typeof t != "string" || !t.startsWith("hsl") ? t : t3(t);
}
function Yo(t, e) {
  `${e}Channel` in t || (t[`${e}Channel`] = rh(ih(t[e])));
}
function JF(t) {
  return typeof t == "number"
    ? `${t}px`
    : typeof t == "string" || typeof t == "function" || Array.isArray(t)
    ? t
    : "8px";
}
const ao = (t) => {
    try {
      return t();
    } catch {}
  },
  e9 = (t = "mui") => Yj(t);
function nE(t, e, n, r) {
  if (!e) return;
  e = e === !0 ? {} : e;
  const i = r === "dark" ? "dark" : "light";
  if (!n) {
    t[r] = KF({
      ...e,
      palette: { mode: i, ...(e == null ? void 0 : e.palette) },
    });
    return;
  }
  const { palette: s, ...o } = YC({
    ...n,
    palette: { mode: i, ...(e == null ? void 0 : e.palette) },
  });
  return (
    (t[r] = {
      ...e,
      palette: s,
      opacity: { ...f3(i), ...(e == null ? void 0 : e.opacity) },
      overlays: (e == null ? void 0 : e.overlays) || h3(i),
    }),
    o
  );
}
function t9(t = {}, ...e) {
  const {
      colorSchemes: n = { light: !0 },
      defaultColorScheme: r,
      disableCssColorScheme: i = !1,
      cssVarPrefix: s = "mui",
      shouldSkipGeneratingVar: o = YF,
      colorSchemeSelector: a = n.light && n.dark ? "media" : void 0,
      rootSelector: l = ":root",
      ...d
    } = t,
    p = Object.keys(n)[0],
    f = r || (n.light && p !== "light" ? "light" : p),
    m = e9(s),
    { [f]: y, light: g, dark: v, ...b } = n,
    E = { ...b };
  let S = y;
  if (
    (((f === "dark" && !("dark" in n)) || (f === "light" && !("light" in n))) &&
      (S = !0),
    !S)
  )
    throw new Error(xa(21, f));
  const C = nE(E, S, d, f);
  g && !E.light && nE(E, g, void 0, "light"),
    v && !E.dark && nE(E, v, void 0, "dark");
  let _ = {
    defaultColorScheme: f,
    ...C,
    cssVarPrefix: s,
    colorSchemeSelector: a,
    rootSelector: l,
    getCssVar: m,
    colorSchemes: E,
    font: { ...DF(C.typography), ...C.font },
    spacing: JF(d.spacing),
  };
  Object.keys(_.colorSchemes).forEach((k) => {
    const T = _.colorSchemes[k].palette,
      U = (q) => {
        const K = q.split("-"),
          H = K[1],
          $ = K[2];
        return m(q, T[H][$]);
      };
    if (
      (T.mode === "light" &&
        (ae(T.common, "background", "#fff"),
        ae(T.common, "onBackground", "#000")),
      T.mode === "dark" &&
        (ae(T.common, "background", "#000"),
        ae(T.common, "onBackground", "#fff")),
      XF(T, [
        "Alert",
        "AppBar",
        "Avatar",
        "Button",
        "Chip",
        "FilledInput",
        "LinearProgress",
        "Skeleton",
        "Slider",
        "SnackbarContent",
        "SpeedDialAction",
        "StepConnector",
        "StepContent",
        "Switch",
        "TableCell",
        "Tooltip",
      ]),
      T.mode === "light")
    ) {
      ae(T.Alert, "errorColor", Zt(T.error.light, 0.6)),
        ae(T.Alert, "infoColor", Zt(T.info.light, 0.6)),
        ae(T.Alert, "successColor", Zt(T.success.light, 0.6)),
        ae(T.Alert, "warningColor", Zt(T.warning.light, 0.6)),
        ae(T.Alert, "errorFilledBg", U("palette-error-main")),
        ae(T.Alert, "infoFilledBg", U("palette-info-main")),
        ae(T.Alert, "successFilledBg", U("palette-success-main")),
        ae(T.Alert, "warningFilledBg", U("palette-warning-main")),
        ae(
          T.Alert,
          "errorFilledColor",
          ao(() => T.getContrastText(T.error.main))
        ),
        ae(
          T.Alert,
          "infoFilledColor",
          ao(() => T.getContrastText(T.info.main))
        ),
        ae(
          T.Alert,
          "successFilledColor",
          ao(() => T.getContrastText(T.success.main))
        ),
        ae(
          T.Alert,
          "warningFilledColor",
          ao(() => T.getContrastText(T.warning.main))
        ),
        ae(T.Alert, "errorStandardBg", Qt(T.error.light, 0.9)),
        ae(T.Alert, "infoStandardBg", Qt(T.info.light, 0.9)),
        ae(T.Alert, "successStandardBg", Qt(T.success.light, 0.9)),
        ae(T.Alert, "warningStandardBg", Qt(T.warning.light, 0.9)),
        ae(T.Alert, "errorIconColor", U("palette-error-main")),
        ae(T.Alert, "infoIconColor", U("palette-info-main")),
        ae(T.Alert, "successIconColor", U("palette-success-main")),
        ae(T.Alert, "warningIconColor", U("palette-warning-main")),
        ae(T.AppBar, "defaultBg", U("palette-grey-100")),
        ae(T.Avatar, "defaultBg", U("palette-grey-400")),
        ae(T.Button, "inheritContainedBg", U("palette-grey-300")),
        ae(T.Button, "inheritContainedHoverBg", U("palette-grey-A100")),
        ae(T.Chip, "defaultBorder", U("palette-grey-400")),
        ae(T.Chip, "defaultAvatarColor", U("palette-grey-700")),
        ae(T.Chip, "defaultIconColor", U("palette-grey-700")),
        ae(T.FilledInput, "bg", "rgba(0, 0, 0, 0.06)"),
        ae(T.FilledInput, "hoverBg", "rgba(0, 0, 0, 0.09)"),
        ae(T.FilledInput, "disabledBg", "rgba(0, 0, 0, 0.12)"),
        ae(T.LinearProgress, "primaryBg", Qt(T.primary.main, 0.62)),
        ae(T.LinearProgress, "secondaryBg", Qt(T.secondary.main, 0.62)),
        ae(T.LinearProgress, "errorBg", Qt(T.error.main, 0.62)),
        ae(T.LinearProgress, "infoBg", Qt(T.info.main, 0.62)),
        ae(T.LinearProgress, "successBg", Qt(T.success.main, 0.62)),
        ae(T.LinearProgress, "warningBg", Qt(T.warning.main, 0.62)),
        ae(
          T.Skeleton,
          "bg",
          `rgba(${U("palette-text-primaryChannel")} / 0.11)`
        ),
        ae(T.Slider, "primaryTrack", Qt(T.primary.main, 0.62)),
        ae(T.Slider, "secondaryTrack", Qt(T.secondary.main, 0.62)),
        ae(T.Slider, "errorTrack", Qt(T.error.main, 0.62)),
        ae(T.Slider, "infoTrack", Qt(T.info.main, 0.62)),
        ae(T.Slider, "successTrack", Qt(T.success.main, 0.62)),
        ae(T.Slider, "warningTrack", Qt(T.warning.main, 0.62));
      const q = Dy(T.background.default, 0.8);
      ae(T.SnackbarContent, "bg", q),
        ae(
          T.SnackbarContent,
          "color",
          ao(() => T.getContrastText(q))
        ),
        ae(T.SpeedDialAction, "fabHoverBg", Dy(T.background.paper, 0.15)),
        ae(T.StepConnector, "border", U("palette-grey-400")),
        ae(T.StepContent, "border", U("palette-grey-400")),
        ae(T.Switch, "defaultColor", U("palette-common-white")),
        ae(T.Switch, "defaultDisabledColor", U("palette-grey-100")),
        ae(T.Switch, "primaryDisabledColor", Qt(T.primary.main, 0.62)),
        ae(T.Switch, "secondaryDisabledColor", Qt(T.secondary.main, 0.62)),
        ae(T.Switch, "errorDisabledColor", Qt(T.error.main, 0.62)),
        ae(T.Switch, "infoDisabledColor", Qt(T.info.main, 0.62)),
        ae(T.Switch, "successDisabledColor", Qt(T.success.main, 0.62)),
        ae(T.Switch, "warningDisabledColor", Qt(T.warning.main, 0.62)),
        ae(T.TableCell, "border", Qt(ky(T.divider, 1), 0.88)),
        ae(T.Tooltip, "bg", ky(T.grey[700], 0.92));
    }
    if (T.mode === "dark") {
      ae(T.Alert, "errorColor", Qt(T.error.light, 0.6)),
        ae(T.Alert, "infoColor", Qt(T.info.light, 0.6)),
        ae(T.Alert, "successColor", Qt(T.success.light, 0.6)),
        ae(T.Alert, "warningColor", Qt(T.warning.light, 0.6)),
        ae(T.Alert, "errorFilledBg", U("palette-error-dark")),
        ae(T.Alert, "infoFilledBg", U("palette-info-dark")),
        ae(T.Alert, "successFilledBg", U("palette-success-dark")),
        ae(T.Alert, "warningFilledBg", U("palette-warning-dark")),
        ae(
          T.Alert,
          "errorFilledColor",
          ao(() => T.getContrastText(T.error.dark))
        ),
        ae(
          T.Alert,
          "infoFilledColor",
          ao(() => T.getContrastText(T.info.dark))
        ),
        ae(
          T.Alert,
          "successFilledColor",
          ao(() => T.getContrastText(T.success.dark))
        ),
        ae(
          T.Alert,
          "warningFilledColor",
          ao(() => T.getContrastText(T.warning.dark))
        ),
        ae(T.Alert, "errorStandardBg", Zt(T.error.light, 0.9)),
        ae(T.Alert, "infoStandardBg", Zt(T.info.light, 0.9)),
        ae(T.Alert, "successStandardBg", Zt(T.success.light, 0.9)),
        ae(T.Alert, "warningStandardBg", Zt(T.warning.light, 0.9)),
        ae(T.Alert, "errorIconColor", U("palette-error-main")),
        ae(T.Alert, "infoIconColor", U("palette-info-main")),
        ae(T.Alert, "successIconColor", U("palette-success-main")),
        ae(T.Alert, "warningIconColor", U("palette-warning-main")),
        ae(T.AppBar, "defaultBg", U("palette-grey-900")),
        ae(T.AppBar, "darkBg", U("palette-background-paper")),
        ae(T.AppBar, "darkColor", U("palette-text-primary")),
        ae(T.Avatar, "defaultBg", U("palette-grey-600")),
        ae(T.Button, "inheritContainedBg", U("palette-grey-800")),
        ae(T.Button, "inheritContainedHoverBg", U("palette-grey-700")),
        ae(T.Chip, "defaultBorder", U("palette-grey-700")),
        ae(T.Chip, "defaultAvatarColor", U("palette-grey-300")),
        ae(T.Chip, "defaultIconColor", U("palette-grey-300")),
        ae(T.FilledInput, "bg", "rgba(255, 255, 255, 0.09)"),
        ae(T.FilledInput, "hoverBg", "rgba(255, 255, 255, 0.13)"),
        ae(T.FilledInput, "disabledBg", "rgba(255, 255, 255, 0.12)"),
        ae(T.LinearProgress, "primaryBg", Zt(T.primary.main, 0.5)),
        ae(T.LinearProgress, "secondaryBg", Zt(T.secondary.main, 0.5)),
        ae(T.LinearProgress, "errorBg", Zt(T.error.main, 0.5)),
        ae(T.LinearProgress, "infoBg", Zt(T.info.main, 0.5)),
        ae(T.LinearProgress, "successBg", Zt(T.success.main, 0.5)),
        ae(T.LinearProgress, "warningBg", Zt(T.warning.main, 0.5)),
        ae(
          T.Skeleton,
          "bg",
          `rgba(${U("palette-text-primaryChannel")} / 0.13)`
        ),
        ae(T.Slider, "primaryTrack", Zt(T.primary.main, 0.5)),
        ae(T.Slider, "secondaryTrack", Zt(T.secondary.main, 0.5)),
        ae(T.Slider, "errorTrack", Zt(T.error.main, 0.5)),
        ae(T.Slider, "infoTrack", Zt(T.info.main, 0.5)),
        ae(T.Slider, "successTrack", Zt(T.success.main, 0.5)),
        ae(T.Slider, "warningTrack", Zt(T.warning.main, 0.5));
      const q = Dy(T.background.default, 0.98);
      ae(T.SnackbarContent, "bg", q),
        ae(
          T.SnackbarContent,
          "color",
          ao(() => T.getContrastText(q))
        ),
        ae(T.SpeedDialAction, "fabHoverBg", Dy(T.background.paper, 0.15)),
        ae(T.StepConnector, "border", U("palette-grey-600")),
        ae(T.StepContent, "border", U("palette-grey-600")),
        ae(T.Switch, "defaultColor", U("palette-grey-300")),
        ae(T.Switch, "defaultDisabledColor", U("palette-grey-600")),
        ae(T.Switch, "primaryDisabledColor", Zt(T.primary.main, 0.55)),
        ae(T.Switch, "secondaryDisabledColor", Zt(T.secondary.main, 0.55)),
        ae(T.Switch, "errorDisabledColor", Zt(T.error.main, 0.55)),
        ae(T.Switch, "infoDisabledColor", Zt(T.info.main, 0.55)),
        ae(T.Switch, "successDisabledColor", Zt(T.success.main, 0.55)),
        ae(T.Switch, "warningDisabledColor", Zt(T.warning.main, 0.55)),
        ae(T.TableCell, "border", Zt(ky(T.divider, 1), 0.68)),
        ae(T.Tooltip, "bg", ky(T.grey[700], 0.92));
    }
    Yo(T.background, "default"),
      Yo(T.background, "paper"),
      Yo(T.common, "background"),
      Yo(T.common, "onBackground"),
      Yo(T, "divider"),
      Object.keys(T).forEach((q) => {
        const K = T[q];
        q !== "tonalOffset" &&
          K &&
          typeof K == "object" &&
          (K.main && ae(T[q], "mainChannel", rh(ih(K.main))),
          K.light && ae(T[q], "lightChannel", rh(ih(K.light))),
          K.dark && ae(T[q], "darkChannel", rh(ih(K.dark))),
          K.contrastText &&
            ae(T[q], "contrastTextChannel", rh(ih(K.contrastText))),
          q === "text" && (Yo(T[q], "primary"), Yo(T[q], "secondary")),
          q === "action" &&
            (K.active && Yo(T[q], "active"),
            K.selected && Yo(T[q], "selected")));
      });
  }),
    (_ = e.reduce((k, T) => yr(k, T), _));
  const A = {
      prefix: s,
      disableCssColorScheme: i,
      shouldSkipGeneratingVar: o,
      getSelector: QF(_),
    },
    { vars: I, generateThemeVars: R, generateStyleSheets: D } = Xj(_, A);
  return (
    (_.vars = I),
    Object.entries(_.colorSchemes[_.defaultColorScheme]).forEach(([k, T]) => {
      _[k] = T;
    }),
    (_.generateThemeVars = R),
    (_.generateStyleSheets = D),
    (_.generateSpacing = function () {
      return G5(d.spacing, Zw(this));
    }),
    (_.getColorSchemeSelector = Jj(a)),
    (_.spacing = _.generateSpacing()),
    (_.shouldSkipGeneratingVar = o),
    (_.unstable_sxConfig = {
      ...jm,
      ...(d == null ? void 0 : d.unstable_sxConfig),
    }),
    (_.unstable_sx = function (T) {
      return Vl({ sx: T, theme: this });
    }),
    (_.toRuntimeSource = p3),
    _
  );
}
function GT(t, e, n) {
  t.colorSchemes &&
    n &&
    (t.colorSchemes[e] = {
      ...(n !== !0 && n),
      palette: VS({ ...(n === !0 ? {} : n.palette), mode: e }),
    });
}
function m3(t = {}, ...e) {
  const {
      palette: n,
      cssVariables: r = !1,
      colorSchemes: i = n ? void 0 : { light: !0 },
      defaultColorScheme: s = n == null ? void 0 : n.mode,
      ...o
    } = t,
    a = s || "light",
    l = i == null ? void 0 : i[a],
    d = {
      ...i,
      ...(n
        ? { [a]: { ...(typeof l != "boolean" && l), palette: n } }
        : void 0),
    };
  if (r === !1) {
    if (!("colorSchemes" in t)) return YC(t, ...e);
    let p = n;
    "palette" in t ||
      (d[a] &&
        (d[a] !== !0
          ? (p = d[a].palette)
          : a === "dark" && (p = { mode: "dark" })));
    const f = YC({ ...t, palette: p }, ...e);
    return (
      (f.defaultColorScheme = a),
      (f.colorSchemes = d),
      f.palette.mode === "light" &&
        ((f.colorSchemes.light = {
          ...(d.light !== !0 && d.light),
          palette: f.palette,
        }),
        GT(f, "dark", d.dark)),
      f.palette.mode === "dark" &&
        ((f.colorSchemes.dark = {
          ...(d.dark !== !0 && d.dark),
          palette: f.palette,
        }),
        GT(f, "light", d.light)),
      f
    );
  }
  return (
    !n && !("light" in d) && a === "light" && (d.light = !0),
    t9(
      {
        ...o,
        colorSchemes: d,
        defaultColorScheme: a,
        ...(typeof r != "boolean" && r),
      },
      ...e
    )
  );
}
const GS = m3();
function Ii() {
  const t = Fm(GS);
  return t[Mm] || t;
}
function g3(t) {
  return t !== "ownerState" && t !== "theme" && t !== "sx" && t !== "as";
}
const Gi = (t) => g3(t) && t !== "classes",
  Ce = J5({ themeId: Mm, defaultTheme: GS, rootShouldForwardProp: Gi });
function y3(t) {
  var e,
    n,
    r = "";
  if (typeof t == "string" || typeof t == "number") r += t;
  else if (typeof t == "object")
    if (Array.isArray(t)) {
      var i = t.length;
      for (e = 0; e < i; e++)
        t[e] && (n = y3(t[e])) && (r && (r += " "), (r += n));
    } else for (n in t) t[n] && (r && (r += " "), (r += n));
  return r;
}
function He() {
  for (var t, e, n = 0, r = "", i = arguments.length; n < i; n++)
    (t = arguments[n]) && (e = y3(t)) && (r && (r += " "), (r += e));
  return r;
}
function n9(t) {
  return O.jsx(wj, { ...t, defaultTheme: GS, themeId: Mm });
}
function r9(t) {
  return function (n) {
    return O.jsx(n9, {
      styles: typeof t == "function" ? (r) => t({ theme: r, ...n }) : t,
    });
  };
}
function i9() {
  return nv;
}
const wt = Kj;
function ft(t) {
  return Gj(t);
}
function s9(t) {
  return st("MuiSvgIcon", t);
}
ut("MuiSvgIcon", [
  "root",
  "colorPrimary",
  "colorSecondary",
  "colorAction",
  "colorError",
  "colorDisabled",
  "fontSizeInherit",
  "fontSizeSmall",
  "fontSizeMedium",
  "fontSizeLarge",
]);
const o9 = (t) => {
    const { color: e, fontSize: n, classes: r } = t,
      i = {
        root: ["root", e !== "inherit" && `color${Re(e)}`, `fontSize${Re(n)}`],
      };
    return dt(i, s9, r);
  },
  a9 = Ce("svg", {
    name: "MuiSvgIcon",
    slot: "Root",
    overridesResolver: (t, e) => {
      const { ownerState: n } = t;
      return [
        e.root,
        n.color !== "inherit" && e[`color${Re(n.color)}`],
        e[`fontSize${Re(n.fontSize)}`],
      ];
    },
  })(
    wt(({ theme: t }) => {
      var e, n, r, i, s, o, a, l, d, p, f, m, y, g;
      return {
        userSelect: "none",
        width: "1em",
        height: "1em",
        display: "inline-block",
        flexShrink: 0,
        transition:
          (i = (e = t.transitions) == null ? void 0 : e.create) == null
            ? void 0
            : i.call(e, "fill", {
                duration:
                  (r =
                    (n = (t.vars ?? t).transitions) == null
                      ? void 0
                      : n.duration) == null
                    ? void 0
                    : r.shorter,
              }),
        variants: [
          { props: (v) => !v.hasSvgAsChild, style: { fill: "currentColor" } },
          { props: { fontSize: "inherit" }, style: { fontSize: "inherit" } },
          {
            props: { fontSize: "small" },
            style: {
              fontSize:
                ((o = (s = t.typography) == null ? void 0 : s.pxToRem) == null
                  ? void 0
                  : o.call(s, 20)) || "1.25rem",
            },
          },
          {
            props: { fontSize: "medium" },
            style: {
              fontSize:
                ((l = (a = t.typography) == null ? void 0 : a.pxToRem) == null
                  ? void 0
                  : l.call(a, 24)) || "1.5rem",
            },
          },
          {
            props: { fontSize: "large" },
            style: {
              fontSize:
                ((p = (d = t.typography) == null ? void 0 : d.pxToRem) == null
                  ? void 0
                  : p.call(d, 35)) || "2.1875rem",
            },
          },
          ...Object.entries((t.vars ?? t).palette)
            .filter(([, v]) => v && v.main)
            .map(([v]) => {
              var b, E;
              return {
                props: { color: v },
                style: {
                  color:
                    (E = (b = (t.vars ?? t).palette) == null ? void 0 : b[v]) ==
                    null
                      ? void 0
                      : E.main,
                },
              };
            }),
          {
            props: { color: "action" },
            style: {
              color:
                (m = (f = (t.vars ?? t).palette) == null ? void 0 : f.action) ==
                null
                  ? void 0
                  : m.active,
            },
          },
          {
            props: { color: "disabled" },
            style: {
              color:
                (g = (y = (t.vars ?? t).palette) == null ? void 0 : y.action) ==
                null
                  ? void 0
                  : g.disabled,
            },
          },
          { props: { color: "inherit" }, style: { color: void 0 } },
        ],
      };
    })
  ),
  QC = N.forwardRef(function (e, n) {
    const r = ft({ props: e, name: "MuiSvgIcon" }),
      {
        children: i,
        className: s,
        color: o = "inherit",
        component: a = "svg",
        fontSize: l = "medium",
        htmlColor: d,
        inheritViewBox: p = !1,
        titleAccess: f,
        viewBox: m = "0 0 24 24",
        ...y
      } = r,
      g = N.isValidElement(i) && i.type === "svg",
      v = {
        ...r,
        color: o,
        component: a,
        fontSize: l,
        instanceFontSize: e.fontSize,
        inheritViewBox: p,
        viewBox: m,
        hasSvgAsChild: g,
      },
      b = {};
    p || (b.viewBox = m);
    const E = o9(v);
    return O.jsxs(a9, {
      as: a,
      className: He(E.root, s),
      focusable: "false",
      color: d,
      "aria-hidden": f ? void 0 : !0,
      role: f ? "img" : void 0,
      ref: n,
      ...b,
      ...y,
      ...(g && i.props),
      ownerState: v,
      children: [
        g ? i.props.children : i,
        f ? O.jsx("title", { children: f }) : null,
      ],
    });
  });
QC.muiName = "SvgIcon";
function Ki(t, e) {
  function n(r, i) {
    return O.jsx(QC, { "data-testid": `${e}Icon`, ref: i, ...r, children: t });
  }
  return (n.muiName = QC.muiName), N.memo(N.forwardRef(n));
}
function w3(t, e) {
  if (t == null) return {};
  var n = {};
  for (var r in t)
    if ({}.hasOwnProperty.call(t, r)) {
      if (e.includes(r)) continue;
      n[r] = t[r];
    }
  return n;
}
function XC(t, e) {
  return (
    (XC = Object.setPrototypeOf
      ? Object.setPrototypeOf.bind()
      : function (n, r) {
          return (n.__proto__ = r), n;
        }),
    XC(t, e)
  );
}
function v3(t, e) {
  (t.prototype = Object.create(e.prototype)),
    (t.prototype.constructor = t),
    XC(t, e);
}
var KS = T5();
const $y = Hc(KS),
  KT = { disabled: !1 },
  sw = gt.createContext(null);
var c9 = function (e) {
    return e.scrollTop;
  },
  sh = "unmounted",
  yl = "exited",
  wl = "entering",
  yd = "entered",
  JC = "exiting",
  Cs = (function (t) {
    v3(e, t);
    function e(r, i) {
      var s;
      s = t.call(this, r, i) || this;
      var o = i,
        a = o && !o.isMounting ? r.enter : r.appear,
        l;
      return (
        (s.appearStatus = null),
        r.in
          ? a
            ? ((l = yl), (s.appearStatus = wl))
            : (l = yd)
          : r.unmountOnExit || r.mountOnEnter
          ? (l = sh)
          : (l = yl),
        (s.state = { status: l }),
        (s.nextCallback = null),
        s
      );
    }
    e.getDerivedStateFromProps = function (i, s) {
      var o = i.in;
      return o && s.status === sh ? { status: yl } : null;
    };
    var n = e.prototype;
    return (
      (n.componentDidMount = function () {
        this.updateStatus(!0, this.appearStatus);
      }),
      (n.componentDidUpdate = function (i) {
        var s = null;
        if (i !== this.props) {
          var o = this.state.status;
          this.props.in
            ? o !== wl && o !== yd && (s = wl)
            : (o === wl || o === yd) && (s = JC);
        }
        this.updateStatus(!1, s);
      }),
      (n.componentWillUnmount = function () {
        this.cancelNextCallback();
      }),
      (n.getTimeouts = function () {
        var i = this.props.timeout,
          s,
          o,
          a;
        return (
          (s = o = a = i),
          i != null &&
            typeof i != "number" &&
            ((s = i.exit),
            (o = i.enter),
            (a = i.appear !== void 0 ? i.appear : o)),
          { exit: s, enter: o, appear: a }
        );
      }),
      (n.updateStatus = function (i, s) {
        if ((i === void 0 && (i = !1), s !== null))
          if ((this.cancelNextCallback(), s === wl)) {
            if (this.props.unmountOnExit || this.props.mountOnEnter) {
              var o = this.props.nodeRef
                ? this.props.nodeRef.current
                : $y.findDOMNode(this);
              o && c9(o);
            }
            this.performEnter(i);
          } else this.performExit();
        else
          this.props.unmountOnExit &&
            this.state.status === yl &&
            this.setState({ status: sh });
      }),
      (n.performEnter = function (i) {
        var s = this,
          o = this.props.enter,
          a = this.context ? this.context.isMounting : i,
          l = this.props.nodeRef ? [a] : [$y.findDOMNode(this), a],
          d = l[0],
          p = l[1],
          f = this.getTimeouts(),
          m = a ? f.appear : f.enter;
        if ((!i && !o) || KT.disabled) {
          this.safeSetState({ status: yd }, function () {
            s.props.onEntered(d);
          });
          return;
        }
        this.props.onEnter(d, p),
          this.safeSetState({ status: wl }, function () {
            s.props.onEntering(d, p),
              s.onTransitionEnd(m, function () {
                s.safeSetState({ status: yd }, function () {
                  s.props.onEntered(d, p);
                });
              });
          });
      }),
      (n.performExit = function () {
        var i = this,
          s = this.props.exit,
          o = this.getTimeouts(),
          a = this.props.nodeRef ? void 0 : $y.findDOMNode(this);
        if (!s || KT.disabled) {
          this.safeSetState({ status: yl }, function () {
            i.props.onExited(a);
          });
          return;
        }
        this.props.onExit(a),
          this.safeSetState({ status: JC }, function () {
            i.props.onExiting(a),
              i.onTransitionEnd(o.exit, function () {
                i.safeSetState({ status: yl }, function () {
                  i.props.onExited(a);
                });
              });
          });
      }),
      (n.cancelNextCallback = function () {
        this.nextCallback !== null &&
          (this.nextCallback.cancel(), (this.nextCallback = null));
      }),
      (n.safeSetState = function (i, s) {
        (s = this.setNextCallback(s)), this.setState(i, s);
      }),
      (n.setNextCallback = function (i) {
        var s = this,
          o = !0;
        return (
          (this.nextCallback = function (a) {
            o && ((o = !1), (s.nextCallback = null), i(a));
          }),
          (this.nextCallback.cancel = function () {
            o = !1;
          }),
          this.nextCallback
        );
      }),
      (n.onTransitionEnd = function (i, s) {
        this.setNextCallback(s);
        var o = this.props.nodeRef
            ? this.props.nodeRef.current
            : $y.findDOMNode(this),
          a = i == null && !this.props.addEndListener;
        if (!o || a) {
          setTimeout(this.nextCallback, 0);
          return;
        }
        if (this.props.addEndListener) {
          var l = this.props.nodeRef
              ? [this.nextCallback]
              : [o, this.nextCallback],
            d = l[0],
            p = l[1];
          this.props.addEndListener(d, p);
        }
        i != null && setTimeout(this.nextCallback, i);
      }),
      (n.render = function () {
        var i = this.state.status;
        if (i === sh) return null;
        var s = this.props,
          o = s.children;
        s.in,
          s.mountOnEnter,
          s.unmountOnExit,
          s.appear,
          s.enter,
          s.exit,
          s.timeout,
          s.addEndListener,
          s.onEnter,
          s.onEntering,
          s.onEntered,
          s.onExit,
          s.onExiting,
          s.onExited,
          s.nodeRef;
        var a = w3(s, [
          "children",
          "in",
          "mountOnEnter",
          "unmountOnExit",
          "appear",
          "enter",
          "exit",
          "timeout",
          "addEndListener",
          "onEnter",
          "onEntering",
          "onEntered",
          "onExit",
          "onExiting",
          "onExited",
          "nodeRef",
        ]);
        return gt.createElement(
          sw.Provider,
          { value: null },
          typeof o == "function"
            ? o(i, a)
            : gt.cloneElement(gt.Children.only(o), a)
        );
      }),
      e
    );
  })(gt.Component);
Cs.contextType = sw;
Cs.propTypes = {};
function qu() {}
Cs.defaultProps = {
  in: !1,
  mountOnEnter: !1,
  unmountOnExit: !1,
  appear: !1,
  enter: !0,
  exit: !0,
  onEnter: qu,
  onEntering: qu,
  onEntered: qu,
  onExit: qu,
  onExiting: qu,
  onExited: qu,
};
Cs.UNMOUNTED = sh;
Cs.EXITED = yl;
Cs.ENTERING = wl;
Cs.ENTERED = yd;
Cs.EXITING = JC;
function l9(t) {
  if (t === void 0)
    throw new ReferenceError(
      "this hasn't been initialised - super() hasn't been called"
    );
  return t;
}
function YS(t, e) {
  var n = function (s) {
      return e && N.isValidElement(s) ? e(s) : s;
    },
    r = Object.create(null);
  return (
    t &&
      N.Children.map(t, function (i) {
        return i;
      }).forEach(function (i) {
        r[i.key] = n(i);
      }),
    r
  );
}
function u9(t, e) {
  (t = t || {}), (e = e || {});
  function n(p) {
    return p in e ? e[p] : t[p];
  }
  var r = Object.create(null),
    i = [];
  for (var s in t) s in e ? i.length && ((r[s] = i), (i = [])) : i.push(s);
  var o,
    a = {};
  for (var l in e) {
    if (r[l])
      for (o = 0; o < r[l].length; o++) {
        var d = r[l][o];
        a[r[l][o]] = n(d);
      }
    a[l] = n(l);
  }
  for (o = 0; o < i.length; o++) a[i[o]] = n(i[o]);
  return a;
}
function Il(t, e, n) {
  return n[e] != null ? n[e] : t.props[e];
}
function d9(t, e) {
  return YS(t.children, function (n) {
    return N.cloneElement(n, {
      onExited: e.bind(null, n),
      in: !0,
      appear: Il(n, "appear", t),
      enter: Il(n, "enter", t),
      exit: Il(n, "exit", t),
    });
  });
}
function p9(t, e, n) {
  var r = YS(t.children),
    i = u9(e, r);
  return (
    Object.keys(i).forEach(function (s) {
      var o = i[s];
      if (N.isValidElement(o)) {
        var a = s in e,
          l = s in r,
          d = e[s],
          p = N.isValidElement(d) && !d.props.in;
        l && (!a || p)
          ? (i[s] = N.cloneElement(o, {
              onExited: n.bind(null, o),
              in: !0,
              exit: Il(o, "exit", t),
              enter: Il(o, "enter", t),
            }))
          : !l && a && !p
          ? (i[s] = N.cloneElement(o, { in: !1 }))
          : l &&
            a &&
            N.isValidElement(d) &&
            (i[s] = N.cloneElement(o, {
              onExited: n.bind(null, o),
              in: d.props.in,
              exit: Il(o, "exit", t),
              enter: Il(o, "enter", t),
            }));
      }
    }),
    i
  );
}
var f9 =
    Object.values ||
    function (t) {
      return Object.keys(t).map(function (e) {
        return t[e];
      });
    },
  h9 = {
    component: "div",
    childFactory: function (e) {
      return e;
    },
  },
  ZS = (function (t) {
    v3(e, t);
    function e(r, i) {
      var s;
      s = t.call(this, r, i) || this;
      var o = s.handleExited.bind(l9(s));
      return (
        (s.state = {
          contextValue: { isMounting: !0 },
          handleExited: o,
          firstRender: !0,
        }),
        s
      );
    }
    var n = e.prototype;
    return (
      (n.componentDidMount = function () {
        (this.mounted = !0),
          this.setState({ contextValue: { isMounting: !1 } });
      }),
      (n.componentWillUnmount = function () {
        this.mounted = !1;
      }),
      (e.getDerivedStateFromProps = function (i, s) {
        var o = s.children,
          a = s.handleExited,
          l = s.firstRender;
        return { children: l ? d9(i, a) : p9(i, o, a), firstRender: !1 };
      }),
      (n.handleExited = function (i, s) {
        var o = YS(this.props.children);
        i.key in o ||
          (i.props.onExited && i.props.onExited(s),
          this.mounted &&
            this.setState(function (a) {
              var l = Q0({}, a.children);
              return delete l[i.key], { children: l };
            }));
      }),
      (n.render = function () {
        var i = this.props,
          s = i.component,
          o = i.childFactory,
          a = w3(i, ["component", "childFactory"]),
          l = this.state.contextValue,
          d = f9(this.state.children).map(o);
        return (
          delete a.appear,
          delete a.enter,
          delete a.exit,
          s === null
            ? gt.createElement(sw.Provider, { value: l }, d)
            : gt.createElement(
                sw.Provider,
                { value: l },
                gt.createElement(s, a, d)
              )
        );
      }),
      e
    );
  })(gt.Component);
ZS.propTypes = {};
ZS.defaultProps = h9;
const QS = (t) => t.scrollTop;
function Uc(t, e) {
  const { timeout: n, easing: r, style: i = {} } = t;
  return {
    duration:
      i.transitionDuration ?? (typeof n == "number" ? n : n[e.mode] || 0),
    easing:
      i.transitionTimingFunction ?? (typeof r == "object" ? r[e.mode] : r),
    delay: i.transitionDelay,
  };
}
function m9(t) {
  return st("MuiCollapse", t);
}
ut("MuiCollapse", [
  "root",
  "horizontal",
  "vertical",
  "entered",
  "hidden",
  "wrapper",
  "wrapperInner",
]);
const g9 = (t) => {
    const { orientation: e, classes: n } = t,
      r = {
        root: ["root", `${e}`],
        entered: ["entered"],
        hidden: ["hidden"],
        wrapper: ["wrapper", `${e}`],
        wrapperInner: ["wrapperInner", `${e}`],
      };
    return dt(r, m9, n);
  },
  y9 = Ce("div", {
    name: "MuiCollapse",
    slot: "Root",
    overridesResolver: (t, e) => {
      const { ownerState: n } = t;
      return [
        e.root,
        e[n.orientation],
        n.state === "entered" && e.entered,
        n.state === "exited" && !n.in && n.collapsedSize === "0px" && e.hidden,
      ];
    },
  })(
    wt(({ theme: t }) => ({
      height: 0,
      overflow: "hidden",
      transition: t.transitions.create("height"),
      variants: [
        {
          props: { orientation: "horizontal" },
          style: {
            height: "auto",
            width: 0,
            transition: t.transitions.create("width"),
          },
        },
        {
          props: { state: "entered" },
          style: { height: "auto", overflow: "visible" },
        },
        {
          props: { state: "entered", orientation: "horizontal" },
          style: { width: "auto" },
        },
        {
          props: ({ ownerState: e }) =>
            e.state === "exited" && !e.in && e.collapsedSize === "0px",
          style: { visibility: "hidden" },
        },
      ],
    }))
  ),
  w9 = Ce("div", {
    name: "MuiCollapse",
    slot: "Wrapper",
    overridesResolver: (t, e) => e.wrapper,
  })({
    display: "flex",
    width: "100%",
    variants: [
      {
        props: { orientation: "horizontal" },
        style: { width: "auto", height: "100%" },
      },
    ],
  }),
  v9 = Ce("div", {
    name: "MuiCollapse",
    slot: "WrapperInner",
    overridesResolver: (t, e) => e.wrapperInner,
  })({
    width: "100%",
    variants: [
      {
        props: { orientation: "horizontal" },
        style: { width: "auto", height: "100%" },
      },
    ],
  }),
  ex = N.forwardRef(function (e, n) {
    const r = ft({ props: e, name: "MuiCollapse" }),
      {
        addEndListener: i,
        children: s,
        className: o,
        collapsedSize: a = "0px",
        component: l,
        easing: d,
        in: p,
        onEnter: f,
        onEntered: m,
        onEntering: y,
        onExit: g,
        onExited: v,
        onExiting: b,
        orientation: E = "vertical",
        style: S,
        timeout: C = d3.standard,
        TransitionComponent: _ = Cs,
        ...A
      } = r,
      I = { ...r, orientation: E, collapsedSize: a },
      R = g9(I),
      D = Ii(),
      k = Ac(),
      T = N.useRef(null),
      U = N.useRef(),
      q = typeof a == "number" ? `${a}px` : a,
      K = E === "horizontal",
      H = K ? "width" : "height",
      $ = N.useRef(null),
      M = In(n, $),
      z = (re) => (fe) => {
        if (re) {
          const ce = $.current;
          fe === void 0 ? re(ce) : re(ce, fe);
        }
      },
      B = () => (T.current ? T.current[K ? "clientWidth" : "clientHeight"] : 0),
      j = z((re, fe) => {
        T.current && K && (T.current.style.position = "absolute"),
          (re.style[H] = q),
          f && f(re, fe);
      }),
      V = z((re, fe) => {
        const ce = B();
        T.current && K && (T.current.style.position = "");
        const { duration: le, easing: Se } = Uc(
          { style: S, timeout: C, easing: d },
          { mode: "enter" }
        );
        if (C === "auto") {
          const je = D.transitions.getAutoHeightDuration(ce);
          (re.style.transitionDuration = `${je}ms`), (U.current = je);
        } else
          re.style.transitionDuration = typeof le == "string" ? le : `${le}ms`;
        (re.style[H] = `${ce}px`),
          (re.style.transitionTimingFunction = Se),
          y && y(re, fe);
      }),
      W = z((re, fe) => {
        (re.style[H] = "auto"), m && m(re, fe);
      }),
      Z = z((re) => {
        (re.style[H] = `${B()}px`), g && g(re);
      }),
      ee = z(v),
      J = z((re) => {
        const fe = B(),
          { duration: ce, easing: le } = Uc(
            { style: S, timeout: C, easing: d },
            { mode: "exit" }
          );
        if (C === "auto") {
          const Se = D.transitions.getAutoHeightDuration(fe);
          (re.style.transitionDuration = `${Se}ms`), (U.current = Se);
        } else
          re.style.transitionDuration = typeof ce == "string" ? ce : `${ce}ms`;
        (re.style[H] = q), (re.style.transitionTimingFunction = le), b && b(re);
      }),
      se = (re) => {
        C === "auto" && k.start(U.current || 0, re), i && i($.current, re);
      };
    return O.jsx(_, {
      in: p,
      onEnter: j,
      onEntered: W,
      onEntering: V,
      onExit: Z,
      onExited: ee,
      onExiting: J,
      addEndListener: se,
      nodeRef: $,
      timeout: C === "auto" ? null : C,
      ...A,
      children: (re, { ownerState: fe, ...ce }) =>
        O.jsx(y9, {
          as: l,
          className: He(
            R.root,
            o,
            { entered: R.entered, exited: !p && q === "0px" && R.hidden }[re]
          ),
          style: { [K ? "minWidth" : "minHeight"]: q, ...S },
          ref: M,
          ownerState: { ...I, state: re },
          ...ce,
          children: O.jsx(w9, {
            ownerState: { ...I, state: re },
            className: R.wrapper,
            ref: T,
            children: O.jsx(v9, {
              ownerState: { ...I, state: re },
              className: R.wrapperInner,
              children: s,
            }),
          }),
        }),
    });
  });
ex && (ex.muiSupportAuto = !0);
function b9(t) {
  return st("MuiPaper", t);
}
ut("MuiPaper", [
  "root",
  "rounded",
  "outlined",
  "elevation",
  "elevation0",
  "elevation1",
  "elevation2",
  "elevation3",
  "elevation4",
  "elevation5",
  "elevation6",
  "elevation7",
  "elevation8",
  "elevation9",
  "elevation10",
  "elevation11",
  "elevation12",
  "elevation13",
  "elevation14",
  "elevation15",
  "elevation16",
  "elevation17",
  "elevation18",
  "elevation19",
  "elevation20",
  "elevation21",
  "elevation22",
  "elevation23",
  "elevation24",
]);
const E9 = (t) => {
    const { square: e, elevation: n, variant: r, classes: i } = t,
      s = {
        root: [
          "root",
          r,
          !e && "rounded",
          r === "elevation" && `elevation${n}`,
        ],
      };
    return dt(s, b9, i);
  },
  C9 = Ce("div", {
    name: "MuiPaper",
    slot: "Root",
    overridesResolver: (t, e) => {
      const { ownerState: n } = t;
      return [
        e.root,
        e[n.variant],
        !n.square && e.rounded,
        n.variant === "elevation" && e[`elevation${n.elevation}`],
      ];
    },
  })(
    wt(({ theme: t }) => ({
      backgroundColor: (t.vars || t).palette.background.paper,
      color: (t.vars || t).palette.text.primary,
      transition: t.transitions.create("box-shadow"),
      variants: [
        {
          props: ({ ownerState: e }) => !e.square,
          style: { borderRadius: t.shape.borderRadius },
        },
        {
          props: { variant: "outlined" },
          style: { border: `1px solid ${(t.vars || t).palette.divider}` },
        },
        {
          props: { variant: "elevation" },
          style: {
            boxShadow: "var(--Paper-shadow)",
            backgroundImage: "var(--Paper-overlay)",
          },
        },
      ],
    }))
  ),
  Vc = N.forwardRef(function (e, n) {
    var y;
    const r = ft({ props: e, name: "MuiPaper" }),
      i = Ii(),
      {
        className: s,
        component: o = "div",
        elevation: a = 1,
        square: l = !1,
        variant: d = "elevation",
        ...p
      } = r,
      f = { ...r, component: o, elevation: a, square: l, variant: d },
      m = E9(f);
    return O.jsx(C9, {
      as: o,
      ownerState: f,
      className: He(m.root, s),
      ref: n,
      ...p,
      style: {
        ...(d === "elevation" && {
          "--Paper-shadow": (i.vars || i).shadows[a],
          ...(i.vars && {
            "--Paper-overlay": (y = i.vars.overlays) == null ? void 0 : y[a],
          }),
          ...(!i.vars &&
            i.palette.mode === "dark" && {
              "--Paper-overlay": `linear-gradient(${An("#fff", ZC(a))}, ${An(
                "#fff",
                ZC(a)
              )})`,
            }),
        }),
        ...p.style,
      },
    });
  }),
  b3 = N.createContext({});
function Jn(t, e) {
  const {
      className: n,
      elementType: r,
      ownerState: i,
      externalForwardedProps: s,
      internalForwardedProps: o,
      ...a
    } = e,
    {
      component: l,
      slots: d = { [t]: void 0 },
      slotProps: p = { [t]: void 0 },
      ...f
    } = s,
    m = d[t] || r,
    y = c3(p[t], i),
    {
      props: { component: g, ...v },
      internalRef: b,
    } = a3({
      className: n,
      ...a,
      externalForwardedProps: t === "root" ? f : void 0,
      externalSlotProps: y,
    }),
    E = In(b, y == null ? void 0 : y.ref, e.ref),
    S = t === "root" ? g || l : g,
    C = s3(
      m,
      {
        ...(t === "root" && !l && !d[t] && o),
        ...(t !== "root" && !d[t] && o),
        ...v,
        ...(S && { as: S }),
        ref: E,
      },
      i
    );
  return [m, C];
}
function x9(t) {
  return st("MuiAccordion", t);
}
const My = ut("MuiAccordion", [
    "root",
    "heading",
    "rounded",
    "expanded",
    "disabled",
    "gutters",
    "region",
  ]),
  S9 = (t) => {
    const {
      classes: e,
      square: n,
      expanded: r,
      disabled: i,
      disableGutters: s,
    } = t;
    return dt(
      {
        root: [
          "root",
          !n && "rounded",
          r && "expanded",
          i && "disabled",
          !s && "gutters",
        ],
        heading: ["heading"],
        region: ["region"],
      },
      x9,
      e
    );
  },
  A9 = Ce(Vc, {
    name: "MuiAccordion",
    slot: "Root",
    overridesResolver: (t, e) => {
      const { ownerState: n } = t;
      return [
        { [`& .${My.region}`]: e.region },
        e.root,
        !n.square && e.rounded,
        !n.disableGutters && e.gutters,
      ];
    },
  })(
    wt(({ theme: t }) => {
      const e = { duration: t.transitions.duration.shortest };
      return {
        position: "relative",
        transition: t.transitions.create(["margin"], e),
        overflowAnchor: "none",
        "&::before": {
          position: "absolute",
          left: 0,
          top: -1,
          right: 0,
          height: 1,
          content: '""',
          opacity: 1,
          backgroundColor: (t.vars || t).palette.divider,
          transition: t.transitions.create(["opacity", "background-color"], e),
        },
        "&:first-of-type": { "&::before": { display: "none" } },
        [`&.${My.expanded}`]: {
          "&::before": { opacity: 0 },
          "&:first-of-type": { marginTop: 0 },
          "&:last-of-type": { marginBottom: 0 },
          "& + &": { "&::before": { display: "none" } },
        },
        [`&.${My.disabled}`]: {
          backgroundColor: (t.vars || t).palette.action.disabledBackground,
        },
      };
    }),
    wt(({ theme: t }) => ({
      variants: [
        {
          props: (e) => !e.square,
          style: {
            borderRadius: 0,
            "&:first-of-type": {
              borderTopLeftRadius: (t.vars || t).shape.borderRadius,
              borderTopRightRadius: (t.vars || t).shape.borderRadius,
            },
            "&:last-of-type": {
              borderBottomLeftRadius: (t.vars || t).shape.borderRadius,
              borderBottomRightRadius: (t.vars || t).shape.borderRadius,
              "@supports (-ms-ime-align: auto)": {
                borderBottomLeftRadius: 0,
                borderBottomRightRadius: 0,
              },
            },
          },
        },
        {
          props: (e) => !e.disableGutters,
          style: { [`&.${My.expanded}`]: { margin: "16px 0" } },
        },
      ],
    }))
  ),
  _9 = Ce("h3", {
    name: "MuiAccordion",
    slot: "Heading",
    overridesResolver: (t, e) => e.heading,
  })({ all: "unset" }),
  I9 = N.forwardRef(function (e, n) {
    const r = ft({ props: e, name: "MuiAccordion" }),
      {
        children: i,
        className: s,
        defaultExpanded: o = !1,
        disabled: a = !1,
        disableGutters: l = !1,
        expanded: d,
        onChange: p,
        square: f = !1,
        slots: m = {},
        slotProps: y = {},
        TransitionComponent: g,
        TransitionProps: v,
        ...b
      } = r,
      [E, S] = ew({
        controlled: d,
        default: o,
        name: "Accordion",
        state: "expanded",
      }),
      C = N.useCallback(
        (M) => {
          S(!E), p && p(M, !E);
        },
        [E, p, S]
      ),
      [_, ...A] = N.Children.toArray(i),
      I = N.useMemo(
        () => ({ expanded: E, disabled: a, disableGutters: l, toggle: C }),
        [E, a, l, C]
      ),
      R = { ...r, square: f, disabled: a, disableGutters: l, expanded: E },
      D = S9(R),
      k = { transition: g, ...m },
      T = { transition: v, ...y },
      U = { slots: k, slotProps: T },
      [q, K] = Jn("heading", {
        elementType: _9,
        externalForwardedProps: U,
        className: D.heading,
        ownerState: R,
      }),
      [H, $] = Jn("transition", {
        elementType: ex,
        externalForwardedProps: U,
        ownerState: R,
      });
    return O.jsxs(A9, {
      className: He(D.root, s),
      ref: n,
      ownerState: R,
      square: f,
      ...b,
      children: [
        O.jsx(q, {
          ...K,
          children: O.jsx(b3.Provider, { value: I, children: _ }),
        }),
        O.jsx(H, {
          in: E,
          timeout: "auto",
          ...$,
          children: O.jsx("div", {
            "aria-labelledby": _.props.id,
            id: _.props["aria-controls"],
            role: "region",
            className: D.region,
            children: A,
          }),
        }),
      ],
    });
  });
function T9(t) {
  return st("MuiAccordionDetails", t);
}
ut("MuiAccordionDetails", ["root"]);
const P9 = (t) => {
    const { classes: e } = t;
    return dt({ root: ["root"] }, T9, e);
  },
  R9 = Ce("div", {
    name: "MuiAccordionDetails",
    slot: "Root",
    overridesResolver: (t, e) => e.root,
  })(wt(({ theme: t }) => ({ padding: t.spacing(1, 2, 2) }))),
  N9 = N.forwardRef(function (e, n) {
    const r = ft({ props: e, name: "MuiAccordionDetails" }),
      { className: i, ...s } = r,
      o = r,
      a = P9(o);
    return O.jsx(R9, { className: He(a.root, i), ref: n, ownerState: o, ...s });
  });
class ow {
  constructor() {
    Cf(this, "mountEffect", () => {
      this.shouldMount &&
        !this.didMount &&
        this.ref.current !== null &&
        ((this.didMount = !0), this.mounted.resolve());
    });
    (this.ref = { current: null }),
      (this.mounted = null),
      (this.didMount = !1),
      (this.shouldMount = !1),
      (this.setShouldMount = null);
  }
  static create() {
    return new ow();
  }
  static use() {
    const e = r3(ow.create).current,
      [n, r] = N.useState(!1);
    return (
      (e.shouldMount = n),
      (e.setShouldMount = r),
      N.useEffect(e.mountEffect, [n]),
      e
    );
  }
  mount() {
    return (
      this.mounted ||
        ((this.mounted = k9()),
        (this.shouldMount = !0),
        this.setShouldMount(this.shouldMount)),
      this.mounted
    );
  }
  start(...e) {
    this.mount().then(() => {
      var n;
      return (n = this.ref.current) == null ? void 0 : n.start(...e);
    });
  }
  stop(...e) {
    this.mount().then(() => {
      var n;
      return (n = this.ref.current) == null ? void 0 : n.stop(...e);
    });
  }
  pulsate(...e) {
    this.mount().then(() => {
      var n;
      return (n = this.ref.current) == null ? void 0 : n.pulsate(...e);
    });
  }
}
function O9() {
  return ow.use();
}
function k9() {
  let t, e;
  const n = new Promise((r, i) => {
    (t = r), (e = i);
  });
  return (n.resolve = t), (n.reject = e), n;
}
function D9(t) {
  const {
      className: e,
      classes: n,
      pulsate: r = !1,
      rippleX: i,
      rippleY: s,
      rippleSize: o,
      in: a,
      onExited: l,
      timeout: d,
    } = t,
    [p, f] = N.useState(!1),
    m = He(e, n.ripple, n.rippleVisible, r && n.ripplePulsate),
    y = { width: o, height: o, top: -(o / 2) + s, left: -(o / 2) + i },
    g = He(n.child, p && n.childLeaving, r && n.childPulsate);
  return (
    !a && !p && f(!0),
    N.useEffect(() => {
      if (!a && l != null) {
        const v = setTimeout(l, d);
        return () => {
          clearTimeout(v);
        };
      }
    }, [l, a, d]),
    O.jsx("span", {
      className: m,
      style: y,
      children: O.jsx("span", { className: g }),
    })
  );
}
const us = ut("MuiTouchRipple", [
    "root",
    "ripple",
    "rippleVisible",
    "ripplePulsate",
    "child",
    "childLeaving",
    "childPulsate",
  ]),
  tx = 550,
  $9 = 80,
  M9 = bp`
  0% {
    transform: scale(0);
    opacity: 0.1;
  }

  100% {
    transform: scale(1);
    opacity: 0.3;
  }
`,
  L9 = bp`
  0% {
    opacity: 1;
  }

  100% {
    opacity: 0;
  }
`,
  U9 = bp`
  0% {
    transform: scale(1);
  }

  50% {
    transform: scale(0.92);
  }

  100% {
    transform: scale(1);
  }
`,
  B9 = Ce("span", { name: "MuiTouchRipple", slot: "Root" })({
    overflow: "hidden",
    pointerEvents: "none",
    position: "absolute",
    zIndex: 0,
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    borderRadius: "inherit",
  }),
  j9 = Ce(D9, { name: "MuiTouchRipple", slot: "Ripple" })`
  opacity: 0;
  position: absolute;

  &.${us.rippleVisible} {
    opacity: 0.3;
    transform: scale(1);
    animation-name: ${M9};
    animation-duration: ${tx}ms;
    animation-timing-function: ${({ theme: t }) =>
      t.transitions.easing.easeInOut};
  }

  &.${us.ripplePulsate} {
    animation-duration: ${({ theme: t }) => t.transitions.duration.shorter}ms;
  }

  & .${us.child} {
    opacity: 1;
    display: block;
    width: 100%;
    height: 100%;
    border-radius: 50%;
    background-color: currentColor;
  }

  & .${us.childLeaving} {
    opacity: 0;
    animation-name: ${L9};
    animation-duration: ${tx}ms;
    animation-timing-function: ${({ theme: t }) =>
      t.transitions.easing.easeInOut};
  }

  & .${us.childPulsate} {
    position: absolute;
    /* @noflip */
    left: 0px;
    top: 0;
    animation-name: ${U9};
    animation-duration: 2500ms;
    animation-timing-function: ${({ theme: t }) =>
      t.transitions.easing.easeInOut};
    animation-iteration-count: infinite;
    animation-delay: 200ms;
  }
`,
  F9 = N.forwardRef(function (e, n) {
    const r = ft({ props: e, name: "MuiTouchRipple" }),
      { center: i = !1, classes: s = {}, className: o, ...a } = r,
      [l, d] = N.useState([]),
      p = N.useRef(0),
      f = N.useRef(null);
    N.useEffect(() => {
      f.current && (f.current(), (f.current = null));
    }, [l]);
    const m = N.useRef(!1),
      y = Ac(),
      g = N.useRef(null),
      v = N.useRef(null),
      b = N.useCallback(
        (_) => {
          const {
            pulsate: A,
            rippleX: I,
            rippleY: R,
            rippleSize: D,
            cb: k,
          } = _;
          d((T) => [
            ...T,
            O.jsx(
              j9,
              {
                classes: {
                  ripple: He(s.ripple, us.ripple),
                  rippleVisible: He(s.rippleVisible, us.rippleVisible),
                  ripplePulsate: He(s.ripplePulsate, us.ripplePulsate),
                  child: He(s.child, us.child),
                  childLeaving: He(s.childLeaving, us.childLeaving),
                  childPulsate: He(s.childPulsate, us.childPulsate),
                },
                timeout: tx,
                pulsate: A,
                rippleX: I,
                rippleY: R,
                rippleSize: D,
              },
              p.current
            ),
          ]),
            (p.current += 1),
            (f.current = k);
        },
        [s]
      ),
      E = N.useCallback(
        (_ = {}, A = {}, I = () => {}) => {
          const {
            pulsate: R = !1,
            center: D = i || A.pulsate,
            fakeElement: k = !1,
          } = A;
          if ((_ == null ? void 0 : _.type) === "mousedown" && m.current) {
            m.current = !1;
            return;
          }
          (_ == null ? void 0 : _.type) === "touchstart" && (m.current = !0);
          const T = k ? null : v.current,
            U = T
              ? T.getBoundingClientRect()
              : { width: 0, height: 0, left: 0, top: 0 };
          let q, K, H;
          if (
            D ||
            _ === void 0 ||
            (_.clientX === 0 && _.clientY === 0) ||
            (!_.clientX && !_.touches)
          )
            (q = Math.round(U.width / 2)), (K = Math.round(U.height / 2));
          else {
            const { clientX: $, clientY: M } =
              _.touches && _.touches.length > 0 ? _.touches[0] : _;
            (q = Math.round($ - U.left)), (K = Math.round(M - U.top));
          }
          if (D)
            (H = Math.sqrt((2 * U.width ** 2 + U.height ** 2) / 3)),
              H % 2 === 0 && (H += 1);
          else {
            const $ =
                Math.max(Math.abs((T ? T.clientWidth : 0) - q), q) * 2 + 2,
              M = Math.max(Math.abs((T ? T.clientHeight : 0) - K), K) * 2 + 2;
            H = Math.sqrt($ ** 2 + M ** 2);
          }
          _ != null && _.touches
            ? g.current === null &&
              ((g.current = () => {
                b({ pulsate: R, rippleX: q, rippleY: K, rippleSize: H, cb: I });
              }),
              y.start($9, () => {
                g.current && (g.current(), (g.current = null));
              }))
            : b({ pulsate: R, rippleX: q, rippleY: K, rippleSize: H, cb: I });
        },
        [i, b, y]
      ),
      S = N.useCallback(() => {
        E({}, { pulsate: !0 });
      }, [E]),
      C = N.useCallback(
        (_, A) => {
          if (
            (y.clear(),
            (_ == null ? void 0 : _.type) === "touchend" && g.current)
          ) {
            g.current(),
              (g.current = null),
              y.start(0, () => {
                C(_, A);
              });
            return;
          }
          (g.current = null),
            d((I) => (I.length > 0 ? I.slice(1) : I)),
            (f.current = A);
        },
        [y]
      );
    return (
      N.useImperativeHandle(n, () => ({ pulsate: S, start: E, stop: C }), [
        S,
        E,
        C,
      ]),
      O.jsx(B9, {
        className: He(us.root, s.root, o),
        ref: v,
        ...a,
        children: O.jsx(ZS, { component: null, exit: !0, children: l }),
      })
    );
  });
function z9(t) {
  return st("MuiButtonBase", t);
}
const W9 = ut("MuiButtonBase", ["root", "disabled", "focusVisible"]),
  H9 = (t) => {
    const {
        disabled: e,
        focusVisible: n,
        focusVisibleClassName: r,
        classes: i,
      } = t,
      o = dt({ root: ["root", e && "disabled", n && "focusVisible"] }, z9, i);
    return n && r && (o.root += ` ${r}`), o;
  },
  q9 = Ce("button", {
    name: "MuiButtonBase",
    slot: "Root",
    overridesResolver: (t, e) => e.root,
  })({
    display: "inline-flex",
    alignItems: "center",
    justifyContent: "center",
    position: "relative",
    boxSizing: "border-box",
    WebkitTapHighlightColor: "transparent",
    backgroundColor: "transparent",
    outline: 0,
    border: 0,
    margin: 0,
    borderRadius: 0,
    padding: 0,
    cursor: "pointer",
    userSelect: "none",
    verticalAlign: "middle",
    MozAppearance: "none",
    WebkitAppearance: "none",
    textDecoration: "none",
    color: "inherit",
    "&::-moz-focus-inner": { borderStyle: "none" },
    [`&.${W9.disabled}`]: { pointerEvents: "none", cursor: "default" },
    "@media print": { colorAdjust: "exact" },
  }),
  Wm = N.forwardRef(function (e, n) {
    const r = ft({ props: e, name: "MuiButtonBase" }),
      {
        action: i,
        centerRipple: s = !1,
        children: o,
        className: a,
        component: l = "button",
        disabled: d = !1,
        disableRipple: p = !1,
        disableTouchRipple: f = !1,
        focusRipple: m = !1,
        focusVisibleClassName: y,
        LinkComponent: g = "a",
        onBlur: v,
        onClick: b,
        onContextMenu: E,
        onDragLeave: S,
        onFocus: C,
        onFocusVisible: _,
        onKeyDown: A,
        onKeyUp: I,
        onMouseDown: R,
        onMouseLeave: D,
        onMouseUp: k,
        onTouchEnd: T,
        onTouchMove: U,
        onTouchStart: q,
        tabIndex: K = 0,
        TouchRippleProps: H,
        touchRippleRef: $,
        type: M,
        ...z
      } = r,
      B = N.useRef(null),
      j = O9(),
      V = In(j.ref, $),
      [W, Z] = N.useState(!1);
    d && W && Z(!1),
      N.useImperativeHandle(
        i,
        () => ({
          focusVisible: () => {
            Z(!0), B.current.focus();
          },
        }),
        []
      );
    const ee = j.shouldMount && !p && !d;
    N.useEffect(() => {
      W && m && !p && j.pulsate();
    }, [p, m, W, j]);
    const J = Zo(j, "start", R, f),
      se = Zo(j, "stop", E, f),
      re = Zo(j, "stop", S, f),
      fe = Zo(j, "stop", k, f),
      ce = Zo(
        j,
        "stop",
        (Le) => {
          W && Le.preventDefault(), D && D(Le);
        },
        f
      ),
      le = Zo(j, "start", q, f),
      Se = Zo(j, "stop", T, f),
      je = Zo(j, "stop", U, f),
      Pe = Zo(
        j,
        "stop",
        (Le) => {
          tw(Le.target) || Z(!1), v && v(Le);
        },
        !1
      ),
      We = Ks((Le) => {
        B.current || (B.current = Le.currentTarget),
          tw(Le.target) && (Z(!0), _ && _(Le)),
          C && C(Le);
      }),
      Ne = () => {
        const Le = B.current;
        return l && l !== "button" && !(Le.tagName === "A" && Le.href);
      },
      pt = Ks((Le) => {
        m &&
          !Le.repeat &&
          W &&
          Le.key === " " &&
          j.stop(Le, () => {
            j.start(Le);
          }),
          Le.target === Le.currentTarget &&
            Ne() &&
            Le.key === " " &&
            Le.preventDefault(),
          A && A(Le),
          Le.target === Le.currentTarget &&
            Ne() &&
            Le.key === "Enter" &&
            !d &&
            (Le.preventDefault(), b && b(Le));
      }),
      hn = Ks((Le) => {
        m &&
          Le.key === " " &&
          W &&
          !Le.defaultPrevented &&
          j.stop(Le, () => {
            j.pulsate(Le);
          }),
          I && I(Le),
          b &&
            Le.target === Le.currentTarget &&
            Ne() &&
            Le.key === " " &&
            !Le.defaultPrevented &&
            b(Le);
      });
    let Wt = l;
    Wt === "button" && (z.href || z.to) && (Wt = g);
    const Lt = {};
    Wt === "button"
      ? ((Lt.type = M === void 0 ? "button" : M), (Lt.disabled = d))
      : (!z.href && !z.to && (Lt.role = "button"),
        d && (Lt["aria-disabled"] = d));
    const vn = In(n, B),
      At = {
        ...r,
        centerRipple: s,
        component: l,
        disabled: d,
        disableRipple: p,
        disableTouchRipple: f,
        focusRipple: m,
        tabIndex: K,
        focusVisible: W,
      },
      vt = H9(At);
    return O.jsxs(q9, {
      as: Wt,
      className: He(vt.root, a),
      ownerState: At,
      onBlur: Pe,
      onClick: b,
      onContextMenu: se,
      onFocus: We,
      onKeyDown: pt,
      onKeyUp: hn,
      onMouseDown: J,
      onMouseLeave: ce,
      onMouseUp: fe,
      onDragLeave: re,
      onTouchEnd: Se,
      onTouchMove: je,
      onTouchStart: le,
      ref: vn,
      tabIndex: d ? -1 : K,
      type: M,
      ...Lt,
      ...z,
      children: [o, ee ? O.jsx(F9, { ref: V, center: s, ...H }) : null],
    });
  });
function Zo(t, e, n, r = !1) {
  return Ks((i) => (n && n(i), r || t[e](i), !0));
}
function V9(t) {
  return st("MuiAccordionSummary", t);
}
const xd = ut("MuiAccordionSummary", [
    "root",
    "expanded",
    "focusVisible",
    "disabled",
    "gutters",
    "contentGutters",
    "content",
    "expandIconWrapper",
  ]),
  G9 = (t) => {
    const { classes: e, expanded: n, disabled: r, disableGutters: i } = t;
    return dt(
      {
        root: ["root", n && "expanded", r && "disabled", !i && "gutters"],
        focusVisible: ["focusVisible"],
        content: ["content", n && "expanded", !i && "contentGutters"],
        expandIconWrapper: ["expandIconWrapper", n && "expanded"],
      },
      V9,
      e
    );
  },
  K9 = Ce(Wm, {
    name: "MuiAccordionSummary",
    slot: "Root",
    overridesResolver: (t, e) => e.root,
  })(
    wt(({ theme: t }) => {
      const e = { duration: t.transitions.duration.shortest };
      return {
        display: "flex",
        width: "100%",
        minHeight: 48,
        padding: t.spacing(0, 2),
        transition: t.transitions.create(["min-height", "background-color"], e),
        [`&.${xd.focusVisible}`]: {
          backgroundColor: (t.vars || t).palette.action.focus,
        },
        [`&.${xd.disabled}`]: {
          opacity: (t.vars || t).palette.action.disabledOpacity,
        },
        [`&:hover:not(.${xd.disabled})`]: { cursor: "pointer" },
        variants: [
          {
            props: (n) => !n.disableGutters,
            style: { [`&.${xd.expanded}`]: { minHeight: 64 } },
          },
        ],
      };
    })
  ),
  Y9 = Ce("span", {
    name: "MuiAccordionSummary",
    slot: "Content",
    overridesResolver: (t, e) => e.content,
  })(
    wt(({ theme: t }) => ({
      display: "flex",
      textAlign: "start",
      flexGrow: 1,
      margin: "12px 0",
      variants: [
        {
          props: (e) => !e.disableGutters,
          style: {
            transition: t.transitions.create(["margin"], {
              duration: t.transitions.duration.shortest,
            }),
            [`&.${xd.expanded}`]: { margin: "20px 0" },
          },
        },
      ],
    }))
  ),
  Z9 = Ce("span", {
    name: "MuiAccordionSummary",
    slot: "ExpandIconWrapper",
    overridesResolver: (t, e) => e.expandIconWrapper,
  })(
    wt(({ theme: t }) => ({
      display: "flex",
      color: (t.vars || t).palette.action.active,
      transform: "rotate(0deg)",
      transition: t.transitions.create("transform", {
        duration: t.transitions.duration.shortest,
      }),
      [`&.${xd.expanded}`]: { transform: "rotate(180deg)" },
    }))
  ),
  Q9 = N.forwardRef(function (e, n) {
    const r = ft({ props: e, name: "MuiAccordionSummary" }),
      {
        children: i,
        className: s,
        expandIcon: o,
        focusVisibleClassName: a,
        onClick: l,
        ...d
      } = r,
      {
        disabled: p = !1,
        disableGutters: f,
        expanded: m,
        toggle: y,
      } = N.useContext(b3),
      g = (E) => {
        y && y(E), l && l(E);
      },
      v = { ...r, expanded: m, disabled: p, disableGutters: f },
      b = G9(v);
    return O.jsxs(K9, {
      focusRipple: !1,
      disableRipple: !0,
      disabled: p,
      "aria-expanded": m,
      className: He(b.root, s),
      focusVisibleClassName: He(b.focusVisible, a),
      onClick: g,
      ref: n,
      ownerState: v,
      ...d,
      children: [
        O.jsx(Y9, { className: b.content, ownerState: v, children: i }),
        o &&
          O.jsx(Z9, {
            className: b.expandIconWrapper,
            ownerState: v,
            children: o,
          }),
      ],
    });
  });
function X9(t) {
  return typeof t.main == "string";
}
function J9(t, e = []) {
  if (!X9(t)) return !1;
  for (const n of e)
    if (!t.hasOwnProperty(n) || typeof t[n] != "string") return !1;
  return !0;
}
function hs(t = []) {
  return ([, e]) => e && J9(e, t);
}
function ez(t) {
  return st("MuiAlert", t);
}
const YT = ut("MuiAlert", [
  "root",
  "action",
  "icon",
  "message",
  "filled",
  "colorSuccess",
  "colorInfo",
  "colorWarning",
  "colorError",
  "filledSuccess",
  "filledInfo",
  "filledWarning",
  "filledError",
  "outlined",
  "outlinedSuccess",
  "outlinedInfo",
  "outlinedWarning",
  "outlinedError",
  "standard",
  "standardSuccess",
  "standardInfo",
  "standardWarning",
  "standardError",
]);
function tz(t) {
  return st("MuiIconButton", t);
}
const nz = ut("MuiIconButton", [
    "root",
    "disabled",
    "colorInherit",
    "colorPrimary",
    "colorSecondary",
    "colorError",
    "colorInfo",
    "colorSuccess",
    "colorWarning",
    "edgeStart",
    "edgeEnd",
    "sizeSmall",
    "sizeMedium",
    "sizeLarge",
  ]),
  rz = (t) => {
    const { classes: e, disabled: n, color: r, edge: i, size: s } = t,
      o = {
        root: [
          "root",
          n && "disabled",
          r !== "default" && `color${Re(r)}`,
          i && `edge${Re(i)}`,
          `size${Re(s)}`,
        ],
      };
    return dt(o, tz, e);
  },
  iz = Ce(Wm, {
    name: "MuiIconButton",
    slot: "Root",
    overridesResolver: (t, e) => {
      const { ownerState: n } = t;
      return [
        e.root,
        n.color !== "default" && e[`color${Re(n.color)}`],
        n.edge && e[`edge${Re(n.edge)}`],
        e[`size${Re(n.size)}`],
      ];
    },
  })(
    wt(({ theme: t }) => ({
      textAlign: "center",
      flex: "0 0 auto",
      fontSize: t.typography.pxToRem(24),
      padding: 8,
      borderRadius: "50%",
      color: (t.vars || t).palette.action.active,
      transition: t.transitions.create("background-color", {
        duration: t.transitions.duration.shortest,
      }),
      variants: [
        {
          props: (e) => !e.disableRipple,
          style: {
            "--IconButton-hoverBg": t.vars
              ? `rgba(${t.vars.palette.action.activeChannel} / ${t.vars.palette.action.hoverOpacity})`
              : An(t.palette.action.active, t.palette.action.hoverOpacity),
            "&:hover": {
              backgroundColor: "var(--IconButton-hoverBg)",
              "@media (hover: none)": { backgroundColor: "transparent" },
            },
          },
        },
        { props: { edge: "start" }, style: { marginLeft: -12 } },
        { props: { edge: "start", size: "small" }, style: { marginLeft: -3 } },
        { props: { edge: "end" }, style: { marginRight: -12 } },
        { props: { edge: "end", size: "small" }, style: { marginRight: -3 } },
      ],
    })),
    wt(({ theme: t }) => ({
      variants: [
        { props: { color: "inherit" }, style: { color: "inherit" } },
        ...Object.entries(t.palette)
          .filter(hs())
          .map(([e]) => ({
            props: { color: e },
            style: { color: (t.vars || t).palette[e].main },
          })),
        ...Object.entries(t.palette)
          .filter(hs())
          .map(([e]) => ({
            props: { color: e },
            style: {
              "--IconButton-hoverBg": t.vars
                ? `rgba(${(t.vars || t).palette[e].mainChannel} / ${
                    t.vars.palette.action.hoverOpacity
                  })`
                : An(
                    (t.vars || t).palette[e].main,
                    t.palette.action.hoverOpacity
                  ),
            },
          })),
        {
          props: { size: "small" },
          style: { padding: 5, fontSize: t.typography.pxToRem(18) },
        },
        {
          props: { size: "large" },
          style: { padding: 12, fontSize: t.typography.pxToRem(28) },
        },
      ],
      [`&.${nz.disabled}`]: {
        backgroundColor: "transparent",
        color: (t.vars || t).palette.action.disabled,
      },
    }))
  ),
  XS = N.forwardRef(function (e, n) {
    const r = ft({ props: e, name: "MuiIconButton" }),
      {
        edge: i = !1,
        children: s,
        className: o,
        color: a = "default",
        disabled: l = !1,
        disableFocusRipple: d = !1,
        size: p = "medium",
        ...f
      } = r,
      m = {
        ...r,
        edge: i,
        color: a,
        disabled: l,
        disableFocusRipple: d,
        size: p,
      },
      y = rz(m);
    return O.jsx(iz, {
      className: He(y.root, o),
      centerRipple: !0,
      focusRipple: !d,
      disabled: l,
      ref: n,
      ...f,
      ownerState: m,
      children: s,
    });
  }),
  sz = Ki(
    O.jsx("path", {
      d: "M20,12A8,8 0 0,1 12,20A8,8 0 0,1 4,12A8,8 0 0,1 12,4C12.76,4 13.5,4.11 14.2, 4.31L15.77,2.74C14.61,2.26 13.34,2 12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0, 0 22,12M7.91,10.08L6.5,11.5L11,16L21,6L19.59,4.58L11,13.17L7.91,10.08Z",
    }),
    "SuccessOutlined"
  ),
  oz = Ki(
    O.jsx("path", {
      d: "M12 5.99L19.53 19H4.47L12 5.99M12 2L1 21h22L12 2zm1 14h-2v2h2v-2zm0-6h-2v4h2v-4z",
    }),
    "ReportProblemOutlined"
  ),
  az = Ki(
    O.jsx("path", {
      d: "M11 15h2v2h-2zm0-8h2v6h-2zm.99-5C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2zM12 20c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8z",
    }),
    "ErrorOutline"
  ),
  cz = Ki(
    O.jsx("path", {
      d: "M11,9H13V7H11M12,20C7.59,20 4,16.41 4,12C4,7.59 7.59,4 12,4C16.41,4 20,7.59 20, 12C20,16.41 16.41,20 12,20M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10, 10 0 0,0 12,2M11,17H13V11H11V17Z",
    }),
    "InfoOutlined"
  ),
  lz = Ki(
    O.jsx("path", {
      d: "M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z",
    }),
    "Close"
  ),
  uz = (t) => {
    const { variant: e, color: n, severity: r, classes: i } = t,
      s = {
        root: ["root", `color${Re(n || r)}`, `${e}${Re(n || r)}`, `${e}`],
        icon: ["icon"],
        message: ["message"],
        action: ["action"],
      };
    return dt(s, ez, i);
  },
  dz = Ce(Vc, {
    name: "MuiAlert",
    slot: "Root",
    overridesResolver: (t, e) => {
      const { ownerState: n } = t;
      return [
        e.root,
        e[n.variant],
        e[`${n.variant}${Re(n.color || n.severity)}`],
      ];
    },
  })(
    wt(({ theme: t }) => {
      const e = t.palette.mode === "light" ? Dh : $h,
        n = t.palette.mode === "light" ? $h : Dh;
      return {
        ...t.typography.body2,
        backgroundColor: "transparent",
        display: "flex",
        padding: "6px 16px",
        variants: [
          ...Object.entries(t.palette)
            .filter(hs(["light"]))
            .map(([r]) => ({
              props: { colorSeverity: r, variant: "standard" },
              style: {
                color: t.vars
                  ? t.vars.palette.Alert[`${r}Color`]
                  : e(t.palette[r].light, 0.6),
                backgroundColor: t.vars
                  ? t.vars.palette.Alert[`${r}StandardBg`]
                  : n(t.palette[r].light, 0.9),
                [`& .${YT.icon}`]: t.vars
                  ? { color: t.vars.palette.Alert[`${r}IconColor`] }
                  : { color: t.palette[r].main },
              },
            })),
          ...Object.entries(t.palette)
            .filter(hs(["light"]))
            .map(([r]) => ({
              props: { colorSeverity: r, variant: "outlined" },
              style: {
                color: t.vars
                  ? t.vars.palette.Alert[`${r}Color`]
                  : e(t.palette[r].light, 0.6),
                border: `1px solid ${(t.vars || t).palette[r].light}`,
                [`& .${YT.icon}`]: t.vars
                  ? { color: t.vars.palette.Alert[`${r}IconColor`] }
                  : { color: t.palette[r].main },
              },
            })),
          ...Object.entries(t.palette)
            .filter(hs(["dark"]))
            .map(([r]) => ({
              props: { colorSeverity: r, variant: "filled" },
              style: {
                fontWeight: t.typography.fontWeightMedium,
                ...(t.vars
                  ? {
                      color: t.vars.palette.Alert[`${r}FilledColor`],
                      backgroundColor: t.vars.palette.Alert[`${r}FilledBg`],
                    }
                  : {
                      backgroundColor:
                        t.palette.mode === "dark"
                          ? t.palette[r].dark
                          : t.palette[r].main,
                      color: t.palette.getContrastText(t.palette[r].main),
                    }),
              },
            })),
        ],
      };
    })
  ),
  pz = Ce("div", {
    name: "MuiAlert",
    slot: "Icon",
    overridesResolver: (t, e) => e.icon,
  })({
    marginRight: 12,
    padding: "7px 0",
    display: "flex",
    fontSize: 22,
    opacity: 0.9,
  }),
  fz = Ce("div", {
    name: "MuiAlert",
    slot: "Message",
    overridesResolver: (t, e) => e.message,
  })({ padding: "8px 0", minWidth: 0, overflow: "auto" }),
  ZT = Ce("div", {
    name: "MuiAlert",
    slot: "Action",
    overridesResolver: (t, e) => e.action,
  })({
    display: "flex",
    alignItems: "flex-start",
    padding: "4px 0 0 16px",
    marginLeft: "auto",
    marginRight: -8,
  }),
  QT = {
    success: O.jsx(sz, { fontSize: "inherit" }),
    warning: O.jsx(oz, { fontSize: "inherit" }),
    error: O.jsx(az, { fontSize: "inherit" }),
    info: O.jsx(cz, { fontSize: "inherit" }),
  },
  hz = N.forwardRef(function (e, n) {
    const r = ft({ props: e, name: "MuiAlert" }),
      {
        action: i,
        children: s,
        className: o,
        closeText: a = "Close",
        color: l,
        components: d = {},
        componentsProps: p = {},
        icon: f,
        iconMapping: m = QT,
        onClose: y,
        role: g = "alert",
        severity: v = "success",
        slotProps: b = {},
        slots: E = {},
        variant: S = "standard",
        ...C
      } = r,
      _ = { ...r, color: l, severity: v, variant: S, colorSeverity: l || v },
      A = uz(_),
      I = {
        slots: { closeButton: d.CloseButton, closeIcon: d.CloseIcon, ...E },
        slotProps: { ...p, ...b },
      },
      [R, D] = Jn("closeButton", {
        elementType: XS,
        externalForwardedProps: I,
        ownerState: _,
      }),
      [k, T] = Jn("closeIcon", {
        elementType: lz,
        externalForwardedProps: I,
        ownerState: _,
      });
    return O.jsxs(dz, {
      role: g,
      elevation: 0,
      ownerState: _,
      className: He(A.root, o),
      ref: n,
      ...C,
      children: [
        f !== !1
          ? O.jsx(pz, {
              ownerState: _,
              className: A.icon,
              children: f || m[v] || QT[v],
            })
          : null,
        O.jsx(fz, { ownerState: _, className: A.message, children: s }),
        i != null
          ? O.jsx(ZT, { ownerState: _, className: A.action, children: i })
          : null,
        i == null && y
          ? O.jsx(ZT, {
              ownerState: _,
              className: A.action,
              children: O.jsx(R, {
                size: "small",
                "aria-label": a,
                title: a,
                color: "inherit",
                onClick: y,
                ...D,
                children: O.jsx(k, { fontSize: "small", ...T }),
              }),
            })
          : null,
      ],
    });
  });
function mz(t) {
  return st("MuiTypography", t);
}
ut("MuiTypography", [
  "root",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "subtitle1",
  "subtitle2",
  "body1",
  "body2",
  "inherit",
  "button",
  "caption",
  "overline",
  "alignLeft",
  "alignRight",
  "alignCenter",
  "alignJustify",
  "noWrap",
  "gutterBottom",
  "paragraph",
]);
const gz = {
    primary: !0,
    secondary: !0,
    error: !0,
    info: !0,
    success: !0,
    warning: !0,
    textPrimary: !0,
    textSecondary: !0,
    textDisabled: !0,
  },
  yz = i9(),
  wz = (t) => {
    const {
        align: e,
        gutterBottom: n,
        noWrap: r,
        paragraph: i,
        variant: s,
        classes: o,
      } = t,
      a = {
        root: [
          "root",
          s,
          t.align !== "inherit" && `align${Re(e)}`,
          n && "gutterBottom",
          r && "noWrap",
          i && "paragraph",
        ],
      };
    return dt(a, mz, o);
  },
  vz = Ce("span", {
    name: "MuiTypography",
    slot: "Root",
    overridesResolver: (t, e) => {
      const { ownerState: n } = t;
      return [
        e.root,
        n.variant && e[n.variant],
        n.align !== "inherit" && e[`align${Re(n.align)}`],
        n.noWrap && e.noWrap,
        n.gutterBottom && e.gutterBottom,
        n.paragraph && e.paragraph,
      ];
    },
  })(
    wt(({ theme: t }) => {
      var e;
      return {
        margin: 0,
        variants: [
          {
            props: { variant: "inherit" },
            style: {
              font: "inherit",
              lineHeight: "inherit",
              letterSpacing: "inherit",
            },
          },
          ...Object.entries(t.typography)
            .filter(([n, r]) => n !== "inherit" && r && typeof r == "object")
            .map(([n, r]) => ({ props: { variant: n }, style: r })),
          ...Object.entries(t.palette)
            .filter(hs())
            .map(([n]) => ({
              props: { color: n },
              style: { color: (t.vars || t).palette[n].main },
            })),
          ...Object.entries(((e = t.palette) == null ? void 0 : e.text) || {})
            .filter(([, n]) => typeof n == "string")
            .map(([n]) => ({
              props: { color: `text${Re(n)}` },
              style: { color: (t.vars || t).palette.text[n] },
            })),
          {
            props: ({ ownerState: n }) => n.align !== "inherit",
            style: { textAlign: "var(--Typography-textAlign)" },
          },
          {
            props: ({ ownerState: n }) => n.noWrap,
            style: {
              overflow: "hidden",
              textOverflow: "ellipsis",
              whiteSpace: "nowrap",
            },
          },
          {
            props: ({ ownerState: n }) => n.gutterBottom,
            style: { marginBottom: "0.35em" },
          },
          {
            props: ({ ownerState: n }) => n.paragraph,
            style: { marginBottom: 16 },
          },
        ],
      };
    })
  ),
  XT = {
    h1: "h1",
    h2: "h2",
    h3: "h3",
    h4: "h4",
    h5: "h5",
    h6: "h6",
    subtitle1: "h6",
    subtitle2: "h6",
    body1: "p",
    body2: "p",
    inherit: "p",
  },
  Ft = N.forwardRef(function (e, n) {
    const { color: r, ...i } = ft({ props: e, name: "MuiTypography" }),
      s = !gz[r],
      o = yz({ ...i, ...(s && { color: r }) }),
      {
        align: a = "inherit",
        className: l,
        component: d,
        gutterBottom: p = !1,
        noWrap: f = !1,
        paragraph: m = !1,
        variant: y = "body1",
        variantMapping: g = XT,
        ...v
      } = o,
      b = {
        ...o,
        align: a,
        color: r,
        className: l,
        component: d,
        gutterBottom: p,
        noWrap: f,
        paragraph: m,
        variant: y,
        variantMapping: g,
      },
      E = d || (m ? "p" : g[y] || XT[y]) || "span",
      S = wz(b);
    return O.jsx(vz, {
      as: E,
      ref: n,
      className: He(S.root, l),
      ...v,
      ownerState: b,
      style: {
        ...(a !== "inherit" && { "--Typography-textAlign": a }),
        ...v.style,
      },
    });
  });
var Ei = "top",
  vs = "bottom",
  bs = "right",
  Ci = "left",
  JS = "auto",
  Hm = [Ei, vs, bs, Ci],
  Kd = "start",
  Mh = "end",
  bz = "clippingParents",
  E3 = "viewport",
  _f = "popper",
  Ez = "reference",
  JT = Hm.reduce(function (t, e) {
    return t.concat([e + "-" + Kd, e + "-" + Mh]);
  }, []),
  C3 = [].concat(Hm, [JS]).reduce(function (t, e) {
    return t.concat([e, e + "-" + Kd, e + "-" + Mh]);
  }, []),
  Cz = "beforeRead",
  xz = "read",
  Sz = "afterRead",
  Az = "beforeMain",
  _z = "main",
  Iz = "afterMain",
  Tz = "beforeWrite",
  Pz = "write",
  Rz = "afterWrite",
  Nz = [Cz, xz, Sz, Az, _z, Iz, Tz, Pz, Rz];
function No(t) {
  return t ? (t.nodeName || "").toLowerCase() : null;
}
function qi(t) {
  if (t == null) return window;
  if (t.toString() !== "[object Window]") {
    var e = t.ownerDocument;
    return (e && e.defaultView) || window;
  }
  return t;
}
function Gl(t) {
  var e = qi(t).Element;
  return t instanceof e || t instanceof Element;
}
function ms(t) {
  var e = qi(t).HTMLElement;
  return t instanceof e || t instanceof HTMLElement;
}
function eA(t) {
  if (typeof ShadowRoot > "u") return !1;
  var e = qi(t).ShadowRoot;
  return t instanceof e || t instanceof ShadowRoot;
}
function Oz(t) {
  var e = t.state;
  Object.keys(e.elements).forEach(function (n) {
    var r = e.styles[n] || {},
      i = e.attributes[n] || {},
      s = e.elements[n];
    !ms(s) ||
      !No(s) ||
      (Object.assign(s.style, r),
      Object.keys(i).forEach(function (o) {
        var a = i[o];
        a === !1 ? s.removeAttribute(o) : s.setAttribute(o, a === !0 ? "" : a);
      }));
  });
}
function kz(t) {
  var e = t.state,
    n = {
      popper: {
        position: e.options.strategy,
        left: "0",
        top: "0",
        margin: "0",
      },
      arrow: { position: "absolute" },
      reference: {},
    };
  return (
    Object.assign(e.elements.popper.style, n.popper),
    (e.styles = n),
    e.elements.arrow && Object.assign(e.elements.arrow.style, n.arrow),
    function () {
      Object.keys(e.elements).forEach(function (r) {
        var i = e.elements[r],
          s = e.attributes[r] || {},
          o = Object.keys(e.styles.hasOwnProperty(r) ? e.styles[r] : n[r]),
          a = o.reduce(function (l, d) {
            return (l[d] = ""), l;
          }, {});
        !ms(i) ||
          !No(i) ||
          (Object.assign(i.style, a),
          Object.keys(s).forEach(function (l) {
            i.removeAttribute(l);
          }));
      });
    }
  );
}
const Dz = {
  name: "applyStyles",
  enabled: !0,
  phase: "write",
  fn: Oz,
  effect: kz,
  requires: ["computeStyles"],
};
function To(t) {
  return t.split("-")[0];
}
var jl = Math.max,
  aw = Math.min,
  Yd = Math.round;
function nx() {
  var t = navigator.userAgentData;
  return t != null && t.brands && Array.isArray(t.brands)
    ? t.brands
        .map(function (e) {
          return e.brand + "/" + e.version;
        })
        .join(" ")
    : navigator.userAgent;
}
function x3() {
  return !/^((?!chrome|android).)*safari/i.test(nx());
}
function Zd(t, e, n) {
  e === void 0 && (e = !1), n === void 0 && (n = !1);
  var r = t.getBoundingClientRect(),
    i = 1,
    s = 1;
  e &&
    ms(t) &&
    ((i = (t.offsetWidth > 0 && Yd(r.width) / t.offsetWidth) || 1),
    (s = (t.offsetHeight > 0 && Yd(r.height) / t.offsetHeight) || 1));
  var o = Gl(t) ? qi(t) : window,
    a = o.visualViewport,
    l = !x3() && n,
    d = (r.left + (l && a ? a.offsetLeft : 0)) / i,
    p = (r.top + (l && a ? a.offsetTop : 0)) / s,
    f = r.width / i,
    m = r.height / s;
  return {
    width: f,
    height: m,
    top: p,
    right: d + f,
    bottom: p + m,
    left: d,
    x: d,
    y: p,
  };
}
function tA(t) {
  var e = Zd(t),
    n = t.offsetWidth,
    r = t.offsetHeight;
  return (
    Math.abs(e.width - n) <= 1 && (n = e.width),
    Math.abs(e.height - r) <= 1 && (r = e.height),
    { x: t.offsetLeft, y: t.offsetTop, width: n, height: r }
  );
}
function S3(t, e) {
  var n = e.getRootNode && e.getRootNode();
  if (t.contains(e)) return !0;
  if (n && eA(n)) {
    var r = e;
    do {
      if (r && t.isSameNode(r)) return !0;
      r = r.parentNode || r.host;
    } while (r);
  }
  return !1;
}
function Sa(t) {
  return qi(t).getComputedStyle(t);
}
function $z(t) {
  return ["table", "td", "th"].indexOf(No(t)) >= 0;
}
function Gc(t) {
  return ((Gl(t) ? t.ownerDocument : t.document) || window.document)
    .documentElement;
}
function lv(t) {
  return No(t) === "html"
    ? t
    : t.assignedSlot || t.parentNode || (eA(t) ? t.host : null) || Gc(t);
}
function eP(t) {
  return !ms(t) || Sa(t).position === "fixed" ? null : t.offsetParent;
}
function Mz(t) {
  var e = /firefox/i.test(nx()),
    n = /Trident/i.test(nx());
  if (n && ms(t)) {
    var r = Sa(t);
    if (r.position === "fixed") return null;
  }
  var i = lv(t);
  for (eA(i) && (i = i.host); ms(i) && ["html", "body"].indexOf(No(i)) < 0; ) {
    var s = Sa(i);
    if (
      s.transform !== "none" ||
      s.perspective !== "none" ||
      s.contain === "paint" ||
      ["transform", "perspective"].indexOf(s.willChange) !== -1 ||
      (e && s.willChange === "filter") ||
      (e && s.filter && s.filter !== "none")
    )
      return i;
    i = i.parentNode;
  }
  return null;
}
function qm(t) {
  for (var e = qi(t), n = eP(t); n && $z(n) && Sa(n).position === "static"; )
    n = eP(n);
  return n &&
    (No(n) === "html" || (No(n) === "body" && Sa(n).position === "static"))
    ? e
    : n || Mz(t) || e;
}
function nA(t) {
  return ["top", "bottom"].indexOf(t) >= 0 ? "x" : "y";
}
function fh(t, e, n) {
  return jl(t, aw(e, n));
}
function Lz(t, e, n) {
  var r = fh(t, e, n);
  return r > n ? n : r;
}
function A3() {
  return { top: 0, right: 0, bottom: 0, left: 0 };
}
function _3(t) {
  return Object.assign({}, A3(), t);
}
function I3(t, e) {
  return e.reduce(function (n, r) {
    return (n[r] = t), n;
  }, {});
}
var Uz = function (e, n) {
  return (
    (e =
      typeof e == "function"
        ? e(Object.assign({}, n.rects, { placement: n.placement }))
        : e),
    _3(typeof e != "number" ? e : I3(e, Hm))
  );
};
function Bz(t) {
  var e,
    n = t.state,
    r = t.name,
    i = t.options,
    s = n.elements.arrow,
    o = n.modifiersData.popperOffsets,
    a = To(n.placement),
    l = nA(a),
    d = [Ci, bs].indexOf(a) >= 0,
    p = d ? "height" : "width";
  if (!(!s || !o)) {
    var f = Uz(i.padding, n),
      m = tA(s),
      y = l === "y" ? Ei : Ci,
      g = l === "y" ? vs : bs,
      v =
        n.rects.reference[p] + n.rects.reference[l] - o[l] - n.rects.popper[p],
      b = o[l] - n.rects.reference[l],
      E = qm(s),
      S = E ? (l === "y" ? E.clientHeight || 0 : E.clientWidth || 0) : 0,
      C = v / 2 - b / 2,
      _ = f[y],
      A = S - m[p] - f[g],
      I = S / 2 - m[p] / 2 + C,
      R = fh(_, I, A),
      D = l;
    n.modifiersData[r] = ((e = {}), (e[D] = R), (e.centerOffset = R - I), e);
  }
}
function jz(t) {
  var e = t.state,
    n = t.options,
    r = n.element,
    i = r === void 0 ? "[data-popper-arrow]" : r;
  i != null &&
    ((typeof i == "string" && ((i = e.elements.popper.querySelector(i)), !i)) ||
      (S3(e.elements.popper, i) && (e.elements.arrow = i)));
}
const Fz = {
  name: "arrow",
  enabled: !0,
  phase: "main",
  fn: Bz,
  effect: jz,
  requires: ["popperOffsets"],
  requiresIfExists: ["preventOverflow"],
};
function Qd(t) {
  return t.split("-")[1];
}
var zz = { top: "auto", right: "auto", bottom: "auto", left: "auto" };
function Wz(t, e) {
  var n = t.x,
    r = t.y,
    i = e.devicePixelRatio || 1;
  return { x: Yd(n * i) / i || 0, y: Yd(r * i) / i || 0 };
}
function tP(t) {
  var e,
    n = t.popper,
    r = t.popperRect,
    i = t.placement,
    s = t.variation,
    o = t.offsets,
    a = t.position,
    l = t.gpuAcceleration,
    d = t.adaptive,
    p = t.roundOffsets,
    f = t.isFixed,
    m = o.x,
    y = m === void 0 ? 0 : m,
    g = o.y,
    v = g === void 0 ? 0 : g,
    b = typeof p == "function" ? p({ x: y, y: v }) : { x: y, y: v };
  (y = b.x), (v = b.y);
  var E = o.hasOwnProperty("x"),
    S = o.hasOwnProperty("y"),
    C = Ci,
    _ = Ei,
    A = window;
  if (d) {
    var I = qm(n),
      R = "clientHeight",
      D = "clientWidth";
    if (
      (I === qi(n) &&
        ((I = Gc(n)),
        Sa(I).position !== "static" &&
          a === "absolute" &&
          ((R = "scrollHeight"), (D = "scrollWidth"))),
      (I = I),
      i === Ei || ((i === Ci || i === bs) && s === Mh))
    ) {
      _ = vs;
      var k = f && I === A && A.visualViewport ? A.visualViewport.height : I[R];
      (v -= k - r.height), (v *= l ? 1 : -1);
    }
    if (i === Ci || ((i === Ei || i === vs) && s === Mh)) {
      C = bs;
      var T = f && I === A && A.visualViewport ? A.visualViewport.width : I[D];
      (y -= T - r.width), (y *= l ? 1 : -1);
    }
  }
  var U = Object.assign({ position: a }, d && zz),
    q = p === !0 ? Wz({ x: y, y: v }, qi(n)) : { x: y, y: v };
  if (((y = q.x), (v = q.y), l)) {
    var K;
    return Object.assign(
      {},
      U,
      ((K = {}),
      (K[_] = S ? "0" : ""),
      (K[C] = E ? "0" : ""),
      (K.transform =
        (A.devicePixelRatio || 1) <= 1
          ? "translate(" + y + "px, " + v + "px)"
          : "translate3d(" + y + "px, " + v + "px, 0)"),
      K)
    );
  }
  return Object.assign(
    {},
    U,
    ((e = {}),
    (e[_] = S ? v + "px" : ""),
    (e[C] = E ? y + "px" : ""),
    (e.transform = ""),
    e)
  );
}
function Hz(t) {
  var e = t.state,
    n = t.options,
    r = n.gpuAcceleration,
    i = r === void 0 ? !0 : r,
    s = n.adaptive,
    o = s === void 0 ? !0 : s,
    a = n.roundOffsets,
    l = a === void 0 ? !0 : a,
    d = {
      placement: To(e.placement),
      variation: Qd(e.placement),
      popper: e.elements.popper,
      popperRect: e.rects.popper,
      gpuAcceleration: i,
      isFixed: e.options.strategy === "fixed",
    };
  e.modifiersData.popperOffsets != null &&
    (e.styles.popper = Object.assign(
      {},
      e.styles.popper,
      tP(
        Object.assign({}, d, {
          offsets: e.modifiersData.popperOffsets,
          position: e.options.strategy,
          adaptive: o,
          roundOffsets: l,
        })
      )
    )),
    e.modifiersData.arrow != null &&
      (e.styles.arrow = Object.assign(
        {},
        e.styles.arrow,
        tP(
          Object.assign({}, d, {
            offsets: e.modifiersData.arrow,
            position: "absolute",
            adaptive: !1,
            roundOffsets: l,
          })
        )
      )),
    (e.attributes.popper = Object.assign({}, e.attributes.popper, {
      "data-popper-placement": e.placement,
    }));
}
const qz = {
  name: "computeStyles",
  enabled: !0,
  phase: "beforeWrite",
  fn: Hz,
  data: {},
};
var Ly = { passive: !0 };
function Vz(t) {
  var e = t.state,
    n = t.instance,
    r = t.options,
    i = r.scroll,
    s = i === void 0 ? !0 : i,
    o = r.resize,
    a = o === void 0 ? !0 : o,
    l = qi(e.elements.popper),
    d = [].concat(e.scrollParents.reference, e.scrollParents.popper);
  return (
    s &&
      d.forEach(function (p) {
        p.addEventListener("scroll", n.update, Ly);
      }),
    a && l.addEventListener("resize", n.update, Ly),
    function () {
      s &&
        d.forEach(function (p) {
          p.removeEventListener("scroll", n.update, Ly);
        }),
        a && l.removeEventListener("resize", n.update, Ly);
    }
  );
}
const Gz = {
  name: "eventListeners",
  enabled: !0,
  phase: "write",
  fn: function () {},
  effect: Vz,
  data: {},
};
var Kz = { left: "right", right: "left", bottom: "top", top: "bottom" };
function N0(t) {
  return t.replace(/left|right|bottom|top/g, function (e) {
    return Kz[e];
  });
}
var Yz = { start: "end", end: "start" };
function nP(t) {
  return t.replace(/start|end/g, function (e) {
    return Yz[e];
  });
}
function rA(t) {
  var e = qi(t),
    n = e.pageXOffset,
    r = e.pageYOffset;
  return { scrollLeft: n, scrollTop: r };
}
function iA(t) {
  return Zd(Gc(t)).left + rA(t).scrollLeft;
}
function Zz(t, e) {
  var n = qi(t),
    r = Gc(t),
    i = n.visualViewport,
    s = r.clientWidth,
    o = r.clientHeight,
    a = 0,
    l = 0;
  if (i) {
    (s = i.width), (o = i.height);
    var d = x3();
    (d || (!d && e === "fixed")) && ((a = i.offsetLeft), (l = i.offsetTop));
  }
  return { width: s, height: o, x: a + iA(t), y: l };
}
function Qz(t) {
  var e,
    n = Gc(t),
    r = rA(t),
    i = (e = t.ownerDocument) == null ? void 0 : e.body,
    s = jl(
      n.scrollWidth,
      n.clientWidth,
      i ? i.scrollWidth : 0,
      i ? i.clientWidth : 0
    ),
    o = jl(
      n.scrollHeight,
      n.clientHeight,
      i ? i.scrollHeight : 0,
      i ? i.clientHeight : 0
    ),
    a = -r.scrollLeft + iA(t),
    l = -r.scrollTop;
  return (
    Sa(i || n).direction === "rtl" &&
      (a += jl(n.clientWidth, i ? i.clientWidth : 0) - s),
    { width: s, height: o, x: a, y: l }
  );
}
function sA(t) {
  var e = Sa(t),
    n = e.overflow,
    r = e.overflowX,
    i = e.overflowY;
  return /auto|scroll|overlay|hidden/.test(n + i + r);
}
function T3(t) {
  return ["html", "body", "#document"].indexOf(No(t)) >= 0
    ? t.ownerDocument.body
    : ms(t) && sA(t)
    ? t
    : T3(lv(t));
}
function hh(t, e) {
  var n;
  e === void 0 && (e = []);
  var r = T3(t),
    i = r === ((n = t.ownerDocument) == null ? void 0 : n.body),
    s = qi(r),
    o = i ? [s].concat(s.visualViewport || [], sA(r) ? r : []) : r,
    a = e.concat(o);
  return i ? a : a.concat(hh(lv(o)));
}
function rx(t) {
  return Object.assign({}, t, {
    left: t.x,
    top: t.y,
    right: t.x + t.width,
    bottom: t.y + t.height,
  });
}
function Xz(t, e) {
  var n = Zd(t, !1, e === "fixed");
  return (
    (n.top = n.top + t.clientTop),
    (n.left = n.left + t.clientLeft),
    (n.bottom = n.top + t.clientHeight),
    (n.right = n.left + t.clientWidth),
    (n.width = t.clientWidth),
    (n.height = t.clientHeight),
    (n.x = n.left),
    (n.y = n.top),
    n
  );
}
function rP(t, e, n) {
  return e === E3 ? rx(Zz(t, n)) : Gl(e) ? Xz(e, n) : rx(Qz(Gc(t)));
}
function Jz(t) {
  var e = hh(lv(t)),
    n = ["absolute", "fixed"].indexOf(Sa(t).position) >= 0,
    r = n && ms(t) ? qm(t) : t;
  return Gl(r)
    ? e.filter(function (i) {
        return Gl(i) && S3(i, r) && No(i) !== "body";
      })
    : [];
}
function e7(t, e, n, r) {
  var i = e === "clippingParents" ? Jz(t) : [].concat(e),
    s = [].concat(i, [n]),
    o = s[0],
    a = s.reduce(function (l, d) {
      var p = rP(t, d, r);
      return (
        (l.top = jl(p.top, l.top)),
        (l.right = aw(p.right, l.right)),
        (l.bottom = aw(p.bottom, l.bottom)),
        (l.left = jl(p.left, l.left)),
        l
      );
    }, rP(t, o, r));
  return (
    (a.width = a.right - a.left),
    (a.height = a.bottom - a.top),
    (a.x = a.left),
    (a.y = a.top),
    a
  );
}
function P3(t) {
  var e = t.reference,
    n = t.element,
    r = t.placement,
    i = r ? To(r) : null,
    s = r ? Qd(r) : null,
    o = e.x + e.width / 2 - n.width / 2,
    a = e.y + e.height / 2 - n.height / 2,
    l;
  switch (i) {
    case Ei:
      l = { x: o, y: e.y - n.height };
      break;
    case vs:
      l = { x: o, y: e.y + e.height };
      break;
    case bs:
      l = { x: e.x + e.width, y: a };
      break;
    case Ci:
      l = { x: e.x - n.width, y: a };
      break;
    default:
      l = { x: e.x, y: e.y };
  }
  var d = i ? nA(i) : null;
  if (d != null) {
    var p = d === "y" ? "height" : "width";
    switch (s) {
      case Kd:
        l[d] = l[d] - (e[p] / 2 - n[p] / 2);
        break;
      case Mh:
        l[d] = l[d] + (e[p] / 2 - n[p] / 2);
        break;
    }
  }
  return l;
}
function Lh(t, e) {
  e === void 0 && (e = {});
  var n = e,
    r = n.placement,
    i = r === void 0 ? t.placement : r,
    s = n.strategy,
    o = s === void 0 ? t.strategy : s,
    a = n.boundary,
    l = a === void 0 ? bz : a,
    d = n.rootBoundary,
    p = d === void 0 ? E3 : d,
    f = n.elementContext,
    m = f === void 0 ? _f : f,
    y = n.altBoundary,
    g = y === void 0 ? !1 : y,
    v = n.padding,
    b = v === void 0 ? 0 : v,
    E = _3(typeof b != "number" ? b : I3(b, Hm)),
    S = m === _f ? Ez : _f,
    C = t.rects.popper,
    _ = t.elements[g ? S : m],
    A = e7(Gl(_) ? _ : _.contextElement || Gc(t.elements.popper), l, p, o),
    I = Zd(t.elements.reference),
    R = P3({ reference: I, element: C, strategy: "absolute", placement: i }),
    D = rx(Object.assign({}, C, R)),
    k = m === _f ? D : I,
    T = {
      top: A.top - k.top + E.top,
      bottom: k.bottom - A.bottom + E.bottom,
      left: A.left - k.left + E.left,
      right: k.right - A.right + E.right,
    },
    U = t.modifiersData.offset;
  if (m === _f && U) {
    var q = U[i];
    Object.keys(T).forEach(function (K) {
      var H = [bs, vs].indexOf(K) >= 0 ? 1 : -1,
        $ = [Ei, vs].indexOf(K) >= 0 ? "y" : "x";
      T[K] += q[$] * H;
    });
  }
  return T;
}
function t7(t, e) {
  e === void 0 && (e = {});
  var n = e,
    r = n.placement,
    i = n.boundary,
    s = n.rootBoundary,
    o = n.padding,
    a = n.flipVariations,
    l = n.allowedAutoPlacements,
    d = l === void 0 ? C3 : l,
    p = Qd(r),
    f = p
      ? a
        ? JT
        : JT.filter(function (g) {
            return Qd(g) === p;
          })
      : Hm,
    m = f.filter(function (g) {
      return d.indexOf(g) >= 0;
    });
  m.length === 0 && (m = f);
  var y = m.reduce(function (g, v) {
    return (
      (g[v] = Lh(t, { placement: v, boundary: i, rootBoundary: s, padding: o })[
        To(v)
      ]),
      g
    );
  }, {});
  return Object.keys(y).sort(function (g, v) {
    return y[g] - y[v];
  });
}
function n7(t) {
  if (To(t) === JS) return [];
  var e = N0(t);
  return [nP(t), e, nP(e)];
}
function r7(t) {
  var e = t.state,
    n = t.options,
    r = t.name;
  if (!e.modifiersData[r]._skip) {
    for (
      var i = n.mainAxis,
        s = i === void 0 ? !0 : i,
        o = n.altAxis,
        a = o === void 0 ? !0 : o,
        l = n.fallbackPlacements,
        d = n.padding,
        p = n.boundary,
        f = n.rootBoundary,
        m = n.altBoundary,
        y = n.flipVariations,
        g = y === void 0 ? !0 : y,
        v = n.allowedAutoPlacements,
        b = e.options.placement,
        E = To(b),
        S = E === b,
        C = l || (S || !g ? [N0(b)] : n7(b)),
        _ = [b].concat(C).reduce(function (J, se) {
          return J.concat(
            To(se) === JS
              ? t7(e, {
                  placement: se,
                  boundary: p,
                  rootBoundary: f,
                  padding: d,
                  flipVariations: g,
                  allowedAutoPlacements: v,
                })
              : se
          );
        }, []),
        A = e.rects.reference,
        I = e.rects.popper,
        R = new Map(),
        D = !0,
        k = _[0],
        T = 0;
      T < _.length;
      T++
    ) {
      var U = _[T],
        q = To(U),
        K = Qd(U) === Kd,
        H = [Ei, vs].indexOf(q) >= 0,
        $ = H ? "width" : "height",
        M = Lh(e, {
          placement: U,
          boundary: p,
          rootBoundary: f,
          altBoundary: m,
          padding: d,
        }),
        z = H ? (K ? bs : Ci) : K ? vs : Ei;
      A[$] > I[$] && (z = N0(z));
      var B = N0(z),
        j = [];
      if (
        (s && j.push(M[q] <= 0),
        a && j.push(M[z] <= 0, M[B] <= 0),
        j.every(function (J) {
          return J;
        }))
      ) {
        (k = U), (D = !1);
        break;
      }
      R.set(U, j);
    }
    if (D)
      for (
        var V = g ? 3 : 1,
          W = function (se) {
            var re = _.find(function (fe) {
              var ce = R.get(fe);
              if (ce)
                return ce.slice(0, se).every(function (le) {
                  return le;
                });
            });
            if (re) return (k = re), "break";
          },
          Z = V;
        Z > 0;
        Z--
      ) {
        var ee = W(Z);
        if (ee === "break") break;
      }
    e.placement !== k &&
      ((e.modifiersData[r]._skip = !0), (e.placement = k), (e.reset = !0));
  }
}
const i7 = {
  name: "flip",
  enabled: !0,
  phase: "main",
  fn: r7,
  requiresIfExists: ["offset"],
  data: { _skip: !1 },
};
function iP(t, e, n) {
  return (
    n === void 0 && (n = { x: 0, y: 0 }),
    {
      top: t.top - e.height - n.y,
      right: t.right - e.width + n.x,
      bottom: t.bottom - e.height + n.y,
      left: t.left - e.width - n.x,
    }
  );
}
function sP(t) {
  return [Ei, bs, vs, Ci].some(function (e) {
    return t[e] >= 0;
  });
}
function s7(t) {
  var e = t.state,
    n = t.name,
    r = e.rects.reference,
    i = e.rects.popper,
    s = e.modifiersData.preventOverflow,
    o = Lh(e, { elementContext: "reference" }),
    a = Lh(e, { altBoundary: !0 }),
    l = iP(o, r),
    d = iP(a, i, s),
    p = sP(l),
    f = sP(d);
  (e.modifiersData[n] = {
    referenceClippingOffsets: l,
    popperEscapeOffsets: d,
    isReferenceHidden: p,
    hasPopperEscaped: f,
  }),
    (e.attributes.popper = Object.assign({}, e.attributes.popper, {
      "data-popper-reference-hidden": p,
      "data-popper-escaped": f,
    }));
}
const o7 = {
  name: "hide",
  enabled: !0,
  phase: "main",
  requiresIfExists: ["preventOverflow"],
  fn: s7,
};
function a7(t, e, n) {
  var r = To(t),
    i = [Ci, Ei].indexOf(r) >= 0 ? -1 : 1,
    s = typeof n == "function" ? n(Object.assign({}, e, { placement: t })) : n,
    o = s[0],
    a = s[1];
  return (
    (o = o || 0),
    (a = (a || 0) * i),
    [Ci, bs].indexOf(r) >= 0 ? { x: a, y: o } : { x: o, y: a }
  );
}
function c7(t) {
  var e = t.state,
    n = t.options,
    r = t.name,
    i = n.offset,
    s = i === void 0 ? [0, 0] : i,
    o = C3.reduce(function (p, f) {
      return (p[f] = a7(f, e.rects, s)), p;
    }, {}),
    a = o[e.placement],
    l = a.x,
    d = a.y;
  e.modifiersData.popperOffsets != null &&
    ((e.modifiersData.popperOffsets.x += l),
    (e.modifiersData.popperOffsets.y += d)),
    (e.modifiersData[r] = o);
}
const l7 = {
  name: "offset",
  enabled: !0,
  phase: "main",
  requires: ["popperOffsets"],
  fn: c7,
};
function u7(t) {
  var e = t.state,
    n = t.name;
  e.modifiersData[n] = P3({
    reference: e.rects.reference,
    element: e.rects.popper,
    strategy: "absolute",
    placement: e.placement,
  });
}
const d7 = {
  name: "popperOffsets",
  enabled: !0,
  phase: "read",
  fn: u7,
  data: {},
};
function p7(t) {
  return t === "x" ? "y" : "x";
}
function f7(t) {
  var e = t.state,
    n = t.options,
    r = t.name,
    i = n.mainAxis,
    s = i === void 0 ? !0 : i,
    o = n.altAxis,
    a = o === void 0 ? !1 : o,
    l = n.boundary,
    d = n.rootBoundary,
    p = n.altBoundary,
    f = n.padding,
    m = n.tether,
    y = m === void 0 ? !0 : m,
    g = n.tetherOffset,
    v = g === void 0 ? 0 : g,
    b = Lh(e, { boundary: l, rootBoundary: d, padding: f, altBoundary: p }),
    E = To(e.placement),
    S = Qd(e.placement),
    C = !S,
    _ = nA(E),
    A = p7(_),
    I = e.modifiersData.popperOffsets,
    R = e.rects.reference,
    D = e.rects.popper,
    k =
      typeof v == "function"
        ? v(Object.assign({}, e.rects, { placement: e.placement }))
        : v,
    T =
      typeof k == "number"
        ? { mainAxis: k, altAxis: k }
        : Object.assign({ mainAxis: 0, altAxis: 0 }, k),
    U = e.modifiersData.offset ? e.modifiersData.offset[e.placement] : null,
    q = { x: 0, y: 0 };
  if (I) {
    if (s) {
      var K,
        H = _ === "y" ? Ei : Ci,
        $ = _ === "y" ? vs : bs,
        M = _ === "y" ? "height" : "width",
        z = I[_],
        B = z + b[H],
        j = z - b[$],
        V = y ? -D[M] / 2 : 0,
        W = S === Kd ? R[M] : D[M],
        Z = S === Kd ? -D[M] : -R[M],
        ee = e.elements.arrow,
        J = y && ee ? tA(ee) : { width: 0, height: 0 },
        se = e.modifiersData["arrow#persistent"]
          ? e.modifiersData["arrow#persistent"].padding
          : A3(),
        re = se[H],
        fe = se[$],
        ce = fh(0, R[M], J[M]),
        le = C ? R[M] / 2 - V - ce - re - T.mainAxis : W - ce - re - T.mainAxis,
        Se = C
          ? -R[M] / 2 + V + ce + fe + T.mainAxis
          : Z + ce + fe + T.mainAxis,
        je = e.elements.arrow && qm(e.elements.arrow),
        Pe = je ? (_ === "y" ? je.clientTop || 0 : je.clientLeft || 0) : 0,
        We = (K = U == null ? void 0 : U[_]) != null ? K : 0,
        Ne = z + le - We - Pe,
        pt = z + Se - We,
        hn = fh(y ? aw(B, Ne) : B, z, y ? jl(j, pt) : j);
      (I[_] = hn), (q[_] = hn - z);
    }
    if (a) {
      var Wt,
        Lt = _ === "x" ? Ei : Ci,
        vn = _ === "x" ? vs : bs,
        At = I[A],
        vt = A === "y" ? "height" : "width",
        Le = At + b[Lt],
        nr = At - b[vn],
        tn = [Ei, Ci].indexOf(E) !== -1,
        wr = (Wt = U == null ? void 0 : U[A]) != null ? Wt : 0,
        Dr = tn ? Le : At - R[vt] - D[vt] - wr + T.altAxis,
        rr = tn ? At + R[vt] + D[vt] - wr - T.altAxis : nr,
        ir = y && tn ? Lz(Dr, At, rr) : fh(y ? Dr : Le, At, y ? rr : nr);
      (I[A] = ir), (q[A] = ir - At);
    }
    e.modifiersData[r] = q;
  }
}
const h7 = {
  name: "preventOverflow",
  enabled: !0,
  phase: "main",
  fn: f7,
  requiresIfExists: ["offset"],
};
function m7(t) {
  return { scrollLeft: t.scrollLeft, scrollTop: t.scrollTop };
}
function g7(t) {
  return t === qi(t) || !ms(t) ? rA(t) : m7(t);
}
function y7(t) {
  var e = t.getBoundingClientRect(),
    n = Yd(e.width) / t.offsetWidth || 1,
    r = Yd(e.height) / t.offsetHeight || 1;
  return n !== 1 || r !== 1;
}
function w7(t, e, n) {
  n === void 0 && (n = !1);
  var r = ms(e),
    i = ms(e) && y7(e),
    s = Gc(e),
    o = Zd(t, i, n),
    a = { scrollLeft: 0, scrollTop: 0 },
    l = { x: 0, y: 0 };
  return (
    (r || (!r && !n)) &&
      ((No(e) !== "body" || sA(s)) && (a = g7(e)),
      ms(e)
        ? ((l = Zd(e, !0)), (l.x += e.clientLeft), (l.y += e.clientTop))
        : s && (l.x = iA(s))),
    {
      x: o.left + a.scrollLeft - l.x,
      y: o.top + a.scrollTop - l.y,
      width: o.width,
      height: o.height,
    }
  );
}
function v7(t) {
  var e = new Map(),
    n = new Set(),
    r = [];
  t.forEach(function (s) {
    e.set(s.name, s);
  });
  function i(s) {
    n.add(s.name);
    var o = [].concat(s.requires || [], s.requiresIfExists || []);
    o.forEach(function (a) {
      if (!n.has(a)) {
        var l = e.get(a);
        l && i(l);
      }
    }),
      r.push(s);
  }
  return (
    t.forEach(function (s) {
      n.has(s.name) || i(s);
    }),
    r
  );
}
function b7(t) {
  var e = v7(t);
  return Nz.reduce(function (n, r) {
    return n.concat(
      e.filter(function (i) {
        return i.phase === r;
      })
    );
  }, []);
}
function E7(t) {
  var e;
  return function () {
    return (
      e ||
        (e = new Promise(function (n) {
          Promise.resolve().then(function () {
            (e = void 0), n(t());
          });
        })),
      e
    );
  };
}
function C7(t) {
  var e = t.reduce(function (n, r) {
    var i = n[r.name];
    return (
      (n[r.name] = i
        ? Object.assign({}, i, r, {
            options: Object.assign({}, i.options, r.options),
            data: Object.assign({}, i.data, r.data),
          })
        : r),
      n
    );
  }, {});
  return Object.keys(e).map(function (n) {
    return e[n];
  });
}
var oP = { placement: "bottom", modifiers: [], strategy: "absolute" };
function aP() {
  for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++)
    e[n] = arguments[n];
  return !e.some(function (r) {
    return !(r && typeof r.getBoundingClientRect == "function");
  });
}
function x7(t) {
  t === void 0 && (t = {});
  var e = t,
    n = e.defaultModifiers,
    r = n === void 0 ? [] : n,
    i = e.defaultOptions,
    s = i === void 0 ? oP : i;
  return function (a, l, d) {
    d === void 0 && (d = s);
    var p = {
        placement: "bottom",
        orderedModifiers: [],
        options: Object.assign({}, oP, s),
        modifiersData: {},
        elements: { reference: a, popper: l },
        attributes: {},
        styles: {},
      },
      f = [],
      m = !1,
      y = {
        state: p,
        setOptions: function (E) {
          var S = typeof E == "function" ? E(p.options) : E;
          v(),
            (p.options = Object.assign({}, s, p.options, S)),
            (p.scrollParents = {
              reference: Gl(a)
                ? hh(a)
                : a.contextElement
                ? hh(a.contextElement)
                : [],
              popper: hh(l),
            });
          var C = b7(C7([].concat(r, p.options.modifiers)));
          return (
            (p.orderedModifiers = C.filter(function (_) {
              return _.enabled;
            })),
            g(),
            y.update()
          );
        },
        forceUpdate: function () {
          if (!m) {
            var E = p.elements,
              S = E.reference,
              C = E.popper;
            if (aP(S, C)) {
              (p.rects = {
                reference: w7(S, qm(C), p.options.strategy === "fixed"),
                popper: tA(C),
              }),
                (p.reset = !1),
                (p.placement = p.options.placement),
                p.orderedModifiers.forEach(function (T) {
                  return (p.modifiersData[T.name] = Object.assign({}, T.data));
                });
              for (var _ = 0; _ < p.orderedModifiers.length; _++) {
                if (p.reset === !0) {
                  (p.reset = !1), (_ = -1);
                  continue;
                }
                var A = p.orderedModifiers[_],
                  I = A.fn,
                  R = A.options,
                  D = R === void 0 ? {} : R,
                  k = A.name;
                typeof I == "function" &&
                  (p = I({ state: p, options: D, name: k, instance: y }) || p);
              }
            }
          }
        },
        update: E7(function () {
          return new Promise(function (b) {
            y.forceUpdate(), b(p);
          });
        }),
        destroy: function () {
          v(), (m = !0);
        },
      };
    if (!aP(a, l)) return y;
    y.setOptions(d).then(function (b) {
      !m && d.onFirstUpdate && d.onFirstUpdate(b);
    });
    function g() {
      p.orderedModifiers.forEach(function (b) {
        var E = b.name,
          S = b.options,
          C = S === void 0 ? {} : S,
          _ = b.effect;
        if (typeof _ == "function") {
          var A = _({ state: p, name: E, instance: y, options: C }),
            I = function () {};
          f.push(A || I);
        }
      });
    }
    function v() {
      f.forEach(function (b) {
        return b();
      }),
        (f = []);
    }
    return y;
  };
}
var S7 = [Gz, d7, qz, Dz, l7, i7, h7, Fz, o7],
  A7 = x7({ defaultModifiers: S7 });
function _7(t) {
  return typeof t == "function" ? t() : t;
}
const R3 = N.forwardRef(function (e, n) {
  const { children: r, container: i, disablePortal: s = !1 } = e,
    [o, a] = N.useState(null),
    l = In(N.isValidElement(r) ? qc(r) : null, n);
  if (
    (ws(() => {
      s || a(_7(i) || document.body);
    }, [i, s]),
    ws(() => {
      if (o && !s)
        return (
          KC(n, o),
          () => {
            KC(n, null);
          }
        );
    }, [n, o, s]),
    s)
  ) {
    if (N.isValidElement(r)) {
      const d = { ref: l };
      return N.cloneElement(r, d);
    }
    return r;
  }
  return o && KS.createPortal(r, o);
});
function I7(t) {
  return st("MuiPopper", t);
}
ut("MuiPopper", ["root"]);
function T7(t, e) {
  if (e === "ltr") return t;
  switch (t) {
    case "bottom-end":
      return "bottom-start";
    case "bottom-start":
      return "bottom-end";
    case "top-end":
      return "top-start";
    case "top-start":
      return "top-end";
    default:
      return t;
  }
}
function ix(t) {
  return typeof t == "function" ? t() : t;
}
function P7(t) {
  return t.nodeType !== void 0;
}
const R7 = (t) => {
    const { classes: e } = t;
    return dt({ root: ["root"] }, I7, e);
  },
  N7 = {},
  O7 = N.forwardRef(function (e, n) {
    const {
        anchorEl: r,
        children: i,
        direction: s,
        disablePortal: o,
        modifiers: a,
        open: l,
        placement: d,
        popperOptions: p,
        popperRef: f,
        slotProps: m = {},
        slots: y = {},
        TransitionProps: g,
        ownerState: v,
        ...b
      } = e,
      E = N.useRef(null),
      S = In(E, n),
      C = N.useRef(null),
      _ = In(C, f),
      A = N.useRef(_);
    ws(() => {
      A.current = _;
    }, [_]),
      N.useImperativeHandle(f, () => C.current, []);
    const I = T7(d, s),
      [R, D] = N.useState(I),
      [k, T] = N.useState(ix(r));
    N.useEffect(() => {
      C.current && C.current.forceUpdate();
    }),
      N.useEffect(() => {
        r && T(ix(r));
      }, [r]),
      ws(() => {
        if (!k || !l) return;
        const $ = (B) => {
          D(B.placement);
        };
        let M = [
          { name: "preventOverflow", options: { altBoundary: o } },
          { name: "flip", options: { altBoundary: o } },
          {
            name: "onUpdate",
            enabled: !0,
            phase: "afterWrite",
            fn: ({ state: B }) => {
              $(B);
            },
          },
        ];
        a != null && (M = M.concat(a)),
          p && p.modifiers != null && (M = M.concat(p.modifiers));
        const z = A7(k, E.current, { placement: I, ...p, modifiers: M });
        return (
          A.current(z),
          () => {
            z.destroy(), A.current(null);
          }
        );
      }, [k, o, a, l, p, I]);
    const U = { placement: R };
    g !== null && (U.TransitionProps = g);
    const q = R7(e),
      K = y.root ?? "div",
      H = rw({
        elementType: K,
        externalSlotProps: m.root,
        externalForwardedProps: b,
        additionalProps: { role: "tooltip", ref: S },
        ownerState: e,
        className: q.root,
      });
    return O.jsx(K, { ...H, children: typeof i == "function" ? i(U) : i });
  }),
  k7 = N.forwardRef(function (e, n) {
    const {
        anchorEl: r,
        children: i,
        container: s,
        direction: o = "ltr",
        disablePortal: a = !1,
        keepMounted: l = !1,
        modifiers: d,
        open: p,
        placement: f = "bottom",
        popperOptions: m = N7,
        popperRef: y,
        style: g,
        transition: v = !1,
        slotProps: b = {},
        slots: E = {},
        ...S
      } = e,
      [C, _] = N.useState(!0),
      A = () => {
        _(!1);
      },
      I = () => {
        _(!0);
      };
    if (!l && !p && (!v || C)) return null;
    let R;
    if (s) R = s;
    else if (r) {
      const T = ix(r);
      R = T && P7(T) ? qr(T).body : qr(null).body;
    }
    const D = !p && l && (!v || C) ? "none" : void 0,
      k = v ? { in: p, onEnter: A, onExited: I } : void 0;
    return O.jsx(R3, {
      disablePortal: a,
      container: R,
      children: O.jsx(O7, {
        anchorEl: r,
        direction: o,
        disablePortal: a,
        modifiers: d,
        ref: n,
        open: v ? !C : p,
        placement: f,
        popperOptions: m,
        popperRef: y,
        slotProps: b,
        slots: E,
        ...S,
        style: { position: "fixed", top: 0, left: 0, display: D, ...g },
        TransitionProps: k,
        children: i,
      }),
    });
  }),
  D7 = Ce(k7, {
    name: "MuiPopper",
    slot: "Root",
    overridesResolver: (t, e) => e.root,
  })({}),
  N3 = N.forwardRef(function (e, n) {
    const r = av(),
      i = ft({ props: e, name: "MuiPopper" }),
      {
        anchorEl: s,
        component: o,
        components: a,
        componentsProps: l,
        container: d,
        disablePortal: p,
        keepMounted: f,
        modifiers: m,
        open: y,
        placement: g,
        popperOptions: v,
        popperRef: b,
        transition: E,
        slots: S,
        slotProps: C,
        ..._
      } = i,
      A = (S == null ? void 0 : S.root) ?? (a == null ? void 0 : a.Root),
      I = {
        anchorEl: s,
        container: d,
        disablePortal: p,
        keepMounted: f,
        modifiers: m,
        open: y,
        placement: g,
        popperOptions: v,
        popperRef: b,
        transition: E,
        ..._,
      };
    return O.jsx(D7, {
      as: o,
      direction: r ? "rtl" : "ltr",
      slots: { root: A },
      slotProps: C ?? l,
      ...I,
      ref: n,
    });
  });
function Uy(t) {
  return parseInt(t, 10) || 0;
}
const $7 = {
  shadow: {
    visibility: "hidden",
    position: "absolute",
    overflow: "hidden",
    height: 0,
    top: 0,
    left: 0,
    transform: "translateZ(0)",
  },
};
function M7(t) {
  return (
    t == null ||
    Object.keys(t).length === 0 ||
    (t.outerHeightStyle === 0 && !t.overflowing)
  );
}
const L7 = N.forwardRef(function (e, n) {
  const {
      onChange: r,
      maxRows: i,
      minRows: s = 1,
      style: o,
      value: a,
      ...l
    } = e,
    { current: d } = N.useRef(a != null),
    p = N.useRef(null),
    f = In(n, p),
    m = N.useRef(null),
    y = N.useRef(null),
    g = N.useCallback(() => {
      const E = p.current,
        C = Xs(E).getComputedStyle(E);
      if (C.width === "0px") return { outerHeightStyle: 0, overflowing: !1 };
      const _ = y.current;
      (_.style.width = C.width),
        (_.value = E.value || e.placeholder || "x"),
        _.value.slice(-1) ===
          `
` && (_.value += " ");
      const A = C.boxSizing,
        I = Uy(C.paddingBottom) + Uy(C.paddingTop),
        R = Uy(C.borderBottomWidth) + Uy(C.borderTopWidth),
        D = _.scrollHeight;
      _.value = "x";
      const k = _.scrollHeight;
      let T = D;
      s && (T = Math.max(Number(s) * k, T)),
        i && (T = Math.min(Number(i) * k, T)),
        (T = Math.max(T, k));
      const U = T + (A === "border-box" ? I + R : 0),
        q = Math.abs(T - D) <= 1;
      return { outerHeightStyle: U, overflowing: q };
    }, [i, s, e.placeholder]),
    v = N.useCallback(() => {
      const E = g();
      if (M7(E)) return;
      const S = E.outerHeightStyle,
        C = p.current;
      m.current !== S && ((m.current = S), (C.style.height = `${S}px`)),
        (C.style.overflow = E.overflowing ? "hidden" : "");
    }, [g]);
  ws(() => {
    const E = () => {
      v();
    };
    let S;
    const C = qS(E),
      _ = p.current,
      A = Xs(_);
    A.addEventListener("resize", C);
    let I;
    return (
      typeof ResizeObserver < "u" &&
        ((I = new ResizeObserver(E)), I.observe(_)),
      () => {
        C.clear(),
          cancelAnimationFrame(S),
          A.removeEventListener("resize", C),
          I && I.disconnect();
      }
    );
  }, [g, v]),
    ws(() => {
      v();
    });
  const b = (E) => {
    d || v(), r && r(E);
  };
  return O.jsxs(N.Fragment, {
    children: [
      O.jsx("textarea", {
        value: a,
        onChange: b,
        ref: f,
        rows: s,
        style: o,
        ...l,
      }),
      O.jsx("textarea", {
        "aria-hidden": !0,
        className: e.className,
        readOnly: !0,
        ref: y,
        tabIndex: -1,
        style: { ...$7.shadow, ...o, paddingTop: 0, paddingBottom: 0 },
      }),
    ],
  });
});
function sx(t) {
  return typeof t == "string";
}
function xp({ props: t, states: e, muiFormControl: n }) {
  return e.reduce(
    (r, i) => ((r[i] = t[i]), n && typeof t[i] > "u" && (r[i] = n[i]), r),
    {}
  );
}
const oA = N.createContext(void 0);
function Sp() {
  return N.useContext(oA);
}
function cP(t) {
  return t != null && !(Array.isArray(t) && t.length === 0);
}
function cw(t, e = !1) {
  return (
    t &&
    ((cP(t.value) && t.value !== "") ||
      (e && cP(t.defaultValue) && t.defaultValue !== ""))
  );
}
function U7(t) {
  return t.startAdornment;
}
function B7(t) {
  return st("MuiInputBase", t);
}
const Xd = ut("MuiInputBase", [
  "root",
  "formControl",
  "focused",
  "disabled",
  "adornedStart",
  "adornedEnd",
  "error",
  "sizeSmall",
  "multiline",
  "colorSecondary",
  "fullWidth",
  "hiddenLabel",
  "readOnly",
  "input",
  "inputSizeSmall",
  "inputMultiline",
  "inputTypeSearch",
  "inputAdornedStart",
  "inputAdornedEnd",
  "inputHiddenLabel",
]);
var lP;
const uv = (t, e) => {
    const { ownerState: n } = t;
    return [
      e.root,
      n.formControl && e.formControl,
      n.startAdornment && e.adornedStart,
      n.endAdornment && e.adornedEnd,
      n.error && e.error,
      n.size === "small" && e.sizeSmall,
      n.multiline && e.multiline,
      n.color && e[`color${Re(n.color)}`],
      n.fullWidth && e.fullWidth,
      n.hiddenLabel && e.hiddenLabel,
    ];
  },
  dv = (t, e) => {
    const { ownerState: n } = t;
    return [
      e.input,
      n.size === "small" && e.inputSizeSmall,
      n.multiline && e.inputMultiline,
      n.type === "search" && e.inputTypeSearch,
      n.startAdornment && e.inputAdornedStart,
      n.endAdornment && e.inputAdornedEnd,
      n.hiddenLabel && e.inputHiddenLabel,
    ];
  },
  j7 = (t) => {
    const {
        classes: e,
        color: n,
        disabled: r,
        error: i,
        endAdornment: s,
        focused: o,
        formControl: a,
        fullWidth: l,
        hiddenLabel: d,
        multiline: p,
        readOnly: f,
        size: m,
        startAdornment: y,
        type: g,
      } = t,
      v = {
        root: [
          "root",
          `color${Re(n)}`,
          r && "disabled",
          i && "error",
          l && "fullWidth",
          o && "focused",
          a && "formControl",
          m && m !== "medium" && `size${Re(m)}`,
          p && "multiline",
          y && "adornedStart",
          s && "adornedEnd",
          d && "hiddenLabel",
          f && "readOnly",
        ],
        input: [
          "input",
          r && "disabled",
          g === "search" && "inputTypeSearch",
          p && "inputMultiline",
          m === "small" && "inputSizeSmall",
          d && "inputHiddenLabel",
          y && "inputAdornedStart",
          s && "inputAdornedEnd",
          f && "readOnly",
        ],
      };
    return dt(v, B7, e);
  },
  pv = Ce("div", { name: "MuiInputBase", slot: "Root", overridesResolver: uv })(
    wt(({ theme: t }) => ({
      ...t.typography.body1,
      color: (t.vars || t).palette.text.primary,
      lineHeight: "1.4375em",
      boxSizing: "border-box",
      position: "relative",
      cursor: "text",
      display: "inline-flex",
      alignItems: "center",
      [`&.${Xd.disabled}`]: {
        color: (t.vars || t).palette.text.disabled,
        cursor: "default",
      },
      variants: [
        {
          props: ({ ownerState: e }) => e.multiline,
          style: { padding: "4px 0 5px" },
        },
        {
          props: ({ ownerState: e, size: n }) => e.multiline && n === "small",
          style: { paddingTop: 1 },
        },
        { props: ({ ownerState: e }) => e.fullWidth, style: { width: "100%" } },
      ],
    }))
  ),
  fv = Ce("input", {
    name: "MuiInputBase",
    slot: "Input",
    overridesResolver: dv,
  })(
    wt(({ theme: t }) => {
      const e = t.palette.mode === "light",
        n = {
          color: "currentColor",
          ...(t.vars
            ? { opacity: t.vars.opacity.inputPlaceholder }
            : { opacity: e ? 0.42 : 0.5 }),
          transition: t.transitions.create("opacity", {
            duration: t.transitions.duration.shorter,
          }),
        },
        r = { opacity: "0 !important" },
        i = t.vars
          ? { opacity: t.vars.opacity.inputPlaceholder }
          : { opacity: e ? 0.42 : 0.5 };
      return {
        font: "inherit",
        letterSpacing: "inherit",
        color: "currentColor",
        padding: "4px 0 5px",
        border: 0,
        boxSizing: "content-box",
        background: "none",
        height: "1.4375em",
        margin: 0,
        WebkitTapHighlightColor: "transparent",
        display: "block",
        minWidth: 0,
        width: "100%",
        "&::-webkit-input-placeholder": n,
        "&::-moz-placeholder": n,
        "&::-ms-input-placeholder": n,
        "&:focus": { outline: 0 },
        "&:invalid": { boxShadow: "none" },
        "&::-webkit-search-decoration": { WebkitAppearance: "none" },
        [`label[data-shrink=false] + .${Xd.formControl} &`]: {
          "&::-webkit-input-placeholder": r,
          "&::-moz-placeholder": r,
          "&::-ms-input-placeholder": r,
          "&:focus::-webkit-input-placeholder": i,
          "&:focus::-moz-placeholder": i,
          "&:focus::-ms-input-placeholder": i,
        },
        [`&.${Xd.disabled}`]: {
          opacity: 1,
          WebkitTextFillColor: (t.vars || t).palette.text.disabled,
        },
        variants: [
          {
            props: ({ ownerState: s }) => !s.disableInjectingGlobalStyles,
            style: {
              animationName: "mui-auto-fill-cancel",
              animationDuration: "10ms",
              "&:-webkit-autofill": {
                animationDuration: "5000s",
                animationName: "mui-auto-fill",
              },
            },
          },
          { props: { size: "small" }, style: { paddingTop: 1 } },
          {
            props: ({ ownerState: s }) => s.multiline,
            style: {
              height: "auto",
              resize: "none",
              padding: 0,
              paddingTop: 0,
            },
          },
          { props: { type: "search" }, style: { MozAppearance: "textfield" } },
        ],
      };
    })
  ),
  uP = r9({
    "@keyframes mui-auto-fill": { from: { display: "block" } },
    "@keyframes mui-auto-fill-cancel": { from: { display: "block" } },
  }),
  aA = N.forwardRef(function (e, n) {
    const r = ft({ props: e, name: "MuiInputBase" }),
      {
        "aria-describedby": i,
        autoComplete: s,
        autoFocus: o,
        className: a,
        color: l,
        components: d = {},
        componentsProps: p = {},
        defaultValue: f,
        disabled: m,
        disableInjectingGlobalStyles: y,
        endAdornment: g,
        error: v,
        fullWidth: b = !1,
        id: E,
        inputComponent: S = "input",
        inputProps: C = {},
        inputRef: _,
        margin: A,
        maxRows: I,
        minRows: R,
        multiline: D = !1,
        name: k,
        onBlur: T,
        onChange: U,
        onClick: q,
        onFocus: K,
        onKeyDown: H,
        onKeyUp: $,
        placeholder: M,
        readOnly: z,
        renderSuffix: B,
        rows: j,
        size: V,
        slotProps: W = {},
        slots: Z = {},
        startAdornment: ee,
        type: J = "text",
        value: se,
        ...re
      } = r,
      fe = C.value != null ? C.value : se,
      { current: ce } = N.useRef(fe != null),
      le = N.useRef(),
      Se = N.useCallback((ot) => {}, []),
      je = In(le, _, C.ref, Se),
      [Pe, We] = N.useState(!1),
      Ne = Sp(),
      pt = xp({
        props: r,
        muiFormControl: Ne,
        states: [
          "color",
          "disabled",
          "error",
          "hiddenLabel",
          "size",
          "required",
          "filled",
        ],
      });
    (pt.focused = Ne ? Ne.focused : Pe),
      N.useEffect(() => {
        !Ne && m && Pe && (We(!1), T && T());
      }, [Ne, m, Pe, T]);
    const hn = Ne && Ne.onFilled,
      Wt = Ne && Ne.onEmpty,
      Lt = N.useCallback(
        (ot) => {
          cw(ot) ? hn && hn() : Wt && Wt();
        },
        [hn, Wt]
      );
    ws(() => {
      ce && Lt({ value: fe });
    }, [fe, Lt, ce]);
    const vn = (ot) => {
        K && K(ot),
          C.onFocus && C.onFocus(ot),
          Ne && Ne.onFocus ? Ne.onFocus(ot) : We(!0);
      },
      At = (ot) => {
        T && T(ot),
          C.onBlur && C.onBlur(ot),
          Ne && Ne.onBlur ? Ne.onBlur(ot) : We(!1);
      },
      vt = (ot, ...oi) => {
        if (!ce) {
          const $r = ot.target || le.current;
          if ($r == null) throw new Error(xa(1));
          Lt({ value: $r.value });
        }
        C.onChange && C.onChange(ot, ...oi), U && U(ot, ...oi);
      };
    N.useEffect(() => {
      Lt(le.current);
    }, []);
    const Le = (ot) => {
      le.current && ot.currentTarget === ot.target && le.current.focus(),
        q && q(ot);
    };
    let nr = S,
      tn = C;
    D &&
      nr === "input" &&
      (j
        ? (tn = { type: void 0, minRows: j, maxRows: j, ...tn })
        : (tn = { type: void 0, maxRows: I, minRows: R, ...tn }),
      (nr = L7));
    const wr = (ot) => {
      Lt(
        ot.animationName === "mui-auto-fill-cancel"
          ? le.current
          : { value: "x" }
      );
    };
    N.useEffect(() => {
      Ne && Ne.setAdornedStart(!!ee);
    }, [Ne, ee]);
    const Dr = {
        ...r,
        color: pt.color || "primary",
        disabled: pt.disabled,
        endAdornment: g,
        error: pt.error,
        focused: pt.focused,
        formControl: Ne,
        fullWidth: b,
        hiddenLabel: pt.hiddenLabel,
        multiline: D,
        size: pt.size,
        startAdornment: ee,
        type: J,
      },
      rr = j7(Dr),
      ir = Z.root || d.Root || pv,
      vr = W.root || p.root || {},
      Vn = Z.input || d.Input || fv;
    return (
      (tn = { ...tn, ...(W.input ?? p.input) }),
      O.jsxs(N.Fragment, {
        children: [
          !y && typeof uP == "function" && (lP || (lP = O.jsx(uP, {}))),
          O.jsxs(ir, {
            ...vr,
            ref: n,
            onClick: Le,
            ...re,
            ...(!sx(ir) && { ownerState: { ...Dr, ...vr.ownerState } }),
            className: He(
              rr.root,
              vr.className,
              a,
              z && "MuiInputBase-readOnly"
            ),
            children: [
              ee,
              O.jsx(oA.Provider, {
                value: null,
                children: O.jsx(Vn, {
                  "aria-invalid": pt.error,
                  "aria-describedby": i,
                  autoComplete: s,
                  autoFocus: o,
                  defaultValue: f,
                  disabled: pt.disabled,
                  id: E,
                  onAnimationStart: wr,
                  name: k,
                  placeholder: M,
                  readOnly: z,
                  required: pt.required,
                  rows: j,
                  value: fe,
                  onKeyDown: H,
                  onKeyUp: $,
                  type: J,
                  ...tn,
                  ...(!sx(Vn) && {
                    as: nr,
                    ownerState: { ...Dr, ...tn.ownerState },
                  }),
                  ref: je,
                  className: He(
                    rr.input,
                    tn.className,
                    z && "MuiInputBase-readOnly"
                  ),
                  onBlur: At,
                  onChange: vt,
                  onFocus: vn,
                }),
              }),
              g,
              B ? B({ ...pt, startAdornment: ee }) : null,
            ],
          }),
        ],
      })
    );
  });
function F7(t) {
  return st("MuiInput", t);
}
const If = { ...Xd, ...ut("MuiInput", ["root", "underline", "input"]) };
function z7(t) {
  return st("MuiOutlinedInput", t);
}
const co = {
  ...Xd,
  ...ut("MuiOutlinedInput", ["root", "notchedOutline", "input"]),
};
function W7(t) {
  return st("MuiFilledInput", t);
}
const ll = {
    ...Xd,
    ...ut("MuiFilledInput", [
      "root",
      "underline",
      "input",
      "adornedStart",
      "adornedEnd",
      "sizeSmall",
      "multiline",
      "hiddenLabel",
    ]),
  },
  H7 = Ki(O.jsx("path", { d: "M7 10l5 5 5-5z" }), "ArrowDropDown"),
  q7 = { entering: { opacity: 1 }, entered: { opacity: 1 } },
  O3 = N.forwardRef(function (e, n) {
    const r = Ii(),
      i = {
        enter: r.transitions.duration.enteringScreen,
        exit: r.transitions.duration.leavingScreen,
      },
      {
        addEndListener: s,
        appear: o = !0,
        children: a,
        easing: l,
        in: d,
        onEnter: p,
        onEntered: f,
        onEntering: m,
        onExit: y,
        onExited: g,
        onExiting: v,
        style: b,
        timeout: E = i,
        TransitionComponent: S = Cs,
        ...C
      } = e,
      _ = N.useRef(null),
      A = In(_, qc(a), n),
      I = (H) => ($) => {
        if (H) {
          const M = _.current;
          $ === void 0 ? H(M) : H(M, $);
        }
      },
      R = I(m),
      D = I((H, $) => {
        QS(H);
        const M = Uc({ style: b, timeout: E, easing: l }, { mode: "enter" });
        (H.style.webkitTransition = r.transitions.create("opacity", M)),
          (H.style.transition = r.transitions.create("opacity", M)),
          p && p(H, $);
      }),
      k = I(f),
      T = I(v),
      U = I((H) => {
        const $ = Uc({ style: b, timeout: E, easing: l }, { mode: "exit" });
        (H.style.webkitTransition = r.transitions.create("opacity", $)),
          (H.style.transition = r.transitions.create("opacity", $)),
          y && y(H);
      }),
      q = I(g),
      K = (H) => {
        s && s(_.current, H);
      };
    return O.jsx(S, {
      appear: o,
      in: d,
      nodeRef: _,
      onEnter: D,
      onEntered: k,
      onEntering: R,
      onExit: U,
      onExited: q,
      onExiting: T,
      addEndListener: K,
      timeout: E,
      ...C,
      children: (H, { ownerState: $, ...M }) =>
        N.cloneElement(a, {
          style: {
            opacity: 0,
            visibility: H === "exited" && !d ? "hidden" : void 0,
            ...q7[H],
            ...b,
            ...a.props.style,
          },
          ref: A,
          ...M,
        }),
    });
  });
function V7(t) {
  return st("MuiBackdrop", t);
}
ut("MuiBackdrop", ["root", "invisible"]);
const G7 = (t) => {
    const { classes: e, invisible: n } = t;
    return dt({ root: ["root", n && "invisible"] }, V7, e);
  },
  K7 = Ce("div", {
    name: "MuiBackdrop",
    slot: "Root",
    overridesResolver: (t, e) => {
      const { ownerState: n } = t;
      return [e.root, n.invisible && e.invisible];
    },
  })({
    position: "fixed",
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    right: 0,
    bottom: 0,
    top: 0,
    left: 0,
    backgroundColor: "rgba(0, 0, 0, 0.5)",
    WebkitTapHighlightColor: "transparent",
    variants: [
      { props: { invisible: !0 }, style: { backgroundColor: "transparent" } },
    ],
  }),
  cA = N.forwardRef(function (e, n) {
    const r = ft({ props: e, name: "MuiBackdrop" }),
      {
        children: i,
        className: s,
        component: o = "div",
        invisible: a = !1,
        open: l,
        components: d = {},
        componentsProps: p = {},
        slotProps: f = {},
        slots: m = {},
        TransitionComponent: y,
        transitionDuration: g,
        ...v
      } = r,
      b = { ...r, component: o, invisible: a },
      E = G7(b),
      S = { transition: y, root: d.Root, ...m },
      C = { ...p, ...f },
      _ = { slots: S, slotProps: C },
      [A, I] = Jn("root", {
        elementType: K7,
        externalForwardedProps: _,
        className: He(E.root, s),
        ownerState: b,
      }),
      [R, D] = Jn("transition", {
        elementType: O3,
        externalForwardedProps: _,
        ownerState: b,
      });
    return O.jsx(R, {
      in: l,
      timeout: g,
      ...v,
      ...D,
      children: O.jsx(A, {
        "aria-hidden": !0,
        ...I,
        classes: E,
        ref: n,
        children: i,
      }),
    });
  }),
  Y7 = ut("MuiBox", ["root"]),
  Z7 = m3(),
  be = Ej({
    themeId: Mm,
    defaultTheme: Z7,
    defaultClassName: Y7.root,
    generateClassName: Y5.generate,
  });
function Q7(t) {
  return st("MuiButton", t);
}
const Vu = ut("MuiButton", [
    "root",
    "text",
    "textInherit",
    "textPrimary",
    "textSecondary",
    "textSuccess",
    "textError",
    "textInfo",
    "textWarning",
    "outlined",
    "outlinedInherit",
    "outlinedPrimary",
    "outlinedSecondary",
    "outlinedSuccess",
    "outlinedError",
    "outlinedInfo",
    "outlinedWarning",
    "contained",
    "containedInherit",
    "containedPrimary",
    "containedSecondary",
    "containedSuccess",
    "containedError",
    "containedInfo",
    "containedWarning",
    "disableElevation",
    "focusVisible",
    "disabled",
    "colorInherit",
    "colorPrimary",
    "colorSecondary",
    "colorSuccess",
    "colorError",
    "colorInfo",
    "colorWarning",
    "textSizeSmall",
    "textSizeMedium",
    "textSizeLarge",
    "outlinedSizeSmall",
    "outlinedSizeMedium",
    "outlinedSizeLarge",
    "containedSizeSmall",
    "containedSizeMedium",
    "containedSizeLarge",
    "sizeMedium",
    "sizeSmall",
    "sizeLarge",
    "fullWidth",
    "startIcon",
    "endIcon",
    "icon",
    "iconSizeSmall",
    "iconSizeMedium",
    "iconSizeLarge",
  ]),
  X7 = N.createContext({}),
  J7 = N.createContext(void 0),
  eW = (t) => {
    const {
        color: e,
        disableElevation: n,
        fullWidth: r,
        size: i,
        variant: s,
        classes: o,
      } = t,
      a = {
        root: [
          "root",
          s,
          `${s}${Re(e)}`,
          `size${Re(i)}`,
          `${s}Size${Re(i)}`,
          `color${Re(e)}`,
          n && "disableElevation",
          r && "fullWidth",
        ],
        label: ["label"],
        startIcon: ["icon", "startIcon", `iconSize${Re(i)}`],
        endIcon: ["icon", "endIcon", `iconSize${Re(i)}`],
      },
      l = dt(a, Q7, o);
    return { ...o, ...l };
  },
  k3 = [
    {
      props: { size: "small" },
      style: { "& > *:nth-of-type(1)": { fontSize: 18 } },
    },
    {
      props: { size: "medium" },
      style: { "& > *:nth-of-type(1)": { fontSize: 20 } },
    },
    {
      props: { size: "large" },
      style: { "& > *:nth-of-type(1)": { fontSize: 22 } },
    },
  ],
  tW = Ce(Wm, {
    shouldForwardProp: (t) => Gi(t) || t === "classes",
    name: "MuiButton",
    slot: "Root",
    overridesResolver: (t, e) => {
      const { ownerState: n } = t;
      return [
        e.root,
        e[n.variant],
        e[`${n.variant}${Re(n.color)}`],
        e[`size${Re(n.size)}`],
        e[`${n.variant}Size${Re(n.size)}`],
        n.color === "inherit" && e.colorInherit,
        n.disableElevation && e.disableElevation,
        n.fullWidth && e.fullWidth,
      ];
    },
  })(
    wt(({ theme: t }) => {
      const e =
          t.palette.mode === "light"
            ? t.palette.grey[300]
            : t.palette.grey[800],
        n =
          t.palette.mode === "light"
            ? t.palette.grey.A100
            : t.palette.grey[700];
      return {
        ...t.typography.button,
        minWidth: 64,
        padding: "6px 16px",
        border: 0,
        borderRadius: (t.vars || t).shape.borderRadius,
        transition: t.transitions.create(
          ["background-color", "box-shadow", "border-color", "color"],
          { duration: t.transitions.duration.short }
        ),
        "&:hover": { textDecoration: "none" },
        [`&.${Vu.disabled}`]: { color: (t.vars || t).palette.action.disabled },
        variants: [
          {
            props: { variant: "contained" },
            style: {
              color: "var(--variant-containedColor)",
              backgroundColor: "var(--variant-containedBg)",
              boxShadow: (t.vars || t).shadows[2],
              "&:hover": {
                boxShadow: (t.vars || t).shadows[4],
                "@media (hover: none)": { boxShadow: (t.vars || t).shadows[2] },
              },
              "&:active": { boxShadow: (t.vars || t).shadows[8] },
              [`&.${Vu.focusVisible}`]: { boxShadow: (t.vars || t).shadows[6] },
              [`&.${Vu.disabled}`]: {
                color: (t.vars || t).palette.action.disabled,
                boxShadow: (t.vars || t).shadows[0],
                backgroundColor: (t.vars || t).palette.action
                  .disabledBackground,
              },
            },
          },
          {
            props: { variant: "outlined" },
            style: {
              padding: "5px 15px",
              border: "1px solid currentColor",
              borderColor: "var(--variant-outlinedBorder, currentColor)",
              backgroundColor: "var(--variant-outlinedBg)",
              color: "var(--variant-outlinedColor)",
              [`&.${Vu.disabled}`]: {
                border: `1px solid ${
                  (t.vars || t).palette.action.disabledBackground
                }`,
              },
            },
          },
          {
            props: { variant: "text" },
            style: {
              padding: "6px 8px",
              color: "var(--variant-textColor)",
              backgroundColor: "var(--variant-textBg)",
            },
          },
          ...Object.entries(t.palette)
            .filter(hs())
            .map(([r]) => ({
              props: { color: r },
              style: {
                "--variant-textColor": (t.vars || t).palette[r].main,
                "--variant-outlinedColor": (t.vars || t).palette[r].main,
                "--variant-outlinedBorder": t.vars
                  ? `rgba(${t.vars.palette[r].mainChannel} / 0.5)`
                  : An(t.palette[r].main, 0.5),
                "--variant-containedColor": (t.vars || t).palette[r]
                  .contrastText,
                "--variant-containedBg": (t.vars || t).palette[r].main,
                "@media (hover: hover)": {
                  "&:hover": {
                    "--variant-containedBg": (t.vars || t).palette[r].dark,
                    "--variant-textBg": t.vars
                      ? `rgba(${t.vars.palette[r].mainChannel} / ${t.vars.palette.action.hoverOpacity})`
                      : An(t.palette[r].main, t.palette.action.hoverOpacity),
                    "--variant-outlinedBorder": (t.vars || t).palette[r].main,
                    "--variant-outlinedBg": t.vars
                      ? `rgba(${t.vars.palette[r].mainChannel} / ${t.vars.palette.action.hoverOpacity})`
                      : An(t.palette[r].main, t.palette.action.hoverOpacity),
                  },
                },
              },
            })),
          {
            props: { color: "inherit" },
            style: {
              color: "inherit",
              borderColor: "currentColor",
              "--variant-containedBg": t.vars
                ? t.vars.palette.Button.inheritContainedBg
                : e,
              "@media (hover: hover)": {
                "&:hover": {
                  "--variant-containedBg": t.vars
                    ? t.vars.palette.Button.inheritContainedHoverBg
                    : n,
                  "--variant-textBg": t.vars
                    ? `rgba(${t.vars.palette.text.primaryChannel} / ${t.vars.palette.action.hoverOpacity})`
                    : An(t.palette.text.primary, t.palette.action.hoverOpacity),
                  "--variant-outlinedBg": t.vars
                    ? `rgba(${t.vars.palette.text.primaryChannel} / ${t.vars.palette.action.hoverOpacity})`
                    : An(t.palette.text.primary, t.palette.action.hoverOpacity),
                },
              },
            },
          },
          {
            props: { size: "small", variant: "text" },
            style: { padding: "4px 5px", fontSize: t.typography.pxToRem(13) },
          },
          {
            props: { size: "large", variant: "text" },
            style: { padding: "8px 11px", fontSize: t.typography.pxToRem(15) },
          },
          {
            props: { size: "small", variant: "outlined" },
            style: { padding: "3px 9px", fontSize: t.typography.pxToRem(13) },
          },
          {
            props: { size: "large", variant: "outlined" },
            style: { padding: "7px 21px", fontSize: t.typography.pxToRem(15) },
          },
          {
            props: { size: "small", variant: "contained" },
            style: { padding: "4px 10px", fontSize: t.typography.pxToRem(13) },
          },
          {
            props: { size: "large", variant: "contained" },
            style: { padding: "8px 22px", fontSize: t.typography.pxToRem(15) },
          },
          {
            props: { disableElevation: !0 },
            style: {
              boxShadow: "none",
              "&:hover": { boxShadow: "none" },
              [`&.${Vu.focusVisible}`]: { boxShadow: "none" },
              "&:active": { boxShadow: "none" },
              [`&.${Vu.disabled}`]: { boxShadow: "none" },
            },
          },
          { props: { fullWidth: !0 }, style: { width: "100%" } },
        ],
      };
    })
  ),
  nW = Ce("span", {
    name: "MuiButton",
    slot: "StartIcon",
    overridesResolver: (t, e) => {
      const { ownerState: n } = t;
      return [e.startIcon, e[`iconSize${Re(n.size)}`]];
    },
  })({
    display: "inherit",
    marginRight: 8,
    marginLeft: -4,
    variants: [{ props: { size: "small" }, style: { marginLeft: -2 } }, ...k3],
  }),
  rW = Ce("span", {
    name: "MuiButton",
    slot: "EndIcon",
    overridesResolver: (t, e) => {
      const { ownerState: n } = t;
      return [e.endIcon, e[`iconSize${Re(n.size)}`]];
    },
  })({
    display: "inherit",
    marginRight: -4,
    marginLeft: 8,
    variants: [{ props: { size: "small" }, style: { marginRight: -2 } }, ...k3],
  }),
  ha = N.forwardRef(function (e, n) {
    const r = N.useContext(X7),
      i = N.useContext(J7),
      s = Gd(r, e),
      o = ft({ props: s, name: "MuiButton" }),
      {
        children: a,
        color: l = "primary",
        component: d = "button",
        className: p,
        disabled: f = !1,
        disableElevation: m = !1,
        disableFocusRipple: y = !1,
        endIcon: g,
        focusVisibleClassName: v,
        fullWidth: b = !1,
        size: E = "medium",
        startIcon: S,
        type: C,
        variant: _ = "text",
        ...A
      } = o,
      I = {
        ...o,
        color: l,
        component: d,
        disabled: f,
        disableElevation: m,
        disableFocusRipple: y,
        fullWidth: b,
        size: E,
        type: C,
        variant: _,
      },
      R = eW(I),
      D =
        S && O.jsx(nW, { className: R.startIcon, ownerState: I, children: S }),
      k = g && O.jsx(rW, { className: R.endIcon, ownerState: I, children: g }),
      T = i || "";
    return O.jsxs(tW, {
      ownerState: I,
      className: He(r.className, R.root, p, T),
      component: d,
      disabled: f,
      focusRipple: !y,
      focusVisibleClassName: He(R.focusVisible, v),
      ref: n,
      type: C,
      ...A,
      classes: R,
      children: [D, a, k],
    });
  });
function iW(t) {
  return st("MuiCard", t);
}
ut("MuiCard", ["root"]);
const sW = (t) => {
    const { classes: e } = t;
    return dt({ root: ["root"] }, iW, e);
  },
  oW = Ce(Vc, {
    name: "MuiCard",
    slot: "Root",
    overridesResolver: (t, e) => e.root,
  })({ overflow: "hidden" }),
  aW = N.forwardRef(function (e, n) {
    const r = ft({ props: e, name: "MuiCard" }),
      { className: i, raised: s = !1, ...o } = r,
      a = { ...r, raised: s },
      l = sW(a);
    return O.jsx(oW, {
      className: He(l.root, i),
      elevation: s ? 8 : void 0,
      ref: n,
      ownerState: a,
      ...o,
    });
  });
function dP(t) {
  return t.substring(2).toLowerCase();
}
function cW(t, e) {
  return (
    e.documentElement.clientWidth < t.clientX ||
    e.documentElement.clientHeight < t.clientY
  );
}
function lW(t) {
  const {
      children: e,
      disableReactTree: n = !1,
      mouseEvent: r = "onClick",
      onClickAway: i,
      touchEvent: s = "onTouchEnd",
    } = t,
    o = N.useRef(!1),
    a = N.useRef(null),
    l = N.useRef(!1),
    d = N.useRef(!1);
  N.useEffect(
    () => (
      setTimeout(() => {
        l.current = !0;
      }, 0),
      () => {
        l.current = !1;
      }
    ),
    []
  );
  const p = In(qc(e), a),
    f = Ks((g) => {
      const v = d.current;
      d.current = !1;
      const b = qr(a.current);
      if (!l.current || !a.current || ("clientX" in g && cW(g, b))) return;
      if (o.current) {
        o.current = !1;
        return;
      }
      let E;
      g.composedPath
        ? (E = g.composedPath().includes(a.current))
        : (E =
            !b.documentElement.contains(g.target) ||
            a.current.contains(g.target)),
        !E && (n || !v) && i(g);
    }),
    m = (g) => (v) => {
      d.current = !0;
      const b = e.props[g];
      b && b(v);
    },
    y = { ref: p };
  return (
    s !== !1 && (y[s] = m(s)),
    N.useEffect(() => {
      if (s !== !1) {
        const g = dP(s),
          v = qr(a.current),
          b = () => {
            o.current = !0;
          };
        return (
          v.addEventListener(g, f),
          v.addEventListener("touchmove", b),
          () => {
            v.removeEventListener(g, f), v.removeEventListener("touchmove", b);
          }
        );
      }
    }, [f, s]),
    r !== !1 && (y[r] = m(r)),
    N.useEffect(() => {
      if (r !== !1) {
        const g = dP(r),
          v = qr(a.current);
        return (
          v.addEventListener(g, f),
          () => {
            v.removeEventListener(g, f);
          }
        );
      }
    }, [f, r]),
    N.cloneElement(e, y)
  );
}
const Kc = iF({
  createStyledComponent: Ce("div", {
    name: "MuiContainer",
    slot: "Root",
    overridesResolver: (t, e) => {
      const { ownerState: n } = t;
      return [
        e.root,
        e[`maxWidth${Re(String(n.maxWidth))}`],
        n.fixed && e.fixed,
        n.disableGutters && e.disableGutters,
      ];
    },
  }),
  useThemeProps: (t) => ft({ props: t, name: "MuiContainer" }),
});
function uW(t) {
  const e = qr(t);
  return e.body === t
    ? Xs(t).innerWidth > e.documentElement.clientWidth
    : t.scrollHeight > t.clientHeight;
}
function mh(t, e) {
  e ? t.setAttribute("aria-hidden", "true") : t.removeAttribute("aria-hidden");
}
function pP(t) {
  return parseInt(Xs(t).getComputedStyle(t).paddingRight, 10) || 0;
}
function dW(t) {
  const n = [
      "TEMPLATE",
      "SCRIPT",
      "STYLE",
      "LINK",
      "MAP",
      "META",
      "NOSCRIPT",
      "PICTURE",
      "COL",
      "COLGROUP",
      "PARAM",
      "SLOT",
      "SOURCE",
      "TRACK",
    ].includes(t.tagName),
    r = t.tagName === "INPUT" && t.getAttribute("type") === "hidden";
  return n || r;
}
function fP(t, e, n, r, i) {
  const s = [e, n, ...r];
  [].forEach.call(t.children, (o) => {
    const a = !s.includes(o),
      l = !dW(o);
    a && l && mh(o, i);
  });
}
function rE(t, e) {
  let n = -1;
  return t.some((r, i) => (e(r) ? ((n = i), !0) : !1)), n;
}
function pW(t, e) {
  const n = [],
    r = t.container;
  if (!e.disableScrollLock) {
    if (uW(r)) {
      const o = i3(Xs(r));
      n.push({ value: r.style.paddingRight, property: "padding-right", el: r }),
        (r.style.paddingRight = `${pP(r) + o}px`);
      const a = qr(r).querySelectorAll(".mui-fixed");
      [].forEach.call(a, (l) => {
        n.push({
          value: l.style.paddingRight,
          property: "padding-right",
          el: l,
        }),
          (l.style.paddingRight = `${pP(l) + o}px`);
      });
    }
    let s;
    if (r.parentNode instanceof DocumentFragment) s = qr(r).body;
    else {
      const o = r.parentElement,
        a = Xs(r);
      s =
        (o == null ? void 0 : o.nodeName) === "HTML" &&
        a.getComputedStyle(o).overflowY === "scroll"
          ? o
          : r;
    }
    n.push(
      { value: s.style.overflow, property: "overflow", el: s },
      { value: s.style.overflowX, property: "overflow-x", el: s },
      { value: s.style.overflowY, property: "overflow-y", el: s }
    ),
      (s.style.overflow = "hidden");
  }
  return () => {
    n.forEach(({ value: s, el: o, property: a }) => {
      s ? o.style.setProperty(a, s) : o.style.removeProperty(a);
    });
  };
}
function fW(t) {
  const e = [];
  return (
    [].forEach.call(t.children, (n) => {
      n.getAttribute("aria-hidden") === "true" && e.push(n);
    }),
    e
  );
}
class hW {
  constructor() {
    (this.modals = []), (this.containers = []);
  }
  add(e, n) {
    let r = this.modals.indexOf(e);
    if (r !== -1) return r;
    (r = this.modals.length),
      this.modals.push(e),
      e.modalRef && mh(e.modalRef, !1);
    const i = fW(n);
    fP(n, e.mount, e.modalRef, i, !0);
    const s = rE(this.containers, (o) => o.container === n);
    return s !== -1
      ? (this.containers[s].modals.push(e), r)
      : (this.containers.push({
          modals: [e],
          container: n,
          restore: null,
          hiddenSiblings: i,
        }),
        r);
  }
  mount(e, n) {
    const r = rE(this.containers, (s) => s.modals.includes(e)),
      i = this.containers[r];
    i.restore || (i.restore = pW(i, n));
  }
  remove(e, n = !0) {
    const r = this.modals.indexOf(e);
    if (r === -1) return r;
    const i = rE(this.containers, (o) => o.modals.includes(e)),
      s = this.containers[i];
    if (
      (s.modals.splice(s.modals.indexOf(e), 1),
      this.modals.splice(r, 1),
      s.modals.length === 0)
    )
      s.restore && s.restore(),
        e.modalRef && mh(e.modalRef, n),
        fP(s.container, e.mount, e.modalRef, s.hiddenSiblings, !1),
        this.containers.splice(i, 1);
    else {
      const o = s.modals[s.modals.length - 1];
      o.modalRef && mh(o.modalRef, !1);
    }
    return r;
  }
  isTopModal(e) {
    return this.modals.length > 0 && this.modals[this.modals.length - 1] === e;
  }
}
const mW = [
  "input",
  "select",
  "textarea",
  "a[href]",
  "button",
  "[tabindex]",
  "audio[controls]",
  "video[controls]",
  '[contenteditable]:not([contenteditable="false"])',
].join(",");
function gW(t) {
  const e = parseInt(t.getAttribute("tabindex") || "", 10);
  return Number.isNaN(e)
    ? t.contentEditable === "true" ||
      ((t.nodeName === "AUDIO" ||
        t.nodeName === "VIDEO" ||
        t.nodeName === "DETAILS") &&
        t.getAttribute("tabindex") === null)
      ? 0
      : t.tabIndex
    : e;
}
function yW(t) {
  if (t.tagName !== "INPUT" || t.type !== "radio" || !t.name) return !1;
  const e = (r) => t.ownerDocument.querySelector(`input[type="radio"]${r}`);
  let n = e(`[name="${t.name}"]:checked`);
  return n || (n = e(`[name="${t.name}"]`)), n !== t;
}
function wW(t) {
  return !(
    t.disabled ||
    (t.tagName === "INPUT" && t.type === "hidden") ||
    yW(t)
  );
}
function vW(t) {
  const e = [],
    n = [];
  return (
    Array.from(t.querySelectorAll(mW)).forEach((r, i) => {
      const s = gW(r);
      s === -1 ||
        !wW(r) ||
        (s === 0
          ? e.push(r)
          : n.push({ documentOrder: i, tabIndex: s, node: r }));
    }),
    n
      .sort((r, i) =>
        r.tabIndex === i.tabIndex
          ? r.documentOrder - i.documentOrder
          : r.tabIndex - i.tabIndex
      )
      .map((r) => r.node)
      .concat(e)
  );
}
function bW() {
  return !0;
}
function EW(t) {
  const {
      children: e,
      disableAutoFocus: n = !1,
      disableEnforceFocus: r = !1,
      disableRestoreFocus: i = !1,
      getTabbable: s = vW,
      isEnabled: o = bW,
      open: a,
    } = t,
    l = N.useRef(!1),
    d = N.useRef(null),
    p = N.useRef(null),
    f = N.useRef(null),
    m = N.useRef(null),
    y = N.useRef(!1),
    g = N.useRef(null),
    v = In(qc(e), g),
    b = N.useRef(null);
  N.useEffect(() => {
    !a || !g.current || (y.current = !n);
  }, [n, a]),
    N.useEffect(() => {
      if (!a || !g.current) return;
      const C = qr(g.current);
      return (
        g.current.contains(C.activeElement) ||
          (g.current.hasAttribute("tabIndex") ||
            g.current.setAttribute("tabIndex", "-1"),
          y.current && g.current.focus()),
        () => {
          i ||
            (f.current &&
              f.current.focus &&
              ((l.current = !0), f.current.focus()),
            (f.current = null));
        }
      );
    }, [a]),
    N.useEffect(() => {
      if (!a || !g.current) return;
      const C = qr(g.current),
        _ = (R) => {
          (b.current = R),
            !(r || !o() || R.key !== "Tab") &&
              C.activeElement === g.current &&
              R.shiftKey &&
              ((l.current = !0), p.current && p.current.focus());
        },
        A = () => {
          var k, T;
          const R = g.current;
          if (R === null) return;
          if (!C.hasFocus() || !o() || l.current) {
            l.current = !1;
            return;
          }
          if (
            R.contains(C.activeElement) ||
            (r &&
              C.activeElement !== d.current &&
              C.activeElement !== p.current)
          )
            return;
          if (C.activeElement !== m.current) m.current = null;
          else if (m.current !== null) return;
          if (!y.current) return;
          let D = [];
          if (
            ((C.activeElement === d.current || C.activeElement === p.current) &&
              (D = s(g.current)),
            D.length > 0)
          ) {
            const U = !!(
                (k = b.current) != null &&
                k.shiftKey &&
                ((T = b.current) == null ? void 0 : T.key) === "Tab"
              ),
              q = D[0],
              K = D[D.length - 1];
            typeof q != "string" &&
              typeof K != "string" &&
              (U ? K.focus() : q.focus());
          } else R.focus();
        };
      C.addEventListener("focusin", A), C.addEventListener("keydown", _, !0);
      const I = setInterval(() => {
        C.activeElement && C.activeElement.tagName === "BODY" && A();
      }, 50);
      return () => {
        clearInterval(I),
          C.removeEventListener("focusin", A),
          C.removeEventListener("keydown", _, !0);
      };
    }, [n, r, i, o, a, s]);
  const E = (C) => {
      f.current === null && (f.current = C.relatedTarget),
        (y.current = !0),
        (m.current = C.target);
      const _ = e.props.onFocus;
      _ && _(C);
    },
    S = (C) => {
      f.current === null && (f.current = C.relatedTarget), (y.current = !0);
    };
  return O.jsxs(N.Fragment, {
    children: [
      O.jsx("div", {
        tabIndex: a ? 0 : -1,
        onFocus: S,
        ref: d,
        "data-testid": "sentinelStart",
      }),
      N.cloneElement(e, { ref: v, onFocus: E }),
      O.jsx("div", {
        tabIndex: a ? 0 : -1,
        onFocus: S,
        ref: p,
        "data-testid": "sentinelEnd",
      }),
    ],
  });
}
function CW(t) {
  return typeof t == "function" ? t() : t;
}
function xW(t) {
  return t ? t.props.hasOwnProperty("in") : !1;
}
const hP = () => {},
  By = new hW();
function SW(t) {
  const {
      container: e,
      disableEscapeKeyDown: n = !1,
      disableScrollLock: r = !1,
      closeAfterTransition: i = !1,
      onTransitionEnter: s,
      onTransitionExited: o,
      children: a,
      onClose: l,
      open: d,
      rootRef: p,
    } = t,
    f = N.useRef({}),
    m = N.useRef(null),
    y = N.useRef(null),
    g = In(y, p),
    [v, b] = N.useState(!d),
    E = xW(a);
  let S = !0;
  (t["aria-hidden"] === "false" || t["aria-hidden"] === !1) && (S = !1);
  const C = () => qr(m.current),
    _ = () => (
      (f.current.modalRef = y.current), (f.current.mount = m.current), f.current
    ),
    A = () => {
      By.mount(_(), { disableScrollLock: r }),
        y.current && (y.current.scrollTop = 0);
    },
    I = Ks(() => {
      const $ = CW(e) || C().body;
      By.add(_(), $), y.current && A();
    }),
    R = () => By.isTopModal(_()),
    D = Ks(($) => {
      (m.current = $), $ && (d && R() ? A() : y.current && mh(y.current, S));
    }),
    k = N.useCallback(() => {
      By.remove(_(), S);
    }, [S]);
  N.useEffect(
    () => () => {
      k();
    },
    [k]
  ),
    N.useEffect(() => {
      d ? I() : (!E || !i) && k();
    }, [d, k, E, i, I]);
  const T = ($) => (M) => {
      var z;
      (z = $.onKeyDown) == null || z.call($, M),
        !(M.key !== "Escape" || M.which === 229 || !R()) &&
          (n || (M.stopPropagation(), l && l(M, "escapeKeyDown")));
    },
    U = ($) => (M) => {
      var z;
      (z = $.onClick) == null || z.call($, M),
        M.target === M.currentTarget && l && l(M, "backdropClick");
    };
  return {
    getRootProps: ($ = {}) => {
      const M = nw(t);
      delete M.onTransitionEnter, delete M.onTransitionExited;
      const z = { ...M, ...$ };
      return { role: "presentation", ...z, onKeyDown: T(z), ref: g };
    },
    getBackdropProps: ($ = {}) => {
      const M = $;
      return { "aria-hidden": !0, ...M, onClick: U(M), open: d };
    },
    getTransitionProps: () => {
      const $ = () => {
          b(!1), s && s();
        },
        M = () => {
          b(!0), o && o(), i && k();
        };
      return {
        onEnter: kT($, (a == null ? void 0 : a.props.onEnter) ?? hP),
        onExited: kT(M, (a == null ? void 0 : a.props.onExited) ?? hP),
      };
    },
    rootRef: g,
    portalRef: D,
    isTopModal: R,
    exited: v,
    hasTransition: E,
  };
}
function AW(t) {
  return st("MuiModal", t);
}
ut("MuiModal", ["root", "hidden", "backdrop"]);
const _W = (t) => {
    const { open: e, exited: n, classes: r } = t;
    return dt(
      { root: ["root", !e && n && "hidden"], backdrop: ["backdrop"] },
      AW,
      r
    );
  },
  IW = Ce("div", {
    name: "MuiModal",
    slot: "Root",
    overridesResolver: (t, e) => {
      const { ownerState: n } = t;
      return [e.root, !n.open && n.exited && e.hidden];
    },
  })(
    wt(({ theme: t }) => ({
      position: "fixed",
      zIndex: (t.vars || t).zIndex.modal,
      right: 0,
      bottom: 0,
      top: 0,
      left: 0,
      variants: [
        {
          props: ({ ownerState: e }) => !e.open && e.exited,
          style: { visibility: "hidden" },
        },
      ],
    }))
  ),
  TW = Ce(cA, {
    name: "MuiModal",
    slot: "Backdrop",
    overridesResolver: (t, e) => e.backdrop,
  })({ zIndex: -1 }),
  lA = N.forwardRef(function (e, n) {
    const r = ft({ name: "MuiModal", props: e }),
      {
        BackdropComponent: i = TW,
        BackdropProps: s,
        classes: o,
        className: a,
        closeAfterTransition: l = !1,
        children: d,
        container: p,
        component: f,
        components: m = {},
        componentsProps: y = {},
        disableAutoFocus: g = !1,
        disableEnforceFocus: v = !1,
        disableEscapeKeyDown: b = !1,
        disablePortal: E = !1,
        disableRestoreFocus: S = !1,
        disableScrollLock: C = !1,
        hideBackdrop: _ = !1,
        keepMounted: A = !1,
        onBackdropClick: I,
        onClose: R,
        onTransitionEnter: D,
        onTransitionExited: k,
        open: T,
        slotProps: U = {},
        slots: q = {},
        theme: K,
        ...H
      } = r,
      $ = {
        ...r,
        closeAfterTransition: l,
        disableAutoFocus: g,
        disableEnforceFocus: v,
        disableEscapeKeyDown: b,
        disablePortal: E,
        disableRestoreFocus: S,
        disableScrollLock: C,
        hideBackdrop: _,
        keepMounted: A,
      },
      {
        getRootProps: M,
        getBackdropProps: z,
        getTransitionProps: B,
        portalRef: j,
        isTopModal: V,
        exited: W,
        hasTransition: Z,
      } = SW({ ...$, rootRef: n }),
      ee = { ...$, exited: W },
      J = _W(ee),
      se = {};
    if ((d.props.tabIndex === void 0 && (se.tabIndex = "-1"), Z)) {
      const { onEnter: Pe, onExited: We } = B();
      (se.onEnter = Pe), (se.onExited = We);
    }
    const re = {
        ...H,
        slots: { root: m.Root, backdrop: m.Backdrop, ...q },
        slotProps: { ...y, ...U },
      },
      [fe, ce] = Jn("root", {
        elementType: IW,
        externalForwardedProps: re,
        getSlotProps: M,
        additionalProps: { ref: n, as: f },
        ownerState: ee,
        className: He(
          a,
          J == null ? void 0 : J.root,
          !ee.open && ee.exited && (J == null ? void 0 : J.hidden)
        ),
      }),
      [le, Se] = Jn("backdrop", {
        elementType: i,
        externalForwardedProps: re,
        additionalProps: s,
        getSlotProps: (Pe) =>
          z({
            ...Pe,
            onClick: (We) => {
              I && I(We), Pe != null && Pe.onClick && Pe.onClick(We);
            },
          }),
        className: He(
          s == null ? void 0 : s.className,
          J == null ? void 0 : J.backdrop
        ),
        ownerState: ee,
      }),
      je = In(s == null ? void 0 : s.ref, Se.ref);
    return !A && !T && (!Z || W)
      ? null
      : O.jsx(R3, {
          ref: j,
          container: p,
          disablePortal: E,
          children: O.jsxs(fe, {
            ...ce,
            children: [
              !_ && i ? O.jsx(le, { ...Se, ref: je }) : null,
              O.jsx(EW, {
                disableEnforceFocus: v,
                disableAutoFocus: g,
                disableRestoreFocus: S,
                isEnabled: V,
                open: T,
                children: N.cloneElement(d, se),
              }),
            ],
          }),
        });
  });
function PW(t) {
  return st("MuiDialog", t);
}
const iE = ut("MuiDialog", [
    "root",
    "scrollPaper",
    "scrollBody",
    "container",
    "paper",
    "paperScrollPaper",
    "paperScrollBody",
    "paperWidthFalse",
    "paperWidthXs",
    "paperWidthSm",
    "paperWidthMd",
    "paperWidthLg",
    "paperWidthXl",
    "paperFullWidth",
    "paperFullScreen",
  ]),
  RW = N.createContext({}),
  NW = Ce(cA, {
    name: "MuiDialog",
    slot: "Backdrop",
    overrides: (t, e) => e.backdrop,
  })({ zIndex: -1 }),
  OW = (t) => {
    const {
        classes: e,
        scroll: n,
        maxWidth: r,
        fullWidth: i,
        fullScreen: s,
      } = t,
      o = {
        root: ["root"],
        container: ["container", `scroll${Re(n)}`],
        paper: [
          "paper",
          `paperScroll${Re(n)}`,
          `paperWidth${Re(String(r))}`,
          i && "paperFullWidth",
          s && "paperFullScreen",
        ],
      };
    return dt(o, PW, e);
  },
  kW = Ce(lA, {
    name: "MuiDialog",
    slot: "Root",
    overridesResolver: (t, e) => e.root,
  })({ "@media print": { position: "absolute !important" } }),
  DW = Ce("div", {
    name: "MuiDialog",
    slot: "Container",
    overridesResolver: (t, e) => {
      const { ownerState: n } = t;
      return [e.container, e[`scroll${Re(n.scroll)}`]];
    },
  })({
    height: "100%",
    "@media print": { height: "auto" },
    outline: 0,
    variants: [
      {
        props: { scroll: "paper" },
        style: {
          display: "flex",
          justifyContent: "center",
          alignItems: "center",
        },
      },
      {
        props: { scroll: "body" },
        style: {
          overflowY: "auto",
          overflowX: "hidden",
          textAlign: "center",
          "&::after": {
            content: '""',
            display: "inline-block",
            verticalAlign: "middle",
            height: "100%",
            width: "0",
          },
        },
      },
    ],
  }),
  $W = Ce(Vc, {
    name: "MuiDialog",
    slot: "Paper",
    overridesResolver: (t, e) => {
      const { ownerState: n } = t;
      return [
        e.paper,
        e[`scrollPaper${Re(n.scroll)}`],
        e[`paperWidth${Re(String(n.maxWidth))}`],
        n.fullWidth && e.paperFullWidth,
        n.fullScreen && e.paperFullScreen,
      ];
    },
  })(
    wt(({ theme: t }) => ({
      margin: 32,
      position: "relative",
      overflowY: "auto",
      "@media print": { overflowY: "visible", boxShadow: "none" },
      variants: [
        {
          props: { scroll: "paper" },
          style: {
            display: "flex",
            flexDirection: "column",
            maxHeight: "calc(100% - 64px)",
          },
        },
        {
          props: { scroll: "body" },
          style: {
            display: "inline-block",
            verticalAlign: "middle",
            textAlign: "initial",
          },
        },
        {
          props: ({ ownerState: e }) => !e.maxWidth,
          style: { maxWidth: "calc(100% - 64px)" },
        },
        {
          props: { maxWidth: "xs" },
          style: {
            maxWidth:
              t.breakpoints.unit === "px"
                ? Math.max(t.breakpoints.values.xs, 444)
                : `max(${t.breakpoints.values.xs}${t.breakpoints.unit}, 444px)`,
            [`&.${iE.paperScrollBody}`]: {
              [t.breakpoints.down(
                Math.max(t.breakpoints.values.xs, 444) + 32 * 2
              )]: { maxWidth: "calc(100% - 64px)" },
            },
          },
        },
        ...Object.keys(t.breakpoints.values)
          .filter((e) => e !== "xs")
          .map((e) => ({
            props: { maxWidth: e },
            style: {
              maxWidth: `${t.breakpoints.values[e]}${t.breakpoints.unit}`,
              [`&.${iE.paperScrollBody}`]: {
                [t.breakpoints.down(t.breakpoints.values[e] + 32 * 2)]: {
                  maxWidth: "calc(100% - 64px)",
                },
              },
            },
          })),
        {
          props: ({ ownerState: e }) => e.fullWidth,
          style: { width: "calc(100% - 64px)" },
        },
        {
          props: ({ ownerState: e }) => e.fullScreen,
          style: {
            margin: 0,
            width: "100%",
            maxWidth: "100%",
            height: "100%",
            maxHeight: "none",
            borderRadius: 0,
            [`&.${iE.paperScrollBody}`]: { margin: 0, maxWidth: "100%" },
          },
        },
      ],
    }))
  ),
  MW = N.forwardRef(function (e, n) {
    const r = ft({ props: e, name: "MuiDialog" }),
      i = Ii(),
      s = {
        enter: i.transitions.duration.enteringScreen,
        exit: i.transitions.duration.leavingScreen,
      },
      {
        "aria-describedby": o,
        "aria-labelledby": a,
        "aria-modal": l = !0,
        BackdropComponent: d,
        BackdropProps: p,
        children: f,
        className: m,
        disableEscapeKeyDown: y = !1,
        fullScreen: g = !1,
        fullWidth: v = !1,
        maxWidth: b = "sm",
        onBackdropClick: E,
        onClick: S,
        onClose: C,
        open: _,
        PaperComponent: A = Vc,
        PaperProps: I = {},
        scroll: R = "paper",
        TransitionComponent: D = O3,
        transitionDuration: k = s,
        TransitionProps: T,
        ...U
      } = r,
      q = {
        ...r,
        disableEscapeKeyDown: y,
        fullScreen: g,
        fullWidth: v,
        maxWidth: b,
        scroll: R,
      },
      K = OW(q),
      H = N.useRef(),
      $ = (j) => {
        H.current = j.target === j.currentTarget;
      },
      M = (j) => {
        S && S(j),
          H.current &&
            ((H.current = null), E && E(j), C && C(j, "backdropClick"));
      },
      z = sv(a),
      B = N.useMemo(() => ({ titleId: z }), [z]);
    return O.jsx(kW, {
      className: He(K.root, m),
      closeAfterTransition: !0,
      components: { Backdrop: NW },
      componentsProps: { backdrop: { transitionDuration: k, as: d, ...p } },
      disableEscapeKeyDown: y,
      onClose: C,
      open: _,
      ref: n,
      onClick: M,
      ownerState: q,
      ...U,
      children: O.jsx(D, {
        appear: !0,
        in: _,
        timeout: k,
        role: "presentation",
        ...T,
        children: O.jsx(DW, {
          className: He(K.container),
          onMouseDown: $,
          ownerState: q,
          children: O.jsx($W, {
            as: A,
            elevation: 24,
            role: "dialog",
            "aria-describedby": o,
            "aria-labelledby": z,
            "aria-modal": l,
            ...I,
            className: He(K.paper, I.className),
            ownerState: q,
            children: O.jsx(RW.Provider, { value: B, children: f }),
          }),
        }),
      }),
    });
  });
function LW(t) {
  return st("MuiDialogContent", t);
}
ut("MuiDialogContent", ["root", "dividers"]);
const UW = ut("MuiDialogTitle", ["root"]),
  BW = (t) => {
    const { classes: e, dividers: n } = t;
    return dt({ root: ["root", n && "dividers"] }, LW, e);
  },
  jW = Ce("div", {
    name: "MuiDialogContent",
    slot: "Root",
    overridesResolver: (t, e) => {
      const { ownerState: n } = t;
      return [e.root, n.dividers && e.dividers];
    },
  })(
    wt(({ theme: t }) => ({
      flex: "1 1 auto",
      WebkitOverflowScrolling: "touch",
      overflowY: "auto",
      padding: "20px 24px",
      variants: [
        {
          props: ({ ownerState: e }) => e.dividers,
          style: {
            padding: "16px 24px",
            borderTop: `1px solid ${(t.vars || t).palette.divider}`,
            borderBottom: `1px solid ${(t.vars || t).palette.divider}`,
          },
        },
        {
          props: ({ ownerState: e }) => !e.dividers,
          style: { [`.${UW.root} + &`]: { paddingTop: 0 } },
        },
      ],
    }))
  ),
  FW = N.forwardRef(function (e, n) {
    const r = ft({ props: e, name: "MuiDialogContent" }),
      { className: i, dividers: s = !1, ...o } = r,
      a = { ...r, dividers: s },
      l = BW(a);
    return O.jsx(jW, { className: He(l.root, i), ownerState: a, ref: n, ...o });
  });
function zW(t, e, n) {
  const r = e.getBoundingClientRect(),
    i = n && n.getBoundingClientRect(),
    s = Xs(e);
  let o;
  if (e.fakeTransform) o = e.fakeTransform;
  else {
    const d = s.getComputedStyle(e);
    o =
      d.getPropertyValue("-webkit-transform") ||
      d.getPropertyValue("transform");
  }
  let a = 0,
    l = 0;
  if (o && o !== "none" && typeof o == "string") {
    const d = o.split("(")[1].split(")")[0].split(",");
    (a = parseInt(d[4], 10)), (l = parseInt(d[5], 10));
  }
  return t === "left"
    ? i
      ? `translateX(${i.right + a - r.left}px)`
      : `translateX(${s.innerWidth + a - r.left}px)`
    : t === "right"
    ? i
      ? `translateX(-${r.right - i.left - a}px)`
      : `translateX(-${r.left + r.width - a}px)`
    : t === "up"
    ? i
      ? `translateY(${i.bottom + l - r.top}px)`
      : `translateY(${s.innerHeight + l - r.top}px)`
    : i
    ? `translateY(-${r.top - i.top + r.height - l}px)`
    : `translateY(-${r.top + r.height - l}px)`;
}
function WW(t) {
  return typeof t == "function" ? t() : t;
}
function jy(t, e, n) {
  const r = WW(n),
    i = zW(t, e, r);
  i && ((e.style.webkitTransform = i), (e.style.transform = i));
}
const D3 = N.forwardRef(function (e, n) {
  const r = Ii(),
    i = {
      enter: r.transitions.easing.easeOut,
      exit: r.transitions.easing.sharp,
    },
    s = {
      enter: r.transitions.duration.enteringScreen,
      exit: r.transitions.duration.leavingScreen,
    },
    {
      addEndListener: o,
      appear: a = !0,
      children: l,
      container: d,
      direction: p = "down",
      easing: f = i,
      in: m,
      onEnter: y,
      onEntered: g,
      onEntering: v,
      onExit: b,
      onExited: E,
      onExiting: S,
      style: C,
      timeout: _ = s,
      TransitionComponent: A = Cs,
      ...I
    } = e,
    R = N.useRef(null),
    D = In(qc(l), R, n),
    k = (B) => (j) => {
      B && (j === void 0 ? B(R.current) : B(R.current, j));
    },
    T = k((B, j) => {
      jy(p, B, d), QS(B), y && y(B, j);
    }),
    U = k((B, j) => {
      const V = Uc({ timeout: _, style: C, easing: f }, { mode: "enter" });
      (B.style.webkitTransition = r.transitions.create("-webkit-transform", {
        ...V,
      })),
        (B.style.transition = r.transitions.create("transform", { ...V })),
        (B.style.webkitTransform = "none"),
        (B.style.transform = "none"),
        v && v(B, j);
    }),
    q = k(g),
    K = k(S),
    H = k((B) => {
      const j = Uc({ timeout: _, style: C, easing: f }, { mode: "exit" });
      (B.style.webkitTransition = r.transitions.create("-webkit-transform", j)),
        (B.style.transition = r.transitions.create("transform", j)),
        jy(p, B, d),
        b && b(B);
    }),
    $ = k((B) => {
      (B.style.webkitTransition = ""), (B.style.transition = ""), E && E(B);
    }),
    M = (B) => {
      o && o(R.current, B);
    },
    z = N.useCallback(() => {
      R.current && jy(p, R.current, d);
    }, [p, d]);
  return (
    N.useEffect(() => {
      if (m || p === "down" || p === "right") return;
      const B = qS(() => {
          R.current && jy(p, R.current, d);
        }),
        j = Xs(R.current);
      return (
        j.addEventListener("resize", B),
        () => {
          B.clear(), j.removeEventListener("resize", B);
        }
      );
    }, [p, m, d]),
    N.useEffect(() => {
      m || z();
    }, [m, z]),
    O.jsx(A, {
      nodeRef: R,
      onEnter: T,
      onEntered: q,
      onEntering: U,
      onExit: H,
      onExited: $,
      onExiting: K,
      addEndListener: M,
      appear: a,
      in: m,
      timeout: _,
      ...I,
      children: (B, { ownerState: j, ...V }) =>
        N.cloneElement(l, {
          ref: D,
          style: {
            visibility: B === "exited" && !m ? "hidden" : void 0,
            ...C,
            ...l.props.style,
          },
          ...V,
        }),
    })
  );
});
function HW(t) {
  return st("MuiDrawer", t);
}
ut("MuiDrawer", [
  "root",
  "docked",
  "paper",
  "paperAnchorLeft",
  "paperAnchorRight",
  "paperAnchorTop",
  "paperAnchorBottom",
  "paperAnchorDockedLeft",
  "paperAnchorDockedRight",
  "paperAnchorDockedTop",
  "paperAnchorDockedBottom",
  "modal",
]);
const $3 = (t, e) => {
    const { ownerState: n } = t;
    return [
      e.root,
      (n.variant === "permanent" || n.variant === "persistent") && e.docked,
      e.modal,
    ];
  },
  qW = (t) => {
    const { classes: e, anchor: n, variant: r } = t,
      i = {
        root: ["root"],
        docked: [(r === "permanent" || r === "persistent") && "docked"],
        modal: ["modal"],
        paper: [
          "paper",
          `paperAnchor${Re(n)}`,
          r !== "temporary" && `paperAnchorDocked${Re(n)}`,
        ],
      };
    return dt(i, HW, e);
  },
  VW = Ce(lA, { name: "MuiDrawer", slot: "Root", overridesResolver: $3 })(
    wt(({ theme: t }) => ({ zIndex: (t.vars || t).zIndex.drawer }))
  ),
  mP = Ce("div", {
    shouldForwardProp: Gi,
    name: "MuiDrawer",
    slot: "Docked",
    skipVariantsResolver: !1,
    overridesResolver: $3,
  })({ flex: "0 0 auto" }),
  GW = Ce(Vc, {
    name: "MuiDrawer",
    slot: "Paper",
    overridesResolver: (t, e) => {
      const { ownerState: n } = t;
      return [
        e.paper,
        e[`paperAnchor${Re(n.anchor)}`],
        n.variant !== "temporary" && e[`paperAnchorDocked${Re(n.anchor)}`],
      ];
    },
  })(
    wt(({ theme: t }) => ({
      overflowY: "auto",
      display: "flex",
      flexDirection: "column",
      height: "100%",
      flex: "1 0 auto",
      zIndex: (t.vars || t).zIndex.drawer,
      WebkitOverflowScrolling: "touch",
      position: "fixed",
      top: 0,
      outline: 0,
      variants: [
        { props: { anchor: "left" }, style: { left: 0 } },
        {
          props: { anchor: "top" },
          style: {
            top: 0,
            left: 0,
            right: 0,
            height: "auto",
            maxHeight: "100%",
          },
        },
        { props: { anchor: "right" }, style: { right: 0 } },
        {
          props: { anchor: "bottom" },
          style: {
            top: "auto",
            left: 0,
            bottom: 0,
            right: 0,
            height: "auto",
            maxHeight: "100%",
          },
        },
        {
          props: ({ ownerState: e }) =>
            e.anchor === "left" && e.variant !== "temporary",
          style: { borderRight: `1px solid ${(t.vars || t).palette.divider}` },
        },
        {
          props: ({ ownerState: e }) =>
            e.anchor === "top" && e.variant !== "temporary",
          style: { borderBottom: `1px solid ${(t.vars || t).palette.divider}` },
        },
        {
          props: ({ ownerState: e }) =>
            e.anchor === "right" && e.variant !== "temporary",
          style: { borderLeft: `1px solid ${(t.vars || t).palette.divider}` },
        },
        {
          props: ({ ownerState: e }) =>
            e.anchor === "bottom" && e.variant !== "temporary",
          style: { borderTop: `1px solid ${(t.vars || t).palette.divider}` },
        },
      ],
    }))
  ),
  M3 = { left: "right", right: "left", top: "down", bottom: "up" };
function KW(t) {
  return ["left", "right"].includes(t);
}
function YW({ direction: t }, e) {
  return t === "rtl" && KW(e) ? M3[e] : e;
}
const ZW = N.forwardRef(function (e, n) {
    const r = ft({ props: e, name: "MuiDrawer" }),
      i = Ii(),
      s = av(),
      o = {
        enter: i.transitions.duration.enteringScreen,
        exit: i.transitions.duration.leavingScreen,
      },
      {
        anchor: a = "left",
        BackdropProps: l,
        children: d,
        className: p,
        elevation: f = 16,
        hideBackdrop: m = !1,
        ModalProps: { BackdropProps: y, ...g } = {},
        onClose: v,
        open: b = !1,
        PaperProps: E = {},
        SlideProps: S,
        TransitionComponent: C = D3,
        transitionDuration: _ = o,
        variant: A = "temporary",
        ...I
      } = r,
      R = N.useRef(!1);
    N.useEffect(() => {
      R.current = !0;
    }, []);
    const D = YW({ direction: s ? "rtl" : "ltr" }, a),
      T = { ...r, anchor: a, elevation: f, open: b, variant: A, ...I },
      U = qW(T),
      q = O.jsx(GW, {
        elevation: A === "temporary" ? f : 0,
        square: !0,
        ...E,
        className: He(U.paper, E.className),
        ownerState: T,
        children: d,
      });
    if (A === "permanent")
      return O.jsx(mP, {
        className: He(U.root, U.docked, p),
        ownerState: T,
        ref: n,
        ...I,
        children: q,
      });
    const K = O.jsx(C, {
      in: b,
      direction: M3[D],
      timeout: _,
      appear: R.current,
      ...S,
      children: q,
    });
    return A === "persistent"
      ? O.jsx(mP, {
          className: He(U.root, U.docked, p),
          ownerState: T,
          ref: n,
          ...I,
          children: K,
        })
      : O.jsx(VW, {
          BackdropProps: { ...l, ...y, transitionDuration: _ },
          className: He(U.root, U.modal, p),
          open: b,
          ownerState: T,
          onClose: v,
          hideBackdrop: m,
          ref: n,
          ...I,
          ...g,
          children: K,
        });
  }),
  QW = (t) => {
    const {
        classes: e,
        disableUnderline: n,
        startAdornment: r,
        endAdornment: i,
        size: s,
        hiddenLabel: o,
        multiline: a,
      } = t,
      l = {
        root: [
          "root",
          !n && "underline",
          r && "adornedStart",
          i && "adornedEnd",
          s === "small" && `size${Re(s)}`,
          o && "hiddenLabel",
          a && "multiline",
        ],
        input: ["input"],
      },
      d = dt(l, W7, e);
    return { ...e, ...d };
  },
  XW = Ce(pv, {
    shouldForwardProp: (t) => Gi(t) || t === "classes",
    name: "MuiFilledInput",
    slot: "Root",
    overridesResolver: (t, e) => {
      const { ownerState: n } = t;
      return [...uv(t, e), !n.disableUnderline && e.underline];
    },
  })(
    wt(({ theme: t }) => {
      const e = t.palette.mode === "light",
        n = e ? "rgba(0, 0, 0, 0.42)" : "rgba(255, 255, 255, 0.7)",
        r = e ? "rgba(0, 0, 0, 0.06)" : "rgba(255, 255, 255, 0.09)",
        i = e ? "rgba(0, 0, 0, 0.09)" : "rgba(255, 255, 255, 0.13)",
        s = e ? "rgba(0, 0, 0, 0.12)" : "rgba(255, 255, 255, 0.12)";
      return {
        position: "relative",
        backgroundColor: t.vars ? t.vars.palette.FilledInput.bg : r,
        borderTopLeftRadius: (t.vars || t).shape.borderRadius,
        borderTopRightRadius: (t.vars || t).shape.borderRadius,
        transition: t.transitions.create("background-color", {
          duration: t.transitions.duration.shorter,
          easing: t.transitions.easing.easeOut,
        }),
        "&:hover": {
          backgroundColor: t.vars ? t.vars.palette.FilledInput.hoverBg : i,
          "@media (hover: none)": {
            backgroundColor: t.vars ? t.vars.palette.FilledInput.bg : r,
          },
        },
        [`&.${ll.focused}`]: {
          backgroundColor: t.vars ? t.vars.palette.FilledInput.bg : r,
        },
        [`&.${ll.disabled}`]: {
          backgroundColor: t.vars ? t.vars.palette.FilledInput.disabledBg : s,
        },
        variants: [
          {
            props: ({ ownerState: o }) => !o.disableUnderline,
            style: {
              "&::after": {
                left: 0,
                bottom: 0,
                content: '""',
                position: "absolute",
                right: 0,
                transform: "scaleX(0)",
                transition: t.transitions.create("transform", {
                  duration: t.transitions.duration.shorter,
                  easing: t.transitions.easing.easeOut,
                }),
                pointerEvents: "none",
              },
              [`&.${ll.focused}:after`]: {
                transform: "scaleX(1) translateX(0)",
              },
              [`&.${ll.error}`]: {
                "&::before, &::after": {
                  borderBottomColor: (t.vars || t).palette.error.main,
                },
              },
              "&::before": {
                borderBottom: `1px solid ${
                  t.vars
                    ? `rgba(${t.vars.palette.common.onBackgroundChannel} / ${t.vars.opacity.inputUnderline})`
                    : n
                }`,
                left: 0,
                bottom: 0,
                content: '"\\00a0"',
                position: "absolute",
                right: 0,
                transition: t.transitions.create("border-bottom-color", {
                  duration: t.transitions.duration.shorter,
                }),
                pointerEvents: "none",
              },
              [`&:hover:not(.${ll.disabled}, .${ll.error}):before`]: {
                borderBottom: `1px solid ${(t.vars || t).palette.text.primary}`,
              },
              [`&.${ll.disabled}:before`]: { borderBottomStyle: "dotted" },
            },
          },
          ...Object.entries(t.palette)
            .filter(hs())
            .map(([o]) => {
              var a;
              return {
                props: { disableUnderline: !1, color: o },
                style: {
                  "&::after": {
                    borderBottom: `2px solid ${
                      (a = (t.vars || t).palette[o]) == null ? void 0 : a.main
                    }`,
                  },
                },
              };
            }),
          {
            props: ({ ownerState: o }) => o.startAdornment,
            style: { paddingLeft: 12 },
          },
          {
            props: ({ ownerState: o }) => o.endAdornment,
            style: { paddingRight: 12 },
          },
          {
            props: ({ ownerState: o }) => o.multiline,
            style: { padding: "25px 12px 8px" },
          },
          {
            props: ({ ownerState: o, size: a }) => o.multiline && a === "small",
            style: { paddingTop: 21, paddingBottom: 4 },
          },
          {
            props: ({ ownerState: o }) => o.multiline && o.hiddenLabel,
            style: { paddingTop: 16, paddingBottom: 17 },
          },
          {
            props: ({ ownerState: o }) =>
              o.multiline && o.hiddenLabel && o.size === "small",
            style: { paddingTop: 8, paddingBottom: 9 },
          },
        ],
      };
    })
  ),
  JW = Ce(fv, { name: "MuiFilledInput", slot: "Input", overridesResolver: dv })(
    wt(({ theme: t }) => ({
      paddingTop: 25,
      paddingRight: 12,
      paddingBottom: 8,
      paddingLeft: 12,
      ...(!t.vars && {
        "&:-webkit-autofill": {
          WebkitBoxShadow:
            t.palette.mode === "light" ? null : "0 0 0 100px #266798 inset",
          WebkitTextFillColor: t.palette.mode === "light" ? null : "#fff",
          caretColor: t.palette.mode === "light" ? null : "#fff",
          borderTopLeftRadius: "inherit",
          borderTopRightRadius: "inherit",
        },
      }),
      ...(t.vars && {
        "&:-webkit-autofill": {
          borderTopLeftRadius: "inherit",
          borderTopRightRadius: "inherit",
        },
        [t.getColorSchemeSelector("dark")]: {
          "&:-webkit-autofill": {
            WebkitBoxShadow: "0 0 0 100px #266798 inset",
            WebkitTextFillColor: "#fff",
            caretColor: "#fff",
          },
        },
      }),
      variants: [
        {
          props: { size: "small" },
          style: { paddingTop: 21, paddingBottom: 4 },
        },
        {
          props: ({ ownerState: e }) => e.hiddenLabel,
          style: { paddingTop: 16, paddingBottom: 17 },
        },
        {
          props: ({ ownerState: e }) => e.startAdornment,
          style: { paddingLeft: 0 },
        },
        {
          props: ({ ownerState: e }) => e.endAdornment,
          style: { paddingRight: 0 },
        },
        {
          props: ({ ownerState: e }) => e.hiddenLabel && e.size === "small",
          style: { paddingTop: 8, paddingBottom: 9 },
        },
        {
          props: ({ ownerState: e }) => e.multiline,
          style: {
            paddingTop: 0,
            paddingBottom: 0,
            paddingLeft: 0,
            paddingRight: 0,
          },
        },
      ],
    }))
  ),
  uA = N.forwardRef(function (e, n) {
    const r = ft({ props: e, name: "MuiFilledInput" }),
      {
        disableUnderline: i = !1,
        components: s = {},
        componentsProps: o,
        fullWidth: a = !1,
        hiddenLabel: l,
        inputComponent: d = "input",
        multiline: p = !1,
        slotProps: f,
        slots: m = {},
        type: y = "text",
        ...g
      } = r,
      v = {
        ...r,
        disableUnderline: i,
        fullWidth: a,
        inputComponent: d,
        multiline: p,
        type: y,
      },
      b = QW(r),
      E = { root: { ownerState: v }, input: { ownerState: v } },
      S = f ?? o ? yr(E, f ?? o) : E,
      C = m.root ?? s.Root ?? XW,
      _ = m.input ?? s.Input ?? JW;
    return O.jsx(aA, {
      slots: { root: C, input: _ },
      slotProps: S,
      fullWidth: a,
      inputComponent: d,
      multiline: p,
      ref: n,
      type: y,
      ...g,
      classes: b,
    });
  });
uA.muiName = "Input";
function eH(t) {
  return st("MuiFormControl", t);
}
ut("MuiFormControl", [
  "root",
  "marginNone",
  "marginNormal",
  "marginDense",
  "fullWidth",
  "disabled",
]);
const tH = (t) => {
    const { classes: e, margin: n, fullWidth: r } = t,
      i = {
        root: ["root", n !== "none" && `margin${Re(n)}`, r && "fullWidth"],
      };
    return dt(i, eH, e);
  },
  nH = Ce("div", {
    name: "MuiFormControl",
    slot: "Root",
    overridesResolver: (t, e) => {
      const { ownerState: n } = t;
      return [e.root, e[`margin${Re(n.margin)}`], n.fullWidth && e.fullWidth];
    },
  })({
    display: "inline-flex",
    flexDirection: "column",
    position: "relative",
    minWidth: 0,
    padding: 0,
    margin: 0,
    border: 0,
    verticalAlign: "top",
    variants: [
      {
        props: { margin: "normal" },
        style: { marginTop: 16, marginBottom: 8 },
      },
      { props: { margin: "dense" }, style: { marginTop: 8, marginBottom: 4 } },
      { props: { fullWidth: !0 }, style: { width: "100%" } },
    ],
  }),
  rH = N.forwardRef(function (e, n) {
    const r = ft({ props: e, name: "MuiFormControl" }),
      {
        children: i,
        className: s,
        color: o = "primary",
        component: a = "div",
        disabled: l = !1,
        error: d = !1,
        focused: p,
        fullWidth: f = !1,
        hiddenLabel: m = !1,
        margin: y = "none",
        required: g = !1,
        size: v = "medium",
        variant: b = "outlined",
        ...E
      } = r,
      S = {
        ...r,
        color: o,
        component: a,
        disabled: l,
        error: d,
        fullWidth: f,
        hiddenLabel: m,
        margin: y,
        required: g,
        size: v,
        variant: b,
      },
      C = tH(S),
      [_, A] = N.useState(() => {
        let K = !1;
        return (
          i &&
            N.Children.forEach(i, (H) => {
              if (!R0(H, ["Input", "Select"])) return;
              const $ = R0(H, ["Select"]) ? H.props.input : H;
              $ && U7($.props) && (K = !0);
            }),
          K
        );
      }),
      [I, R] = N.useState(() => {
        let K = !1;
        return (
          i &&
            N.Children.forEach(i, (H) => {
              R0(H, ["Input", "Select"]) &&
                (cw(H.props, !0) || cw(H.props.inputProps, !0)) &&
                (K = !0);
            }),
          K
        );
      }),
      [D, k] = N.useState(!1);
    l && D && k(!1);
    const T = p !== void 0 && !l ? p : D;
    let U;
    N.useRef(!1);
    const q = N.useMemo(
      () => ({
        adornedStart: _,
        setAdornedStart: A,
        color: o,
        disabled: l,
        error: d,
        filled: I,
        focused: T,
        fullWidth: f,
        hiddenLabel: m,
        size: v,
        onBlur: () => {
          k(!1);
        },
        onEmpty: () => {
          R(!1);
        },
        onFilled: () => {
          R(!0);
        },
        onFocus: () => {
          k(!0);
        },
        registerEffect: U,
        required: g,
        variant: b,
      }),
      [_, o, l, d, I, T, f, m, U, g, v, b]
    );
    return O.jsx(oA.Provider, {
      value: q,
      children: O.jsx(nH, {
        as: a,
        ownerState: S,
        className: He(C.root, s),
        ref: n,
        ...E,
        children: i,
      }),
    });
  });
function iH(t) {
  return st("MuiFormHelperText", t);
}
const gP = ut("MuiFormHelperText", [
  "root",
  "error",
  "disabled",
  "sizeSmall",
  "sizeMedium",
  "contained",
  "focused",
  "filled",
  "required",
]);
var yP;
const sH = (t) => {
    const {
        classes: e,
        contained: n,
        size: r,
        disabled: i,
        error: s,
        filled: o,
        focused: a,
        required: l,
      } = t,
      d = {
        root: [
          "root",
          i && "disabled",
          s && "error",
          r && `size${Re(r)}`,
          n && "contained",
          a && "focused",
          o && "filled",
          l && "required",
        ],
      };
    return dt(d, iH, e);
  },
  oH = Ce("p", {
    name: "MuiFormHelperText",
    slot: "Root",
    overridesResolver: (t, e) => {
      const { ownerState: n } = t;
      return [
        e.root,
        n.size && e[`size${Re(n.size)}`],
        n.contained && e.contained,
        n.filled && e.filled,
      ];
    },
  })(
    wt(({ theme: t }) => ({
      color: (t.vars || t).palette.text.secondary,
      ...t.typography.caption,
      textAlign: "left",
      marginTop: 3,
      marginRight: 0,
      marginBottom: 0,
      marginLeft: 0,
      [`&.${gP.disabled}`]: { color: (t.vars || t).palette.text.disabled },
      [`&.${gP.error}`]: { color: (t.vars || t).palette.error.main },
      variants: [
        { props: { size: "small" }, style: { marginTop: 4 } },
        {
          props: ({ ownerState: e }) => e.contained,
          style: { marginLeft: 14, marginRight: 14 },
        },
      ],
    }))
  ),
  aH = N.forwardRef(function (e, n) {
    const r = ft({ props: e, name: "MuiFormHelperText" }),
      {
        children: i,
        className: s,
        component: o = "p",
        disabled: a,
        error: l,
        filled: d,
        focused: p,
        margin: f,
        required: m,
        variant: y,
        ...g
      } = r,
      v = Sp(),
      b = xp({
        props: r,
        muiFormControl: v,
        states: [
          "variant",
          "size",
          "disabled",
          "error",
          "filled",
          "focused",
          "required",
        ],
      }),
      E = {
        ...r,
        component: o,
        contained: b.variant === "filled" || b.variant === "outlined",
        variant: b.variant,
        size: b.size,
        disabled: b.disabled,
        error: b.error,
        filled: b.filled,
        focused: b.focused,
        required: b.required,
      };
    delete E.ownerState;
    const S = sH(E);
    return O.jsx(oH, {
      as: o,
      className: He(S.root, s),
      ref: n,
      ...g,
      ownerState: E,
      children:
        i === " "
          ? yP ||
            (yP = O.jsx("span", {
              className: "notranslate",
              "aria-hidden": !0,
              children: "",
            }))
          : i,
    });
  });
function cH(t) {
  return st("MuiFormLabel", t);
}
const gh = ut("MuiFormLabel", [
    "root",
    "colorSecondary",
    "focused",
    "disabled",
    "error",
    "filled",
    "required",
    "asterisk",
  ]),
  lH = (t) => {
    const {
        classes: e,
        color: n,
        focused: r,
        disabled: i,
        error: s,
        filled: o,
        required: a,
      } = t,
      l = {
        root: [
          "root",
          `color${Re(n)}`,
          i && "disabled",
          s && "error",
          o && "filled",
          r && "focused",
          a && "required",
        ],
        asterisk: ["asterisk", s && "error"],
      };
    return dt(l, cH, e);
  },
  uH = Ce("label", {
    name: "MuiFormLabel",
    slot: "Root",
    overridesResolver: (t, e) => {
      const { ownerState: n } = t;
      return [
        e.root,
        n.color === "secondary" && e.colorSecondary,
        n.filled && e.filled,
      ];
    },
  })(
    wt(({ theme: t }) => ({
      color: (t.vars || t).palette.text.secondary,
      ...t.typography.body1,
      lineHeight: "1.4375em",
      padding: 0,
      position: "relative",
      variants: [
        ...Object.entries(t.palette)
          .filter(hs())
          .map(([e]) => ({
            props: { color: e },
            style: {
              [`&.${gh.focused}`]: { color: (t.vars || t).palette[e].main },
            },
          })),
        {
          props: {},
          style: {
            [`&.${gh.disabled}`]: {
              color: (t.vars || t).palette.text.disabled,
            },
            [`&.${gh.error}`]: { color: (t.vars || t).palette.error.main },
          },
        },
      ],
    }))
  ),
  dH = Ce("span", {
    name: "MuiFormLabel",
    slot: "Asterisk",
    overridesResolver: (t, e) => e.asterisk,
  })(
    wt(({ theme: t }) => ({
      [`&.${gh.error}`]: { color: (t.vars || t).palette.error.main },
    }))
  ),
  pH = N.forwardRef(function (e, n) {
    const r = ft({ props: e, name: "MuiFormLabel" }),
      {
        children: i,
        className: s,
        color: o,
        component: a = "label",
        disabled: l,
        error: d,
        filled: p,
        focused: f,
        required: m,
        ...y
      } = r,
      g = Sp(),
      v = xp({
        props: r,
        muiFormControl: g,
        states: ["color", "required", "focused", "disabled", "error", "filled"],
      }),
      b = {
        ...r,
        color: v.color || "primary",
        component: a,
        disabled: v.disabled,
        error: v.error,
        filled: v.filled,
        focused: v.focused,
        required: v.required,
      },
      E = lH(b);
    return O.jsxs(uH, {
      as: a,
      ownerState: b,
      className: He(E.root, s),
      ref: n,
      ...y,
      children: [
        i,
        v.required &&
          O.jsxs(dH, {
            ownerState: b,
            "aria-hidden": !0,
            className: E.asterisk,
            children: ["", "*"],
          }),
      ],
    });
  }),
  xn = vF({
    createStyledComponent: Ce("div", {
      name: "MuiGrid2",
      slot: "Root",
      overridesResolver: (t, e) => {
        const { ownerState: n } = t;
        return [e.root, n.container && e.container];
      },
    }),
    componentName: "MuiGrid2",
    useThemeProps: (t) => ft({ props: t, name: "MuiGrid2" }),
    useTheme: Ii,
  });
function ox(t) {
  return `scale(${t}, ${t ** 2})`;
}
const fH = {
    entering: { opacity: 1, transform: ox(1) },
    entered: { opacity: 1, transform: "none" },
  },
  sE =
    typeof navigator < "u" &&
    /^((?!chrome|android).)*(safari|mobile)/i.test(navigator.userAgent) &&
    /(os |version\/)15(.|_)4/i.test(navigator.userAgent),
  Uh = N.forwardRef(function (e, n) {
    const {
        addEndListener: r,
        appear: i = !0,
        children: s,
        easing: o,
        in: a,
        onEnter: l,
        onEntered: d,
        onEntering: p,
        onExit: f,
        onExited: m,
        onExiting: y,
        style: g,
        timeout: v = "auto",
        TransitionComponent: b = Cs,
        ...E
      } = e,
      S = Ac(),
      C = N.useRef(),
      _ = Ii(),
      A = N.useRef(null),
      I = In(A, qc(s), n),
      R = ($) => (M) => {
        if ($) {
          const z = A.current;
          M === void 0 ? $(z) : $(z, M);
        }
      },
      D = R(p),
      k = R(($, M) => {
        QS($);
        const {
          duration: z,
          delay: B,
          easing: j,
        } = Uc({ style: g, timeout: v, easing: o }, { mode: "enter" });
        let V;
        v === "auto"
          ? ((V = _.transitions.getAutoHeightDuration($.clientHeight)),
            (C.current = V))
          : (V = z),
          ($.style.transition = [
            _.transitions.create("opacity", { duration: V, delay: B }),
            _.transitions.create("transform", {
              duration: sE ? V : V * 0.666,
              delay: B,
              easing: j,
            }),
          ].join(",")),
          l && l($, M);
      }),
      T = R(d),
      U = R(y),
      q = R(($) => {
        const {
          duration: M,
          delay: z,
          easing: B,
        } = Uc({ style: g, timeout: v, easing: o }, { mode: "exit" });
        let j;
        v === "auto"
          ? ((j = _.transitions.getAutoHeightDuration($.clientHeight)),
            (C.current = j))
          : (j = M),
          ($.style.transition = [
            _.transitions.create("opacity", { duration: j, delay: z }),
            _.transitions.create("transform", {
              duration: sE ? j : j * 0.666,
              delay: sE ? z : z || j * 0.333,
              easing: B,
            }),
          ].join(",")),
          ($.style.opacity = 0),
          ($.style.transform = ox(0.75)),
          f && f($);
      }),
      K = R(m),
      H = ($) => {
        v === "auto" && S.start(C.current || 0, $), r && r(A.current, $);
      };
    return O.jsx(b, {
      appear: i,
      in: a,
      nodeRef: A,
      onEnter: k,
      onEntered: T,
      onEntering: D,
      onExit: q,
      onExited: K,
      onExiting: U,
      addEndListener: H,
      timeout: v === "auto" ? null : v,
      ...E,
      children: ($, { ownerState: M, ...z }) =>
        N.cloneElement(s, {
          style: {
            opacity: 0,
            transform: ox(0.75),
            visibility: $ === "exited" && !a ? "hidden" : void 0,
            ...fH[$],
            ...g,
            ...s.props.style,
          },
          ref: I,
          ...z,
        }),
    });
  });
Uh && (Uh.muiSupportAuto = !0);
const xs = kj({ themeId: Mm }),
  _c = ["xs", "sm", "md", "lg", "xl"],
  hH = (t, e, n = !0) =>
    n ? _c.indexOf(t) <= _c.indexOf(e) : _c.indexOf(t) < _c.indexOf(e),
  mH = (t, e, n = !1) =>
    n ? _c.indexOf(e) <= _c.indexOf(t) : _c.indexOf(e) < _c.indexOf(t),
  gH =
    (t = {}) =>
    (e) => {
      const { withTheme: n = !1, noSSR: r = !1, initialWidth: i } = t;
      function s(o) {
        const a = Ii(),
          l = o.theme || a,
          {
            initialWidth: d,
            width: p,
            ...f
          } = zS({ theme: l, name: "MuiWithWidth", props: o }),
          [m, y] = N.useState(!1);
        ws(() => {
          y(!0);
        }, []);
        const v = l.breakpoints.keys
            .slice()
            .reverse()
            .reduce((E, S) => {
              const C = xs(l.breakpoints.up(S));
              return !E && C ? S : E;
            }, null),
          b = {
            width: p || (m || r ? v : void 0) || d || i,
            ...(n ? { theme: l } : {}),
            ...f,
          };
        return b.width === void 0 ? null : O.jsx(e, { ...b });
      }
      return s;
    };
function L3(t) {
  const { children: e, only: n, width: r } = t,
    i = Ii();
  let s = !0;
  if (n)
    if (Array.isArray(n))
      for (let o = 0; o < n.length; o += 1) {
        const a = n[o];
        if (r === a) {
          s = !1;
          break;
        }
      }
    else n && r === n && (s = !1);
  if (s)
    for (let o = 0; o < i.breakpoints.keys.length; o += 1) {
      const a = i.breakpoints.keys[o],
        l = t[`${a}Up`],
        d = t[`${a}Down`];
      if ((l && hH(a, r)) || (d && mH(a, r))) {
        s = !1;
        break;
      }
    }
  return s ? e : null;
}
L3.propTypes = {
  children: jr.node,
  lgDown: jr.bool,
  lgUp: jr.bool,
  mdDown: jr.bool,
  mdUp: jr.bool,
  only: jr.oneOfType([
    jr.oneOf(["xs", "sm", "md", "lg", "xl"]),
    jr.arrayOf(jr.oneOf(["xs", "sm", "md", "lg", "xl"])),
  ]),
  smDown: jr.bool,
  smUp: jr.bool,
  width: jr.string.isRequired,
  xlDown: jr.bool,
  xlUp: jr.bool,
  xsDown: jr.bool,
  xsUp: jr.bool,
};
const yH = gH()(L3);
function wH(t) {
  return st("PrivateHiddenCss", t);
}
ut("PrivateHiddenCss", [
  "root",
  "xlDown",
  "xlUp",
  "onlyXl",
  "lgDown",
  "lgUp",
  "onlyLg",
  "mdDown",
  "mdUp",
  "onlyMd",
  "smDown",
  "smUp",
  "onlySm",
  "xsDown",
  "xsUp",
  "onlyXs",
]);
const vH = (t) => {
    const { classes: e, breakpoints: n } = t,
      r = {
        root: [
          "root",
          ...n.map(({ breakpoint: i, dir: s }) =>
            s === "only" ? `${s}${Re(i)}` : `${i}${Re(s)}`
          ),
        ],
      };
    return dt(r, wH, e);
  },
  bH = Ce("div", { name: "PrivateHiddenCss", slot: "Root" })(
    ({ theme: t, ownerState: e }) => {
      const n = { display: "none" };
      return {
        ...e.breakpoints
          .map(({ breakpoint: r, dir: i }) =>
            i === "only"
              ? { [t.breakpoints.only(r)]: n }
              : i === "up"
              ? { [t.breakpoints.up(r)]: n }
              : { [t.breakpoints.down(r)]: n }
          )
          .reduce(
            (r, i) => (
              Object.keys(i).forEach((s) => {
                r[s] = i[s];
              }),
              r
            ),
            {}
          ),
      };
    }
  );
function EH(t) {
  const { children: e, className: n, only: r, ...i } = t,
    s = Ii(),
    o = [];
  for (let d = 0; d < s.breakpoints.keys.length; d += 1) {
    const p = s.breakpoints.keys[d],
      f = i[`${p}Up`],
      m = i[`${p}Down`];
    f && o.push({ breakpoint: p, dir: "up" }),
      m && o.push({ breakpoint: p, dir: "down" });
  }
  r &&
    (Array.isArray(r) ? r : [r]).forEach((p) => {
      o.push({ breakpoint: p, dir: "only" });
    });
  const a = { ...t, breakpoints: o },
    l = vH(a);
  return O.jsx(bH, { className: He(l.root, n), ownerState: a, children: e });
}
function oE(t) {
  const {
    implementation: e = "js",
    lgDown: n = !1,
    lgUp: r = !1,
    mdDown: i = !1,
    mdUp: s = !1,
    smDown: o = !1,
    smUp: a = !1,
    xlDown: l = !1,
    xlUp: d = !1,
    xsDown: p = !1,
    xsUp: f = !1,
    ...m
  } = t;
  return e === "js"
    ? O.jsx(yH, {
        lgDown: n,
        lgUp: r,
        mdDown: i,
        mdUp: s,
        smDown: o,
        smUp: a,
        xlDown: l,
        xlUp: d,
        xsDown: p,
        xsUp: f,
        ...m,
      })
    : O.jsx(EH, {
        lgDown: n,
        lgUp: r,
        mdDown: i,
        mdUp: s,
        smDown: o,
        smUp: a,
        xlDown: l,
        xlUp: d,
        xsDown: p,
        xsUp: f,
        ...m,
      });
}
const CH = (t) => {
    const { classes: e, disableUnderline: n } = t,
      i = dt({ root: ["root", !n && "underline"], input: ["input"] }, F7, e);
    return { ...e, ...i };
  },
  xH = Ce(pv, {
    shouldForwardProp: (t) => Gi(t) || t === "classes",
    name: "MuiInput",
    slot: "Root",
    overridesResolver: (t, e) => {
      const { ownerState: n } = t;
      return [...uv(t, e), !n.disableUnderline && e.underline];
    },
  })(
    wt(({ theme: t }) => {
      let n =
        t.palette.mode === "light"
          ? "rgba(0, 0, 0, 0.42)"
          : "rgba(255, 255, 255, 0.7)";
      return (
        t.vars &&
          (n = `rgba(${t.vars.palette.common.onBackgroundChannel} / ${t.vars.opacity.inputUnderline})`),
        {
          position: "relative",
          variants: [
            {
              props: ({ ownerState: r }) => r.formControl,
              style: { "label + &": { marginTop: 16 } },
            },
            {
              props: ({ ownerState: r }) => !r.disableUnderline,
              style: {
                "&::after": {
                  left: 0,
                  bottom: 0,
                  content: '""',
                  position: "absolute",
                  right: 0,
                  transform: "scaleX(0)",
                  transition: t.transitions.create("transform", {
                    duration: t.transitions.duration.shorter,
                    easing: t.transitions.easing.easeOut,
                  }),
                  pointerEvents: "none",
                },
                [`&.${If.focused}:after`]: {
                  transform: "scaleX(1) translateX(0)",
                },
                [`&.${If.error}`]: {
                  "&::before, &::after": {
                    borderBottomColor: (t.vars || t).palette.error.main,
                  },
                },
                "&::before": {
                  borderBottom: `1px solid ${n}`,
                  left: 0,
                  bottom: 0,
                  content: '"\\00a0"',
                  position: "absolute",
                  right: 0,
                  transition: t.transitions.create("border-bottom-color", {
                    duration: t.transitions.duration.shorter,
                  }),
                  pointerEvents: "none",
                },
                [`&:hover:not(.${If.disabled}, .${If.error}):before`]: {
                  borderBottom: `2px solid ${
                    (t.vars || t).palette.text.primary
                  }`,
                  "@media (hover: none)": { borderBottom: `1px solid ${n}` },
                },
                [`&.${If.disabled}:before`]: { borderBottomStyle: "dotted" },
              },
            },
            ...Object.entries(t.palette)
              .filter(hs())
              .map(([r]) => ({
                props: { color: r, disableUnderline: !1 },
                style: {
                  "&::after": {
                    borderBottom: `2px solid ${(t.vars || t).palette[r].main}`,
                  },
                },
              })),
          ],
        }
      );
    })
  ),
  SH = Ce(fv, { name: "MuiInput", slot: "Input", overridesResolver: dv })({}),
  dA = N.forwardRef(function (e, n) {
    const r = ft({ props: e, name: "MuiInput" }),
      {
        disableUnderline: i = !1,
        components: s = {},
        componentsProps: o,
        fullWidth: a = !1,
        inputComponent: l = "input",
        multiline: d = !1,
        slotProps: p,
        slots: f = {},
        type: m = "text",
        ...y
      } = r,
      g = CH(r),
      b = { root: { ownerState: { disableUnderline: i } } },
      E = p ?? o ? yr(p ?? o, b) : b,
      S = f.root ?? s.Root ?? xH,
      C = f.input ?? s.Input ?? SH;
    return O.jsx(aA, {
      slots: { root: S, input: C },
      slotProps: E,
      fullWidth: a,
      inputComponent: l,
      multiline: d,
      ref: n,
      type: m,
      ...y,
      classes: g,
    });
  });
dA.muiName = "Input";
function AH(t) {
  return st("MuiInputLabel", t);
}
ut("MuiInputLabel", [
  "root",
  "focused",
  "disabled",
  "error",
  "required",
  "asterisk",
  "formControl",
  "sizeSmall",
  "shrink",
  "animated",
  "standard",
  "filled",
  "outlined",
]);
const _H = (t) => {
    const {
        classes: e,
        formControl: n,
        size: r,
        shrink: i,
        disableAnimation: s,
        variant: o,
        required: a,
      } = t,
      l = {
        root: [
          "root",
          n && "formControl",
          !s && "animated",
          i && "shrink",
          r && r !== "normal" && `size${Re(r)}`,
          o,
        ],
        asterisk: [a && "asterisk"],
      },
      d = dt(l, AH, e);
    return { ...e, ...d };
  },
  IH = Ce(pH, {
    shouldForwardProp: (t) => Gi(t) || t === "classes",
    name: "MuiInputLabel",
    slot: "Root",
    overridesResolver: (t, e) => {
      const { ownerState: n } = t;
      return [
        { [`& .${gh.asterisk}`]: e.asterisk },
        e.root,
        n.formControl && e.formControl,
        n.size === "small" && e.sizeSmall,
        n.shrink && e.shrink,
        !n.disableAnimation && e.animated,
        n.focused && e.focused,
        e[n.variant],
      ];
    },
  })(
    wt(({ theme: t }) => ({
      display: "block",
      transformOrigin: "top left",
      whiteSpace: "nowrap",
      overflow: "hidden",
      textOverflow: "ellipsis",
      maxWidth: "100%",
      variants: [
        {
          props: ({ ownerState: e }) => e.formControl,
          style: {
            position: "absolute",
            left: 0,
            top: 0,
            transform: "translate(0, 20px) scale(1)",
          },
        },
        {
          props: { size: "small" },
          style: { transform: "translate(0, 17px) scale(1)" },
        },
        {
          props: ({ ownerState: e }) => e.shrink,
          style: {
            transform: "translate(0, -1.5px) scale(0.75)",
            transformOrigin: "top left",
            maxWidth: "133%",
          },
        },
        {
          props: ({ ownerState: e }) => !e.disableAnimation,
          style: {
            transition: t.transitions.create(
              ["color", "transform", "max-width"],
              {
                duration: t.transitions.duration.shorter,
                easing: t.transitions.easing.easeOut,
              }
            ),
          },
        },
        {
          props: { variant: "filled" },
          style: {
            zIndex: 1,
            pointerEvents: "none",
            transform: "translate(12px, 16px) scale(1)",
            maxWidth: "calc(100% - 24px)",
          },
        },
        {
          props: { variant: "filled", size: "small" },
          style: { transform: "translate(12px, 13px) scale(1)" },
        },
        {
          props: ({ variant: e, ownerState: n }) => e === "filled" && n.shrink,
          style: {
            userSelect: "none",
            pointerEvents: "auto",
            transform: "translate(12px, 7px) scale(0.75)",
            maxWidth: "calc(133% - 24px)",
          },
        },
        {
          props: ({ variant: e, ownerState: n, size: r }) =>
            e === "filled" && n.shrink && r === "small",
          style: { transform: "translate(12px, 4px) scale(0.75)" },
        },
        {
          props: { variant: "outlined" },
          style: {
            zIndex: 1,
            pointerEvents: "none",
            transform: "translate(14px, 16px) scale(1)",
            maxWidth: "calc(100% - 24px)",
          },
        },
        {
          props: { variant: "outlined", size: "small" },
          style: { transform: "translate(14px, 9px) scale(1)" },
        },
        {
          props: ({ variant: e, ownerState: n }) =>
            e === "outlined" && n.shrink,
          style: {
            userSelect: "none",
            pointerEvents: "auto",
            maxWidth: "calc(133% - 32px)",
            transform: "translate(14px, -9px) scale(0.75)",
          },
        },
      ],
    }))
  ),
  TH = N.forwardRef(function (e, n) {
    const r = ft({ name: "MuiInputLabel", props: e }),
      {
        disableAnimation: i = !1,
        margin: s,
        shrink: o,
        variant: a,
        className: l,
        ...d
      } = r,
      p = Sp();
    let f = o;
    typeof f > "u" && p && (f = p.filled || p.focused || p.adornedStart);
    const m = xp({
        props: r,
        muiFormControl: p,
        states: ["size", "variant", "required", "focused"],
      }),
      y = {
        ...r,
        disableAnimation: i,
        formControl: p,
        shrink: f,
        size: m.size,
        variant: m.variant,
        required: m.required,
        focused: m.focused,
      },
      g = _H(y);
    return O.jsx(IH, {
      "data-shrink": f,
      ref: n,
      className: He(g.root, l),
      ...d,
      ownerState: y,
      classes: g,
    });
  }),
  ax = N.createContext({});
function PH(t) {
  return st("MuiList", t);
}
ut("MuiList", ["root", "padding", "dense", "subheader"]);
const RH = (t) => {
    const { classes: e, disablePadding: n, dense: r, subheader: i } = t;
    return dt(
      { root: ["root", !n && "padding", r && "dense", i && "subheader"] },
      PH,
      e
    );
  },
  NH = Ce("ul", {
    name: "MuiList",
    slot: "Root",
    overridesResolver: (t, e) => {
      const { ownerState: n } = t;
      return [
        e.root,
        !n.disablePadding && e.padding,
        n.dense && e.dense,
        n.subheader && e.subheader,
      ];
    },
  })({
    listStyle: "none",
    margin: 0,
    padding: 0,
    position: "relative",
    variants: [
      {
        props: ({ ownerState: t }) => !t.disablePadding,
        style: { paddingTop: 8, paddingBottom: 8 },
      },
      { props: ({ ownerState: t }) => t.subheader, style: { paddingTop: 0 } },
    ],
  }),
  U3 = N.forwardRef(function (e, n) {
    const r = ft({ props: e, name: "MuiList" }),
      {
        children: i,
        className: s,
        component: o = "ul",
        dense: a = !1,
        disablePadding: l = !1,
        subheader: d,
        ...p
      } = r,
      f = N.useMemo(() => ({ dense: a }), [a]),
      m = { ...r, component: o, dense: a, disablePadding: l },
      y = RH(m);
    return O.jsx(ax.Provider, {
      value: f,
      children: O.jsxs(NH, {
        as: o,
        className: He(y.root, s),
        ref: n,
        ownerState: m,
        ...p,
        children: [d, i],
      }),
    });
  });
function OH(t) {
  return st("MuiListItemButton", t);
}
const Tf = ut("MuiListItemButton", [
    "root",
    "focusVisible",
    "dense",
    "alignItemsFlexStart",
    "disabled",
    "divider",
    "gutters",
    "selected",
  ]),
  kH = (t, e) => {
    const { ownerState: n } = t;
    return [
      e.root,
      n.dense && e.dense,
      n.alignItems === "flex-start" && e.alignItemsFlexStart,
      n.divider && e.divider,
      !n.disableGutters && e.gutters,
    ];
  },
  DH = (t) => {
    const {
        alignItems: e,
        classes: n,
        dense: r,
        disabled: i,
        disableGutters: s,
        divider: o,
        selected: a,
      } = t,
      d = dt(
        {
          root: [
            "root",
            r && "dense",
            !s && "gutters",
            o && "divider",
            i && "disabled",
            e === "flex-start" && "alignItemsFlexStart",
            a && "selected",
          ],
        },
        OH,
        n
      );
    return { ...n, ...d };
  },
  $H = Ce(Wm, {
    shouldForwardProp: (t) => Gi(t) || t === "classes",
    name: "MuiListItemButton",
    slot: "Root",
    overridesResolver: kH,
  })(
    wt(({ theme: t }) => ({
      display: "flex",
      flexGrow: 1,
      justifyContent: "flex-start",
      alignItems: "center",
      position: "relative",
      textDecoration: "none",
      minWidth: 0,
      boxSizing: "border-box",
      textAlign: "left",
      paddingTop: 8,
      paddingBottom: 8,
      transition: t.transitions.create("background-color", {
        duration: t.transitions.duration.shortest,
      }),
      "&:hover": {
        textDecoration: "none",
        backgroundColor: (t.vars || t).palette.action.hover,
        "@media (hover: none)": { backgroundColor: "transparent" },
      },
      [`&.${Tf.selected}`]: {
        backgroundColor: t.vars
          ? `rgba(${t.vars.palette.primary.mainChannel} / ${t.vars.palette.action.selectedOpacity})`
          : An(t.palette.primary.main, t.palette.action.selectedOpacity),
        [`&.${Tf.focusVisible}`]: {
          backgroundColor: t.vars
            ? `rgba(${t.vars.palette.primary.mainChannel} / calc(${t.vars.palette.action.selectedOpacity} + ${t.vars.palette.action.focusOpacity}))`
            : An(
                t.palette.primary.main,
                t.palette.action.selectedOpacity + t.palette.action.focusOpacity
              ),
        },
      },
      [`&.${Tf.selected}:hover`]: {
        backgroundColor: t.vars
          ? `rgba(${t.vars.palette.primary.mainChannel} / calc(${t.vars.palette.action.selectedOpacity} + ${t.vars.palette.action.hoverOpacity}))`
          : An(
              t.palette.primary.main,
              t.palette.action.selectedOpacity + t.palette.action.hoverOpacity
            ),
        "@media (hover: none)": {
          backgroundColor: t.vars
            ? `rgba(${t.vars.palette.primary.mainChannel} / ${t.vars.palette.action.selectedOpacity})`
            : An(t.palette.primary.main, t.palette.action.selectedOpacity),
        },
      },
      [`&.${Tf.focusVisible}`]: {
        backgroundColor: (t.vars || t).palette.action.focus,
      },
      [`&.${Tf.disabled}`]: {
        opacity: (t.vars || t).palette.action.disabledOpacity,
      },
      variants: [
        {
          props: ({ ownerState: e }) => e.divider,
          style: {
            borderBottom: `1px solid ${(t.vars || t).palette.divider}`,
            backgroundClip: "padding-box",
          },
        },
        {
          props: { alignItems: "flex-start" },
          style: { alignItems: "flex-start" },
        },
        {
          props: ({ ownerState: e }) => !e.disableGutters,
          style: { paddingLeft: 16, paddingRight: 16 },
        },
        {
          props: ({ ownerState: e }) => e.dense,
          style: { paddingTop: 4, paddingBottom: 4 },
        },
      ],
    }))
  ),
  MH = N.forwardRef(function (e, n) {
    const r = ft({ props: e, name: "MuiListItemButton" }),
      {
        alignItems: i = "center",
        autoFocus: s = !1,
        component: o = "div",
        children: a,
        dense: l = !1,
        disableGutters: d = !1,
        divider: p = !1,
        focusVisibleClassName: f,
        selected: m = !1,
        className: y,
        ...g
      } = r,
      v = N.useContext(ax),
      b = N.useMemo(
        () => ({ dense: l || v.dense || !1, alignItems: i, disableGutters: d }),
        [i, v.dense, l, d]
      ),
      E = N.useRef(null);
    ws(() => {
      s && E.current && E.current.focus();
    }, [s]);
    const S = {
        ...r,
        alignItems: i,
        dense: b.dense,
        disableGutters: d,
        divider: p,
        selected: m,
      },
      C = DH(S),
      _ = In(E, n);
    return O.jsx(ax.Provider, {
      value: b,
      children: O.jsx($H, {
        ref: _,
        href: g.href || g.to,
        component: (g.href || g.to) && o === "div" ? "button" : o,
        focusVisibleClassName: He(C.focusVisible, f),
        ownerState: S,
        className: He(C.root, y),
        ...g,
        classes: C,
        children: a,
      }),
    });
  });
function aE(t, e, n) {
  return t === e
    ? t.firstChild
    : e && e.nextElementSibling
    ? e.nextElementSibling
    : n
    ? null
    : t.firstChild;
}
function wP(t, e, n) {
  return t === e
    ? n
      ? t.firstChild
      : t.lastChild
    : e && e.previousElementSibling
    ? e.previousElementSibling
    : n
    ? null
    : t.lastChild;
}
function B3(t, e) {
  if (e === void 0) return !0;
  let n = t.innerText;
  return (
    n === void 0 && (n = t.textContent),
    (n = n.trim().toLowerCase()),
    n.length === 0
      ? !1
      : e.repeating
      ? n[0] === e.keys[0]
      : n.startsWith(e.keys.join(""))
  );
}
function Pf(t, e, n, r, i, s) {
  let o = !1,
    a = i(t, e, e ? n : !1);
  for (; a; ) {
    if (a === t.firstChild) {
      if (o) return !1;
      o = !0;
    }
    const l = r ? !1 : a.disabled || a.getAttribute("aria-disabled") === "true";
    if (!a.hasAttribute("tabindex") || !B3(a, s) || l) a = i(t, a, n);
    else return a.focus(), !0;
  }
  return !1;
}
const LH = N.forwardRef(function (e, n) {
  const {
      actions: r,
      autoFocus: i = !1,
      autoFocusItem: s = !1,
      children: o,
      className: a,
      disabledItemsFocusable: l = !1,
      disableListWrap: d = !1,
      onKeyDown: p,
      variant: f = "selectedMenu",
      ...m
    } = e,
    y = N.useRef(null),
    g = N.useRef({
      keys: [],
      repeating: !0,
      previousKeyMatched: !0,
      lastTime: null,
    });
  ws(() => {
    i && y.current.focus();
  }, [i]),
    N.useImperativeHandle(
      r,
      () => ({
        adjustStyleForScrollbar: (C, { direction: _ }) => {
          const A = !y.current.style.width;
          if (C.clientHeight < y.current.clientHeight && A) {
            const I = `${i3(Xs(C))}px`;
            (y.current.style[_ === "rtl" ? "paddingLeft" : "paddingRight"] = I),
              (y.current.style.width = `calc(100% + ${I})`);
          }
          return y.current;
        },
      }),
      []
    );
  const v = (C) => {
      const _ = y.current,
        A = C.key;
      if (C.ctrlKey || C.metaKey || C.altKey) {
        p && p(C);
        return;
      }
      const R = qr(_).activeElement;
      if (A === "ArrowDown") C.preventDefault(), Pf(_, R, d, l, aE);
      else if (A === "ArrowUp") C.preventDefault(), Pf(_, R, d, l, wP);
      else if (A === "Home") C.preventDefault(), Pf(_, null, d, l, aE);
      else if (A === "End") C.preventDefault(), Pf(_, null, d, l, wP);
      else if (A.length === 1) {
        const D = g.current,
          k = A.toLowerCase(),
          T = performance.now();
        D.keys.length > 0 &&
          (T - D.lastTime > 500
            ? ((D.keys = []), (D.repeating = !0), (D.previousKeyMatched = !0))
            : D.repeating && k !== D.keys[0] && (D.repeating = !1)),
          (D.lastTime = T),
          D.keys.push(k);
        const U = R && !D.repeating && B3(R, D);
        D.previousKeyMatched && (U || Pf(_, R, !1, l, aE, D))
          ? C.preventDefault()
          : (D.previousKeyMatched = !1);
      }
      p && p(C);
    },
    b = In(y, n);
  let E = -1;
  N.Children.forEach(o, (C, _) => {
    if (!N.isValidElement(C)) {
      E === _ && ((E += 1), E >= o.length && (E = -1));
      return;
    }
    C.props.disabled ||
      (((f === "selectedMenu" && C.props.selected) || E === -1) && (E = _)),
      E === _ &&
        (C.props.disabled ||
          C.props.muiSkipListHighlight ||
          C.type.muiSkipListHighlight) &&
        ((E += 1), E >= o.length && (E = -1));
  });
  const S = N.Children.map(o, (C, _) => {
    if (_ === E) {
      const A = {};
      return (
        s && (A.autoFocus = !0),
        C.props.tabIndex === void 0 && f === "selectedMenu" && (A.tabIndex = 0),
        N.cloneElement(C, A)
      );
    }
    return C;
  });
  return O.jsx(U3, {
    role: "menu",
    ref: b,
    className: a,
    onKeyDown: v,
    tabIndex: i ? 0 : -1,
    ...m,
    children: S,
  });
});
function UH(t) {
  return st("MuiPopover", t);
}
ut("MuiPopover", ["root", "paper"]);
function vP(t, e) {
  let n = 0;
  return (
    typeof e == "number"
      ? (n = e)
      : e === "center"
      ? (n = t.height / 2)
      : e === "bottom" && (n = t.height),
    n
  );
}
function bP(t, e) {
  let n = 0;
  return (
    typeof e == "number"
      ? (n = e)
      : e === "center"
      ? (n = t.width / 2)
      : e === "right" && (n = t.width),
    n
  );
}
function EP(t) {
  return [t.horizontal, t.vertical]
    .map((e) => (typeof e == "number" ? `${e}px` : e))
    .join(" ");
}
function cE(t) {
  return typeof t == "function" ? t() : t;
}
const BH = (t) => {
    const { classes: e } = t;
    return dt({ root: ["root"], paper: ["paper"] }, UH, e);
  },
  jH = Ce(lA, {
    name: "MuiPopover",
    slot: "Root",
    overridesResolver: (t, e) => e.root,
  })({}),
  j3 = Ce(Vc, {
    name: "MuiPopover",
    slot: "Paper",
    overridesResolver: (t, e) => e.paper,
  })({
    position: "absolute",
    overflowY: "auto",
    overflowX: "hidden",
    minWidth: 16,
    minHeight: 16,
    maxWidth: "calc(100% - 32px)",
    maxHeight: "calc(100% - 32px)",
    outline: 0,
  }),
  FH = N.forwardRef(function (e, n) {
    const r = ft({ props: e, name: "MuiPopover" }),
      {
        action: i,
        anchorEl: s,
        anchorOrigin: o = { vertical: "top", horizontal: "left" },
        anchorPosition: a,
        anchorReference: l = "anchorEl",
        children: d,
        className: p,
        container: f,
        elevation: m = 8,
        marginThreshold: y = 16,
        open: g,
        PaperProps: v = {},
        slots: b = {},
        slotProps: E = {},
        transformOrigin: S = { vertical: "top", horizontal: "left" },
        TransitionComponent: C = Uh,
        transitionDuration: _ = "auto",
        TransitionProps: { onEntering: A, ...I } = {},
        disableScrollLock: R = !1,
        ...D
      } = r,
      k = (E == null ? void 0 : E.paper) ?? v,
      T = N.useRef(),
      U = {
        ...r,
        anchorOrigin: o,
        anchorReference: l,
        elevation: m,
        marginThreshold: y,
        externalPaperSlotProps: k,
        transformOrigin: S,
        TransitionComponent: C,
        transitionDuration: _,
        TransitionProps: I,
      },
      q = BH(U),
      K = N.useCallback(() => {
        if (l === "anchorPosition") return a;
        const Se = cE(s),
          Pe = (
            Se && Se.nodeType === 1 ? Se : qr(T.current).body
          ).getBoundingClientRect();
        return {
          top: Pe.top + vP(Pe, o.vertical),
          left: Pe.left + bP(Pe, o.horizontal),
        };
      }, [s, o.horizontal, o.vertical, a, l]),
      H = N.useCallback(
        (Se) => ({
          vertical: vP(Se, S.vertical),
          horizontal: bP(Se, S.horizontal),
        }),
        [S.horizontal, S.vertical]
      ),
      $ = N.useCallback(
        (Se) => {
          const je = { width: Se.offsetWidth, height: Se.offsetHeight },
            Pe = H(je);
          if (l === "none")
            return { top: null, left: null, transformOrigin: EP(Pe) };
          const We = K();
          let Ne = We.top - Pe.vertical,
            pt = We.left - Pe.horizontal;
          const hn = Ne + je.height,
            Wt = pt + je.width,
            Lt = Xs(cE(s)),
            vn = Lt.innerHeight - y,
            At = Lt.innerWidth - y;
          if (y !== null && Ne < y) {
            const vt = Ne - y;
            (Ne -= vt), (Pe.vertical += vt);
          } else if (y !== null && hn > vn) {
            const vt = hn - vn;
            (Ne -= vt), (Pe.vertical += vt);
          }
          if (y !== null && pt < y) {
            const vt = pt - y;
            (pt -= vt), (Pe.horizontal += vt);
          } else if (Wt > At) {
            const vt = Wt - At;
            (pt -= vt), (Pe.horizontal += vt);
          }
          return {
            top: `${Math.round(Ne)}px`,
            left: `${Math.round(pt)}px`,
            transformOrigin: EP(Pe),
          };
        },
        [s, l, K, H, y]
      ),
      [M, z] = N.useState(g),
      B = N.useCallback(() => {
        const Se = T.current;
        if (!Se) return;
        const je = $(Se);
        je.top !== null && Se.style.setProperty("top", je.top),
          je.left !== null && (Se.style.left = je.left),
          (Se.style.transformOrigin = je.transformOrigin),
          z(!0);
      }, [$]);
    N.useEffect(
      () => (
        R && window.addEventListener("scroll", B),
        () => window.removeEventListener("scroll", B)
      ),
      [s, R, B]
    );
    const j = (Se, je) => {
        A && A(Se, je), B();
      },
      V = () => {
        z(!1);
      };
    N.useEffect(() => {
      g && B();
    }),
      N.useImperativeHandle(
        i,
        () =>
          g
            ? {
                updatePosition: () => {
                  B();
                },
              }
            : null,
        [g, B]
      ),
      N.useEffect(() => {
        if (!g) return;
        const Se = qS(() => {
            B();
          }),
          je = Xs(s);
        return (
          je.addEventListener("resize", Se),
          () => {
            Se.clear(), je.removeEventListener("resize", Se);
          }
        );
      }, [s, g, B]);
    let W = _;
    _ === "auto" && !C.muiSupportAuto && (W = void 0);
    const Z = f || (s ? qr(cE(s)).body : void 0),
      ee = { slots: b, slotProps: { ...E, paper: k } },
      [J, se] = Jn("paper", {
        elementType: j3,
        externalForwardedProps: ee,
        additionalProps: {
          elevation: m,
          className: He(q.paper, k == null ? void 0 : k.className),
          style: M ? k.style : { ...k.style, opacity: 0 },
        },
        ownerState: U,
      }),
      [re, { slotProps: fe, ...ce }] = Jn("root", {
        elementType: jH,
        externalForwardedProps: ee,
        additionalProps: {
          slotProps: { backdrop: { invisible: !0 } },
          container: Z,
          open: g,
        },
        ownerState: U,
        className: He(q.root, p),
      }),
      le = In(T, se.ref);
    return O.jsx(re, {
      ...ce,
      ...(!sx(re) && { slotProps: fe, disableScrollLock: R }),
      ...D,
      ref: n,
      children: O.jsx(C, {
        appear: !0,
        in: g,
        onEntering: j,
        onExited: V,
        timeout: W,
        ...I,
        children: O.jsx(J, { ...se, ref: le, children: d }),
      }),
    });
  });
function zH(t) {
  return st("MuiMenu", t);
}
ut("MuiMenu", ["root", "paper", "list"]);
const WH = { vertical: "top", horizontal: "right" },
  HH = { vertical: "top", horizontal: "left" },
  qH = (t) => {
    const { classes: e } = t;
    return dt({ root: ["root"], paper: ["paper"], list: ["list"] }, zH, e);
  },
  VH = Ce(FH, {
    shouldForwardProp: (t) => Gi(t) || t === "classes",
    name: "MuiMenu",
    slot: "Root",
    overridesResolver: (t, e) => e.root,
  })({}),
  GH = Ce(j3, {
    name: "MuiMenu",
    slot: "Paper",
    overridesResolver: (t, e) => e.paper,
  })({ maxHeight: "calc(100% - 96px)", WebkitOverflowScrolling: "touch" }),
  KH = Ce(LH, {
    name: "MuiMenu",
    slot: "List",
    overridesResolver: (t, e) => e.list,
  })({ outline: 0 }),
  YH = N.forwardRef(function (e, n) {
    const r = ft({ props: e, name: "MuiMenu" }),
      {
        autoFocus: i = !0,
        children: s,
        className: o,
        disableAutoFocusItem: a = !1,
        MenuListProps: l = {},
        onClose: d,
        open: p,
        PaperProps: f = {},
        PopoverClasses: m,
        transitionDuration: y = "auto",
        TransitionProps: { onEntering: g, ...v } = {},
        variant: b = "selectedMenu",
        slots: E = {},
        slotProps: S = {},
        ...C
      } = r,
      _ = av(),
      A = {
        ...r,
        autoFocus: i,
        disableAutoFocusItem: a,
        MenuListProps: l,
        onEntering: g,
        PaperProps: f,
        transitionDuration: y,
        TransitionProps: v,
        variant: b,
      },
      I = qH(A),
      R = i && !a && p,
      D = N.useRef(null),
      k = (M, z) => {
        D.current &&
          D.current.adjustStyleForScrollbar(M, {
            direction: _ ? "rtl" : "ltr",
          }),
          g && g(M, z);
      },
      T = (M) => {
        M.key === "Tab" && (M.preventDefault(), d && d(M, "tabKeyDown"));
      };
    let U = -1;
    N.Children.map(s, (M, z) => {
      N.isValidElement(M) &&
        (M.props.disabled ||
          (((b === "selectedMenu" && M.props.selected) || U === -1) &&
            (U = z)));
    });
    const q = E.paper ?? GH,
      K = S.paper ?? f,
      H = rw({
        elementType: E.root,
        externalSlotProps: S.root,
        ownerState: A,
        className: [I.root, o],
      }),
      $ = rw({
        elementType: q,
        externalSlotProps: K,
        ownerState: A,
        className: I.paper,
      });
    return O.jsx(VH, {
      onClose: d,
      anchorOrigin: { vertical: "bottom", horizontal: _ ? "right" : "left" },
      transformOrigin: _ ? WH : HH,
      slots: { paper: q, root: E.root },
      slotProps: { root: H, paper: $ },
      open: p,
      ref: n,
      transitionDuration: y,
      TransitionProps: { onEntering: k, ...v },
      ownerState: A,
      ...C,
      classes: m,
      children: O.jsx(KH, {
        onKeyDown: T,
        actions: D,
        autoFocus: i && (U === -1 || a),
        autoFocusItem: R,
        variant: b,
        ...l,
        className: He(I.list, l.className),
        children: s,
      }),
    });
  });
function ZH(t) {
  return st("MuiNativeSelect", t);
}
const pA = ut("MuiNativeSelect", [
    "root",
    "select",
    "multiple",
    "filled",
    "outlined",
    "standard",
    "disabled",
    "icon",
    "iconOpen",
    "iconFilled",
    "iconOutlined",
    "iconStandard",
    "nativeInput",
    "error",
  ]),
  QH = (t) => {
    const {
        classes: e,
        variant: n,
        disabled: r,
        multiple: i,
        open: s,
        error: o,
      } = t,
      a = {
        select: ["select", n, r && "disabled", i && "multiple", o && "error"],
        icon: ["icon", `icon${Re(n)}`, s && "iconOpen", r && "disabled"],
      };
    return dt(a, ZH, e);
  },
  F3 = Ce("select")(({ theme: t }) => ({
    MozAppearance: "none",
    WebkitAppearance: "none",
    userSelect: "none",
    borderRadius: 0,
    cursor: "pointer",
    "&:focus": { borderRadius: 0 },
    [`&.${pA.disabled}`]: { cursor: "default" },
    "&[multiple]": { height: "auto" },
    "&:not([multiple]) option, &:not([multiple]) optgroup": {
      backgroundColor: (t.vars || t).palette.background.paper,
    },
    variants: [
      {
        props: ({ ownerState: e }) =>
          e.variant !== "filled" && e.variant !== "outlined",
        style: { "&&&": { paddingRight: 24, minWidth: 16 } },
      },
      { props: { variant: "filled" }, style: { "&&&": { paddingRight: 32 } } },
      {
        props: { variant: "outlined" },
        style: {
          borderRadius: (t.vars || t).shape.borderRadius,
          "&:focus": { borderRadius: (t.vars || t).shape.borderRadius },
          "&&&": { paddingRight: 32 },
        },
      },
    ],
  })),
  XH = Ce(F3, {
    name: "MuiNativeSelect",
    slot: "Select",
    shouldForwardProp: Gi,
    overridesResolver: (t, e) => {
      const { ownerState: n } = t;
      return [
        e.select,
        e[n.variant],
        n.error && e.error,
        { [`&.${pA.multiple}`]: e.multiple },
      ];
    },
  })({}),
  z3 = Ce("svg")(({ theme: t }) => ({
    position: "absolute",
    right: 0,
    top: "calc(50% - .5em)",
    pointerEvents: "none",
    color: (t.vars || t).palette.action.active,
    [`&.${pA.disabled}`]: { color: (t.vars || t).palette.action.disabled },
    variants: [
      {
        props: ({ ownerState: e }) => e.open,
        style: { transform: "rotate(180deg)" },
      },
      { props: { variant: "filled" }, style: { right: 7 } },
      { props: { variant: "outlined" }, style: { right: 7 } },
    ],
  })),
  JH = Ce(z3, {
    name: "MuiNativeSelect",
    slot: "Icon",
    overridesResolver: (t, e) => {
      const { ownerState: n } = t;
      return [
        e.icon,
        n.variant && e[`icon${Re(n.variant)}`],
        n.open && e.iconOpen,
      ];
    },
  })({}),
  eq = N.forwardRef(function (e, n) {
    const {
        className: r,
        disabled: i,
        error: s,
        IconComponent: o,
        inputRef: a,
        variant: l = "standard",
        ...d
      } = e,
      p = { ...e, disabled: i, variant: l, error: s },
      f = QH(p);
    return O.jsxs(N.Fragment, {
      children: [
        O.jsx(XH, {
          ownerState: p,
          className: He(f.select, r),
          disabled: i,
          ref: a || n,
          ...d,
        }),
        e.multiple
          ? null
          : O.jsx(JH, { as: o, ownerState: p, className: f.icon }),
      ],
    });
  });
var CP;
const tq = Ce("fieldset", { shouldForwardProp: Gi })({
    textAlign: "left",
    position: "absolute",
    bottom: 0,
    right: 0,
    top: -5,
    left: 0,
    margin: 0,
    padding: "0 8px",
    pointerEvents: "none",
    borderRadius: "inherit",
    borderStyle: "solid",
    borderWidth: 1,
    overflow: "hidden",
    minWidth: "0%",
  }),
  nq = Ce("legend", { shouldForwardProp: Gi })(
    wt(({ theme: t }) => ({
      float: "unset",
      width: "auto",
      overflow: "hidden",
      variants: [
        {
          props: ({ ownerState: e }) => !e.withLabel,
          style: {
            padding: 0,
            lineHeight: "11px",
            transition: t.transitions.create("width", {
              duration: 150,
              easing: t.transitions.easing.easeOut,
            }),
          },
        },
        {
          props: ({ ownerState: e }) => e.withLabel,
          style: {
            display: "block",
            padding: 0,
            height: 11,
            fontSize: "0.75em",
            visibility: "hidden",
            maxWidth: 0.01,
            transition: t.transitions.create("max-width", {
              duration: 50,
              easing: t.transitions.easing.easeOut,
            }),
            whiteSpace: "nowrap",
            "& > span": {
              paddingLeft: 5,
              paddingRight: 5,
              display: "inline-block",
              opacity: 0,
              visibility: "visible",
            },
          },
        },
        {
          props: ({ ownerState: e }) => e.withLabel && e.notched,
          style: {
            maxWidth: "100%",
            transition: t.transitions.create("max-width", {
              duration: 100,
              easing: t.transitions.easing.easeOut,
              delay: 50,
            }),
          },
        },
      ],
    }))
  );
function rq(t) {
  const {
      children: e,
      classes: n,
      className: r,
      label: i,
      notched: s,
      ...o
    } = t,
    a = i != null && i !== "",
    l = { ...t, notched: s, withLabel: a };
  return O.jsx(tq, {
    "aria-hidden": !0,
    className: r,
    ownerState: l,
    ...o,
    children: O.jsx(nq, {
      ownerState: l,
      children: a
        ? O.jsx("span", { children: i })
        : CP ||
          (CP = O.jsx("span", {
            className: "notranslate",
            "aria-hidden": !0,
            children: "",
          })),
    }),
  });
}
const iq = (t) => {
    const { classes: e } = t,
      r = dt(
        {
          root: ["root"],
          notchedOutline: ["notchedOutline"],
          input: ["input"],
        },
        z7,
        e
      );
    return { ...e, ...r };
  },
  sq = Ce(pv, {
    shouldForwardProp: (t) => Gi(t) || t === "classes",
    name: "MuiOutlinedInput",
    slot: "Root",
    overridesResolver: uv,
  })(
    wt(({ theme: t }) => {
      const e =
        t.palette.mode === "light"
          ? "rgba(0, 0, 0, 0.23)"
          : "rgba(255, 255, 255, 0.23)";
      return {
        position: "relative",
        borderRadius: (t.vars || t).shape.borderRadius,
        [`&:hover .${co.notchedOutline}`]: {
          borderColor: (t.vars || t).palette.text.primary,
        },
        "@media (hover: none)": {
          [`&:hover .${co.notchedOutline}`]: {
            borderColor: t.vars
              ? `rgba(${t.vars.palette.common.onBackgroundChannel} / 0.23)`
              : e,
          },
        },
        [`&.${co.focused} .${co.notchedOutline}`]: { borderWidth: 2 },
        variants: [
          ...Object.entries(t.palette)
            .filter(hs())
            .map(([n]) => ({
              props: { color: n },
              style: {
                [`&.${co.focused} .${co.notchedOutline}`]: {
                  borderColor: (t.vars || t).palette[n].main,
                },
              },
            })),
          {
            props: {},
            style: {
              [`&.${co.error} .${co.notchedOutline}`]: {
                borderColor: (t.vars || t).palette.error.main,
              },
              [`&.${co.disabled} .${co.notchedOutline}`]: {
                borderColor: (t.vars || t).palette.action.disabled,
              },
            },
          },
          {
            props: ({ ownerState: n }) => n.startAdornment,
            style: { paddingLeft: 14 },
          },
          {
            props: ({ ownerState: n }) => n.endAdornment,
            style: { paddingRight: 14 },
          },
          {
            props: ({ ownerState: n }) => n.multiline,
            style: { padding: "16.5px 14px" },
          },
          {
            props: ({ ownerState: n, size: r }) => n.multiline && r === "small",
            style: { padding: "8.5px 14px" },
          },
        ],
      };
    })
  ),
  oq = Ce(rq, {
    name: "MuiOutlinedInput",
    slot: "NotchedOutline",
    overridesResolver: (t, e) => e.notchedOutline,
  })(
    wt(({ theme: t }) => {
      const e =
        t.palette.mode === "light"
          ? "rgba(0, 0, 0, 0.23)"
          : "rgba(255, 255, 255, 0.23)";
      return {
        borderColor: t.vars
          ? `rgba(${t.vars.palette.common.onBackgroundChannel} / 0.23)`
          : e,
      };
    })
  ),
  aq = Ce(fv, {
    name: "MuiOutlinedInput",
    slot: "Input",
    overridesResolver: dv,
  })(
    wt(({ theme: t }) => ({
      padding: "16.5px 14px",
      ...(!t.vars && {
        "&:-webkit-autofill": {
          WebkitBoxShadow:
            t.palette.mode === "light" ? null : "0 0 0 100px #266798 inset",
          WebkitTextFillColor: t.palette.mode === "light" ? null : "#fff",
          caretColor: t.palette.mode === "light" ? null : "#fff",
          borderRadius: "inherit",
        },
      }),
      ...(t.vars && {
        "&:-webkit-autofill": { borderRadius: "inherit" },
        [t.getColorSchemeSelector("dark")]: {
          "&:-webkit-autofill": {
            WebkitBoxShadow: "0 0 0 100px #266798 inset",
            WebkitTextFillColor: "#fff",
            caretColor: "#fff",
          },
        },
      }),
      variants: [
        { props: { size: "small" }, style: { padding: "8.5px 14px" } },
        { props: ({ ownerState: e }) => e.multiline, style: { padding: 0 } },
        {
          props: ({ ownerState: e }) => e.startAdornment,
          style: { paddingLeft: 0 },
        },
        {
          props: ({ ownerState: e }) => e.endAdornment,
          style: { paddingRight: 0 },
        },
      ],
    }))
  ),
  fA = N.forwardRef(function (e, n) {
    var r;
    const i = ft({ props: e, name: "MuiOutlinedInput" }),
      {
        components: s = {},
        fullWidth: o = !1,
        inputComponent: a = "input",
        label: l,
        multiline: d = !1,
        notched: p,
        slots: f = {},
        type: m = "text",
        ...y
      } = i,
      g = iq(i),
      v = Sp(),
      b = xp({
        props: i,
        muiFormControl: v,
        states: [
          "color",
          "disabled",
          "error",
          "focused",
          "hiddenLabel",
          "size",
          "required",
        ],
      }),
      E = {
        ...i,
        color: b.color || "primary",
        disabled: b.disabled,
        error: b.error,
        focused: b.focused,
        formControl: v,
        fullWidth: o,
        hiddenLabel: b.hiddenLabel,
        multiline: d,
        size: b.size,
        type: m,
      },
      S = f.root ?? s.Root ?? sq,
      C = f.input ?? s.Input ?? aq;
    return O.jsx(aA, {
      slots: { root: S, input: C },
      renderSuffix: (_) =>
        O.jsx(oq, {
          ownerState: E,
          className: g.notchedOutline,
          label:
            l != null && l !== "" && b.required
              ? r || (r = O.jsxs(N.Fragment, { children: [l, "", "*"] }))
              : l,
          notched:
            typeof p < "u" ? p : !!(_.startAdornment || _.filled || _.focused),
        }),
      fullWidth: o,
      inputComponent: a,
      multiline: d,
      ref: n,
      type: m,
      ...y,
      classes: { ...g, notchedOutline: null },
    });
  });
fA.muiName = "Input";
function cq(t) {
  return st("MuiSelect", t);
}
const Rf = ut("MuiSelect", [
  "root",
  "select",
  "multiple",
  "filled",
  "outlined",
  "standard",
  "disabled",
  "focused",
  "icon",
  "iconOpen",
  "iconFilled",
  "iconOutlined",
  "iconStandard",
  "nativeInput",
  "error",
]);
var xP;
const lq = Ce(F3, {
    name: "MuiSelect",
    slot: "Select",
    overridesResolver: (t, e) => {
      const { ownerState: n } = t;
      return [
        { [`&.${Rf.select}`]: e.select },
        { [`&.${Rf.select}`]: e[n.variant] },
        { [`&.${Rf.error}`]: e.error },
        { [`&.${Rf.multiple}`]: e.multiple },
      ];
    },
  })({
    [`&.${Rf.select}`]: {
      height: "auto",
      minHeight: "1.4375em",
      textOverflow: "ellipsis",
      whiteSpace: "nowrap",
      overflow: "hidden",
    },
  }),
  uq = Ce(z3, {
    name: "MuiSelect",
    slot: "Icon",
    overridesResolver: (t, e) => {
      const { ownerState: n } = t;
      return [
        e.icon,
        n.variant && e[`icon${Re(n.variant)}`],
        n.open && e.iconOpen,
      ];
    },
  })({}),
  dq = Ce("input", {
    shouldForwardProp: (t) => g3(t) && t !== "classes",
    name: "MuiSelect",
    slot: "NativeInput",
    overridesResolver: (t, e) => e.nativeInput,
  })({
    bottom: 0,
    left: 0,
    position: "absolute",
    opacity: 0,
    pointerEvents: "none",
    width: "100%",
    boxSizing: "border-box",
  });
function SP(t, e) {
  return typeof e == "object" && e !== null ? t === e : String(t) === String(e);
}
function pq(t) {
  return t == null || (typeof t == "string" && !t.trim());
}
const fq = (t) => {
    const {
        classes: e,
        variant: n,
        disabled: r,
        multiple: i,
        open: s,
        error: o,
      } = t,
      a = {
        select: ["select", n, r && "disabled", i && "multiple", o && "error"],
        icon: ["icon", `icon${Re(n)}`, s && "iconOpen", r && "disabled"],
        nativeInput: ["nativeInput"],
      };
    return dt(a, cq, e);
  },
  hq = N.forwardRef(function (e, n) {
    var br;
    const {
        "aria-describedby": r,
        "aria-label": i,
        autoFocus: s,
        autoWidth: o,
        children: a,
        className: l,
        defaultOpen: d,
        defaultValue: p,
        disabled: f,
        displayEmpty: m,
        error: y = !1,
        IconComponent: g,
        inputRef: v,
        labelId: b,
        MenuProps: E = {},
        multiple: S,
        name: C,
        onBlur: _,
        onChange: A,
        onClose: I,
        onFocus: R,
        onOpen: D,
        open: k,
        readOnly: T,
        renderValue: U,
        required: q,
        SelectDisplayProps: K = {},
        tabIndex: H,
        type: $,
        value: M,
        variant: z = "standard",
        ...B
      } = e,
      [j, V] = ew({ controlled: M, default: p, name: "Select" }),
      [W, Z] = ew({ controlled: k, default: d, name: "Select" }),
      ee = N.useRef(null),
      J = N.useRef(null),
      [se, re] = N.useState(null),
      { current: fe } = N.useRef(k != null),
      [ce, le] = N.useState(),
      Se = In(n, v),
      je = N.useCallback((Ve) => {
        (J.current = Ve), Ve && re(Ve);
      }, []),
      Pe = se == null ? void 0 : se.parentNode;
    N.useImperativeHandle(
      Se,
      () => ({
        focus: () => {
          J.current.focus();
        },
        node: ee.current,
        value: j,
      }),
      [j]
    ),
      N.useEffect(() => {
        d &&
          W &&
          se &&
          !fe &&
          (le(o ? null : Pe.clientWidth), J.current.focus());
      }, [se, o]),
      N.useEffect(() => {
        s && J.current.focus();
      }, [s]),
      N.useEffect(() => {
        if (!b) return;
        const Ve = qr(J.current).getElementById(b);
        if (Ve) {
          const It = () => {
            getSelection().isCollapsed && J.current.focus();
          };
          return (
            Ve.addEventListener("click", It),
            () => {
              Ve.removeEventListener("click", It);
            }
          );
        }
      }, [b]);
    const We = (Ve, It) => {
        Ve ? D && D(It) : I && I(It),
          fe || (le(o ? null : Pe.clientWidth), Z(Ve));
      },
      Ne = (Ve) => {
        Ve.button === 0 && (Ve.preventDefault(), J.current.focus(), We(!0, Ve));
      },
      pt = (Ve) => {
        We(!1, Ve);
      },
      hn = N.Children.toArray(a),
      Wt = (Ve) => {
        const It = hn.find((bn) => bn.props.value === Ve.target.value);
        It !== void 0 && (V(It.props.value), A && A(Ve, It));
      },
      Lt = (Ve) => (It) => {
        let bn;
        if (It.currentTarget.hasAttribute("tabindex")) {
          if (S) {
            bn = Array.isArray(j) ? j.slice() : [];
            const Kr = j.indexOf(Ve.props.value);
            Kr === -1 ? bn.push(Ve.props.value) : bn.splice(Kr, 1);
          } else bn = Ve.props.value;
          if (
            (Ve.props.onClick && Ve.props.onClick(It), j !== bn && (V(bn), A))
          ) {
            const Kr = It.nativeEvent || It,
              ka = new Kr.constructor(Kr.type, Kr);
            Object.defineProperty(ka, "target", {
              writable: !0,
              value: { value: bn, name: C },
            }),
              A(ka, Ve);
          }
          S || We(!1, It);
        }
      },
      vn = (Ve) => {
        T ||
          ([" ", "ArrowUp", "ArrowDown", "Enter"].includes(Ve.key) &&
            (Ve.preventDefault(), We(!0, Ve)));
      },
      At = se !== null && W,
      vt = (Ve) => {
        !At &&
          _ &&
          (Object.defineProperty(Ve, "target", {
            writable: !0,
            value: { value: j, name: C },
          }),
          _(Ve));
      };
    delete B["aria-invalid"];
    let Le, nr;
    const tn = [];
    let wr = !1;
    (cw({ value: j }) || m) && (U ? (Le = U(j)) : (wr = !0));
    const Dr = hn.map((Ve) => {
      if (!N.isValidElement(Ve)) return null;
      let It;
      if (S) {
        if (!Array.isArray(j)) throw new Error(xa(2));
        (It = j.some((bn) => SP(bn, Ve.props.value))),
          It && wr && tn.push(Ve.props.children);
      } else (It = SP(j, Ve.props.value)), It && wr && (nr = Ve.props.children);
      return N.cloneElement(Ve, {
        "aria-selected": It ? "true" : "false",
        onClick: Lt(Ve),
        onKeyUp: (bn) => {
          bn.key === " " && bn.preventDefault(),
            Ve.props.onKeyUp && Ve.props.onKeyUp(bn);
        },
        role: "option",
        selected: It,
        value: void 0,
        "data-value": Ve.props.value,
      });
    });
    wr &&
      (S
        ? tn.length === 0
          ? (Le = null)
          : (Le = tn.reduce(
              (Ve, It, bn) => (
                Ve.push(It), bn < tn.length - 1 && Ve.push(", "), Ve
              ),
              []
            ))
        : (Le = nr));
    let rr = ce;
    !o && fe && se && (rr = Pe.clientWidth);
    let ir;
    typeof H < "u" ? (ir = H) : (ir = f ? null : 0);
    const vr = K.id || (C ? `mui-component-select-${C}` : void 0),
      Vn = { ...e, variant: z, value: j, open: At, error: y },
      ot = fq(Vn),
      oi = {
        ...E.PaperProps,
        ...((br = E.slotProps) == null ? void 0 : br.paper),
      },
      $r = sv();
    return O.jsxs(N.Fragment, {
      children: [
        O.jsx(lq, {
          as: "div",
          ref: je,
          tabIndex: ir,
          role: "combobox",
          "aria-controls": $r,
          "aria-disabled": f ? "true" : void 0,
          "aria-expanded": At ? "true" : "false",
          "aria-haspopup": "listbox",
          "aria-label": i,
          "aria-labelledby": [b, vr].filter(Boolean).join(" ") || void 0,
          "aria-describedby": r,
          "aria-required": q ? "true" : void 0,
          "aria-invalid": y ? "true" : void 0,
          onKeyDown: vn,
          onMouseDown: f || T ? null : Ne,
          onBlur: vt,
          onFocus: R,
          ...K,
          ownerState: Vn,
          className: He(K.className, ot.select, l),
          id: vr,
          children: pq(Le)
            ? xP ||
              (xP = O.jsx("span", {
                className: "notranslate",
                "aria-hidden": !0,
                children: "",
              }))
            : Le,
        }),
        O.jsx(dq, {
          "aria-invalid": y,
          value: Array.isArray(j) ? j.join(",") : j,
          name: C,
          ref: ee,
          "aria-hidden": !0,
          onChange: Wt,
          tabIndex: -1,
          disabled: f,
          className: ot.nativeInput,
          autoFocus: s,
          required: q,
          ...B,
          ownerState: Vn,
        }),
        O.jsx(uq, { as: g, className: ot.icon, ownerState: Vn }),
        O.jsx(YH, {
          id: `menu-${C || ""}`,
          anchorEl: Pe,
          open: At,
          onClose: pt,
          anchorOrigin: { vertical: "bottom", horizontal: "center" },
          transformOrigin: { vertical: "top", horizontal: "center" },
          ...E,
          MenuListProps: {
            "aria-labelledby": b,
            role: "listbox",
            "aria-multiselectable": S ? "true" : void 0,
            disableListWrap: !0,
            id: $r,
            ...E.MenuListProps,
          },
          slotProps: {
            ...E.slotProps,
            paper: {
              ...oi,
              style: { minWidth: rr, ...(oi != null ? oi.style : null) },
            },
          },
          children: Dr,
        }),
      ],
    });
  }),
  mq = (t) => {
    const { classes: e } = t;
    return e;
  },
  hA = {
    name: "MuiSelect",
    overridesResolver: (t, e) => e.root,
    shouldForwardProp: (t) => Gi(t) && t !== "variant",
    slot: "Root",
  },
  gq = Ce(dA, hA)(""),
  yq = Ce(fA, hA)(""),
  wq = Ce(uA, hA)(""),
  W3 = N.forwardRef(function (e, n) {
    const r = ft({ name: "MuiSelect", props: e }),
      {
        autoWidth: i = !1,
        children: s,
        classes: o = {},
        className: a,
        defaultOpen: l = !1,
        displayEmpty: d = !1,
        IconComponent: p = H7,
        id: f,
        input: m,
        inputProps: y,
        label: g,
        labelId: v,
        MenuProps: b,
        multiple: E = !1,
        native: S = !1,
        onClose: C,
        onOpen: _,
        open: A,
        renderValue: I,
        SelectDisplayProps: R,
        variant: D = "outlined",
        ...k
      } = r,
      T = S ? eq : hq,
      U = Sp(),
      q = xp({ props: r, muiFormControl: U, states: ["variant", "error"] }),
      K = q.variant || D,
      H = { ...r, variant: K, classes: o },
      $ = mq(H),
      { root: M, ...z } = $,
      B =
        m ||
        {
          standard: O.jsx(gq, { ownerState: H }),
          outlined: O.jsx(yq, { label: g, ownerState: H }),
          filled: O.jsx(wq, { ownerState: H }),
        }[K],
      j = In(n, qc(B));
    return O.jsx(N.Fragment, {
      children: N.cloneElement(B, {
        inputComponent: T,
        inputProps: {
          children: s,
          error: q.error,
          IconComponent: p,
          variant: K,
          type: void 0,
          multiple: E,
          ...(S
            ? { id: f }
            : {
                autoWidth: i,
                defaultOpen: l,
                displayEmpty: d,
                labelId: v,
                MenuProps: b,
                onClose: C,
                onOpen: _,
                open: A,
                renderValue: I,
                SelectDisplayProps: { id: f, ...R },
              }),
          ...y,
          classes: y ? yr(z, y.classes) : z,
          ...(m ? m.props.inputProps : {}),
        },
        ...(((E && S) || d) && K === "outlined" ? { notched: !0 } : {}),
        ref: j,
        className: He(B.props.className, a, $.root),
        ...(!m && { variant: K }),
        ...k,
      }),
    });
  });
W3.muiName = "Select";
function vq(t = {}) {
  const {
      autoHideDuration: e = null,
      disableWindowBlurListener: n = !1,
      onClose: r,
      open: i,
      resumeHideDuration: s,
    } = t,
    o = Ac();
  N.useEffect(() => {
    if (!i) return;
    function E(S) {
      S.defaultPrevented ||
        (S.key === "Escape" && (r == null || r(S, "escapeKeyDown")));
    }
    return (
      document.addEventListener("keydown", E),
      () => {
        document.removeEventListener("keydown", E);
      }
    );
  }, [i, r]);
  const a = Ks((E, S) => {
      r == null || r(E, S);
    }),
    l = Ks((E) => {
      !r ||
        E == null ||
        o.start(E, () => {
          a(null, "timeout");
        });
    });
  N.useEffect(() => (i && l(e), o.clear), [i, e, l, o]);
  const d = (E) => {
      r == null || r(E, "clickaway");
    },
    p = o.clear,
    f = N.useCallback(() => {
      e != null && l(s ?? e * 0.5);
    }, [e, s, l]),
    m = (E) => (S) => {
      const C = E.onBlur;
      C == null || C(S), f();
    },
    y = (E) => (S) => {
      const C = E.onFocus;
      C == null || C(S), p();
    },
    g = (E) => (S) => {
      const C = E.onMouseEnter;
      C == null || C(S), p();
    },
    v = (E) => (S) => {
      const C = E.onMouseLeave;
      C == null || C(S), f();
    };
  return (
    N.useEffect(() => {
      if (!n && i)
        return (
          window.addEventListener("focus", f),
          window.addEventListener("blur", p),
          () => {
            window.removeEventListener("focus", f),
              window.removeEventListener("blur", p);
          }
        );
    }, [n, i, f, p]),
    {
      getRootProps: (E = {}) => {
        const S = { ...nw(t), ...nw(E) };
        return {
          role: "presentation",
          ...E,
          ...S,
          onBlur: m(S),
          onFocus: y(S),
          onMouseEnter: g(S),
          onMouseLeave: v(S),
        };
      },
      onClickAway: d,
    }
  );
}
function bq(t) {
  return st("MuiSnackbarContent", t);
}
ut("MuiSnackbarContent", ["root", "message", "action"]);
const Eq = (t) => {
    const { classes: e } = t;
    return dt(
      { root: ["root"], action: ["action"], message: ["message"] },
      bq,
      e
    );
  },
  Cq = Ce(Vc, {
    name: "MuiSnackbarContent",
    slot: "Root",
    overridesResolver: (t, e) => e.root,
  })(
    wt(({ theme: t }) => {
      const e = t.palette.mode === "light" ? 0.8 : 0.98,
        n = n3(t.palette.background.default, e);
      return {
        ...t.typography.body2,
        color: t.vars
          ? t.vars.palette.SnackbarContent.color
          : t.palette.getContrastText(n),
        backgroundColor: t.vars ? t.vars.palette.SnackbarContent.bg : n,
        display: "flex",
        alignItems: "center",
        flexWrap: "wrap",
        padding: "6px 16px",
        borderRadius: (t.vars || t).shape.borderRadius,
        flexGrow: 1,
        [t.breakpoints.up("sm")]: { flexGrow: "initial", minWidth: 288 },
      };
    })
  ),
  xq = Ce("div", {
    name: "MuiSnackbarContent",
    slot: "Message",
    overridesResolver: (t, e) => e.message,
  })({ padding: "8px 0" }),
  Sq = Ce("div", {
    name: "MuiSnackbarContent",
    slot: "Action",
    overridesResolver: (t, e) => e.action,
  })({
    display: "flex",
    alignItems: "center",
    marginLeft: "auto",
    paddingLeft: 16,
    marginRight: -8,
  }),
  Aq = N.forwardRef(function (e, n) {
    const r = ft({ props: e, name: "MuiSnackbarContent" }),
      { action: i, className: s, message: o, role: a = "alert", ...l } = r,
      d = r,
      p = Eq(d);
    return O.jsxs(Cq, {
      role: a,
      square: !0,
      elevation: 6,
      className: He(p.root, s),
      ownerState: d,
      ref: n,
      ...l,
      children: [
        O.jsx(xq, { className: p.message, ownerState: d, children: o }),
        i
          ? O.jsx(Sq, { className: p.action, ownerState: d, children: i })
          : null,
      ],
    });
  });
function _q(t) {
  return st("MuiSnackbar", t);
}
ut("MuiSnackbar", [
  "root",
  "anchorOriginTopCenter",
  "anchorOriginBottomCenter",
  "anchorOriginTopRight",
  "anchorOriginBottomRight",
  "anchorOriginTopLeft",
  "anchorOriginBottomLeft",
]);
const Iq = (t) => {
    const { classes: e, anchorOrigin: n } = t,
      r = {
        root: ["root", `anchorOrigin${Re(n.vertical)}${Re(n.horizontal)}`],
      };
    return dt(r, _q, e);
  },
  AP = Ce("div", {
    name: "MuiSnackbar",
    slot: "Root",
    overridesResolver: (t, e) => {
      const { ownerState: n } = t;
      return [
        e.root,
        e[
          `anchorOrigin${Re(n.anchorOrigin.vertical)}${Re(
            n.anchorOrigin.horizontal
          )}`
        ],
      ];
    },
  })(
    wt(({ theme: t }) => ({
      zIndex: (t.vars || t).zIndex.snackbar,
      position: "fixed",
      display: "flex",
      left: 8,
      right: 8,
      justifyContent: "center",
      alignItems: "center",
      variants: [
        {
          props: ({ ownerState: e }) => e.anchorOrigin.vertical === "top",
          style: { top: 8, [t.breakpoints.up("sm")]: { top: 24 } },
        },
        {
          props: ({ ownerState: e }) => e.anchorOrigin.vertical !== "top",
          style: { bottom: 8, [t.breakpoints.up("sm")]: { bottom: 24 } },
        },
        {
          props: ({ ownerState: e }) => e.anchorOrigin.horizontal === "left",
          style: {
            justifyContent: "flex-start",
            [t.breakpoints.up("sm")]: { left: 24, right: "auto" },
          },
        },
        {
          props: ({ ownerState: e }) => e.anchorOrigin.horizontal === "right",
          style: {
            justifyContent: "flex-end",
            [t.breakpoints.up("sm")]: { right: 24, left: "auto" },
          },
        },
        {
          props: ({ ownerState: e }) => e.anchorOrigin.horizontal === "center",
          style: {
            [t.breakpoints.up("sm")]: {
              left: "50%",
              right: "auto",
              transform: "translateX(-50%)",
            },
          },
        },
      ],
    }))
  ),
  Tq = N.forwardRef(function (e, n) {
    const r = ft({ props: e, name: "MuiSnackbar" }),
      i = Ii(),
      s = {
        enter: i.transitions.duration.enteringScreen,
        exit: i.transitions.duration.leavingScreen,
      },
      {
        action: o,
        anchorOrigin: { vertical: a, horizontal: l } = {
          vertical: "bottom",
          horizontal: "left",
        },
        autoHideDuration: d = null,
        children: p,
        className: f,
        ClickAwayListenerProps: m,
        ContentProps: y,
        disableWindowBlurListener: g = !1,
        message: v,
        onBlur: b,
        onClose: E,
        onFocus: S,
        onMouseEnter: C,
        onMouseLeave: _,
        open: A,
        resumeHideDuration: I,
        TransitionComponent: R = Uh,
        transitionDuration: D = s,
        TransitionProps: { onEnter: k, onExited: T, ...U } = {},
        ...q
      } = r,
      K = {
        ...r,
        anchorOrigin: { vertical: a, horizontal: l },
        autoHideDuration: d,
        disableWindowBlurListener: g,
        TransitionComponent: R,
        transitionDuration: D,
      },
      H = Iq(K),
      { getRootProps: $, onClickAway: M } = vq({ ...K }),
      [z, B] = N.useState(!0),
      j = rw({
        elementType: AP,
        getSlotProps: $,
        externalForwardedProps: q,
        ownerState: K,
        additionalProps: { ref: n },
        className: [H.root, f],
      }),
      V = (Z) => {
        B(!0), T && T(Z);
      },
      W = (Z, ee) => {
        B(!1), k && k(Z, ee);
      };
    return !A && z
      ? null
      : O.jsx(lW, {
          onClickAway: M,
          ...m,
          children: O.jsx(AP, {
            ...j,
            children: O.jsx(R, {
              appear: !0,
              in: A,
              timeout: D,
              direction: a === "top" ? "down" : "up",
              onEnter: W,
              onExited: V,
              ...U,
              children: p || O.jsx(Aq, { message: v, action: o, ...y }),
            }),
          }),
        });
  });
function Pq(t) {
  return st("MuiTooltip", t);
}
const kn = ut("MuiTooltip", [
  "popper",
  "popperInteractive",
  "popperArrow",
  "popperClose",
  "tooltip",
  "tooltipArrow",
  "touch",
  "tooltipPlacementLeft",
  "tooltipPlacementRight",
  "tooltipPlacementTop",
  "tooltipPlacementBottom",
  "arrow",
]);
function Rq(t) {
  return Math.round(t * 1e5) / 1e5;
}
const Nq = (t) => {
    const {
        classes: e,
        disableInteractive: n,
        arrow: r,
        touch: i,
        placement: s,
      } = t,
      o = {
        popper: ["popper", !n && "popperInteractive", r && "popperArrow"],
        tooltip: [
          "tooltip",
          r && "tooltipArrow",
          i && "touch",
          `tooltipPlacement${Re(s.split("-")[0])}`,
        ],
        arrow: ["arrow"],
      };
    return dt(o, Pq, e);
  },
  Oq = Ce(N3, {
    name: "MuiTooltip",
    slot: "Popper",
    overridesResolver: (t, e) => {
      const { ownerState: n } = t;
      return [
        e.popper,
        !n.disableInteractive && e.popperInteractive,
        n.arrow && e.popperArrow,
        !n.open && e.popperClose,
      ];
    },
  })(
    wt(({ theme: t }) => ({
      zIndex: (t.vars || t).zIndex.tooltip,
      pointerEvents: "none",
      variants: [
        {
          props: ({ ownerState: e }) => !e.disableInteractive,
          style: { pointerEvents: "auto" },
        },
        { props: ({ open: e }) => !e, style: { pointerEvents: "none" } },
        {
          props: ({ ownerState: e }) => e.arrow,
          style: {
            [`&[data-popper-placement*="bottom"] .${kn.arrow}`]: {
              top: 0,
              marginTop: "-0.71em",
              "&::before": { transformOrigin: "0 100%" },
            },
            [`&[data-popper-placement*="top"] .${kn.arrow}`]: {
              bottom: 0,
              marginBottom: "-0.71em",
              "&::before": { transformOrigin: "100% 0" },
            },
            [`&[data-popper-placement*="right"] .${kn.arrow}`]: {
              height: "1em",
              width: "0.71em",
              "&::before": { transformOrigin: "100% 100%" },
            },
            [`&[data-popper-placement*="left"] .${kn.arrow}`]: {
              height: "1em",
              width: "0.71em",
              "&::before": { transformOrigin: "0 0" },
            },
          },
        },
        {
          props: ({ ownerState: e }) => e.arrow && !e.isRtl,
          style: {
            [`&[data-popper-placement*="right"] .${kn.arrow}`]: {
              left: 0,
              marginLeft: "-0.71em",
            },
          },
        },
        {
          props: ({ ownerState: e }) => e.arrow && !!e.isRtl,
          style: {
            [`&[data-popper-placement*="right"] .${kn.arrow}`]: {
              right: 0,
              marginRight: "-0.71em",
            },
          },
        },
        {
          props: ({ ownerState: e }) => e.arrow && !e.isRtl,
          style: {
            [`&[data-popper-placement*="left"] .${kn.arrow}`]: {
              right: 0,
              marginRight: "-0.71em",
            },
          },
        },
        {
          props: ({ ownerState: e }) => e.arrow && !!e.isRtl,
          style: {
            [`&[data-popper-placement*="left"] .${kn.arrow}`]: {
              left: 0,
              marginLeft: "-0.71em",
            },
          },
        },
      ],
    }))
  ),
  kq = Ce("div", {
    name: "MuiTooltip",
    slot: "Tooltip",
    overridesResolver: (t, e) => {
      const { ownerState: n } = t;
      return [
        e.tooltip,
        n.touch && e.touch,
        n.arrow && e.tooltipArrow,
        e[`tooltipPlacement${Re(n.placement.split("-")[0])}`],
      ];
    },
  })(
    wt(({ theme: t }) => ({
      backgroundColor: t.vars
        ? t.vars.palette.Tooltip.bg
        : An(t.palette.grey[700], 0.92),
      borderRadius: (t.vars || t).shape.borderRadius,
      color: (t.vars || t).palette.common.white,
      fontFamily: t.typography.fontFamily,
      padding: "4px 8px",
      fontSize: t.typography.pxToRem(11),
      maxWidth: 300,
      margin: 2,
      wordWrap: "break-word",
      fontWeight: t.typography.fontWeightMedium,
      [`.${kn.popper}[data-popper-placement*="left"] &`]: {
        transformOrigin: "right center",
      },
      [`.${kn.popper}[data-popper-placement*="right"] &`]: {
        transformOrigin: "left center",
      },
      [`.${kn.popper}[data-popper-placement*="top"] &`]: {
        transformOrigin: "center bottom",
        marginBottom: "14px",
      },
      [`.${kn.popper}[data-popper-placement*="bottom"] &`]: {
        transformOrigin: "center top",
        marginTop: "14px",
      },
      variants: [
        {
          props: ({ ownerState: e }) => e.arrow,
          style: { position: "relative", margin: 0 },
        },
        {
          props: ({ ownerState: e }) => e.touch,
          style: {
            padding: "8px 16px",
            fontSize: t.typography.pxToRem(14),
            lineHeight: `${Rq(16 / 14)}em`,
            fontWeight: t.typography.fontWeightRegular,
          },
        },
        {
          props: ({ ownerState: e }) => !e.isRtl,
          style: {
            [`.${kn.popper}[data-popper-placement*="left"] &`]: {
              marginRight: "14px",
            },
            [`.${kn.popper}[data-popper-placement*="right"] &`]: {
              marginLeft: "14px",
            },
          },
        },
        {
          props: ({ ownerState: e }) => !e.isRtl && e.touch,
          style: {
            [`.${kn.popper}[data-popper-placement*="left"] &`]: {
              marginRight: "24px",
            },
            [`.${kn.popper}[data-popper-placement*="right"] &`]: {
              marginLeft: "24px",
            },
          },
        },
        {
          props: ({ ownerState: e }) => !!e.isRtl,
          style: {
            [`.${kn.popper}[data-popper-placement*="left"] &`]: {
              marginLeft: "14px",
            },
            [`.${kn.popper}[data-popper-placement*="right"] &`]: {
              marginRight: "14px",
            },
          },
        },
        {
          props: ({ ownerState: e }) => !!e.isRtl && e.touch,
          style: {
            [`.${kn.popper}[data-popper-placement*="left"] &`]: {
              marginLeft: "24px",
            },
            [`.${kn.popper}[data-popper-placement*="right"] &`]: {
              marginRight: "24px",
            },
          },
        },
        {
          props: ({ ownerState: e }) => e.touch,
          style: {
            [`.${kn.popper}[data-popper-placement*="top"] &`]: {
              marginBottom: "24px",
            },
          },
        },
        {
          props: ({ ownerState: e }) => e.touch,
          style: {
            [`.${kn.popper}[data-popper-placement*="bottom"] &`]: {
              marginTop: "24px",
            },
          },
        },
      ],
    }))
  ),
  Dq = Ce("span", {
    name: "MuiTooltip",
    slot: "Arrow",
    overridesResolver: (t, e) => e.arrow,
  })(
    wt(({ theme: t }) => ({
      overflow: "hidden",
      position: "absolute",
      width: "1em",
      height: "0.71em",
      boxSizing: "border-box",
      color: t.vars ? t.vars.palette.Tooltip.bg : An(t.palette.grey[700], 0.9),
      "&::before": {
        content: '""',
        margin: "auto",
        display: "block",
        width: "100%",
        height: "100%",
        backgroundColor: "currentColor",
        transform: "rotate(45deg)",
      },
    }))
  );
let Fy = !1;
const _P = new ov();
let Nf = { x: 0, y: 0 };
function zy(t, e) {
  return (n, ...r) => {
    e && e(n, ...r), t(n, ...r);
  };
}
const $q = N.forwardRef(function (e, n) {
    const r = ft({ props: e, name: "MuiTooltip" }),
      {
        arrow: i = !1,
        children: s,
        classes: o,
        components: a = {},
        componentsProps: l = {},
        describeChild: d = !1,
        disableFocusListener: p = !1,
        disableHoverListener: f = !1,
        disableInteractive: m = !1,
        disableTouchListener: y = !1,
        enterDelay: g = 100,
        enterNextDelay: v = 0,
        enterTouchDelay: b = 700,
        followCursor: E = !1,
        id: S,
        leaveDelay: C = 0,
        leaveTouchDelay: _ = 1500,
        onClose: A,
        onOpen: I,
        open: R,
        placement: D = "bottom",
        PopperComponent: k,
        PopperProps: T = {},
        slotProps: U = {},
        slots: q = {},
        title: K,
        TransitionComponent: H,
        TransitionProps: $,
        ...M
      } = r,
      z = N.isValidElement(s) ? s : O.jsx("span", { children: s }),
      B = Ii(),
      j = av(),
      [V, W] = N.useState(),
      [Z, ee] = N.useState(null),
      J = N.useRef(!1),
      se = m || E,
      re = Ac(),
      fe = Ac(),
      ce = Ac(),
      le = Ac(),
      [Se, je] = ew({
        controlled: R,
        default: !1,
        name: "Tooltip",
        state: "open",
      });
    let Pe = Se;
    const We = sv(S),
      Ne = N.useRef(),
      pt = Ks(() => {
        Ne.current !== void 0 &&
          ((document.body.style.WebkitUserSelect = Ne.current),
          (Ne.current = void 0)),
          le.clear();
      });
    N.useEffect(() => pt, [pt]);
    const hn = (at) => {
        _P.clear(), (Fy = !0), je(!0), I && !Pe && I(at);
      },
      Wt = Ks((at) => {
        _P.start(800 + C, () => {
          Fy = !1;
        }),
          je(!1),
          A && Pe && A(at),
          re.start(B.transitions.duration.shortest, () => {
            J.current = !1;
          });
      }),
      Lt = (at) => {
        (J.current && at.type !== "touchstart") ||
          (V && V.removeAttribute("title"),
          fe.clear(),
          ce.clear(),
          g || (Fy && v)
            ? fe.start(Fy ? v : g, () => {
                hn(at);
              })
            : hn(at));
      },
      vn = (at) => {
        fe.clear(),
          ce.start(C, () => {
            Wt(at);
          });
      },
      [, At] = N.useState(!1),
      vt = (at) => {
        tw(at.target) || (At(!1), vn(at));
      },
      Le = (at) => {
        V || W(at.currentTarget), tw(at.target) && (At(!0), Lt(at));
      },
      nr = (at) => {
        J.current = !0;
        const Yr = z.props;
        Yr.onTouchStart && Yr.onTouchStart(at);
      },
      tn = (at) => {
        nr(at),
          ce.clear(),
          re.clear(),
          pt(),
          (Ne.current = document.body.style.WebkitUserSelect),
          (document.body.style.WebkitUserSelect = "none"),
          le.start(b, () => {
            (document.body.style.WebkitUserSelect = Ne.current), Lt(at);
          });
      },
      wr = (at) => {
        z.props.onTouchEnd && z.props.onTouchEnd(at),
          pt(),
          ce.start(_, () => {
            Wt(at);
          });
      };
    N.useEffect(() => {
      if (!Pe) return;
      function at(Yr) {
        Yr.key === "Escape" && Wt(Yr);
      }
      return (
        document.addEventListener("keydown", at),
        () => {
          document.removeEventListener("keydown", at);
        }
      );
    }, [Wt, Pe]);
    const Dr = In(qc(z), W, n);
    !K && K !== 0 && (Pe = !1);
    const rr = N.useRef(),
      ir = (at) => {
        const Yr = z.props;
        Yr.onMouseMove && Yr.onMouseMove(at),
          (Nf = { x: at.clientX, y: at.clientY }),
          rr.current && rr.current.update();
      },
      vr = {},
      Vn = typeof K == "string";
    d
      ? ((vr.title = !Pe && Vn && !f ? K : null),
        (vr["aria-describedby"] = Pe ? We : null))
      : ((vr["aria-label"] = Vn ? K : null),
        (vr["aria-labelledby"] = Pe && !Vn ? We : null));
    const ot = {
        ...vr,
        ...M,
        ...z.props,
        className: He(M.className, z.props.className),
        onTouchStart: nr,
        ref: Dr,
        ...(E ? { onMouseMove: ir } : {}),
      },
      oi = {};
    y || ((ot.onTouchStart = tn), (ot.onTouchEnd = wr)),
      f ||
        ((ot.onMouseOver = zy(Lt, ot.onMouseOver)),
        (ot.onMouseLeave = zy(vn, ot.onMouseLeave)),
        se || ((oi.onMouseOver = Lt), (oi.onMouseLeave = vn))),
      p ||
        ((ot.onFocus = zy(Le, ot.onFocus)),
        (ot.onBlur = zy(vt, ot.onBlur)),
        se || ((oi.onFocus = Le), (oi.onBlur = vt)));
    const $r = {
        ...r,
        isRtl: j,
        arrow: i,
        disableInteractive: se,
        placement: D,
        PopperComponentProp: k,
        touch: J.current,
      },
      br = typeof U.popper == "function" ? U.popper($r) : U.popper,
      Ve = N.useMemo(() => {
        var Yr, Up;
        let at = [
          { name: "arrow", enabled: !!Z, options: { element: Z, padding: 4 } },
        ];
        return (
          (Yr = T.popperOptions) != null &&
            Yr.modifiers &&
            (at = at.concat(T.popperOptions.modifiers)),
          (Up = br == null ? void 0 : br.popperOptions) != null &&
            Up.modifiers &&
            (at = at.concat(br.popperOptions.modifiers)),
          {
            ...T.popperOptions,
            ...(br == null ? void 0 : br.popperOptions),
            modifiers: at,
          }
        );
      }, [Z, T.popperOptions, br == null ? void 0 : br.popperOptions]),
      It = Nq($r),
      bn = typeof U.transition == "function" ? U.transition($r) : U.transition,
      Kr = {
        slots: {
          popper: a.Popper,
          transition: a.Transition ?? H,
          tooltip: a.Tooltip,
          arrow: a.Arrow,
          ...q,
        },
        slotProps: {
          arrow: U.arrow ?? l.arrow,
          popper: { ...T, ...(br ?? l.popper) },
          tooltip: U.tooltip ?? l.tooltip,
          transition: { ...$, ...(bn ?? l.transition) },
        },
      },
      [ka, Lp] = Jn("popper", {
        elementType: Oq,
        externalForwardedProps: Kr,
        ownerState: $r,
        className: He(It.popper, T == null ? void 0 : T.className),
      }),
      [Da, $a] = Jn("transition", {
        elementType: Uh,
        externalForwardedProps: Kr,
        ownerState: $r,
      }),
      [vg, bg] = Jn("tooltip", {
        elementType: kq,
        className: It.tooltip,
        externalForwardedProps: Kr,
        ownerState: $r,
      }),
      [Eg, Cg] = Jn("arrow", {
        elementType: Dq,
        className: It.arrow,
        externalForwardedProps: Kr,
        ownerState: $r,
        ref: ee,
      });
    return O.jsxs(N.Fragment, {
      children: [
        N.cloneElement(z, ot),
        O.jsx(ka, {
          as: k ?? N3,
          placement: D,
          anchorEl: E
            ? {
                getBoundingClientRect: () => ({
                  top: Nf.y,
                  left: Nf.x,
                  right: Nf.x,
                  bottom: Nf.y,
                  width: 0,
                  height: 0,
                }),
              }
            : V,
          popperRef: rr,
          open: V ? Pe : !1,
          id: We,
          transition: !0,
          ...oi,
          ...Lp,
          popperOptions: Ve,
          children: ({ TransitionProps: at }) =>
            O.jsx(Da, {
              timeout: B.transitions.duration.shorter,
              ...at,
              ...$a,
              children: O.jsxs(vg, {
                ...bg,
                children: [K, i ? O.jsx(Eg, { ...Cg }) : null],
              }),
            }),
        }),
      ],
    });
  }),
  cx = _F({
    createStyledComponent: Ce("div", {
      name: "MuiStack",
      slot: "Root",
      overridesResolver: (t, e) => e.root,
    }),
    useThemeProps: (t) => ft({ props: t, name: "MuiStack" }),
  });
function Mq(t) {
  return st("MuiTextField", t);
}
ut("MuiTextField", ["root"]);
const Lq = { standard: dA, filled: uA, outlined: fA },
  Uq = (t) => {
    const { classes: e } = t;
    return dt({ root: ["root"] }, Mq, e);
  },
  Bq = Ce(rH, {
    name: "MuiTextField",
    slot: "Root",
    overridesResolver: (t, e) => e.root,
  })({}),
  IP = N.forwardRef(function (e, n) {
    const r = ft({ props: e, name: "MuiTextField" }),
      {
        autoComplete: i,
        autoFocus: s = !1,
        children: o,
        className: a,
        color: l = "primary",
        defaultValue: d,
        disabled: p = !1,
        error: f = !1,
        FormHelperTextProps: m,
        fullWidth: y = !1,
        helperText: g,
        id: v,
        InputLabelProps: b,
        inputProps: E,
        InputProps: S,
        inputRef: C,
        label: _,
        maxRows: A,
        minRows: I,
        multiline: R = !1,
        name: D,
        onBlur: k,
        onChange: T,
        onFocus: U,
        placeholder: q,
        required: K = !1,
        rows: H,
        select: $ = !1,
        SelectProps: M,
        slots: z = {},
        slotProps: B = {},
        type: j,
        value: V,
        variant: W = "outlined",
        ...Z
      } = r,
      ee = {
        ...r,
        autoFocus: s,
        color: l,
        disabled: p,
        error: f,
        fullWidth: y,
        multiline: R,
        required: K,
        select: $,
        variant: W,
      },
      J = Uq(ee),
      se = sv(v),
      re = g && se ? `${se}-helper-text` : void 0,
      fe = _ && se ? `${se}-label` : void 0,
      ce = Lq[W],
      le = {
        slots: z,
        slotProps: {
          input: S,
          inputLabel: b,
          htmlInput: E,
          formHelperText: m,
          select: M,
          ...B,
        },
      },
      Se = {},
      je = le.slotProps.inputLabel;
    W === "outlined" &&
      (je && typeof je.shrink < "u" && (Se.notched = je.shrink),
      (Se.label = _)),
      $ &&
        ((!M || !M.native) && (Se.id = void 0),
        (Se["aria-describedby"] = void 0));
    const [Pe, We] = Jn("input", {
        elementType: ce,
        externalForwardedProps: le,
        additionalProps: Se,
        ownerState: ee,
      }),
      [Ne, pt] = Jn("inputLabel", {
        elementType: TH,
        externalForwardedProps: le,
        ownerState: ee,
      }),
      [hn, Wt] = Jn("htmlInput", {
        elementType: "input",
        externalForwardedProps: le,
        ownerState: ee,
      }),
      [Lt, vn] = Jn("formHelperText", {
        elementType: aH,
        externalForwardedProps: le,
        ownerState: ee,
      }),
      [At, vt] = Jn("select", {
        elementType: W3,
        externalForwardedProps: le,
        ownerState: ee,
      }),
      Le = O.jsx(Pe, {
        "aria-describedby": re,
        autoComplete: i,
        autoFocus: s,
        defaultValue: d,
        fullWidth: y,
        multiline: R,
        name: D,
        rows: H,
        maxRows: A,
        minRows: I,
        type: j,
        value: V,
        id: se,
        inputRef: C,
        onBlur: k,
        onChange: T,
        onFocus: U,
        placeholder: q,
        inputProps: Wt,
        slots: { input: z.htmlInput ? hn : void 0 },
        ...We,
      });
    return O.jsxs(Bq, {
      className: He(J.root, a),
      disabled: p,
      error: f,
      fullWidth: y,
      ref: n,
      required: K,
      color: l,
      variant: W,
      ownerState: ee,
      ...Z,
      children: [
        _ != null &&
          _ !== "" &&
          O.jsx(Ne, { htmlFor: se, id: fe, ...pt, children: _ }),
        $
          ? O.jsx(At, {
              "aria-describedby": re,
              id: se,
              labelId: fe,
              value: V,
              input: Le,
              ...vt,
              children: o,
            })
          : Le,
        g && O.jsx(Lt, { id: re, ...vn, children: g }),
      ],
    });
  });
function jq(t) {
  return st("MuiToggleButton", t);
}
const Tl = ut("MuiToggleButton", [
    "root",
    "disabled",
    "selected",
    "standard",
    "primary",
    "secondary",
    "sizeSmall",
    "sizeMedium",
    "sizeLarge",
    "fullWidth",
  ]),
  H3 = N.createContext({}),
  q3 = N.createContext(void 0);
function Fq(t, e) {
  return e === void 0 || t === void 0
    ? !1
    : Array.isArray(e)
    ? e.includes(t)
    : t === e;
}
const zq = (t) => {
    const {
        classes: e,
        fullWidth: n,
        selected: r,
        disabled: i,
        size: s,
        color: o,
      } = t,
      a = {
        root: [
          "root",
          r && "selected",
          i && "disabled",
          n && "fullWidth",
          `size${Re(s)}`,
          o,
        ],
      };
    return dt(a, jq, e);
  },
  Wq = Ce(Wm, {
    name: "MuiToggleButton",
    slot: "Root",
    overridesResolver: (t, e) => {
      const { ownerState: n } = t;
      return [e.root, e[`size${Re(n.size)}`]];
    },
  })(
    wt(({ theme: t }) => ({
      ...t.typography.button,
      borderRadius: (t.vars || t).shape.borderRadius,
      padding: 11,
      border: `1px solid ${(t.vars || t).palette.divider}`,
      color: (t.vars || t).palette.action.active,
      [`&.${Tl.disabled}`]: {
        color: (t.vars || t).palette.action.disabled,
        border: `1px solid ${(t.vars || t).palette.action.disabledBackground}`,
      },
      "&:hover": {
        textDecoration: "none",
        backgroundColor: t.vars
          ? `rgba(${t.vars.palette.text.primaryChannel} / ${t.vars.palette.action.hoverOpacity})`
          : An(t.palette.text.primary, t.palette.action.hoverOpacity),
        "@media (hover: none)": { backgroundColor: "transparent" },
      },
      variants: [
        {
          props: { color: "standard" },
          style: {
            [`&.${Tl.selected}`]: {
              color: (t.vars || t).palette.text.primary,
              backgroundColor: t.vars
                ? `rgba(${t.vars.palette.text.primaryChannel} / ${t.vars.palette.action.selectedOpacity})`
                : An(t.palette.text.primary, t.palette.action.selectedOpacity),
              "&:hover": {
                backgroundColor: t.vars
                  ? `rgba(${t.vars.palette.text.primaryChannel} / calc(${t.vars.palette.action.selectedOpacity} + ${t.vars.palette.action.hoverOpacity}))`
                  : An(
                      t.palette.text.primary,
                      t.palette.action.selectedOpacity +
                        t.palette.action.hoverOpacity
                    ),
                "@media (hover: none)": {
                  backgroundColor: t.vars
                    ? `rgba(${t.vars.palette.text.primaryChannel} / ${t.vars.palette.action.selectedOpacity})`
                    : An(
                        t.palette.text.primary,
                        t.palette.action.selectedOpacity
                      ),
                },
              },
            },
          },
        },
        ...Object.entries(t.palette)
          .filter(hs())
          .map(([e]) => ({
            props: { color: e },
            style: {
              [`&.${Tl.selected}`]: {
                color: (t.vars || t).palette[e].main,
                backgroundColor: t.vars
                  ? `rgba(${t.vars.palette[e].mainChannel} / ${t.vars.palette.action.selectedOpacity})`
                  : An(t.palette[e].main, t.palette.action.selectedOpacity),
                "&:hover": {
                  backgroundColor: t.vars
                    ? `rgba(${t.vars.palette[e].mainChannel} / calc(${t.vars.palette.action.selectedOpacity} + ${t.vars.palette.action.hoverOpacity}))`
                    : An(
                        t.palette[e].main,
                        t.palette.action.selectedOpacity +
                          t.palette.action.hoverOpacity
                      ),
                  "@media (hover: none)": {
                    backgroundColor: t.vars
                      ? `rgba(${t.vars.palette[e].mainChannel} / ${t.vars.palette.action.selectedOpacity})`
                      : An(t.palette[e].main, t.palette.action.selectedOpacity),
                  },
                },
              },
            },
          })),
        { props: { fullWidth: !0 }, style: { width: "100%" } },
        {
          props: { size: "small" },
          style: { padding: 7, fontSize: t.typography.pxToRem(13) },
        },
        {
          props: { size: "large" },
          style: { padding: 15, fontSize: t.typography.pxToRem(15) },
        },
      ],
    }))
  ),
  Hq = N.forwardRef(function (e, n) {
    const { value: r, ...i } = N.useContext(H3),
      s = N.useContext(q3),
      o = Gd({ ...i, selected: Fq(e.value, r) }, e),
      a = ft({ props: o, name: "MuiToggleButton" }),
      {
        children: l,
        className: d,
        color: p = "standard",
        disabled: f = !1,
        disableFocusRipple: m = !1,
        fullWidth: y = !1,
        onChange: g,
        onClick: v,
        selected: b,
        size: E = "medium",
        value: S,
        ...C
      } = a,
      _ = {
        ...a,
        color: p,
        disabled: f,
        disableFocusRipple: m,
        fullWidth: y,
        size: E,
      },
      A = zq(_),
      I = (D) => {
        (v && (v(D, S), D.defaultPrevented)) || (g && g(D, S));
      },
      R = s || "";
    return O.jsx(Wq, {
      className: He(i.className, A.root, d, R),
      disabled: f,
      focusRipple: !m,
      ref: n,
      onClick: I,
      onChange: g,
      value: S,
      ownerState: _,
      "aria-pressed": b,
      ...C,
      children: l,
    });
  });
function qq(t) {
  return st("MuiToggleButtonGroup", t);
}
const un = ut("MuiToggleButtonGroup", [
    "root",
    "selected",
    "horizontal",
    "vertical",
    "disabled",
    "grouped",
    "groupedHorizontal",
    "groupedVertical",
    "fullWidth",
    "firstButton",
    "lastButton",
    "middleButton",
  ]),
  Vq = (t) => {
    const { classes: e, orientation: n, fullWidth: r, disabled: i } = t,
      s = {
        root: ["root", n, r && "fullWidth"],
        grouped: ["grouped", `grouped${Re(n)}`, i && "disabled"],
        firstButton: ["firstButton"],
        lastButton: ["lastButton"],
        middleButton: ["middleButton"],
      };
    return dt(s, qq, e);
  },
  Gq = Ce("div", {
    name: "MuiToggleButtonGroup",
    slot: "Root",
    overridesResolver: (t, e) => {
      const { ownerState: n } = t;
      return [
        { [`& .${un.grouped}`]: e.grouped },
        { [`& .${un.grouped}`]: e[`grouped${Re(n.orientation)}`] },
        { [`& .${un.firstButton}`]: e.firstButton },
        { [`& .${un.lastButton}`]: e.lastButton },
        { [`& .${un.middleButton}`]: e.middleButton },
        e.root,
        n.orientation === "vertical" && e.vertical,
        n.fullWidth && e.fullWidth,
      ];
    },
  })(
    wt(({ theme: t }) => ({
      display: "inline-flex",
      borderRadius: (t.vars || t).shape.borderRadius,
      variants: [
        {
          props: { orientation: "vertical" },
          style: {
            flexDirection: "column",
            [`& .${un.grouped}`]: {
              [`&.${un.selected} + .${un.grouped}.${un.selected}`]: {
                borderTop: 0,
                marginTop: 0,
              },
            },
            [`& .${un.firstButton},& .${un.middleButton}`]: {
              borderBottomLeftRadius: 0,
              borderBottomRightRadius: 0,
            },
            [`& .${un.lastButton},& .${un.middleButton}`]: {
              marginTop: -1,
              borderTop: "1px solid transparent",
              borderTopLeftRadius: 0,
              borderTopRightRadius: 0,
            },
            [`& .${un.lastButton}.${Tl.disabled},& .${un.middleButton}.${Tl.disabled}`]:
              { borderTop: "1px solid transparent" },
          },
        },
        { props: { fullWidth: !0 }, style: { width: "100%" } },
        {
          props: { orientation: "horizontal" },
          style: {
            [`& .${un.grouped}`]: {
              [`&.${un.selected} + .${un.grouped}.${un.selected}`]: {
                borderLeft: 0,
                marginLeft: 0,
              },
            },
            [`& .${un.firstButton},& .${un.middleButton}`]: {
              borderTopRightRadius: 0,
              borderBottomRightRadius: 0,
            },
            [`& .${un.lastButton},& .${un.middleButton}`]: {
              marginLeft: -1,
              borderLeft: "1px solid transparent",
              borderTopLeftRadius: 0,
              borderBottomLeftRadius: 0,
            },
            [`& .${un.lastButton}.${Tl.disabled},& .${un.middleButton}.${Tl.disabled}`]:
              { borderLeft: "1px solid transparent" },
          },
        },
      ],
    }))
  ),
  Kq = N.forwardRef(function (e, n) {
    const r = ft({ props: e, name: "MuiToggleButtonGroup" }),
      {
        children: i,
        className: s,
        color: o = "standard",
        disabled: a = !1,
        exclusive: l = !1,
        fullWidth: d = !1,
        onChange: p,
        orientation: f = "horizontal",
        size: m = "medium",
        value: y,
        ...g
      } = r,
      v = { ...r, disabled: a, fullWidth: d, orientation: f, size: m },
      b = Vq(v),
      E = N.useCallback(
        (R, D) => {
          if (!p) return;
          const k = y && y.indexOf(D);
          let T;
          y && k >= 0
            ? ((T = y.slice()), T.splice(k, 1))
            : (T = y ? y.concat(D) : [D]),
            p(R, T);
        },
        [p, y]
      ),
      S = N.useCallback(
        (R, D) => {
          p && p(R, y === D ? null : D);
        },
        [p, y]
      ),
      C = N.useMemo(
        () => ({
          className: b.grouped,
          onChange: l ? S : E,
          value: y,
          size: m,
          fullWidth: d,
          color: o,
          disabled: a,
        }),
        [b.grouped, l, S, E, y, m, d, o, a]
      ),
      _ = zj(i),
      A = _.length,
      I = (R) => {
        const D = R === 0,
          k = R === A - 1;
        return D && k
          ? ""
          : D
          ? b.firstButton
          : k
          ? b.lastButton
          : b.middleButton;
      };
    return O.jsx(Gq, {
      role: "group",
      className: He(b.root, s),
      ref: n,
      ownerState: v,
      ...g,
      children: O.jsx(H3.Provider, {
        value: C,
        children: _.map((R, D) =>
          O.jsx(q3.Provider, { value: I(D), children: R }, D)
        ),
      }),
    });
  }),
  Yq = Ki(
    O.jsx("path", { d: "M3 18h18v-2H3zm0-5h18v-2H3zm0-7v2h18V6z" }),
    "Menu"
  ),
  hv = "/assets/logo-CPEVDSpN.png",
  Zq = "/assets/error-BNamEpav.png",
  Qq = Symbol(),
  TP = Object.getPrototypeOf,
  lx = new WeakMap(),
  Xq = (t) =>
    t &&
    (lx.has(t)
      ? lx.get(t)
      : TP(t) === Object.prototype || TP(t) === Array.prototype),
  Jq = (t) => (Xq(t) && t[Qq]) || null,
  PP = (t, e = !0) => {
    lx.set(t, e);
  },
  lE = (t) => typeof t == "object" && t !== null,
  pc = new WeakMap(),
  oh = new WeakSet(),
  eV = (
    t = Object.is,
    e = (d, p) => new Proxy(d, p),
    n = (d) =>
      lE(d) &&
      !oh.has(d) &&
      (Array.isArray(d) || !(Symbol.iterator in d)) &&
      !(d instanceof WeakMap) &&
      !(d instanceof WeakSet) &&
      !(d instanceof Error) &&
      !(d instanceof Number) &&
      !(d instanceof Date) &&
      !(d instanceof String) &&
      !(d instanceof RegExp) &&
      !(d instanceof ArrayBuffer),
    r = (d) => {
      switch (d.status) {
        case "fulfilled":
          return d.value;
        case "rejected":
          throw d.reason;
        default:
          throw d;
      }
    },
    i = new WeakMap(),
    s = (d, p, f = r) => {
      const m = i.get(d);
      if ((m == null ? void 0 : m[0]) === p) return m[1];
      const y = Array.isArray(d) ? [] : Object.create(Object.getPrototypeOf(d));
      return (
        PP(y, !0),
        i.set(d, [p, y]),
        Reflect.ownKeys(d).forEach((g) => {
          if (Object.getOwnPropertyDescriptor(y, g)) return;
          const v = Reflect.get(d, g),
            { enumerable: b } = Reflect.getOwnPropertyDescriptor(d, g),
            E = { value: v, enumerable: b, configurable: !0 };
          if (oh.has(v)) PP(v, !1);
          else if (v instanceof Promise) delete E.value, (E.get = () => f(v));
          else if (pc.has(v)) {
            const [S, C] = pc.get(v);
            E.value = s(S, C(), f);
          }
          Object.defineProperty(y, g, E);
        }),
        Object.preventExtensions(y)
      );
    },
    o = new WeakMap(),
    a = [1, 1],
    l = (d) => {
      if (!lE(d)) throw new Error("object required");
      const p = o.get(d);
      if (p) return p;
      let f = a[0];
      const m = new Set(),
        y = (k, T = ++a[0]) => {
          f !== T && ((f = T), m.forEach((U) => U(k, T)));
        };
      let g = a[1];
      const v = (k = ++a[1]) => (
          g !== k &&
            !m.size &&
            ((g = k),
            E.forEach(([T]) => {
              const U = T[1](k);
              U > f && (f = U);
            })),
          f
        ),
        b = (k) => (T, U) => {
          const q = [...T];
          (q[1] = [k, ...q[1]]), y(q, U);
        },
        E = new Map(),
        S = (k, T) => {
          if (m.size) {
            const U = T[3](b(k));
            E.set(k, [T, U]);
          } else E.set(k, [T]);
        },
        C = (k) => {
          var T;
          const U = E.get(k);
          U && (E.delete(k), (T = U[1]) == null || T.call(U));
        },
        _ = (k) => (
          m.add(k),
          m.size === 1 &&
            E.forEach(([U, q], K) => {
              const H = U[3](b(K));
              E.set(K, [U, H]);
            }),
          () => {
            m.delete(k),
              m.size === 0 &&
                E.forEach(([U, q], K) => {
                  q && (q(), E.set(K, [U]));
                });
          }
        ),
        A = Array.isArray(d) ? [] : Object.create(Object.getPrototypeOf(d)),
        R = e(A, {
          deleteProperty(k, T) {
            const U = Reflect.get(k, T);
            C(T);
            const q = Reflect.deleteProperty(k, T);
            return q && y(["delete", [T], U]), q;
          },
          set(k, T, U, q) {
            const K = Reflect.has(k, T),
              H = Reflect.get(k, T, q);
            if (K && (t(H, U) || (o.has(U) && t(H, o.get(U))))) return !0;
            C(T), lE(U) && (U = Jq(U) || U);
            let $ = U;
            if (U instanceof Promise)
              U.then((M) => {
                (U.status = "fulfilled"), (U.value = M), y(["resolve", [T], M]);
              }).catch((M) => {
                (U.status = "rejected"), (U.reason = M), y(["reject", [T], M]);
              });
            else {
              !pc.has(U) && n(U) && ($ = l(U));
              const M = !oh.has($) && pc.get($);
              M && S(T, M);
            }
            return Reflect.set(k, T, $, q), y(["set", [T], U, H]), !0;
          },
        });
      o.set(d, R);
      const D = [A, v, s, _];
      return (
        pc.set(R, D),
        Reflect.ownKeys(d).forEach((k) => {
          const T = Object.getOwnPropertyDescriptor(d, k);
          "value" in T && ((R[k] = d[k]), delete T.value, delete T.writable),
            Object.defineProperty(A, k, T);
        }),
        R
      );
    }
  ) => [l, pc, oh, t, e, n, r, i, s, o, a],
  [tV] = eV();
function wn(t = {}) {
  return tV(t);
}
function ri(t, e, n) {
  const r = pc.get(t);
  let i;
  const s = [],
    o = r[3];
  let a = !1;
  const d = o((p) => {
    s.push(p),
      i ||
        (i = Promise.resolve().then(() => {
          (i = void 0), a && e(s.splice(0));
        }));
  });
  return (
    (a = !0),
    () => {
      (a = !1), d();
    }
  );
}
function Bh(t, e) {
  const n = pc.get(t),
    [r, i, s] = n;
  return s(r, i(), e);
}
function Kl(t) {
  return oh.add(t), t;
}
function si(t, e, n, r) {
  let i = t[e];
  return ri(t, () => {
    const s = t[e];
    Object.is(i, s) || n((i = s));
  });
}
function nV(t) {
  const e = wn({
    data: Array.from([]),
    has(n) {
      return this.data.some((r) => r[0] === n);
    },
    set(n, r) {
      const i = this.data.find((s) => s[0] === n);
      return i ? (i[1] = r) : this.data.push([n, r]), this;
    },
    get(n) {
      var r;
      return (r = this.data.find((i) => i[0] === n)) == null ? void 0 : r[1];
    },
    delete(n) {
      const r = this.data.findIndex((i) => i[0] === n);
      return r === -1 ? !1 : (this.data.splice(r, 1), !0);
    },
    clear() {
      this.data.splice(0);
    },
    get size() {
      return this.data.length;
    },
    toJSON() {
      return new Map(this.data);
    },
    forEach(n) {
      this.data.forEach((r) => {
        n(r[1], r[0], this);
      });
    },
    keys() {
      return this.data.map((n) => n[0]).values();
    },
    values() {
      return this.data.map((n) => n[1]).values();
    },
    entries() {
      return new Map(this.data).entries();
    },
    get [Symbol.toStringTag]() {
      return "Map";
    },
    [Symbol.iterator]() {
      return this.entries();
    },
  });
  return (
    Object.defineProperties(e, {
      data: { enumerable: !1 },
      size: { enumerable: !1 },
      toJSON: { enumerable: !1 },
    }),
    Object.seal(e),
    e
  );
}
const jh = {
  caipNetworkIdToNumber(t) {
    return t ? Number(t.split(":")[1]) : void 0;
  },
  parseEvmChainId(t) {
    return typeof t == "string" ? this.caipNetworkIdToNumber(t) : t;
  },
  getNetworksByNamespace(t, e) {
    return (t == null ? void 0 : t.filter((n) => n.chainNamespace === e)) || [];
  },
  getFirstNetworkByNamespace(t, e) {
    return this.getNetworksByNamespace(t, e)[0];
  },
};
var rV = 20,
  iV = 1,
  Yl = 1e6,
  RP = 1e6,
  sV = -7,
  oV = 21,
  aV = !1,
  Vm = "[big.js] ",
  uu = Vm + "Invalid ",
  mv = uu + "decimal places",
  cV = uu + "rounding mode",
  V3 = Vm + "Division by zero",
  Vt = {},
  Po = void 0,
  lV = /^-?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i;
function G3() {
  function t(e) {
    var n = this;
    if (!(n instanceof t)) return e === Po ? G3() : new t(e);
    if (e instanceof t) (n.s = e.s), (n.e = e.e), (n.c = e.c.slice());
    else {
      if (typeof e != "string") {
        if (t.strict === !0 && typeof e != "bigint")
          throw TypeError(uu + "value");
        e = e === 0 && 1 / e < 0 ? "-0" : String(e);
      }
      uV(n, e);
    }
    n.constructor = t;
  }
  return (
    (t.prototype = Vt),
    (t.DP = rV),
    (t.RM = iV),
    (t.NE = sV),
    (t.PE = oV),
    (t.strict = aV),
    (t.roundDown = 0),
    (t.roundHalfUp = 1),
    (t.roundHalfEven = 2),
    (t.roundUp = 3),
    t
  );
}
function uV(t, e) {
  var n, r, i;
  if (!lV.test(e)) throw Error(uu + "number");
  for (
    t.s = e.charAt(0) == "-" ? ((e = e.slice(1)), -1) : 1,
      (n = e.indexOf(".")) > -1 && (e = e.replace(".", "")),
      (r = e.search(/e/i)) > 0
        ? (n < 0 && (n = r), (n += +e.slice(r + 1)), (e = e.substring(0, r)))
        : n < 0 && (n = e.length),
      i = e.length,
      r = 0;
    r < i && e.charAt(r) == "0";

  )
    ++r;
  if (r == i) t.c = [(t.e = 0)];
  else {
    for (; i > 0 && e.charAt(--i) == "0"; );
    for (t.e = n - r - 1, t.c = [], n = 0; r <= i; ) t.c[n++] = +e.charAt(r++);
  }
  return t;
}
function du(t, e, n, r) {
  var i = t.c;
  if (
    (n === Po && (n = t.constructor.RM),
    n !== 0 && n !== 1 && n !== 2 && n !== 3)
  )
    throw Error(cV);
  if (e < 1)
    (r =
      (n === 3 && (r || !!i[0])) ||
      (e === 0 &&
        ((n === 1 && i[0] >= 5) ||
          (n === 2 && (i[0] > 5 || (i[0] === 5 && (r || i[1] !== Po))))))),
      (i.length = 1),
      r ? ((t.e = t.e - e + 1), (i[0] = 1)) : (i[0] = t.e = 0);
  else if (e < i.length) {
    if (
      ((r =
        (n === 1 && i[e] >= 5) ||
        (n === 2 &&
          (i[e] > 5 ||
            (i[e] === 5 && (r || i[e + 1] !== Po || i[e - 1] & 1)))) ||
        (n === 3 && (r || !!i[0]))),
      (i.length = e),
      r)
    ) {
      for (; ++i[--e] > 9; )
        if (((i[e] = 0), e === 0)) {
          ++t.e, i.unshift(1);
          break;
        }
    }
    for (e = i.length; !i[--e]; ) i.pop();
  }
  return t;
}
function pu(t, e, n) {
  var r = t.e,
    i = t.c.join(""),
    s = i.length;
  if (e)
    i =
      i.charAt(0) + (s > 1 ? "." + i.slice(1) : "") + (r < 0 ? "e" : "e+") + r;
  else if (r < 0) {
    for (; ++r; ) i = "0" + i;
    i = "0." + i;
  } else if (r > 0)
    if (++r > s) for (r -= s; r--; ) i += "0";
    else r < s && (i = i.slice(0, r) + "." + i.slice(r));
  else s > 1 && (i = i.charAt(0) + "." + i.slice(1));
  return t.s < 0 && n ? "-" + i : i;
}
Vt.abs = function () {
  var t = new this.constructor(this);
  return (t.s = 1), t;
};
Vt.cmp = function (t) {
  var e,
    n = this,
    r = n.c,
    i = (t = new n.constructor(t)).c,
    s = n.s,
    o = t.s,
    a = n.e,
    l = t.e;
  if (!r[0] || !i[0]) return r[0] ? s : i[0] ? -o : 0;
  if (s != o) return s;
  if (((e = s < 0), a != l)) return (a > l) ^ e ? 1 : -1;
  for (o = (a = r.length) < (l = i.length) ? a : l, s = -1; ++s < o; )
    if (r[s] != i[s]) return (r[s] > i[s]) ^ e ? 1 : -1;
  return a == l ? 0 : (a > l) ^ e ? 1 : -1;
};
Vt.div = function (t) {
  var e = this,
    n = e.constructor,
    r = e.c,
    i = (t = new n(t)).c,
    s = e.s == t.s ? 1 : -1,
    o = n.DP;
  if (o !== ~~o || o < 0 || o > Yl) throw Error(mv);
  if (!i[0]) throw Error(V3);
  if (!r[0]) return (t.s = s), (t.c = [(t.e = 0)]), t;
  var a,
    l,
    d,
    p,
    f,
    m = i.slice(),
    y = (a = i.length),
    g = r.length,
    v = r.slice(0, a),
    b = v.length,
    E = t,
    S = (E.c = []),
    C = 0,
    _ = o + (E.e = e.e - t.e) + 1;
  for (E.s = s, s = _ < 0 ? 0 : _, m.unshift(0); b++ < a; ) v.push(0);
  do {
    for (d = 0; d < 10; d++) {
      if (a != (b = v.length)) p = a > b ? 1 : -1;
      else
        for (f = -1, p = 0; ++f < a; )
          if (i[f] != v[f]) {
            p = i[f] > v[f] ? 1 : -1;
            break;
          }
      if (p < 0) {
        for (l = b == a ? i : m; b; ) {
          if (v[--b] < l[b]) {
            for (f = b; f && !v[--f]; ) v[f] = 9;
            --v[f], (v[b] += 10);
          }
          v[b] -= l[b];
        }
        for (; !v[0]; ) v.shift();
      } else break;
    }
    (S[C++] = p ? d : ++d), v[0] && p ? (v[b] = r[y] || 0) : (v = [r[y]]);
  } while ((y++ < g || v[0] !== Po) && s--);
  return (
    !S[0] && C != 1 && (S.shift(), E.e--, _--),
    C > _ && du(E, _, n.RM, v[0] !== Po),
    E
  );
};
Vt.eq = function (t) {
  return this.cmp(t) === 0;
};
Vt.gt = function (t) {
  return this.cmp(t) > 0;
};
Vt.gte = function (t) {
  return this.cmp(t) > -1;
};
Vt.lt = function (t) {
  return this.cmp(t) < 0;
};
Vt.lte = function (t) {
  return this.cmp(t) < 1;
};
Vt.minus = Vt.sub = function (t) {
  var e,
    n,
    r,
    i,
    s = this,
    o = s.constructor,
    a = s.s,
    l = (t = new o(t)).s;
  if (a != l) return (t.s = -l), s.plus(t);
  var d = s.c.slice(),
    p = s.e,
    f = t.c,
    m = t.e;
  if (!d[0] || !f[0])
    return f[0] ? (t.s = -l) : d[0] ? (t = new o(s)) : (t.s = 1), t;
  if ((a = p - m)) {
    for (
      (i = a < 0) ? ((a = -a), (r = d)) : ((m = p), (r = f)),
        r.reverse(),
        l = a;
      l--;

    )
      r.push(0);
    r.reverse();
  } else
    for (n = ((i = d.length < f.length) ? d : f).length, a = l = 0; l < n; l++)
      if (d[l] != f[l]) {
        i = d[l] < f[l];
        break;
      }
  if (
    (i && ((r = d), (d = f), (f = r), (t.s = -t.s)),
    (l = (n = f.length) - (e = d.length)) > 0)
  )
    for (; l--; ) d[e++] = 0;
  for (l = e; n > a; ) {
    if (d[--n] < f[n]) {
      for (e = n; e && !d[--e]; ) d[e] = 9;
      --d[e], (d[n] += 10);
    }
    d[n] -= f[n];
  }
  for (; d[--l] === 0; ) d.pop();
  for (; d[0] === 0; ) d.shift(), --m;
  return d[0] || ((t.s = 1), (d = [(m = 0)])), (t.c = d), (t.e = m), t;
};
Vt.mod = function (t) {
  var e,
    n = this,
    r = n.constructor,
    i = n.s,
    s = (t = new r(t)).s;
  if (!t.c[0]) throw Error(V3);
  return (
    (n.s = t.s = 1),
    (e = t.cmp(n) == 1),
    (n.s = i),
    (t.s = s),
    e
      ? new r(n)
      : ((i = r.DP),
        (s = r.RM),
        (r.DP = r.RM = 0),
        (n = n.div(t)),
        (r.DP = i),
        (r.RM = s),
        this.minus(n.times(t)))
  );
};
Vt.neg = function () {
  var t = new this.constructor(this);
  return (t.s = -t.s), t;
};
Vt.plus = Vt.add = function (t) {
  var e,
    n,
    r,
    i = this,
    s = i.constructor;
  if (((t = new s(t)), i.s != t.s)) return (t.s = -t.s), i.minus(t);
  var o = i.e,
    a = i.c,
    l = t.e,
    d = t.c;
  if (!a[0] || !d[0]) return d[0] || (a[0] ? (t = new s(i)) : (t.s = i.s)), t;
  if (((a = a.slice()), (e = o - l))) {
    for (e > 0 ? ((l = o), (r = d)) : ((e = -e), (r = a)), r.reverse(); e--; )
      r.push(0);
    r.reverse();
  }
  for (
    a.length - d.length < 0 && ((r = d), (d = a), (a = r)), e = d.length, n = 0;
    e;
    a[e] %= 10
  )
    n = ((a[--e] = a[e] + d[e] + n) / 10) | 0;
  for (n && (a.unshift(n), ++l), e = a.length; a[--e] === 0; ) a.pop();
  return (t.c = a), (t.e = l), t;
};
Vt.pow = function (t) {
  var e = this,
    n = new e.constructor("1"),
    r = n,
    i = t < 0;
  if (t !== ~~t || t < -RP || t > RP) throw Error(uu + "exponent");
  for (i && (t = -t); t & 1 && (r = r.times(e)), (t >>= 1), !!t; )
    e = e.times(e);
  return i ? n.div(r) : r;
};
Vt.prec = function (t, e) {
  if (t !== ~~t || t < 1 || t > Yl) throw Error(uu + "precision");
  return du(new this.constructor(this), t, e);
};
Vt.round = function (t, e) {
  if (t === Po) t = 0;
  else if (t !== ~~t || t < -Yl || t > Yl) throw Error(mv);
  return du(new this.constructor(this), t + this.e + 1, e);
};
Vt.sqrt = function () {
  var t,
    e,
    n,
    r = this,
    i = r.constructor,
    s = r.s,
    o = r.e,
    a = new i("0.5");
  if (!r.c[0]) return new i(r);
  if (s < 0) throw Error(Vm + "No square root");
  (s = Math.sqrt(+pu(r, !0, !0))),
    s === 0 || s === 1 / 0
      ? ((e = r.c.join("")),
        (e.length + o) & 1 || (e += "0"),
        (s = Math.sqrt(e)),
        (o = (((o + 1) / 2) | 0) - (o < 0 || o & 1)),
        (t = new i(
          (s == 1 / 0
            ? "5e"
            : (s = s.toExponential()).slice(0, s.indexOf("e") + 1)) + o
        )))
      : (t = new i(s + "")),
    (o = t.e + (i.DP += 4));
  do (n = t), (t = a.times(n.plus(r.div(n))));
  while (n.c.slice(0, o).join("") !== t.c.slice(0, o).join(""));
  return du(t, (i.DP -= 4) + t.e + 1, i.RM);
};
Vt.times = Vt.mul = function (t) {
  var e,
    n = this,
    r = n.constructor,
    i = n.c,
    s = (t = new r(t)).c,
    o = i.length,
    a = s.length,
    l = n.e,
    d = t.e;
  if (((t.s = n.s == t.s ? 1 : -1), !i[0] || !s[0]))
    return (t.c = [(t.e = 0)]), t;
  for (
    t.e = l + d,
      o < a && ((e = i), (i = s), (s = e), (d = o), (o = a), (a = d)),
      e = new Array((d = o + a));
    d--;

  )
    e[d] = 0;
  for (l = a; l--; ) {
    for (a = 0, d = o + l; d > l; )
      (a = e[d] + s[l] * i[d - l - 1] + a),
        (e[d--] = a % 10),
        (a = (a / 10) | 0);
    e[d] = a;
  }
  for (a ? ++t.e : e.shift(), l = e.length; !e[--l]; ) e.pop();
  return (t.c = e), t;
};
Vt.toExponential = function (t, e) {
  var n = this,
    r = n.c[0];
  if (t !== Po) {
    if (t !== ~~t || t < 0 || t > Yl) throw Error(mv);
    for (n = du(new n.constructor(n), ++t, e); n.c.length < t; ) n.c.push(0);
  }
  return pu(n, !0, !!r);
};
Vt.toFixed = function (t, e) {
  var n = this,
    r = n.c[0];
  if (t !== Po) {
    if (t !== ~~t || t < 0 || t > Yl) throw Error(mv);
    for (
      n = du(new n.constructor(n), t + n.e + 1, e), t = t + n.e + 1;
      n.c.length < t;

    )
      n.c.push(0);
  }
  return pu(n, !1, !!r);
};
Vt[Symbol.for("nodejs.util.inspect.custom")] =
  Vt.toJSON =
  Vt.toString =
    function () {
      var t = this,
        e = t.constructor;
      return pu(t, t.e <= e.NE || t.e >= e.PE, !!t.c[0]);
    };
Vt.toNumber = function () {
  var t = +pu(this, !0, !0);
  if (this.constructor.strict === !0 && !this.eq(t.toString()))
    throw Error(Vm + "Imprecise conversion");
  return t;
};
Vt.toPrecision = function (t, e) {
  var n = this,
    r = n.constructor,
    i = n.c[0];
  if (t !== Po) {
    if (t !== ~~t || t < 1 || t > Yl) throw Error(uu + "precision");
    for (n = du(new r(n), t, e); n.c.length < t; ) n.c.push(0);
  }
  return pu(n, t <= n.e || n.e <= r.NE || n.e >= r.PE, !!i);
};
Vt.valueOf = function () {
  var t = this,
    e = t.constructor;
  if (e.strict === !0) throw Error(Vm + "valueOf disallowed");
  return pu(t, t.e <= e.NE || t.e >= e.PE, !0);
};
var Of = G3();
const dV = {
    bigNumber(t) {
      return t ? new Of(t) : new Of(0);
    },
    multiply(t, e) {
      if (t === void 0 || e === void 0) return new Of(0);
      const n = new Of(t),
        r = new Of(e);
      return n.times(r);
    },
    formatNumberToLocalString(t, e = 2) {
      return t === void 0
        ? "0.00"
        : typeof t == "number"
        ? t.toLocaleString("en-US", {
            maximumFractionDigits: e,
            minimumFractionDigits: e,
          })
        : parseFloat(t).toLocaleString("en-US", {
            maximumFractionDigits: e,
            minimumFractionDigits: e,
          });
    },
    parseLocalStringToNumber(t) {
      return t === void 0 ? 0 : parseFloat(t.replace(/,/gu, ""));
    },
  },
  pV = [
    {
      type: "function",
      name: "transfer",
      stateMutability: "nonpayable",
      inputs: [
        { name: "_to", type: "address" },
        { name: "_value", type: "uint256" },
      ],
      outputs: [{ name: "", type: "bool" }],
    },
    {
      type: "function",
      name: "transferFrom",
      stateMutability: "nonpayable",
      inputs: [
        { name: "_from", type: "address" },
        { name: "_to", type: "address" },
        { name: "_value", type: "uint256" },
      ],
      outputs: [{ name: "", type: "bool" }],
    },
  ],
  fV = [
    {
      type: "function",
      name: "approve",
      stateMutability: "nonpayable",
      inputs: [
        { name: "spender", type: "address" },
        { name: "amount", type: "uint256" },
      ],
      outputs: [{ type: "bool" }],
    },
  ],
  hV = [
    {
      type: "function",
      name: "transfer",
      stateMutability: "nonpayable",
      inputs: [
        { name: "recipient", type: "address" },
        { name: "amount", type: "uint256" },
      ],
      outputs: [],
    },
    {
      type: "function",
      name: "transferFrom",
      stateMutability: "nonpayable",
      inputs: [
        { name: "sender", type: "address" },
        { name: "recipient", type: "address" },
        { name: "amount", type: "uint256" },
      ],
      outputs: [{ name: "", type: "bool" }],
    },
  ];
var NP = {};
const ye = {
    WC_NAME_SUFFIX: ".reown.id",
    WC_NAME_SUFFIX_LEGACY: ".wcn.id",
    BLOCKCHAIN_API_RPC_URL: "https://rpc.walletconnect.org",
    PULSE_API_URL: "https://pulse.walletconnect.org",
    W3M_API_URL: "https://api.web3modal.org",
    CONNECTOR_ID: {
      WALLET_CONNECT: "walletConnect",
      INJECTED: "injected",
      WALLET_STANDARD: "announced",
      COINBASE: "coinbaseWallet",
      COINBASE_SDK: "coinbaseWalletSDK",
      SAFE: "safe",
      LEDGER: "ledger",
      OKX: "okx",
      EIP6963: "eip6963",
      AUTH: "ID_AUTH",
    },
    CONNECTOR_NAMES: { AUTH: "Auth" },
    AUTH_CONNECTOR_SUPPORTED_CHAINS: ["eip155", "solana"],
    LIMITS: { PENDING_TRANSACTIONS: 99 },
    CHAIN: {
      EVM: "eip155",
      SOLANA: "solana",
      POLKADOT: "polkadot",
      BITCOIN: "bip122",
    },
    CHAIN_NAME_MAP: {
      eip155: "EVM Networks",
      solana: "Solana",
      polkadot: "Polkadot",
      bip122: "Bitcoin",
      cosmos: "Cosmos",
    },
    ADAPTER_TYPES: {
      BITCOIN: "bitcoin",
      SOLANA: "solana",
      WAGMI: "wagmi",
      ETHERS: "ethers",
      ETHERS5: "ethers5",
    },
    USDT_CONTRACT_ADDRESSES: [
      "0xdac17f958d2ee523a2206206994597c13d831ec7",
      "0xc2132d05d31c914a87c6611c10748aeb04b58e8f",
      "0x9702230a8ea53601f5cd2dc00fdbc13d4df4a8c7",
      "0x919C1c267BC06a7039e03fcc2eF738525769109c",
      "0x48065fbBE25f71C9282ddf5e1cD6D6A887483D5e",
      "0x55d398326f99059fF775485246999027B3197955",
      "0xfd086bc7cd5c481dcc9c85ebe478a1c0b69fcbb9",
    ],
    HTTP_STATUS_CODES: { SERVICE_UNAVAILABLE: 503, FORBIDDEN: 403 },
    UNSUPPORTED_NETWORK_NAME: "Unknown Network",
    SECURE_SITE_SDK_ORIGIN:
      (typeof process < "u" && typeof NP < "u"
        ? NP.NEXT_PUBLIC_SECURE_SITE_ORIGIN
        : void 0) || "https://secure.walletconnect.org",
  },
  mV = {
    getERC20Abi: (t) => (ye.USDT_CONTRACT_ADDRESSES.includes(t) ? hV : pV),
    getSwapAbi: () => fV,
  },
  tc = {
    validateCaipAddress(t) {
      var e;
      if (((e = t.split(":")) == null ? void 0 : e.length) !== 3)
        throw new Error("Invalid CAIP Address");
      return t;
    },
    parseCaipAddress(t) {
      const e = t.split(":");
      if (e.length !== 3) throw new Error(`Invalid CAIP-10 address: ${t}`);
      const [n, r, i] = e;
      if (!n || !r || !i) throw new Error(`Invalid CAIP-10 address: ${t}`);
      return { chainNamespace: n, chainId: r, address: i };
    },
    parseCaipNetworkId(t) {
      const e = t.split(":");
      if (e.length !== 2) throw new Error(`Invalid CAIP-2 network id: ${t}`);
      const [n, r] = e;
      if (!n || !r) throw new Error(`Invalid CAIP-2 network id: ${t}`);
      return { chainNamespace: n, chainId: r };
    },
  },
  ht = {
    WALLET_ID: "@appkit/wallet_id",
    WALLET_NAME: "@appkit/wallet_name",
    SOLANA_WALLET: "@appkit/solana_wallet",
    SOLANA_CAIP_CHAIN: "@appkit/solana_caip_chain",
    ACTIVE_CAIP_NETWORK_ID: "@appkit/active_caip_network_id",
    CONNECTED_SOCIAL: "@appkit/connected_social",
    CONNECTED_SOCIAL_USERNAME: "@appkit-wallet/SOCIAL_USERNAME",
    RECENT_WALLETS: "@appkit/recent_wallets",
    DEEPLINK_CHOICE: "WALLETCONNECT_DEEPLINK_CHOICE",
    ACTIVE_NAMESPACE: "@appkit/active_namespace",
    CONNECTED_NAMESPACES: "@appkit/connected_namespaces",
    CONNECTION_STATUS: "@appkit/connection_status",
    SIWX_AUTH_TOKEN: "@appkit/siwx-auth-token",
    SIWX_NONCE_TOKEN: "@appkit/siwx-nonce-token",
    TELEGRAM_SOCIAL_PROVIDER: "@appkit/social_provider",
    NATIVE_BALANCE_CACHE: "@appkit/native_balance_cache",
    PORTFOLIO_CACHE: "@appkit/portfolio_cache",
    ENS_CACHE: "@appkit/ens_cache",
    IDENTITY_CACHE: "@appkit/identity_cache",
    PREFERRED_ACCOUNT_TYPES: "@appkit/preferred_account_types",
  };
function uE(t) {
  if (!t) throw new Error("Namespace is required for CONNECTED_CONNECTOR_ID");
  return `@appkit/${t}:connected_connector_id`;
}
const it = {
  setItem(t, e) {
    ah() && e !== void 0 && localStorage.setItem(t, e);
  },
  getItem(t) {
    if (ah()) return localStorage.getItem(t) || void 0;
  },
  removeItem(t) {
    ah() && localStorage.removeItem(t);
  },
  clear() {
    ah() && localStorage.clear();
  },
};
function ah() {
  return typeof window < "u" && typeof localStorage < "u";
}
function ga(t, e) {
  return e === "light"
    ? {
        "--w3m-accent":
          (t == null ? void 0 : t["--w3m-accent"]) || "hsla(231, 100%, 70%, 1)",
        "--w3m-background": "#fff",
      }
    : {
        "--w3m-accent":
          (t == null ? void 0 : t["--w3m-accent"]) || "hsla(230, 100%, 67%, 1)",
        "--w3m-background": "#121313",
      };
}
var OP = {};
const dE =
    (typeof process < "u" && typeof OP < "u"
      ? OP.NEXT_PUBLIC_SECURE_SITE_ORIGIN
      : void 0) || "https://secure.walletconnect.org",
  Tbe = [
    {
      label: "Coinbase",
      name: "coinbase",
      feeRange: "1-2%",
      url: "",
      supportedChains: ["eip155"],
    },
    {
      label: "Meld.io",
      name: "meld",
      feeRange: "1-2%",
      url: "https://meldcrypto.com",
      supportedChains: ["eip155", "solana"],
    },
  ],
  Pbe = "WXETMuFUQmqqybHuRkSgxv:25B8LJHSfpG6LVjR2ytU5Cwh7Z4Sch2ocoU",
  er = {
    FOUR_MINUTES_MS: 24e4,
    TEN_SEC_MS: 1e4,
    FIVE_SEC_MS: 5e3,
    THREE_SEC_MS: 3e3,
    ONE_SEC_MS: 1e3,
    SECURE_SITE: dE,
    SECURE_SITE_DASHBOARD: `${dE}/dashboard`,
    SECURE_SITE_FAVICON: `${dE}/images/favicon.png`,
    RESTRICTED_TIMEZONES: [
      "ASIA/SHANGHAI",
      "ASIA/URUMQI",
      "ASIA/CHONGQING",
      "ASIA/HARBIN",
      "ASIA/KASHGAR",
      "ASIA/MACAU",
      "ASIA/HONG_KONG",
      "ASIA/MACAO",
      "ASIA/BEIJING",
      "ASIA/HARBIN",
    ],
    WC_COINBASE_PAY_SDK_CHAINS: [
      "ethereum",
      "arbitrum",
      "polygon",
      "berachain",
      "avalanche-c-chain",
      "optimism",
      "celo",
      "base",
    ],
    WC_COINBASE_PAY_SDK_FALLBACK_CHAIN: "ethereum",
    WC_COINBASE_PAY_SDK_CHAIN_NAME_MAP: {
      Ethereum: "ethereum",
      "Arbitrum One": "arbitrum",
      Polygon: "polygon",
      Berachain: "berachain",
      Avalanche: "avalanche-c-chain",
      "OP Mainnet": "optimism",
      Celo: "celo",
      Base: "base",
    },
    WC_COINBASE_ONRAMP_APP_ID: "bf18c88d-495a-463b-b249-0b9d3656cf5e",
    SWAP_SUGGESTED_TOKENS: [
      "ETH",
      "UNI",
      "1INCH",
      "AAVE",
      "SOL",
      "ADA",
      "AVAX",
      "DOT",
      "LINK",
      "NITRO",
      "GAIA",
      "MILK",
      "TRX",
      "NEAR",
      "GNO",
      "WBTC",
      "DAI",
      "WETH",
      "USDC",
      "USDT",
      "ARB",
      "BAL",
      "BICO",
      "CRV",
      "ENS",
      "MATIC",
      "OP",
    ],
    SWAP_POPULAR_TOKENS: [
      "ETH",
      "UNI",
      "1INCH",
      "AAVE",
      "SOL",
      "ADA",
      "AVAX",
      "DOT",
      "LINK",
      "NITRO",
      "GAIA",
      "MILK",
      "TRX",
      "NEAR",
      "GNO",
      "WBTC",
      "DAI",
      "WETH",
      "USDC",
      "USDT",
      "ARB",
      "BAL",
      "BICO",
      "CRV",
      "ENS",
      "MATIC",
      "OP",
      "METAL",
      "DAI",
      "CHAMP",
      "WOLF",
      "SALE",
      "BAL",
      "BUSD",
      "MUST",
      "BTCpx",
      "ROUTE",
      "HEX",
      "WELT",
      "amDAI",
      "VSQ",
      "VISION",
      "AURUM",
      "pSP",
      "SNX",
      "VC",
      "LINK",
      "CHP",
      "amUSDT",
      "SPHERE",
      "FOX",
      "GIDDY",
      "GFC",
      "OMEN",
      "OX_OLD",
      "DE",
      "WNT",
    ],
    BALANCE_SUPPORTED_CHAINS: ["eip155", "solana"],
    SWAP_SUPPORTED_NETWORKS: [
      "eip155:1",
      "eip155:42161",
      "eip155:10",
      "eip155:324",
      "eip155:8453",
      "eip155:56",
      "eip155:137",
      "eip155:100",
      "eip155:43114",
      "eip155:250",
      "eip155:8217",
      "eip155:1313161554",
    ],
    NAMES_SUPPORTED_CHAIN_NAMESPACES: ["eip155"],
    ONRAMP_SUPPORTED_CHAIN_NAMESPACES: ["eip155", "solana"],
    ACTIVITY_ENABLED_CHAIN_NAMESPACES: ["eip155"],
    NATIVE_TOKEN_ADDRESS: {
      eip155: "0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee",
      solana: "So11111111111111111111111111111111111111111",
      polkadot: "0x",
      bip122: "0x",
      cosmos: "0x",
    },
    CONVERT_SLIPPAGE_TOLERANCE: 1,
    CONNECT_LABELS: { MOBILE: "Open and continue in a new browser tab" },
    SEND_SUPPORTED_NAMESPACES: ["eip155", "solana"],
    DEFAULT_FEATURES: {
      swaps: !0,
      onramp: !0,
      receive: !0,
      send: !0,
      email: !0,
      emailShowWallets: !0,
      socials: [
        "google",
        "x",
        "discord",
        "farcaster",
        "github",
        "apple",
        "facebook",
      ],
      connectorTypeOrder: [
        "walletConnect",
        "recent",
        "injected",
        "featured",
        "custom",
        "external",
        "recommended",
      ],
      history: !0,
      analytics: !0,
      allWallets: !0,
      legalCheckbox: !1,
      smartSessions: !1,
      collapseWallets: !1,
      walletFeaturesOrder: ["onramp", "swaps", "receive", "send"],
      connectMethodsOrder: void 0,
      pay: !1,
    },
    DEFAULT_ACCOUNT_TYPES: {
      bip122: "payment",
      eip155: "smartAccount",
      polkadot: "eoa",
      solana: "eoa",
    },
    ADAPTER_TYPES: {
      UNIVERSAL: "universal",
      SOLANA: "solana",
      WAGMI: "wagmi",
      ETHERS: "ethers",
      ETHERS5: "ethers5",
      BITCOIN: "bitcoin",
    },
  },
  Ie = {
    cacheExpiry: {
      portfolio: 3e4,
      nativeBalance: 3e4,
      ens: 3e5,
      identity: 3e5,
    },
    isCacheExpired(t, e) {
      return Date.now() - t > e;
    },
    getActiveNetworkProps() {
      const t = Ie.getActiveNamespace(),
        e = Ie.getActiveCaipNetworkId(),
        n = e ? e.split(":")[1] : void 0,
        r = n ? (isNaN(Number(n)) ? n : Number(n)) : void 0;
      return { namespace: t, caipNetworkId: e, chainId: r };
    },
    setWalletConnectDeepLink({ name: t, href: e }) {
      try {
        it.setItem(ht.DEEPLINK_CHOICE, JSON.stringify({ href: e, name: t }));
      } catch {
        console.info("Unable to set WalletConnect deep link");
      }
    },
    getWalletConnectDeepLink() {
      try {
        const t = it.getItem(ht.DEEPLINK_CHOICE);
        if (t) return JSON.parse(t);
      } catch {
        console.info("Unable to get WalletConnect deep link");
      }
    },
    deleteWalletConnectDeepLink() {
      try {
        it.removeItem(ht.DEEPLINK_CHOICE);
      } catch {
        console.info("Unable to delete WalletConnect deep link");
      }
    },
    setActiveNamespace(t) {
      try {
        it.setItem(ht.ACTIVE_NAMESPACE, t);
      } catch {
        console.info("Unable to set active namespace");
      }
    },
    setActiveCaipNetworkId(t) {
      try {
        it.setItem(ht.ACTIVE_CAIP_NETWORK_ID, t),
          Ie.setActiveNamespace(t.split(":")[0]);
      } catch {
        console.info("Unable to set active caip network id");
      }
    },
    getActiveCaipNetworkId() {
      try {
        return it.getItem(ht.ACTIVE_CAIP_NETWORK_ID);
      } catch {
        console.info("Unable to get active caip network id");
        return;
      }
    },
    deleteActiveCaipNetworkId() {
      try {
        it.removeItem(ht.ACTIVE_CAIP_NETWORK_ID);
      } catch {
        console.info("Unable to delete active caip network id");
      }
    },
    deleteConnectedConnectorId(t) {
      try {
        const e = uE(t);
        it.removeItem(e);
      } catch {
        console.info("Unable to delete connected connector id");
      }
    },
    setAppKitRecent(t) {
      try {
        const e = Ie.getRecentWallets();
        e.find((r) => r.id === t.id) ||
          (e.unshift(t),
          e.length > 2 && e.pop(),
          it.setItem(ht.RECENT_WALLETS, JSON.stringify(e)));
      } catch {
        console.info("Unable to set AppKit recent");
      }
    },
    getRecentWallets() {
      try {
        const t = it.getItem(ht.RECENT_WALLETS);
        return t ? JSON.parse(t) : [];
      } catch {
        console.info("Unable to get AppKit recent");
      }
      return [];
    },
    setConnectedConnectorId(t, e) {
      try {
        const n = uE(t);
        it.setItem(n, e);
      } catch {
        console.info("Unable to set Connected Connector Id");
      }
    },
    getActiveNamespace() {
      try {
        return it.getItem(ht.ACTIVE_NAMESPACE);
      } catch {
        console.info("Unable to get active namespace");
      }
    },
    getConnectedConnectorId(t) {
      if (t)
        try {
          const e = uE(t);
          return it.getItem(e);
        } catch {
          console.info("Unable to get connected connector id in namespace ", t);
        }
    },
    setConnectedSocialProvider(t) {
      try {
        it.setItem(ht.CONNECTED_SOCIAL, t);
      } catch {
        console.info("Unable to set connected social provider");
      }
    },
    getConnectedSocialProvider() {
      try {
        return it.getItem(ht.CONNECTED_SOCIAL);
      } catch {
        console.info("Unable to get connected social provider");
      }
    },
    deleteConnectedSocialProvider() {
      try {
        it.removeItem(ht.CONNECTED_SOCIAL);
      } catch {
        console.info("Unable to delete connected social provider");
      }
    },
    getConnectedSocialUsername() {
      try {
        return it.getItem(ht.CONNECTED_SOCIAL_USERNAME);
      } catch {
        console.info("Unable to get connected social username");
      }
    },
    getStoredActiveCaipNetworkId() {
      var n;
      const t = it.getItem(ht.ACTIVE_CAIP_NETWORK_ID);
      return (n = t == null ? void 0 : t.split(":")) == null ? void 0 : n[1];
    },
    setConnectionStatus(t) {
      try {
        it.setItem(ht.CONNECTION_STATUS, t);
      } catch {
        console.info("Unable to set connection status");
      }
    },
    getConnectionStatus() {
      try {
        return it.getItem(ht.CONNECTION_STATUS);
      } catch {
        return;
      }
    },
    getConnectedNamespaces() {
      try {
        const t = it.getItem(ht.CONNECTED_NAMESPACES);
        return t != null && t.length ? t.split(",") : [];
      } catch {
        return [];
      }
    },
    setConnectedNamespaces(t) {
      try {
        const e = Array.from(new Set(t));
        it.setItem(ht.CONNECTED_NAMESPACES, e.join(","));
      } catch {
        console.info("Unable to set namespaces in storage");
      }
    },
    addConnectedNamespace(t) {
      try {
        const e = Ie.getConnectedNamespaces();
        e.includes(t) || (e.push(t), Ie.setConnectedNamespaces(e));
      } catch {
        console.info("Unable to add connected namespace");
      }
    },
    removeConnectedNamespace(t) {
      try {
        const e = Ie.getConnectedNamespaces(),
          n = e.indexOf(t);
        n > -1 && (e.splice(n, 1), Ie.setConnectedNamespaces(e));
      } catch {
        console.info("Unable to remove connected namespace");
      }
    },
    getTelegramSocialProvider() {
      try {
        return it.getItem(ht.TELEGRAM_SOCIAL_PROVIDER);
      } catch {
        return console.info("Unable to get telegram social provider"), null;
      }
    },
    setTelegramSocialProvider(t) {
      try {
        it.setItem(ht.TELEGRAM_SOCIAL_PROVIDER, t);
      } catch {
        console.info("Unable to set telegram social provider");
      }
    },
    removeTelegramSocialProvider() {
      try {
        it.removeItem(ht.TELEGRAM_SOCIAL_PROVIDER);
      } catch {
        console.info("Unable to remove telegram social provider");
      }
    },
    getBalanceCache() {
      let t = {};
      try {
        const e = it.getItem(ht.PORTFOLIO_CACHE);
        t = e ? JSON.parse(e) : {};
      } catch {
        console.info("Unable to get balance cache");
      }
      return t;
    },
    removeAddressFromBalanceCache(t) {
      try {
        const e = Ie.getBalanceCache();
        it.setItem(ht.PORTFOLIO_CACHE, JSON.stringify({ ...e, [t]: void 0 }));
      } catch {
        console.info("Unable to remove address from balance cache", t);
      }
    },
    getBalanceCacheForCaipAddress(t) {
      try {
        const n = Ie.getBalanceCache()[t];
        if (n && !this.isCacheExpired(n.timestamp, this.cacheExpiry.portfolio))
          return n.balance;
        Ie.removeAddressFromBalanceCache(t);
      } catch {
        console.info("Unable to get balance cache for address", t);
      }
    },
    updateBalanceCache(t) {
      try {
        const e = Ie.getBalanceCache();
        (e[t.caipAddress] = t),
          it.setItem(ht.PORTFOLIO_CACHE, JSON.stringify(e));
      } catch {
        console.info("Unable to update balance cache", t);
      }
    },
    getNativeBalanceCache() {
      let t = {};
      try {
        const e = it.getItem(ht.NATIVE_BALANCE_CACHE);
        t = e ? JSON.parse(e) : {};
      } catch {
        console.info("Unable to get balance cache");
      }
      return t;
    },
    removeAddressFromNativeBalanceCache(t) {
      try {
        const e = Ie.getBalanceCache();
        it.setItem(
          ht.NATIVE_BALANCE_CACHE,
          JSON.stringify({ ...e, [t]: void 0 })
        );
      } catch {
        console.info("Unable to remove address from balance cache", t);
      }
    },
    getNativeBalanceCacheForCaipAddress(t) {
      try {
        const n = Ie.getNativeBalanceCache()[t];
        if (
          n &&
          !this.isCacheExpired(n.timestamp, this.cacheExpiry.nativeBalance)
        )
          return n;
        console.info("Discarding cache for address", t),
          Ie.removeAddressFromBalanceCache(t);
      } catch {
        console.info("Unable to get balance cache for address", t);
      }
    },
    updateNativeBalanceCache(t) {
      try {
        const e = Ie.getNativeBalanceCache();
        (e[t.caipAddress] = t),
          it.setItem(ht.NATIVE_BALANCE_CACHE, JSON.stringify(e));
      } catch {
        console.info("Unable to update balance cache", t);
      }
    },
    getEnsCache() {
      let t = {};
      try {
        const e = it.getItem(ht.ENS_CACHE);
        t = e ? JSON.parse(e) : {};
      } catch {
        console.info("Unable to get ens name cache");
      }
      return t;
    },
    getEnsFromCacheForAddress(t) {
      try {
        const n = Ie.getEnsCache()[t];
        if (n && !this.isCacheExpired(n.timestamp, this.cacheExpiry.ens))
          return n.ens;
        Ie.removeEnsFromCache(t);
      } catch {
        console.info("Unable to get ens name from cache", t);
      }
    },
    updateEnsCache(t) {
      try {
        const e = Ie.getEnsCache();
        (e[t.address] = t), it.setItem(ht.ENS_CACHE, JSON.stringify(e));
      } catch {
        console.info("Unable to update ens name cache", t);
      }
    },
    removeEnsFromCache(t) {
      try {
        const e = Ie.getEnsCache();
        it.setItem(ht.ENS_CACHE, JSON.stringify({ ...e, [t]: void 0 }));
      } catch {
        console.info("Unable to remove ens name from cache", t);
      }
    },
    getIdentityCache() {
      let t = {};
      try {
        const e = it.getItem(ht.IDENTITY_CACHE);
        t = e ? JSON.parse(e) : {};
      } catch {
        console.info("Unable to get identity cache");
      }
      return t;
    },
    getIdentityFromCacheForAddress(t) {
      try {
        const n = Ie.getIdentityCache()[t];
        if (n && !this.isCacheExpired(n.timestamp, this.cacheExpiry.identity))
          return n.identity;
        Ie.removeIdentityFromCache(t);
      } catch {
        console.info("Unable to get identity from cache", t);
      }
    },
    updateIdentityCache(t) {
      try {
        const e = Ie.getIdentityCache();
        (e[t.address] = { identity: t.identity, timestamp: t.timestamp }),
          it.setItem(ht.IDENTITY_CACHE, JSON.stringify(e));
      } catch {
        console.info("Unable to update identity cache", t);
      }
    },
    removeIdentityFromCache(t) {
      try {
        const e = Ie.getIdentityCache();
        it.setItem(ht.IDENTITY_CACHE, JSON.stringify({ ...e, [t]: void 0 }));
      } catch {
        console.info("Unable to remove identity from cache", t);
      }
    },
    clearAddressCache() {
      try {
        it.removeItem(ht.PORTFOLIO_CACHE),
          it.removeItem(ht.NATIVE_BALANCE_CACHE),
          it.removeItem(ht.ENS_CACHE),
          it.removeItem(ht.IDENTITY_CACHE);
      } catch {
        console.info("Unable to clear address cache");
      }
    },
    setPreferredAccountTypes(t) {
      try {
        it.setItem(ht.PREFERRED_ACCOUNT_TYPES, JSON.stringify(t));
      } catch {
        console.info("Unable to set preferred account types", t);
      }
    },
    getPreferredAccountTypes() {
      try {
        const t = it.getItem(ht.PREFERRED_ACCOUNT_TYPES);
        return JSON.parse(t);
      } catch {
        console.info("Unable to get preferred account types");
      }
    },
  },
  Je = {
    isMobile() {
      var t;
      return this.isClient()
        ? !!(
            ((t =
              window == null
                ? void 0
                : window.matchMedia("(pointer:coarse)")) != null &&
              t.matches) ||
            /Android|webOS|iPhone|iPad|iPod|BlackBerry|Opera Mini/u.test(
              navigator.userAgent
            )
          )
        : !1;
    },
    checkCaipNetwork(t, e = "") {
      return t == null
        ? void 0
        : t.caipNetworkId.toLocaleLowerCase().includes(e.toLowerCase());
    },
    isAndroid() {
      if (!this.isMobile()) return !1;
      const t =
        window == null ? void 0 : window.navigator.userAgent.toLowerCase();
      return Je.isMobile() && t.includes("android");
    },
    isIos() {
      if (!this.isMobile()) return !1;
      const t =
        window == null ? void 0 : window.navigator.userAgent.toLowerCase();
      return t.includes("iphone") || t.includes("ipad");
    },
    isSafari() {
      return this.isClient()
        ? (window == null
            ? void 0
            : window.navigator.userAgent.toLowerCase()
          ).includes("safari")
        : !1;
    },
    isClient() {
      return typeof window < "u";
    },
    isPairingExpired(t) {
      return t ? t - Date.now() <= er.TEN_SEC_MS : !0;
    },
    isAllowedRetry(t, e = er.ONE_SEC_MS) {
      return Date.now() - t >= e;
    },
    copyToClopboard(t) {
      navigator.clipboard.writeText(t);
    },
    isIframe() {
      try {
        return (
          (window == null ? void 0 : window.self) !==
          (window == null ? void 0 : window.top)
        );
      } catch {
        return !1;
      }
    },
    getPairingExpiry() {
      return Date.now() + er.FOUR_MINUTES_MS;
    },
    getNetworkId(t) {
      return t == null ? void 0 : t.split(":")[1];
    },
    getPlainAddress(t) {
      return t == null ? void 0 : t.split(":")[2];
    },
    async wait(t) {
      return new Promise((e) => {
        setTimeout(e, t);
      });
    },
    debounce(t, e = 500) {
      let n;
      return (...r) => {
        function i() {
          t(...r);
        }
        n && clearTimeout(n), (n = setTimeout(i, e));
      };
    },
    isHttpUrl(t) {
      return t.startsWith("http://") || t.startsWith("https://");
    },
    formatNativeUrl(t, e) {
      if (Je.isHttpUrl(t)) return this.formatUniversalUrl(t, e);
      let n = t;
      n.includes("://") ||
        ((n = t.replaceAll("/", "").replaceAll(":", "")), (n = `${n}://`)),
        n.endsWith("/") || (n = `${n}/`),
        this.isTelegram() && this.isAndroid() && (e = encodeURIComponent(e));
      const r = encodeURIComponent(e);
      return { redirect: `${n}wc?uri=${r}`, href: n };
    },
    formatUniversalUrl(t, e) {
      if (!Je.isHttpUrl(t)) return this.formatNativeUrl(t, e);
      let n = t;
      n.endsWith("/") || (n = `${n}/`);
      const r = encodeURIComponent(e);
      return { redirect: `${n}wc?uri=${r}`, href: n };
    },
    getOpenTargetForPlatform(t) {
      return t === "popupWindow"
        ? t
        : this.isTelegram()
        ? Ie.getTelegramSocialProvider()
          ? "_top"
          : "_blank"
        : t;
    },
    openHref(t, e, n) {
      window == null ||
        window.open(
          t,
          this.getOpenTargetForPlatform(e),
          n || "noreferrer noopener"
        );
    },
    returnOpenHref(t, e, n) {
      return window == null
        ? void 0
        : window.open(
            t,
            this.getOpenTargetForPlatform(e),
            n || "noreferrer noopener"
          );
    },
    isTelegram() {
      return (
        typeof window < "u" &&
        (!!window.TelegramWebviewProxy ||
          !!window.Telegram ||
          !!window.TelegramWebviewProxyProto)
      );
    },
    isPWA() {
      var n, r, i;
      if (typeof window > "u") return !1;
      const t =
          (r =
            (n = window.matchMedia) == null
              ? void 0
              : n.call(window, "(display-mode: standalone)")) == null
            ? void 0
            : r.matches,
        e =
          (i = window == null ? void 0 : window.navigator) == null
            ? void 0
            : i.standalone;
      return !!(t || e);
    },
    async preloadImage(t) {
      const e = new Promise((n, r) => {
        const i = new Image();
        (i.onload = n),
          (i.onerror = r),
          (i.crossOrigin = "anonymous"),
          (i.src = t);
      });
      return Promise.race([e, Je.wait(2e3)]);
    },
    formatBalance(t, e) {
      let n = "0.000";
      if (typeof t == "string") {
        const r = Number(t);
        if (r) {
          const i = Math.floor(r * 1e3) / 1e3;
          i && (n = i.toString());
        }
      }
      return `${n}${e ? ` ${e}` : ""}`;
    },
    formatBalance2(t, e) {
      var r;
      let n;
      if (t === "0") n = "0";
      else if (typeof t == "string") {
        const i = Number(t);
        i &&
          (n =
            (r = i.toString().match(/^-?\d+(?:\.\d{0,3})?/u)) == null
              ? void 0
              : r[0]);
      }
      return { value: n ?? "0", rest: n === "0" ? "000" : "", symbol: e };
    },
    getApiUrl() {
      return ye.W3M_API_URL;
    },
    getBlockchainApiUrl() {
      return ye.BLOCKCHAIN_API_RPC_URL;
    },
    getAnalyticsUrl() {
      return ye.PULSE_API_URL;
    },
    getUUID() {
      return crypto != null && crypto.randomUUID
        ? crypto.randomUUID()
        : "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/gu, (t) => {
            const e = (Math.random() * 16) | 0;
            return (t === "x" ? e : (e & 3) | 8).toString(16);
          });
    },
    parseError(t) {
      var e, n;
      return typeof t == "string"
        ? t
        : typeof ((n =
            (e = t == null ? void 0 : t.issues) == null ? void 0 : e[0]) == null
            ? void 0
            : n.message) == "string"
        ? t.issues[0].message
        : t instanceof Error
        ? t.message
        : "Unknown error";
    },
    sortRequestedNetworks(t, e = []) {
      const n = {};
      return (
        e &&
          t &&
          (t.forEach((r, i) => {
            n[r] = i;
          }),
          e.sort((r, i) => {
            const s = n[r.id],
              o = n[i.id];
            return s !== void 0 && o !== void 0
              ? s - o
              : s !== void 0
              ? -1
              : o !== void 0
              ? 1
              : 0;
          })),
        e
      );
    },
    calculateBalance(t) {
      let e = 0;
      for (const n of t) e += n.value ?? 0;
      return e;
    },
    formatTokenBalance(t) {
      const e = t.toFixed(2),
        [n, r] = e.split(".");
      return { dollars: n, pennies: r };
    },
    isAddress(t, e = "eip155") {
      switch (e) {
        case "eip155":
          if (/^(?:0x)?[0-9a-f]{40}$/iu.test(t)) {
            if (
              /^(?:0x)?[0-9a-f]{40}$/iu.test(t) ||
              /^(?:0x)?[0-9A-F]{40}$/iu.test(t)
            )
              return !0;
          } else return !1;
          return !1;
        case "solana":
          return /[1-9A-HJ-NP-Za-km-z]{32,44}$/iu.test(t);
        default:
          return !1;
      }
    },
    uniqueBy(t, e) {
      const n = new Set();
      return t.filter((r) => {
        const i = r[e];
        return n.has(i) ? !1 : (n.add(i), !0);
      });
    },
    generateSdkVersion(t, e, n) {
      const i =
        t.length === 0
          ? er.ADAPTER_TYPES.UNIVERSAL
          : t.map((s) => s.adapterType).join(",");
      return `${e}-${i}-${n}`;
    },
    createAccount(t, e, n, r, i) {
      return { namespace: t, address: e, type: n, publicKey: r, path: i };
    },
    isCaipAddress(t) {
      if (typeof t != "string") return !1;
      const e = t.split(":"),
        n = e[0];
      return e.filter(Boolean).length === 3 && n in ye.CHAIN_NAME_MAP;
    },
    isMac() {
      const t =
        window == null ? void 0 : window.navigator.userAgent.toLowerCase();
      return t.includes("macintosh") && !t.includes("safari");
    },
    formatTelegramSocialLoginUrl(t) {
      const e = `--${encodeURIComponent(
          window == null ? void 0 : window.location.href
        )}`,
        n = "state=";
      if (new URL(t).host === "auth.magic.link") {
        const i = "provider_authorization_url=",
          s = t.substring(t.indexOf(i) + i.length),
          o = this.injectIntoUrl(decodeURIComponent(s), n, e);
        return t.replace(s, encodeURIComponent(o));
      }
      return this.injectIntoUrl(t, n, e);
    },
    injectIntoUrl(t, e, n) {
      const r = t.indexOf(e);
      if (r === -1)
        throw new Error(`${e} parameter not found in the URL: ${t}`);
      const i = t.indexOf("&", r),
        s = e.length,
        o = i !== -1 ? i : t.length,
        a = t.substring(0, r + s),
        l = t.substring(r + s, o),
        d = t.substring(i),
        p = l + n;
      return a + p + d;
    },
  };
async function kf(...t) {
  const e = await fetch(...t);
  if (!e.ok) throw new Error(`HTTP status code: ${e.status}`, { cause: e });
  return e;
}
class gv {
  constructor({ baseUrl: e, clientId: n }) {
    (this.baseUrl = e), (this.clientId = n);
  }
  async get({ headers: e, signal: n, cache: r, ...i }) {
    const s = this.createUrl(i);
    return (
      await kf(s, { method: "GET", headers: e, signal: n, cache: r })
    ).json();
  }
  async getBlob({ headers: e, signal: n, ...r }) {
    const i = this.createUrl(r);
    return (await kf(i, { method: "GET", headers: e, signal: n })).blob();
  }
  async post({ body: e, headers: n, signal: r, ...i }) {
    const s = this.createUrl(i);
    return (
      await kf(s, {
        method: "POST",
        headers: n,
        body: e ? JSON.stringify(e) : void 0,
        signal: r,
      })
    ).json();
  }
  async put({ body: e, headers: n, signal: r, ...i }) {
    const s = this.createUrl(i);
    return (
      await kf(s, {
        method: "PUT",
        headers: n,
        body: e ? JSON.stringify(e) : void 0,
        signal: r,
      })
    ).json();
  }
  async delete({ body: e, headers: n, signal: r, ...i }) {
    const s = this.createUrl(i);
    return (
      await kf(s, {
        method: "DELETE",
        headers: n,
        body: e ? JSON.stringify(e) : void 0,
        signal: r,
      })
    ).json();
  }
  createUrl({ path: e, params: n }) {
    const r = new URL(e, this.baseUrl);
    return (
      n &&
        Object.entries(n).forEach(([i, s]) => {
          s && r.searchParams.append(i, s);
        }),
      this.clientId && r.searchParams.append("clientId", this.clientId),
      r
    );
  }
}
const gV = {
    handleSolanaDeeplinkRedirect(t) {
      if (Y.state.activeChain === ye.CHAIN.SOLANA) {
        const e = window.location.href,
          n = encodeURIComponent(e);
        if (t === "Phantom" && !("phantom" in window)) {
          const r = e.startsWith("https") ? "https" : "http",
            i = e.split("/")[2],
            s = encodeURIComponent(`${r}://${i}`);
          window.location.href = `https://phantom.app/ul/browse/${n}?ref=${s}`;
        }
        t === "Coinbase Wallet" &&
          !("coinbaseSolana" in window) &&
          (window.location.href = `https://go.cb-w.com/dapp?cb_url=${n}`);
      }
    },
  },
  Di = wn({
    walletImages: {},
    networkImages: {},
    chainImages: {},
    connectorImages: {},
    tokenImages: {},
    currencyImages: {},
  }),
  Ws = {
    state: Di,
    subscribeNetworkImages(t) {
      return ri(Di.networkImages, () => t(Di.networkImages));
    },
    subscribeKey(t, e) {
      return si(Di, t, e);
    },
    subscribe(t) {
      return ri(Di, () => t(Di));
    },
    setWalletImage(t, e) {
      Di.walletImages[t] = e;
    },
    setNetworkImage(t, e) {
      Di.networkImages[t] = e;
    },
    setChainImage(t, e) {
      Di.chainImages[t] = e;
    },
    setConnectorImage(t, e) {
      Di.connectorImages = { ...Di.connectorImages, [t]: e };
    },
    setTokenImage(t, e) {
      Di.tokenImages[t] = e;
    },
    setCurrencyImage(t, e) {
      Di.currencyImages[t] = e;
    },
  },
  yV = {
    eip155: "ba0ba0cd-17c6-4806-ad93-f9d174f17900",
    solana: "a1b58899-f671-4276-6a5e-56ca5bd59700",
    polkadot: "",
    bip122: "0b4838db-0161-4ffe-022d-532bf03dba00",
    cosmos: "",
  },
  pE = wn({ networkImagePromises: {} }),
  K3 = {
    async fetchWalletImage(t) {
      if (t) return await Ze._fetchWalletImage(t), this.getWalletImageById(t);
    },
    async fetchNetworkImage(t) {
      if (!t) return;
      const e = this.getNetworkImageById(t);
      return (
        e ||
        (pE.networkImagePromises[t] ||
          (pE.networkImagePromises[t] = Ze._fetchNetworkImage(t)),
        await pE.networkImagePromises[t],
        this.getNetworkImageById(t))
      );
    },
    getWalletImageById(t) {
      if (t) return Ws.state.walletImages[t];
    },
    getWalletImage(t) {
      if (t != null && t.image_url) return t == null ? void 0 : t.image_url;
      if (t != null && t.image_id) return Ws.state.walletImages[t.image_id];
    },
    getNetworkImage(t) {
      var e, n, r;
      if ((e = t == null ? void 0 : t.assets) != null && e.imageUrl)
        return (n = t == null ? void 0 : t.assets) == null
          ? void 0
          : n.imageUrl;
      if ((r = t == null ? void 0 : t.assets) != null && r.imageId)
        return Ws.state.networkImages[t.assets.imageId];
    },
    getNetworkImageById(t) {
      if (t) return Ws.state.networkImages[t];
    },
    getConnectorImage(t) {
      if (t != null && t.imageUrl) return t.imageUrl;
      if (t != null && t.imageId) return Ws.state.connectorImages[t.imageId];
    },
    getChainImage(t) {
      return Ws.state.networkImages[yV[t]];
    },
  },
  wV = {
    getFeatureValue(t, e) {
      const n = e == null ? void 0 : e[t];
      return n === void 0 ? er.DEFAULT_FEATURES[t] : n;
    },
    filterSocialsByPlatform(t) {
      if (!t || !t.length) return t;
      if (Je.isTelegram()) {
        if (Je.isIos()) return t.filter((e) => e !== "google");
        if (Je.isMac()) return t.filter((e) => e !== "x");
        if (Je.isAndroid())
          return t.filter((e) => !["facebook", "x"].includes(e));
      }
      return t;
    },
  },
  Ye = wn({
    features: er.DEFAULT_FEATURES,
    projectId: "",
    sdkType: "appkit",
    sdkVersion: "html-wagmi-undefined",
    defaultAccountTypes: {
      solana: "eoa",
      bip122: "payment",
      polkadot: "eoa",
      eip155: "smartAccount",
    },
    enableNetworkSwitch: !0,
  }),
  me = {
    state: Ye,
    subscribeKey(t, e) {
      return si(Ye, t, e);
    },
    setOptions(t) {
      Object.assign(Ye, t);
    },
    setFeatures(t) {
      if (!t) return;
      Ye.features || (Ye.features = er.DEFAULT_FEATURES);
      const e = { ...Ye.features, ...t };
      (Ye.features = e),
        Ye.features.socials &&
          (Ye.features.socials = wV.filterSocialsByPlatform(
            Ye.features.socials
          ));
    },
    setProjectId(t) {
      Ye.projectId = t;
    },
    setCustomRpcUrls(t) {
      Ye.customRpcUrls = t;
    },
    setAllWallets(t) {
      Ye.allWallets = t;
    },
    setIncludeWalletIds(t) {
      Ye.includeWalletIds = t;
    },
    setExcludeWalletIds(t) {
      Ye.excludeWalletIds = t;
    },
    setFeaturedWalletIds(t) {
      Ye.featuredWalletIds = t;
    },
    setTokens(t) {
      Ye.tokens = t;
    },
    setTermsConditionsUrl(t) {
      Ye.termsConditionsUrl = t;
    },
    setPrivacyPolicyUrl(t) {
      Ye.privacyPolicyUrl = t;
    },
    setCustomWallets(t) {
      Ye.customWallets = t;
    },
    setIsSiweEnabled(t) {
      Ye.isSiweEnabled = t;
    },
    setIsUniversalProvider(t) {
      Ye.isUniversalProvider = t;
    },
    setSdkVersion(t) {
      Ye.sdkVersion = t;
    },
    setMetadata(t) {
      Ye.metadata = t;
    },
    setDisableAppend(t) {
      Ye.disableAppend = t;
    },
    setEIP6963Enabled(t) {
      Ye.enableEIP6963 = t;
    },
    setDebug(t) {
      Ye.debug = t;
    },
    setEnableWalletConnect(t) {
      Ye.enableWalletConnect = t;
    },
    setEnableWalletGuide(t) {
      Ye.enableWalletGuide = t;
    },
    setEnableAuthLogger(t) {
      Ye.enableAuthLogger = t;
    },
    setEnableWallets(t) {
      Ye.enableWallets = t;
    },
    setHasMultipleAddresses(t) {
      Ye.hasMultipleAddresses = t;
    },
    setSIWX(t) {
      Ye.siwx = t;
    },
    setConnectMethodsOrder(t) {
      Ye.features = { ...Ye.features, connectMethodsOrder: t };
    },
    setWalletFeaturesOrder(t) {
      Ye.features = { ...Ye.features, walletFeaturesOrder: t };
    },
    setSocialsOrder(t) {
      Ye.features = { ...Ye.features, socials: t };
    },
    setCollapseWallets(t) {
      Ye.features = { ...Ye.features, collapseWallets: t };
    },
    setEnableEmbedded(t) {
      Ye.enableEmbedded = t;
    },
    setAllowUnsupportedChain(t) {
      Ye.allowUnsupportedChain = t;
    },
    setManualWCControl(t) {
      Ye.manualWCControl = t;
    },
    setEnableNetworkSwitch(t) {
      Ye.enableNetworkSwitch = t;
    },
    setDefaultAccountTypes(t = {}) {
      Object.entries(t).forEach(([e, n]) => {
        n && (Ye.defaultAccountTypes[e] = n);
      });
    },
    setUniversalProviderConfigOverride(t) {
      Ye.universalProviderConfigOverride = t;
    },
    getUniversalProviderConfigOverride() {
      return Ye.universalProviderConfigOverride;
    },
    getSnapshot() {
      return Bh(Ye);
    },
  },
  nc = wn({ message: "", variant: "info", open: !1 }),
  ti = {
    state: nc,
    subscribeKey(t, e) {
      return si(nc, t, e);
    },
    open(t, e) {
      const { debug: n } = me.state,
        { shortMessage: r, longMessage: i } = t;
      n && ((nc.message = r), (nc.variant = e), (nc.open = !0)),
        i && console.error(typeof i == "function" ? i() : i);
    },
    close() {
      (nc.open = !1), (nc.message = ""), (nc.variant = "info");
    },
  },
  vV = Je.getAnalyticsUrl(),
  bV = new gv({ baseUrl: vV, clientId: null }),
  EV = ["MODAL_CREATED"],
  Qo = wn({
    timestamp: Date.now(),
    reportedErrors: {},
    data: { type: "track", event: "MODAL_CREATED" },
  }),
  fn = {
    state: Qo,
    subscribe(t) {
      return ri(Qo, () => t(Qo));
    },
    getSdkProperties() {
      const { projectId: t, sdkType: e, sdkVersion: n } = me.state;
      return { projectId: t, st: e, sv: n || "html-wagmi-4.2.2" };
    },
    async _sendAnalyticsEvent(t) {
      try {
        const e = Be.state.address;
        if (EV.includes(t.data.event) || typeof window > "u") return;
        await bV.post({
          path: "/e",
          params: fn.getSdkProperties(),
          body: {
            eventId: Je.getUUID(),
            url: window.location.href,
            domain: window.location.hostname,
            timestamp: t.timestamp,
            props: { ...t.data, address: e },
          },
        }),
          (Qo.reportedErrors.FORBIDDEN = !1);
      } catch (e) {
        e instanceof Error &&
          e.cause instanceof Response &&
          e.cause.status === ye.HTTP_STATUS_CODES.FORBIDDEN &&
          !Qo.reportedErrors.FORBIDDEN &&
          (ti.open(
            {
              shortMessage: "Invalid App Configuration",
              longMessage: `Origin ${
                ah() ? window.origin : "uknown"
              } not found on Allowlist - update configuration on cloud.reown.com`,
            },
            "error"
          ),
          (Qo.reportedErrors.FORBIDDEN = !0));
      }
    },
    sendEvent(t) {
      var e;
      (Qo.timestamp = Date.now()),
        (Qo.data = t),
        (e = me.state.features) != null &&
          e.analytics &&
          fn._sendAnalyticsEvent(Qo);
    },
  },
  CV = [
    "1ca0bdd4747578705b1939af023d120677c64fe6ca76add81fda36e350605e79",
    "fd20dc426fb37566d803205b19bbc1d4096b248ac04548e3cfb6b3a38bd033aa",
    "a797aa35c0fadbfc1a53e7f675162ed5226968b44a19ee3d24385c64d1d3c393",
  ],
  xV = Je.getApiUrl(),
  $i = new gv({ baseUrl: xV, clientId: null }),
  SV = 40,
  kP = 4,
  AV = 20,
  ct = wn({
    promises: {},
    page: 1,
    count: 0,
    featured: [],
    allFeatured: [],
    recommended: [],
    allRecommended: [],
    wallets: [],
    filteredWallets: [],
    search: [],
    isAnalyticsEnabled: !1,
    excludedWallets: [],
    isFetchingRecommendedWallets: !1,
  }),
  Ze = {
    state: ct,
    subscribeKey(t, e) {
      return si(ct, t, e);
    },
    _getSdkProperties() {
      const { projectId: t, sdkType: e, sdkVersion: n } = me.state;
      return { projectId: t, st: e || "appkit", sv: n || "html-wagmi-4.2.2" };
    },
    _filterOutExtensions(t) {
      return me.state.isUniversalProvider
        ? t.filter((e) => !!(e.mobile_link || e.desktop_link || e.webapp_link))
        : t;
    },
    async _fetchWalletImage(t) {
      const e = `${$i.baseUrl}/getWalletImage/${t}`,
        n = await $i.getBlob({ path: e, params: Ze._getSdkProperties() });
      Ws.setWalletImage(t, URL.createObjectURL(n));
    },
    async _fetchNetworkImage(t) {
      const e = `${$i.baseUrl}/public/getAssetImage/${t}`,
        n = await $i.getBlob({ path: e, params: Ze._getSdkProperties() });
      Ws.setNetworkImage(t, URL.createObjectURL(n));
    },
    async _fetchConnectorImage(t) {
      const e = `${$i.baseUrl}/public/getAssetImage/${t}`,
        n = await $i.getBlob({ path: e, params: Ze._getSdkProperties() });
      Ws.setConnectorImage(t, URL.createObjectURL(n));
    },
    async _fetchCurrencyImage(t) {
      const e = `${$i.baseUrl}/public/getCurrencyImage/${t}`,
        n = await $i.getBlob({ path: e, params: Ze._getSdkProperties() });
      Ws.setCurrencyImage(t, URL.createObjectURL(n));
    },
    async _fetchTokenImage(t) {
      const e = `${$i.baseUrl}/public/getTokenImage/${t}`,
        n = await $i.getBlob({ path: e, params: Ze._getSdkProperties() });
      Ws.setTokenImage(t, URL.createObjectURL(n));
    },
    async fetchAllowedOrigins() {
      try {
        const { allowedOrigins: t } = await $i.get({
          path: "/projects/v1/origins",
          params: Ze._getSdkProperties(),
        });
        return t;
      } catch {
        return [];
      }
    },
    async fetchNetworkImages() {
      const t = Y.getAllRequestedCaipNetworks(),
        e =
          t == null
            ? void 0
            : t
                .map(({ assets: n }) => (n == null ? void 0 : n.imageId))
                .filter(Boolean)
                .filter((n) => !K3.getNetworkImageById(n));
      e && (await Promise.allSettled(e.map((n) => Ze._fetchNetworkImage(n))));
    },
    async fetchConnectorImages() {
      const { connectors: t } = nt.state,
        e = t.map(({ imageId: n }) => n).filter(Boolean);
      await Promise.allSettled(e.map((n) => Ze._fetchConnectorImage(n)));
    },
    async fetchCurrencyImages(t = []) {
      await Promise.allSettled(t.map((e) => Ze._fetchCurrencyImage(e)));
    },
    async fetchTokenImages(t = []) {
      await Promise.allSettled(t.map((e) => Ze._fetchTokenImage(e)));
    },
    async fetchWallets(t) {
      var r, i;
      const e = t.exclude ?? [];
      return (
        Ze._getSdkProperties().sv.startsWith("html-core-") && e.push(...CV),
        await $i.get({
          path: "/getWallets",
          params: {
            ...Ze._getSdkProperties(),
            ...t,
            page: String(t.page),
            entries: String(t.entries),
            include: (r = t.include) == null ? void 0 : r.join(","),
            exclude: (i = t.exclude) == null ? void 0 : i.join(","),
          },
        })
      );
    },
    async fetchFeaturedWallets() {
      const { featuredWalletIds: t } = me.state;
      if (t != null && t.length) {
        const e = {
            ...Ze._getSdkProperties(),
            page: 1,
            entries: (t == null ? void 0 : t.length) ?? kP,
            include: t,
          },
          { data: n } = await Ze.fetchWallets(e);
        n.sort((i, s) => t.indexOf(i.id) - t.indexOf(s.id));
        const r = n.map((i) => i.image_id).filter(Boolean);
        await Promise.allSettled(r.map((i) => Ze._fetchWalletImage(i))),
          (ct.featured = n),
          (ct.allFeatured = n);
      }
    },
    async fetchRecommendedWallets() {
      try {
        ct.isFetchingRecommendedWallets = !0;
        const {
            includeWalletIds: t,
            excludeWalletIds: e,
            featuredWalletIds: n,
          } = me.state,
          r = [...(e ?? []), ...(n ?? [])].filter(Boolean),
          i = Y.getRequestedCaipNetworkIds().join(","),
          s = { page: 1, entries: kP, include: t, exclude: r, chains: i },
          { data: o, count: a } = await Ze.fetchWallets(s),
          l = Ie.getRecentWallets(),
          d = o.map((f) => f.image_id).filter(Boolean),
          p = l.map((f) => f.image_id).filter(Boolean);
        await Promise.allSettled(
          [...d, ...p].map((f) => Ze._fetchWalletImage(f))
        ),
          (ct.recommended = o),
          (ct.allRecommended = o),
          (ct.count = a ?? 0);
      } catch {
      } finally {
        ct.isFetchingRecommendedWallets = !1;
      }
    },
    async fetchWalletsByPage({ page: t }) {
      const {
          includeWalletIds: e,
          excludeWalletIds: n,
          featuredWalletIds: r,
        } = me.state,
        i = Y.getRequestedCaipNetworkIds().join(","),
        s = [
          ...ct.recommended.map(({ id: p }) => p),
          ...(n ?? []),
          ...(r ?? []),
        ].filter(Boolean),
        o = { page: t, entries: SV, include: e, exclude: s, chains: i },
        { data: a, count: l } = await Ze.fetchWallets(o),
        d = a
          .slice(0, AV)
          .map((p) => p.image_id)
          .filter(Boolean);
      await Promise.allSettled(d.map((p) => Ze._fetchWalletImage(p))),
        (ct.wallets = Je.uniqueBy(
          [...ct.wallets, ...Ze._filterOutExtensions(a)],
          "id"
        )),
        (ct.count = l > ct.count ? l : ct.count),
        (ct.page = t);
    },
    async initializeExcludedWallets({ ids: t }) {
      const e = Y.getRequestedCaipNetworkIds().join(","),
        n = { page: 1, entries: t.length, include: t, chains: e },
        { data: r } = await Ze.fetchWallets(n);
      r &&
        r.forEach((i) => {
          ct.excludedWallets.push({ rdns: i.rdns, name: i.name });
        });
    },
    async searchWallet({ search: t, badge: e }) {
      const { includeWalletIds: n, excludeWalletIds: r } = me.state,
        i = Y.getRequestedCaipNetworkIds().join(",");
      ct.search = [];
      const s = {
          page: 1,
          entries: 100,
          search: t == null ? void 0 : t.trim(),
          badge_type: e,
          include: n,
          exclude: r,
          chains: i,
        },
        { data: o } = await Ze.fetchWallets(s);
      fn.sendEvent({
        type: "track",
        event: "SEARCH_WALLET",
        properties: { badge: e ?? "", search: t ?? "" },
      });
      const a = o.map((l) => l.image_id).filter(Boolean);
      await Promise.allSettled([
        ...a.map((l) => Ze._fetchWalletImage(l)),
        Je.wait(300),
      ]),
        (ct.search = Ze._filterOutExtensions(o));
    },
    initPromise(t, e) {
      const n = ct.promises[t];
      return n || (ct.promises[t] = e());
    },
    prefetch({
      fetchConnectorImages: t = !0,
      fetchFeaturedWallets: e = !0,
      fetchRecommendedWallets: n = !0,
      fetchNetworkImages: r = !0,
    } = {}) {
      const i = [
        t && Ze.initPromise("connectorImages", Ze.fetchConnectorImages),
        e && Ze.initPromise("featuredWallets", Ze.fetchFeaturedWallets),
        n && Ze.initPromise("recommendedWallets", Ze.fetchRecommendedWallets),
        r && Ze.initPromise("networkImages", Ze.fetchNetworkImages),
      ].filter(Boolean);
      return Promise.allSettled(i);
    },
    prefetchAnalyticsConfig() {
      var t;
      (t = me.state.features) != null &&
        t.analytics &&
        Ze.fetchAnalyticsConfig();
    },
    async fetchAnalyticsConfig() {
      try {
        const { isAnalyticsEnabled: t } = await $i.get({
          path: "/getAnalyticsConfig",
          params: Ze._getSdkProperties(),
        });
        me.setFeatures({ analytics: t });
      } catch {
        me.setFeatures({ analytics: !1 });
      }
    },
    filterByNamespaces(t) {
      if (!(t != null && t.length)) {
        (ct.featured = ct.allFeatured), (ct.recommended = ct.allRecommended);
        return;
      }
      const e = Y.getRequestedCaipNetworkIds().join(",");
      (ct.featured = ct.allFeatured.filter((n) => {
        var r;
        return (r = n.chains) == null ? void 0 : r.some((i) => e.includes(i));
      })),
        (ct.recommended = ct.allRecommended.filter((n) => {
          var r;
          return (r = n.chains) == null ? void 0 : r.some((i) => e.includes(i));
        })),
        (ct.filteredWallets = ct.wallets.filter((n) => {
          var r;
          return (r = n.chains) == null ? void 0 : r.some((i) => e.includes(i));
        }));
    },
    clearFilterByNamespaces() {
      ct.filteredWallets = [];
    },
    setFilterByNamespace(t) {
      if (!t) {
        (ct.featured = ct.allFeatured), (ct.recommended = ct.allRecommended);
        return;
      }
      const e = Y.getRequestedCaipNetworkIds().join(",");
      (ct.featured = ct.allFeatured.filter((n) => {
        var r;
        return (r = n.chains) == null ? void 0 : r.some((i) => e.includes(i));
      })),
        (ct.recommended = ct.allRecommended.filter((n) => {
          var r;
          return (r = n.chains) == null ? void 0 : r.some((i) => e.includes(i));
        })),
        (ct.filteredWallets = ct.wallets.filter((n) => {
          var r;
          return (r = n.chains) == null ? void 0 : r.some((i) => e.includes(i));
        }));
    },
  },
  Bt = wn({ view: "Connect", history: ["Connect"], transactionStack: [] }),
  zt = {
    state: Bt,
    subscribeKey(t, e) {
      return si(Bt, t, e);
    },
    pushTransactionStack(t) {
      Bt.transactionStack.push(t);
    },
    popTransactionStack(t) {
      var n, r;
      const e = Bt.transactionStack.pop();
      if (e)
        if (t)
          this.goBack(),
            (n = e == null ? void 0 : e.onCancel) == null || n.call(e);
        else {
          if (e.goBack) this.goBack();
          else if (e.replace) {
            const s = Bt.history.indexOf("ConnectingSiwe");
            s > 0
              ? this.goBackToIndex(s - 1)
              : (jn.close(!0), (Bt.history = []));
          } else e.view && this.reset(e.view);
          (r = e == null ? void 0 : e.onSuccess) == null || r.call(e);
        }
    },
    push(t, e) {
      t !== Bt.view && ((Bt.view = t), Bt.history.push(t), (Bt.data = e));
    },
    reset(t, e) {
      (Bt.view = t), (Bt.history = [t]), (Bt.data = e);
    },
    replace(t, e) {
      Bt.history.at(-1) === t ||
        ((Bt.view = t), (Bt.history[Bt.history.length - 1] = t), (Bt.data = e));
    },
    goBack() {
      var e;
      const t =
        !Y.state.activeCaipAddress && this.state.view === "ConnectingFarcaster";
      if (Bt.history.length > 1 && !Bt.history.includes("UnsupportedChain")) {
        Bt.history.pop();
        const [n] = Bt.history.slice(-1);
        n && (Bt.view = n);
      } else jn.close();
      (e = Bt.data) != null && e.wallet && (Bt.data.wallet = void 0),
        setTimeout(() => {
          var n, r, i;
          if (t) {
            Be.setFarcasterUrl(void 0, Y.state.activeChain);
            const s = nt.getAuthConnector();
            (n = s == null ? void 0 : s.provider) == null || n.reload();
            const o = Bh(me.state);
            (i =
              (r = s == null ? void 0 : s.provider) == null
                ? void 0
                : r.syncDappData) == null ||
              i.call(r, {
                metadata: o.metadata,
                sdkVersion: o.sdkVersion,
                projectId: o.projectId,
                sdkType: o.sdkType,
              });
          }
        }, 100);
    },
    goBackToIndex(t) {
      if (Bt.history.length > 1) {
        Bt.history = Bt.history.slice(0, t + 1);
        const [e] = Bt.history.slice(-1);
        e && (Bt.view = e);
      }
    },
  },
  Xo = wn({ themeMode: "dark", themeVariables: {}, w3mThemeVariables: void 0 }),
  Hr = {
    state: Xo,
    subscribe(t) {
      return ri(Xo, () => t(Xo));
    },
    setThemeMode(t) {
      Xo.themeMode = t;
      try {
        const e = nt.getAuthConnector();
        if (e) {
          const n = Hr.getSnapshot().themeVariables;
          e.provider.syncTheme({
            themeMode: t,
            themeVariables: n,
            w3mThemeVariables: ga(n, t),
          });
        }
      } catch {
        console.info("Unable to sync theme to auth connector");
      }
    },
    setThemeVariables(t) {
      Xo.themeVariables = { ...Xo.themeVariables, ...t };
      try {
        const e = nt.getAuthConnector();
        if (e) {
          const n = Hr.getSnapshot().themeVariables;
          e.provider.syncTheme({
            themeVariables: n,
            w3mThemeVariables: ga(Xo.themeVariables, Xo.themeMode),
          });
        }
      } catch {
        console.info("Unable to sync theme to auth connector");
      }
    },
    getSnapshot() {
      return Bh(Xo);
    },
  },
  Y3 = {
    eip155: void 0,
    solana: void 0,
    polkadot: void 0,
    bip122: void 0,
    cosmos: void 0,
  },
  Rt = wn({
    allConnectors: [],
    connectors: [],
    activeConnector: void 0,
    filterByNamespace: void 0,
    activeConnectorIds: { ...Y3 },
    filterByNamespaceMap: {
      eip155: !0,
      solana: !0,
      polkadot: !0,
      bip122: !0,
      cosmos: !0,
    },
  }),
  nt = {
    state: Rt,
    subscribe(t) {
      return ri(Rt, () => {
        t(Rt);
      });
    },
    subscribeKey(t, e) {
      return si(Rt, t, e);
    },
    initialize(t) {
      t.forEach((e) => {
        const n = Ie.getConnectedConnectorId(e);
        n && this.setConnectorId(n, e);
      });
    },
    setActiveConnector(t) {
      t && (Rt.activeConnector = Kl(t));
    },
    setConnectors(t) {
      t.filter(
        (i) =>
          !Rt.allConnectors.some(
            (s) =>
              s.id === i.id &&
              this.getConnectorName(s.name) === this.getConnectorName(i.name) &&
              s.chain === i.chain
          )
      ).forEach((i) => {
        i.type !== "MULTI_CHAIN" && Rt.allConnectors.push(Kl(i));
      });
      const n = this.getEnabledNamespaces(),
        r = this.getEnabledConnectors(n);
      Rt.connectors = this.mergeMultiChainConnectors(r);
    },
    filterByNamespaces(t) {
      Object.keys(Rt.filterByNamespaceMap).forEach((e) => {
        Rt.filterByNamespaceMap[e] = !1;
      }),
        t.forEach((e) => {
          Rt.filterByNamespaceMap[e] = !0;
        }),
        this.updateConnectorsForEnabledNamespaces();
    },
    filterByNamespace(t, e) {
      (Rt.filterByNamespaceMap[t] = e),
        this.updateConnectorsForEnabledNamespaces();
    },
    updateConnectorsForEnabledNamespaces() {
      const t = this.getEnabledNamespaces(),
        e = this.getEnabledConnectors(t),
        n = this.areAllNamespacesEnabled();
      (Rt.connectors = this.mergeMultiChainConnectors(e)),
        n ? Ze.clearFilterByNamespaces() : Ze.filterByNamespaces(t);
    },
    getEnabledNamespaces() {
      return Object.entries(Rt.filterByNamespaceMap)
        .filter(([t, e]) => e)
        .map(([t]) => t);
    },
    getEnabledConnectors(t) {
      return Rt.allConnectors.filter((e) => t.includes(e.chain));
    },
    areAllNamespacesEnabled() {
      return Object.values(Rt.filterByNamespaceMap).every((t) => t);
    },
    mergeMultiChainConnectors(t) {
      const e = this.generateConnectorMapByName(t),
        n = [];
      return (
        e.forEach((r) => {
          const i = r[0],
            s = (i == null ? void 0 : i.id) === ye.CONNECTOR_ID.AUTH;
          r.length > 1 && i
            ? n.push({
                name: i.name,
                imageUrl: i.imageUrl,
                imageId: i.imageId,
                connectors: [...r],
                type: s ? "AUTH" : "MULTI_CHAIN",
                chain: "eip155",
                id: (i == null ? void 0 : i.id) || "",
              })
            : i && n.push(i);
        }),
        n
      );
    },
    generateConnectorMapByName(t) {
      const e = new Map();
      return (
        t.forEach((n) => {
          const { name: r } = n,
            i = this.getConnectorName(r);
          if (!i) return;
          const s = e.get(i) || [];
          s.find((a) => a.chain === n.chain) || s.push(n), e.set(i, s);
        }),
        e
      );
    },
    getConnectorName(t) {
      return t && ({ "Trust Wallet": "Trust" }[t] || t);
    },
    getUniqueConnectorsByName(t) {
      const e = [];
      return (
        t.forEach((n) => {
          e.find((r) => r.chain === n.chain) || e.push(n);
        }),
        e
      );
    },
    addConnector(t) {
      var e, n, r;
      if (t.id === ye.CONNECTOR_ID.AUTH) {
        const i = t,
          s = Bh(me.state),
          o = Hr.getSnapshot().themeMode,
          a = Hr.getSnapshot().themeVariables;
        (n =
          (e = i == null ? void 0 : i.provider) == null
            ? void 0
            : e.syncDappData) == null ||
          n.call(e, {
            metadata: s.metadata,
            sdkVersion: s.sdkVersion,
            projectId: s.projectId,
            sdkType: s.sdkType,
          }),
          (r = i == null ? void 0 : i.provider) == null ||
            r.syncTheme({
              themeMode: o,
              themeVariables: a,
              w3mThemeVariables: ga(a, o),
            }),
          this.setConnectors([t]);
      } else this.setConnectors([t]);
    },
    getAuthConnector(t) {
      var r;
      const e = t || Y.state.activeChain,
        n = Rt.connectors.find((i) => i.id === ye.CONNECTOR_ID.AUTH);
      if (n)
        return (r = n == null ? void 0 : n.connectors) != null && r.length
          ? n.connectors.find((s) => s.chain === e)
          : n;
    },
    getAnnouncedConnectorRdns() {
      return Rt.connectors
        .filter((t) => t.type === "ANNOUNCED")
        .map((t) => {
          var e;
          return (e = t.info) == null ? void 0 : e.rdns;
        });
    },
    getConnectorById(t) {
      return Rt.allConnectors.find((e) => e.id === t);
    },
    getConnector(t, e) {
      return Rt.allConnectors
        .filter((r) => r.chain === Y.state.activeChain)
        .find((r) => {
          var i;
          return (
            r.explorerId === t || ((i = r.info) == null ? void 0 : i.rdns) === e
          );
        });
    },
    syncIfAuthConnector(t) {
      var s, o;
      if (t.id !== "ID_AUTH") return;
      const e = t,
        n = Bh(me.state),
        r = Hr.getSnapshot().themeMode,
        i = Hr.getSnapshot().themeVariables;
      (o =
        (s = e == null ? void 0 : e.provider) == null
          ? void 0
          : s.syncDappData) == null ||
        o.call(s, {
          metadata: n.metadata,
          sdkVersion: n.sdkVersion,
          sdkType: n.sdkType,
          projectId: n.projectId,
        }),
        e.provider.syncTheme({
          themeMode: r,
          themeVariables: i,
          w3mThemeVariables: ga(i, r),
        });
    },
    getConnectorsByNamespace(t) {
      const e = Rt.allConnectors.filter((n) => n.chain === t);
      return this.mergeMultiChainConnectors(e);
    },
    selectWalletConnector(t) {
      const e = nt.getConnector(t.id, t.rdns);
      Y.state.activeChain === ye.CHAIN.SOLANA &&
        gV.handleSolanaDeeplinkRedirect(
          (e == null ? void 0 : e.name) || t.name || ""
        ),
        e
          ? zt.push("ConnectingExternal", { connector: e })
          : zt.push("ConnectingWalletConnect", { wallet: t });
    },
    getConnectors(t) {
      return t
        ? this.getConnectorsByNamespace(t)
        : this.mergeMultiChainConnectors(Rt.allConnectors);
    },
    setFilterByNamespace(t) {
      (Rt.filterByNamespace = t),
        (Rt.connectors = this.getConnectors(t)),
        Ze.setFilterByNamespace(t);
    },
    setConnectorId(t, e) {
      t &&
        ((Rt.activeConnectorIds = { ...Rt.activeConnectorIds, [e]: t }),
        Ie.setConnectedConnectorId(e, t));
    },
    removeConnectorId(t) {
      (Rt.activeConnectorIds = { ...Rt.activeConnectorIds, [t]: void 0 }),
        Ie.deleteConnectedConnectorId(t);
    },
    getConnectorId(t) {
      if (t) return Rt.activeConnectorIds[t];
    },
    isConnected(t) {
      return t
        ? !!Rt.activeConnectorIds[t]
        : Object.values(Rt.activeConnectorIds).some((e) => !!e);
    },
    resetConnectorIds() {
      Rt.activeConnectorIds = { ...Y3 };
    },
  };
function Wy(t, e) {
  return nt.getConnectorId(t) === e;
}
function _V(t) {
  const e = Array.from(Y.state.chains.keys());
  let n = [];
  return (
    t
      ? (n.push([t, Y.state.chains.get(t)]),
        Wy(t, ye.CONNECTOR_ID.WALLET_CONNECT)
          ? e.forEach((r) => {
              r !== t &&
                Wy(r, ye.CONNECTOR_ID.WALLET_CONNECT) &&
                n.push([r, Y.state.chains.get(r)]);
            })
          : Wy(t, ye.CONNECTOR_ID.AUTH) &&
            e.forEach((r) => {
              r !== t &&
                Wy(r, ye.CONNECTOR_ID.AUTH) &&
                n.push([r, Y.state.chains.get(r)]);
            }))
      : (n = Array.from(Y.state.chains.entries())),
    n
  );
}
var Hy = { exports: {} },
  DP;
function IV() {
  if (DP) return Hy.exports;
  DP = 1;
  var t = typeof Reflect == "object" ? Reflect : null,
    e =
      t && typeof t.apply == "function"
        ? t.apply
        : function (A, I, R) {
            return Function.prototype.apply.call(A, I, R);
          },
    n;
  t && typeof t.ownKeys == "function"
    ? (n = t.ownKeys)
    : Object.getOwnPropertySymbols
    ? (n = function (A) {
        return Object.getOwnPropertyNames(A).concat(
          Object.getOwnPropertySymbols(A)
        );
      })
    : (n = function (A) {
        return Object.getOwnPropertyNames(A);
      });
  function r(_) {
    console && console.warn && console.warn(_);
  }
  var i =
    Number.isNaN ||
    function (A) {
      return A !== A;
    };
  function s() {
    s.init.call(this);
  }
  (Hy.exports = s),
    (Hy.exports.once = E),
    (s.EventEmitter = s),
    (s.prototype._events = void 0),
    (s.prototype._eventsCount = 0),
    (s.prototype._maxListeners = void 0);
  var o = 10;
  function a(_) {
    if (typeof _ != "function")
      throw new TypeError(
        'The "listener" argument must be of type Function. Received type ' +
          typeof _
      );
  }
  Object.defineProperty(s, "defaultMaxListeners", {
    enumerable: !0,
    get: function () {
      return o;
    },
    set: function (_) {
      if (typeof _ != "number" || _ < 0 || i(_))
        throw new RangeError(
          'The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' +
            _ +
            "."
        );
      o = _;
    },
  }),
    (s.init = function () {
      (this._events === void 0 ||
        this._events === Object.getPrototypeOf(this)._events) &&
        ((this._events = Object.create(null)), (this._eventsCount = 0)),
        (this._maxListeners = this._maxListeners || void 0);
    }),
    (s.prototype.setMaxListeners = function (A) {
      if (typeof A != "number" || A < 0 || i(A))
        throw new RangeError(
          'The value of "n" is out of range. It must be a non-negative number. Received ' +
            A +
            "."
        );
      return (this._maxListeners = A), this;
    });
  function l(_) {
    return _._maxListeners === void 0 ? s.defaultMaxListeners : _._maxListeners;
  }
  (s.prototype.getMaxListeners = function () {
    return l(this);
  }),
    (s.prototype.emit = function (A) {
      for (var I = [], R = 1; R < arguments.length; R++) I.push(arguments[R]);
      var D = A === "error",
        k = this._events;
      if (k !== void 0) D = D && k.error === void 0;
      else if (!D) return !1;
      if (D) {
        var T;
        if ((I.length > 0 && (T = I[0]), T instanceof Error)) throw T;
        var U = new Error(
          "Unhandled error." + (T ? " (" + T.message + ")" : "")
        );
        throw ((U.context = T), U);
      }
      var q = k[A];
      if (q === void 0) return !1;
      if (typeof q == "function") e(q, this, I);
      else
        for (var K = q.length, H = g(q, K), R = 0; R < K; ++R) e(H[R], this, I);
      return !0;
    });
  function d(_, A, I, R) {
    var D, k, T;
    if (
      (a(I),
      (k = _._events),
      k === void 0
        ? ((k = _._events = Object.create(null)), (_._eventsCount = 0))
        : (k.newListener !== void 0 &&
            (_.emit("newListener", A, I.listener ? I.listener : I),
            (k = _._events)),
          (T = k[A])),
      T === void 0)
    )
      (T = k[A] = I), ++_._eventsCount;
    else if (
      (typeof T == "function"
        ? (T = k[A] = R ? [I, T] : [T, I])
        : R
        ? T.unshift(I)
        : T.push(I),
      (D = l(_)),
      D > 0 && T.length > D && !T.warned)
    ) {
      T.warned = !0;
      var U = new Error(
        "Possible EventEmitter memory leak detected. " +
          T.length +
          " " +
          String(A) +
          " listeners added. Use emitter.setMaxListeners() to increase limit"
      );
      (U.name = "MaxListenersExceededWarning"),
        (U.emitter = _),
        (U.type = A),
        (U.count = T.length),
        r(U);
    }
    return _;
  }
  (s.prototype.addListener = function (A, I) {
    return d(this, A, I, !1);
  }),
    (s.prototype.on = s.prototype.addListener),
    (s.prototype.prependListener = function (A, I) {
      return d(this, A, I, !0);
    });
  function p() {
    if (!this.fired)
      return (
        this.target.removeListener(this.type, this.wrapFn),
        (this.fired = !0),
        arguments.length === 0
          ? this.listener.call(this.target)
          : this.listener.apply(this.target, arguments)
      );
  }
  function f(_, A, I) {
    var R = { fired: !1, wrapFn: void 0, target: _, type: A, listener: I },
      D = p.bind(R);
    return (D.listener = I), (R.wrapFn = D), D;
  }
  (s.prototype.once = function (A, I) {
    return a(I), this.on(A, f(this, A, I)), this;
  }),
    (s.prototype.prependOnceListener = function (A, I) {
      return a(I), this.prependListener(A, f(this, A, I)), this;
    }),
    (s.prototype.removeListener = function (A, I) {
      var R, D, k, T, U;
      if ((a(I), (D = this._events), D === void 0)) return this;
      if (((R = D[A]), R === void 0)) return this;
      if (R === I || R.listener === I)
        --this._eventsCount === 0
          ? (this._events = Object.create(null))
          : (delete D[A],
            D.removeListener &&
              this.emit("removeListener", A, R.listener || I));
      else if (typeof R != "function") {
        for (k = -1, T = R.length - 1; T >= 0; T--)
          if (R[T] === I || R[T].listener === I) {
            (U = R[T].listener), (k = T);
            break;
          }
        if (k < 0) return this;
        k === 0 ? R.shift() : v(R, k),
          R.length === 1 && (D[A] = R[0]),
          D.removeListener !== void 0 && this.emit("removeListener", A, U || I);
      }
      return this;
    }),
    (s.prototype.off = s.prototype.removeListener),
    (s.prototype.removeAllListeners = function (A) {
      var I, R, D;
      if (((R = this._events), R === void 0)) return this;
      if (R.removeListener === void 0)
        return (
          arguments.length === 0
            ? ((this._events = Object.create(null)), (this._eventsCount = 0))
            : R[A] !== void 0 &&
              (--this._eventsCount === 0
                ? (this._events = Object.create(null))
                : delete R[A]),
          this
        );
      if (arguments.length === 0) {
        var k = Object.keys(R),
          T;
        for (D = 0; D < k.length; ++D)
          (T = k[D]), T !== "removeListener" && this.removeAllListeners(T);
        return (
          this.removeAllListeners("removeListener"),
          (this._events = Object.create(null)),
          (this._eventsCount = 0),
          this
        );
      }
      if (((I = R[A]), typeof I == "function")) this.removeListener(A, I);
      else if (I !== void 0)
        for (D = I.length - 1; D >= 0; D--) this.removeListener(A, I[D]);
      return this;
    });
  function m(_, A, I) {
    var R = _._events;
    if (R === void 0) return [];
    var D = R[A];
    return D === void 0
      ? []
      : typeof D == "function"
      ? I
        ? [D.listener || D]
        : [D]
      : I
      ? b(D)
      : g(D, D.length);
  }
  (s.prototype.listeners = function (A) {
    return m(this, A, !0);
  }),
    (s.prototype.rawListeners = function (A) {
      return m(this, A, !1);
    }),
    (s.listenerCount = function (_, A) {
      return typeof _.listenerCount == "function"
        ? _.listenerCount(A)
        : y.call(_, A);
    }),
    (s.prototype.listenerCount = y);
  function y(_) {
    var A = this._events;
    if (A !== void 0) {
      var I = A[_];
      if (typeof I == "function") return 1;
      if (I !== void 0) return I.length;
    }
    return 0;
  }
  s.prototype.eventNames = function () {
    return this._eventsCount > 0 ? n(this._events) : [];
  };
  function g(_, A) {
    for (var I = new Array(A), R = 0; R < A; ++R) I[R] = _[R];
    return I;
  }
  function v(_, A) {
    for (; A + 1 < _.length; A++) _[A] = _[A + 1];
    _.pop();
  }
  function b(_) {
    for (var A = new Array(_.length), I = 0; I < A.length; ++I)
      A[I] = _[I].listener || _[I];
    return A;
  }
  function E(_, A) {
    return new Promise(function (I, R) {
      function D(T) {
        _.removeListener(A, k), R(T);
      }
      function k() {
        typeof _.removeListener == "function" && _.removeListener("error", D),
          I([].slice.call(arguments));
      }
      C(_, A, k, { once: !0 }), A !== "error" && S(_, D, { once: !0 });
    });
  }
  function S(_, A, I) {
    typeof _.on == "function" && C(_, "error", A, I);
  }
  function C(_, A, I, R) {
    if (typeof _.on == "function") R.once ? _.once(A, I) : _.on(A, I);
    else if (typeof _.addEventListener == "function")
      _.addEventListener(A, function D(k) {
        R.once && _.removeEventListener(A, D), I(k);
      });
    else
      throw new TypeError(
        'The "emitter" argument must be of type EventEmitter. Received type ' +
          typeof _
      );
  }
  return Hy.exports;
}
var Ss = IV();
const mA = Hc(Ss);
var fE = {};
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */ var ux =
  function (t, e) {
    return (
      (ux =
        Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array &&
          function (n, r) {
            n.__proto__ = r;
          }) ||
        function (n, r) {
          for (var i in r) r.hasOwnProperty(i) && (n[i] = r[i]);
        }),
      ux(t, e)
    );
  };
function TV(t, e) {
  ux(t, e);
  function n() {
    this.constructor = t;
  }
  t.prototype =
    e === null ? Object.create(e) : ((n.prototype = e.prototype), new n());
}
var dx = function () {
  return (
    (dx =
      Object.assign ||
      function (e) {
        for (var n, r = 1, i = arguments.length; r < i; r++) {
          n = arguments[r];
          for (var s in n)
            Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s]);
        }
        return e;
      }),
    dx.apply(this, arguments)
  );
};
function PV(t, e) {
  var n = {};
  for (var r in t)
    Object.prototype.hasOwnProperty.call(t, r) &&
      e.indexOf(r) < 0 &&
      (n[r] = t[r]);
  if (t != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, r = Object.getOwnPropertySymbols(t); i < r.length; i++)
      e.indexOf(r[i]) < 0 &&
        Object.prototype.propertyIsEnumerable.call(t, r[i]) &&
        (n[r[i]] = t[r[i]]);
  return n;
}
function RV(t, e, n, r) {
  var i = arguments.length,
    s =
      i < 3 ? e : r === null ? (r = Object.getOwnPropertyDescriptor(e, n)) : r,
    o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(t, e, n, r);
  else
    for (var a = t.length - 1; a >= 0; a--)
      (o = t[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, n, s) : o(e, n)) || s);
  return i > 3 && s && Object.defineProperty(e, n, s), s;
}
function NV(t, e) {
  return function (n, r) {
    e(n, r, t);
  };
}
function OV(t, e) {
  if (typeof Reflect == "object" && typeof Reflect.metadata == "function")
    return Reflect.metadata(t, e);
}
function kV(t, e, n, r) {
  function i(s) {
    return s instanceof n
      ? s
      : new n(function (o) {
          o(s);
        });
  }
  return new (n || (n = Promise))(function (s, o) {
    function a(p) {
      try {
        d(r.next(p));
      } catch (f) {
        o(f);
      }
    }
    function l(p) {
      try {
        d(r.throw(p));
      } catch (f) {
        o(f);
      }
    }
    function d(p) {
      p.done ? s(p.value) : i(p.value).then(a, l);
    }
    d((r = r.apply(t, e || [])).next());
  });
}
function DV(t, e) {
  var n = {
      label: 0,
      sent: function () {
        if (s[0] & 1) throw s[1];
        return s[1];
      },
      trys: [],
      ops: [],
    },
    r,
    i,
    s,
    o;
  return (
    (o = { next: a(0), throw: a(1), return: a(2) }),
    typeof Symbol == "function" &&
      (o[Symbol.iterator] = function () {
        return this;
      }),
    o
  );
  function a(d) {
    return function (p) {
      return l([d, p]);
    };
  }
  function l(d) {
    if (r) throw new TypeError("Generator is already executing.");
    for (; n; )
      try {
        if (
          ((r = 1),
          i &&
            (s =
              d[0] & 2
                ? i.return
                : d[0]
                ? i.throw || ((s = i.return) && s.call(i), 0)
                : i.next) &&
            !(s = s.call(i, d[1])).done)
        )
          return s;
        switch (((i = 0), s && (d = [d[0] & 2, s.value]), d[0])) {
          case 0:
          case 1:
            s = d;
            break;
          case 4:
            return n.label++, { value: d[1], done: !1 };
          case 5:
            n.label++, (i = d[1]), (d = [0]);
            continue;
          case 7:
            (d = n.ops.pop()), n.trys.pop();
            continue;
          default:
            if (
              ((s = n.trys),
              !(s = s.length > 0 && s[s.length - 1]) &&
                (d[0] === 6 || d[0] === 2))
            ) {
              n = 0;
              continue;
            }
            if (d[0] === 3 && (!s || (d[1] > s[0] && d[1] < s[3]))) {
              n.label = d[1];
              break;
            }
            if (d[0] === 6 && n.label < s[1]) {
              (n.label = s[1]), (s = d);
              break;
            }
            if (s && n.label < s[2]) {
              (n.label = s[2]), n.ops.push(d);
              break;
            }
            s[2] && n.ops.pop(), n.trys.pop();
            continue;
        }
        d = e.call(t, n);
      } catch (p) {
        (d = [6, p]), (i = 0);
      } finally {
        r = s = 0;
      }
    if (d[0] & 5) throw d[1];
    return { value: d[0] ? d[1] : void 0, done: !0 };
  }
}
function $V(t, e, n, r) {
  r === void 0 && (r = n), (t[r] = e[n]);
}
function MV(t, e) {
  for (var n in t) n !== "default" && !e.hasOwnProperty(n) && (e[n] = t[n]);
}
function px(t) {
  var e = typeof Symbol == "function" && Symbol.iterator,
    n = e && t[e],
    r = 0;
  if (n) return n.call(t);
  if (t && typeof t.length == "number")
    return {
      next: function () {
        return (
          t && r >= t.length && (t = void 0), { value: t && t[r++], done: !t }
        );
      },
    };
  throw new TypeError(
    e ? "Object is not iterable." : "Symbol.iterator is not defined."
  );
}
function Z3(t, e) {
  var n = typeof Symbol == "function" && t[Symbol.iterator];
  if (!n) return t;
  var r = n.call(t),
    i,
    s = [],
    o;
  try {
    for (; (e === void 0 || e-- > 0) && !(i = r.next()).done; ) s.push(i.value);
  } catch (a) {
    o = { error: a };
  } finally {
    try {
      i && !i.done && (n = r.return) && n.call(r);
    } finally {
      if (o) throw o.error;
    }
  }
  return s;
}
function LV() {
  for (var t = [], e = 0; e < arguments.length; e++)
    t = t.concat(Z3(arguments[e]));
  return t;
}
function UV() {
  for (var t = 0, e = 0, n = arguments.length; e < n; e++)
    t += arguments[e].length;
  for (var r = Array(t), i = 0, e = 0; e < n; e++)
    for (var s = arguments[e], o = 0, a = s.length; o < a; o++, i++)
      r[i] = s[o];
  return r;
}
function Fh(t) {
  return this instanceof Fh ? ((this.v = t), this) : new Fh(t);
}
function BV(t, e, n) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var r = n.apply(t, e || []),
    i,
    s = [];
  return (
    (i = {}),
    o("next"),
    o("throw"),
    o("return"),
    (i[Symbol.asyncIterator] = function () {
      return this;
    }),
    i
  );
  function o(m) {
    r[m] &&
      (i[m] = function (y) {
        return new Promise(function (g, v) {
          s.push([m, y, g, v]) > 1 || a(m, y);
        });
      });
  }
  function a(m, y) {
    try {
      l(r[m](y));
    } catch (g) {
      f(s[0][3], g);
    }
  }
  function l(m) {
    m.value instanceof Fh
      ? Promise.resolve(m.value.v).then(d, p)
      : f(s[0][2], m);
  }
  function d(m) {
    a("next", m);
  }
  function p(m) {
    a("throw", m);
  }
  function f(m, y) {
    m(y), s.shift(), s.length && a(s[0][0], s[0][1]);
  }
}
function jV(t) {
  var e, n;
  return (
    (e = {}),
    r("next"),
    r("throw", function (i) {
      throw i;
    }),
    r("return"),
    (e[Symbol.iterator] = function () {
      return this;
    }),
    e
  );
  function r(i, s) {
    e[i] = t[i]
      ? function (o) {
          return (n = !n)
            ? { value: Fh(t[i](o)), done: i === "return" }
            : s
            ? s(o)
            : o;
        }
      : s;
  }
}
function FV(t) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var e = t[Symbol.asyncIterator],
    n;
  return e
    ? e.call(t)
    : ((t = typeof px == "function" ? px(t) : t[Symbol.iterator]()),
      (n = {}),
      r("next"),
      r("throw"),
      r("return"),
      (n[Symbol.asyncIterator] = function () {
        return this;
      }),
      n);
  function r(s) {
    n[s] =
      t[s] &&
      function (o) {
        return new Promise(function (a, l) {
          (o = t[s](o)), i(a, l, o.done, o.value);
        });
      };
  }
  function i(s, o, a, l) {
    Promise.resolve(l).then(function (d) {
      s({ value: d, done: a });
    }, o);
  }
}
function zV(t, e) {
  return (
    Object.defineProperty
      ? Object.defineProperty(t, "raw", { value: e })
      : (t.raw = e),
    t
  );
}
function WV(t) {
  if (t && t.__esModule) return t;
  var e = {};
  if (t != null)
    for (var n in t) Object.hasOwnProperty.call(t, n) && (e[n] = t[n]);
  return (e.default = t), e;
}
function HV(t) {
  return t && t.__esModule ? t : { default: t };
}
function qV(t, e) {
  if (!e.has(t))
    throw new TypeError("attempted to get private field on non-instance");
  return e.get(t);
}
function VV(t, e, n) {
  if (!e.has(t))
    throw new TypeError("attempted to set private field on non-instance");
  return e.set(t, n), n;
}
const GV = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        get __assign() {
          return dx;
        },
        __asyncDelegator: jV,
        __asyncGenerator: BV,
        __asyncValues: FV,
        __await: Fh,
        __awaiter: kV,
        __classPrivateFieldGet: qV,
        __classPrivateFieldSet: VV,
        __createBinding: $V,
        __decorate: RV,
        __exportStar: MV,
        __extends: TV,
        __generator: DV,
        __importDefault: HV,
        __importStar: WV,
        __makeTemplateObject: zV,
        __metadata: OV,
        __param: NV,
        __read: Z3,
        __rest: PV,
        __spread: LV,
        __spreadArrays: UV,
        __values: px,
      },
      Symbol.toStringTag,
      { value: "Module" }
    )
  ),
  Gm = nU(GV);
var hE = {},
  Df = {},
  $P;
function KV() {
  if ($P) return Df;
  ($P = 1),
    Object.defineProperty(Df, "__esModule", { value: !0 }),
    (Df.delay = void 0);
  function t(e) {
    return new Promise((n) => {
      setTimeout(() => {
        n(!0);
      }, e);
    });
  }
  return (Df.delay = t), Df;
}
var ul = {},
  mE = {},
  dl = {},
  MP;
function YV() {
  return (
    MP ||
      ((MP = 1),
      Object.defineProperty(dl, "__esModule", { value: !0 }),
      (dl.ONE_THOUSAND = dl.ONE_HUNDRED = void 0),
      (dl.ONE_HUNDRED = 100),
      (dl.ONE_THOUSAND = 1e3)),
    dl
  );
}
var gE = {},
  LP;
function ZV() {
  return (
    LP ||
      ((LP = 1),
      (function (t) {
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.ONE_YEAR =
            t.FOUR_WEEKS =
            t.THREE_WEEKS =
            t.TWO_WEEKS =
            t.ONE_WEEK =
            t.THIRTY_DAYS =
            t.SEVEN_DAYS =
            t.FIVE_DAYS =
            t.THREE_DAYS =
            t.ONE_DAY =
            t.TWENTY_FOUR_HOURS =
            t.TWELVE_HOURS =
            t.SIX_HOURS =
            t.THREE_HOURS =
            t.ONE_HOUR =
            t.SIXTY_MINUTES =
            t.THIRTY_MINUTES =
            t.TEN_MINUTES =
            t.FIVE_MINUTES =
            t.ONE_MINUTE =
            t.SIXTY_SECONDS =
            t.THIRTY_SECONDS =
            t.TEN_SECONDS =
            t.FIVE_SECONDS =
            t.ONE_SECOND =
              void 0),
          (t.ONE_SECOND = 1),
          (t.FIVE_SECONDS = 5),
          (t.TEN_SECONDS = 10),
          (t.THIRTY_SECONDS = 30),
          (t.SIXTY_SECONDS = 60),
          (t.ONE_MINUTE = t.SIXTY_SECONDS),
          (t.FIVE_MINUTES = t.ONE_MINUTE * 5),
          (t.TEN_MINUTES = t.ONE_MINUTE * 10),
          (t.THIRTY_MINUTES = t.ONE_MINUTE * 30),
          (t.SIXTY_MINUTES = t.ONE_MINUTE * 60),
          (t.ONE_HOUR = t.SIXTY_MINUTES),
          (t.THREE_HOURS = t.ONE_HOUR * 3),
          (t.SIX_HOURS = t.ONE_HOUR * 6),
          (t.TWELVE_HOURS = t.ONE_HOUR * 12),
          (t.TWENTY_FOUR_HOURS = t.ONE_HOUR * 24),
          (t.ONE_DAY = t.TWENTY_FOUR_HOURS),
          (t.THREE_DAYS = t.ONE_DAY * 3),
          (t.FIVE_DAYS = t.ONE_DAY * 5),
          (t.SEVEN_DAYS = t.ONE_DAY * 7),
          (t.THIRTY_DAYS = t.ONE_DAY * 30),
          (t.ONE_WEEK = t.SEVEN_DAYS),
          (t.TWO_WEEKS = t.ONE_WEEK * 2),
          (t.THREE_WEEKS = t.ONE_WEEK * 3),
          (t.FOUR_WEEKS = t.ONE_WEEK * 4),
          (t.ONE_YEAR = t.ONE_DAY * 365);
      })(gE)),
    gE
  );
}
var UP;
function Q3() {
  return (
    UP ||
      ((UP = 1),
      (function (t) {
        Object.defineProperty(t, "__esModule", { value: !0 });
        const e = Gm;
        e.__exportStar(YV(), t), e.__exportStar(ZV(), t);
      })(mE)),
    mE
  );
}
var BP;
function QV() {
  if (BP) return ul;
  (BP = 1),
    Object.defineProperty(ul, "__esModule", { value: !0 }),
    (ul.fromMiliseconds = ul.toMiliseconds = void 0);
  const t = Q3();
  function e(r) {
    return r * t.ONE_THOUSAND;
  }
  ul.toMiliseconds = e;
  function n(r) {
    return Math.floor(r / t.ONE_THOUSAND);
  }
  return (ul.fromMiliseconds = n), ul;
}
var jP;
function XV() {
  return (
    jP ||
      ((jP = 1),
      (function (t) {
        Object.defineProperty(t, "__esModule", { value: !0 });
        const e = Gm;
        e.__exportStar(KV(), t), e.__exportStar(QV(), t);
      })(hE)),
    hE
  );
}
var Gu = {},
  FP;
function JV() {
  if (FP) return Gu;
  (FP = 1),
    Object.defineProperty(Gu, "__esModule", { value: !0 }),
    (Gu.Watch = void 0);
  class t {
    constructor() {
      this.timestamps = new Map();
    }
    start(n) {
      if (this.timestamps.has(n))
        throw new Error(`Watch already started for label: ${n}`);
      this.timestamps.set(n, { started: Date.now() });
    }
    stop(n) {
      const r = this.get(n);
      if (typeof r.elapsed < "u")
        throw new Error(`Watch already stopped for label: ${n}`);
      const i = Date.now() - r.started;
      this.timestamps.set(n, { started: r.started, elapsed: i });
    }
    get(n) {
      const r = this.timestamps.get(n);
      if (typeof r > "u") throw new Error(`No timestamp found for label: ${n}`);
      return r;
    }
    elapsed(n) {
      const r = this.get(n);
      return r.elapsed || Date.now() - r.started;
    }
  }
  return (Gu.Watch = t), (Gu.default = t), Gu;
}
var yE = {},
  $f = {},
  zP;
function eG() {
  if (zP) return $f;
  (zP = 1),
    Object.defineProperty($f, "__esModule", { value: !0 }),
    ($f.IWatch = void 0);
  class t {}
  return ($f.IWatch = t), $f;
}
var WP;
function tG() {
  return (
    WP ||
      ((WP = 1),
      (function (t) {
        Object.defineProperty(t, "__esModule", { value: !0 }),
          Gm.__exportStar(eG(), t);
      })(yE)),
    yE
  );
}
var HP;
function nG() {
  return (
    HP ||
      ((HP = 1),
      (function (t) {
        Object.defineProperty(t, "__esModule", { value: !0 });
        const e = Gm;
        e.__exportStar(XV(), t),
          e.__exportStar(JV(), t),
          e.__exportStar(tG(), t),
          e.__exportStar(Q3(), t);
      })(fE)),
    fE
  );
}
var Ee = nG();
class fu {}
let rG = class extends fu {
  constructor(e) {
    super();
  }
};
const qP = Ee.FIVE_SECONDS,
  Ap = { pulse: "heartbeat_pulse" };
let iG = class X3 extends rG {
  constructor(e) {
    super(e),
      (this.events = new Ss.EventEmitter()),
      (this.interval = qP),
      (this.interval = (e == null ? void 0 : e.interval) || qP);
  }
  static async init(e) {
    const n = new X3(e);
    return await n.init(), n;
  }
  async init() {
    await this.initialize();
  }
  stop() {
    clearInterval(this.intervalRef);
  }
  on(e, n) {
    this.events.on(e, n);
  }
  once(e, n) {
    this.events.once(e, n);
  }
  off(e, n) {
    this.events.off(e, n);
  }
  removeListener(e, n) {
    this.events.removeListener(e, n);
  }
  async initialize() {
    this.intervalRef = setInterval(
      () => this.pulse(),
      Ee.toMiliseconds(this.interval)
    );
  }
  pulse() {
    this.events.emit(Ap.pulse);
  }
};
const sG =
    /"(?:_|\\u0{2}5[Ff]){2}(?:p|\\u0{2}70)(?:r|\\u0{2}72)(?:o|\\u0{2}6[Ff])(?:t|\\u0{2}74)(?:o|\\u0{2}6[Ff])(?:_|\\u0{2}5[Ff]){2}"\s*:/,
  oG =
    /"(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)"\s*:/,
  aG = /^\s*["[{]|^\s*-?\d{1,16}(\.\d{1,17})?([Ee][+-]?\d+)?\s*$/;
function cG(t, e) {
  if (
    t === "__proto__" ||
    (t === "constructor" && e && typeof e == "object" && "prototype" in e)
  ) {
    lG(t);
    return;
  }
  return e;
}
function lG(t) {
  console.warn(`[destr] Dropping "${t}" key to prevent prototype pollution.`);
}
function qy(t, e = {}) {
  if (typeof t != "string") return t;
  const n = t.trim();
  if (t[0] === '"' && t.endsWith('"') && !t.includes("\\"))
    return n.slice(1, -1);
  if (n.length <= 9) {
    const r = n.toLowerCase();
    if (r === "true") return !0;
    if (r === "false") return !1;
    if (r === "undefined") return;
    if (r === "null") return null;
    if (r === "nan") return Number.NaN;
    if (r === "infinity") return Number.POSITIVE_INFINITY;
    if (r === "-infinity") return Number.NEGATIVE_INFINITY;
  }
  if (!aG.test(t)) {
    if (e.strict) throw new SyntaxError("[destr] Invalid JSON");
    return t;
  }
  try {
    if (sG.test(t) || oG.test(t)) {
      if (e.strict) throw new Error("[destr] Possible prototype pollution");
      return JSON.parse(t, cG);
    }
    return JSON.parse(t);
  } catch (r) {
    if (e.strict) throw r;
    return t;
  }
}
function uG(t) {
  return !t || typeof t.then != "function" ? Promise.resolve(t) : t;
}
function ur(t, ...e) {
  try {
    return uG(t(...e));
  } catch (n) {
    return Promise.reject(n);
  }
}
function dG(t) {
  const e = typeof t;
  return t === null || (e !== "object" && e !== "function");
}
function pG(t) {
  const e = Object.getPrototypeOf(t);
  return !e || e.isPrototypeOf(Object);
}
function O0(t) {
  if (dG(t)) return String(t);
  if (pG(t) || Array.isArray(t)) return JSON.stringify(t);
  if (typeof t.toJSON == "function") return O0(t.toJSON());
  throw new Error("[unstorage] Cannot stringify value!");
}
const fx = "base64:";
function fG(t) {
  return typeof t == "string" ? t : fx + gG(t);
}
function hG(t) {
  return typeof t != "string" || !t.startsWith(fx) ? t : mG(t.slice(fx.length));
}
function mG(t) {
  return globalThis.Buffer
    ? Buffer.from(t, "base64")
    : Uint8Array.from(globalThis.atob(t), (e) => e.codePointAt(0));
}
function gG(t) {
  return globalThis.Buffer
    ? Buffer.from(t).toString("base64")
    : globalThis.btoa(String.fromCodePoint(...t));
}
function yi(t) {
  var e;
  return (
    (t &&
      ((e = t.split("?")[0]) == null
        ? void 0
        : e
            .replace(/[/\\]/g, ":")
            .replace(/:+/g, ":")
            .replace(/^:|:$/g, ""))) ||
    ""
  );
}
function yG(...t) {
  return yi(t.join(":"));
}
function Vy(t) {
  return (t = yi(t)), t ? t + ":" : "";
}
const wG = "memory",
  vG = () => {
    const t = new Map();
    return {
      name: wG,
      getInstance: () => t,
      hasItem(e) {
        return t.has(e);
      },
      getItem(e) {
        return t.get(e) ?? null;
      },
      getItemRaw(e) {
        return t.get(e) ?? null;
      },
      setItem(e, n) {
        t.set(e, n);
      },
      setItemRaw(e, n) {
        t.set(e, n);
      },
      removeItem(e) {
        t.delete(e);
      },
      getKeys() {
        return [...t.keys()];
      },
      clear() {
        t.clear();
      },
      dispose() {
        t.clear();
      },
    };
  };
function bG(t = {}) {
  const e = {
      mounts: { "": t.driver || vG() },
      mountpoints: [""],
      watching: !1,
      watchListeners: [],
      unwatch: {},
    },
    n = (d) => {
      for (const p of e.mountpoints)
        if (d.startsWith(p))
          return {
            base: p,
            relativeKey: d.slice(p.length),
            driver: e.mounts[p],
          };
      return { base: "", relativeKey: d, driver: e.mounts[""] };
    },
    r = (d, p) =>
      e.mountpoints
        .filter((f) => f.startsWith(d) || (p && d.startsWith(f)))
        .map((f) => ({
          relativeBase: d.length > f.length ? d.slice(f.length) : void 0,
          mountpoint: f,
          driver: e.mounts[f],
        })),
    i = (d, p) => {
      if (e.watching) {
        p = yi(p);
        for (const f of e.watchListeners) f(d, p);
      }
    },
    s = async () => {
      if (!e.watching) {
        e.watching = !0;
        for (const d in e.mounts) e.unwatch[d] = await VP(e.mounts[d], i, d);
      }
    },
    o = async () => {
      if (e.watching) {
        for (const d in e.unwatch) await e.unwatch[d]();
        (e.unwatch = {}), (e.watching = !1);
      }
    },
    a = (d, p, f) => {
      const m = new Map(),
        y = (g) => {
          let v = m.get(g.base);
          return (
            v ||
              ((v = { driver: g.driver, base: g.base, items: [] }),
              m.set(g.base, v)),
            v
          );
        };
      for (const g of d) {
        const v = typeof g == "string",
          b = yi(v ? g : g.key),
          E = v ? void 0 : g.value,
          S = v || !g.options ? p : { ...p, ...g.options },
          C = n(b);
        y(C).items.push({
          key: b,
          value: E,
          relativeKey: C.relativeKey,
          options: S,
        });
      }
      return Promise.all([...m.values()].map((g) => f(g))).then((g) =>
        g.flat()
      );
    },
    l = {
      hasItem(d, p = {}) {
        d = yi(d);
        const { relativeKey: f, driver: m } = n(d);
        return ur(m.hasItem, f, p);
      },
      getItem(d, p = {}) {
        d = yi(d);
        const { relativeKey: f, driver: m } = n(d);
        return ur(m.getItem, f, p).then((y) => qy(y));
      },
      getItems(d, p = {}) {
        return a(d, p, (f) =>
          f.driver.getItems
            ? ur(
                f.driver.getItems,
                f.items.map((m) => ({
                  key: m.relativeKey,
                  options: m.options,
                })),
                p
              ).then((m) =>
                m.map((y) => ({ key: yG(f.base, y.key), value: qy(y.value) }))
              )
            : Promise.all(
                f.items.map((m) =>
                  ur(f.driver.getItem, m.relativeKey, m.options).then((y) => ({
                    key: m.key,
                    value: qy(y),
                  }))
                )
              )
        );
      },
      getItemRaw(d, p = {}) {
        d = yi(d);
        const { relativeKey: f, driver: m } = n(d);
        return m.getItemRaw
          ? ur(m.getItemRaw, f, p)
          : ur(m.getItem, f, p).then((y) => hG(y));
      },
      async setItem(d, p, f = {}) {
        if (p === void 0) return l.removeItem(d);
        d = yi(d);
        const { relativeKey: m, driver: y } = n(d);
        y.setItem &&
          (await ur(y.setItem, m, O0(p), f), y.watch || i("update", d));
      },
      async setItems(d, p) {
        await a(d, p, async (f) => {
          if (f.driver.setItems)
            return ur(
              f.driver.setItems,
              f.items.map((m) => ({
                key: m.relativeKey,
                value: O0(m.value),
                options: m.options,
              })),
              p
            );
          f.driver.setItem &&
            (await Promise.all(
              f.items.map((m) =>
                ur(f.driver.setItem, m.relativeKey, O0(m.value), m.options)
              )
            ));
        });
      },
      async setItemRaw(d, p, f = {}) {
        if (p === void 0) return l.removeItem(d, f);
        d = yi(d);
        const { relativeKey: m, driver: y } = n(d);
        if (y.setItemRaw) await ur(y.setItemRaw, m, p, f);
        else if (y.setItem) await ur(y.setItem, m, fG(p), f);
        else return;
        y.watch || i("update", d);
      },
      async removeItem(d, p = {}) {
        typeof p == "boolean" && (p = { removeMeta: p }), (d = yi(d));
        const { relativeKey: f, driver: m } = n(d);
        m.removeItem &&
          (await ur(m.removeItem, f, p),
          (p.removeMeta || p.removeMata) &&
            (await ur(m.removeItem, f + "$", p)),
          m.watch || i("remove", d));
      },
      async getMeta(d, p = {}) {
        typeof p == "boolean" && (p = { nativeOnly: p }), (d = yi(d));
        const { relativeKey: f, driver: m } = n(d),
          y = Object.create(null);
        if (
          (m.getMeta && Object.assign(y, await ur(m.getMeta, f, p)),
          !p.nativeOnly)
        ) {
          const g = await ur(m.getItem, f + "$", p).then((v) => qy(v));
          g &&
            typeof g == "object" &&
            (typeof g.atime == "string" && (g.atime = new Date(g.atime)),
            typeof g.mtime == "string" && (g.mtime = new Date(g.mtime)),
            Object.assign(y, g));
        }
        return y;
      },
      setMeta(d, p, f = {}) {
        return this.setItem(d + "$", p, f);
      },
      removeMeta(d, p = {}) {
        return this.removeItem(d + "$", p);
      },
      async getKeys(d, p = {}) {
        d = Vy(d);
        const f = r(d, !0);
        let m = [];
        const y = [];
        for (const g of f) {
          const v = await ur(g.driver.getKeys, g.relativeBase, p);
          for (const b of v) {
            const E = g.mountpoint + yi(b);
            m.some((S) => E.startsWith(S)) || y.push(E);
          }
          m = [g.mountpoint, ...m.filter((b) => !b.startsWith(g.mountpoint))];
        }
        return d
          ? y.filter((g) => g.startsWith(d) && g[g.length - 1] !== "$")
          : y.filter((g) => g[g.length - 1] !== "$");
      },
      async clear(d, p = {}) {
        (d = Vy(d)),
          await Promise.all(
            r(d, !1).map(async (f) => {
              if (f.driver.clear) return ur(f.driver.clear, f.relativeBase, p);
              if (f.driver.removeItem) {
                const m = await f.driver.getKeys(f.relativeBase || "", p);
                return Promise.all(m.map((y) => f.driver.removeItem(y, p)));
              }
            })
          );
      },
      async dispose() {
        await Promise.all(Object.values(e.mounts).map((d) => GP(d)));
      },
      async watch(d) {
        return (
          await s(),
          e.watchListeners.push(d),
          async () => {
            (e.watchListeners = e.watchListeners.filter((p) => p !== d)),
              e.watchListeners.length === 0 && (await o());
          }
        );
      },
      async unwatch() {
        (e.watchListeners = []), await o();
      },
      mount(d, p) {
        if (((d = Vy(d)), d && e.mounts[d]))
          throw new Error(`already mounted at ${d}`);
        return (
          d &&
            (e.mountpoints.push(d),
            e.mountpoints.sort((f, m) => m.length - f.length)),
          (e.mounts[d] = p),
          e.watching &&
            Promise.resolve(VP(p, i, d))
              .then((f) => {
                e.unwatch[d] = f;
              })
              .catch(console.error),
          l
        );
      },
      async unmount(d, p = !0) {
        var f, m;
        (d = Vy(d)),
          !(!d || !e.mounts[d]) &&
            (e.watching &&
              d in e.unwatch &&
              ((m = (f = e.unwatch)[d]) == null || m.call(f),
              delete e.unwatch[d]),
            p && (await GP(e.mounts[d])),
            (e.mountpoints = e.mountpoints.filter((y) => y !== d)),
            delete e.mounts[d]);
      },
      getMount(d = "") {
        d = yi(d) + ":";
        const p = n(d);
        return { driver: p.driver, base: p.base };
      },
      getMounts(d = "", p = {}) {
        return (
          (d = yi(d)),
          r(d, p.parents).map((m) => ({ driver: m.driver, base: m.mountpoint }))
        );
      },
      keys: (d, p = {}) => l.getKeys(d, p),
      get: (d, p = {}) => l.getItem(d, p),
      set: (d, p, f = {}) => l.setItem(d, p, f),
      has: (d, p = {}) => l.hasItem(d, p),
      del: (d, p = {}) => l.removeItem(d, p),
      remove: (d, p = {}) => l.removeItem(d, p),
    };
  return l;
}
function VP(t, e, n) {
  return t.watch ? t.watch((r, i) => e(r, n + i)) : () => {};
}
async function GP(t) {
  typeof t.dispose == "function" && (await ur(t.dispose));
}
function hu(t) {
  return new Promise((e, n) => {
    (t.oncomplete = t.onsuccess = () => e(t.result)),
      (t.onabort = t.onerror = () => n(t.error));
  });
}
function J3(t, e) {
  const n = indexedDB.open(t);
  n.onupgradeneeded = () => n.result.createObjectStore(e);
  const r = hu(n);
  return (i, s) => r.then((o) => s(o.transaction(e, i).objectStore(e)));
}
let wE;
function Km() {
  return wE || (wE = J3("keyval-store", "keyval")), wE;
}
function KP(t, e = Km()) {
  return e("readonly", (n) => hu(n.get(t)));
}
function EG(t, e, n = Km()) {
  return n("readwrite", (r) => (r.put(e, t), hu(r.transaction)));
}
function CG(t, e = Km()) {
  return e("readwrite", (n) => (n.delete(t), hu(n.transaction)));
}
function xG(t = Km()) {
  return t("readwrite", (e) => (e.clear(), hu(e.transaction)));
}
function SG(t, e) {
  return (
    (t.openCursor().onsuccess = function () {
      this.result && (e(this.result), this.result.continue());
    }),
    hu(t.transaction)
  );
}
function AG(t = Km()) {
  return t("readonly", (e) => {
    if (e.getAllKeys) return hu(e.getAllKeys());
    const n = [];
    return SG(e, (r) => n.push(r.key)).then(() => n);
  });
}
const _G = (t) =>
    JSON.stringify(t, (e, n) =>
      typeof n == "bigint" ? n.toString() + "n" : n
    ),
  IG = (t) => {
    const e =
        /([\[:])?(\d{17,}|(?:[9](?:[1-9]07199254740991|0[1-9]7199254740991|00[8-9]199254740991|007[2-9]99254740991|007199[3-9]54740991|0071992[6-9]4740991|00719925[5-9]740991|007199254[8-9]40991|0071992547[5-9]0991|00719925474[1-9]991|00719925474099[2-9])))([,\}\]])/g,
      n = t.replace(e, '$1"$2n"$3');
    return JSON.parse(n, (r, i) =>
      typeof i == "string" && i.match(/^\d+n$/)
        ? BigInt(i.substring(0, i.length - 1))
        : i
    );
  };
function Zl(t) {
  if (typeof t != "string")
    throw new Error(`Cannot safe json parse value of type ${typeof t}`);
  try {
    return IG(t);
  } catch {
    return t;
  }
}
function Aa(t) {
  return typeof t == "string" ? t : _G(t) || "";
}
const TG = "idb-keyval";
var PG = (t = {}) => {
  const e = t.base && t.base.length > 0 ? `${t.base}:` : "",
    n = (i) => e + i;
  let r;
  return (
    t.dbName && t.storeName && (r = J3(t.dbName, t.storeName)),
    {
      name: TG,
      options: t,
      async hasItem(i) {
        return !(typeof (await KP(n(i), r)) > "u");
      },
      async getItem(i) {
        return (await KP(n(i), r)) ?? null;
      },
      setItem(i, s) {
        return EG(n(i), s, r);
      },
      removeItem(i) {
        return CG(n(i), r);
      },
      getKeys() {
        return AG(r);
      },
      clear() {
        return xG(r);
      },
    }
  );
};
const RG = "WALLET_CONNECT_V2_INDEXED_DB",
  NG = "keyvaluestorage";
let OG = class {
  constructor() {
    this.indexedDb = bG({ driver: PG({ dbName: RG, storeName: NG }) });
  }
  async getKeys() {
    return this.indexedDb.getKeys();
  }
  async getEntries() {
    return (await this.indexedDb.getItems(await this.indexedDb.getKeys())).map(
      (e) => [e.key, e.value]
    );
  }
  async getItem(e) {
    const n = await this.indexedDb.getItem(e);
    if (n !== null) return n;
  }
  async setItem(e, n) {
    await this.indexedDb.setItem(e, Aa(n));
  }
  async removeItem(e) {
    await this.indexedDb.removeItem(e);
  }
};
var vE =
    typeof globalThis < "u"
      ? globalThis
      : typeof window < "u"
      ? window
      : typeof global < "u"
      ? global
      : typeof self < "u"
      ? self
      : {},
  k0 = { exports: {} };
(function () {
  let t;
  function e() {}
  (t = e),
    (t.prototype.getItem = function (n) {
      return this.hasOwnProperty(n) ? String(this[n]) : null;
    }),
    (t.prototype.setItem = function (n, r) {
      this[n] = String(r);
    }),
    (t.prototype.removeItem = function (n) {
      delete this[n];
    }),
    (t.prototype.clear = function () {
      const n = this;
      Object.keys(n).forEach(function (r) {
        (n[r] = void 0), delete n[r];
      });
    }),
    (t.prototype.key = function (n) {
      return (n = n || 0), Object.keys(this)[n];
    }),
    t.prototype.__defineGetter__("length", function () {
      return Object.keys(this).length;
    }),
    typeof vE < "u" && vE.localStorage
      ? (k0.exports = vE.localStorage)
      : typeof window < "u" && window.localStorage
      ? (k0.exports = window.localStorage)
      : (k0.exports = new e());
})();
function kG(t) {
  var e;
  return [t[0], Zl((e = t[1]) != null ? e : "")];
}
let DG = class {
  constructor() {
    this.localStorage = k0.exports;
  }
  async getKeys() {
    return Object.keys(this.localStorage);
  }
  async getEntries() {
    return Object.entries(this.localStorage).map(kG);
  }
  async getItem(e) {
    const n = this.localStorage.getItem(e);
    if (n !== null) return Zl(n);
  }
  async setItem(e, n) {
    this.localStorage.setItem(e, Aa(n));
  }
  async removeItem(e) {
    this.localStorage.removeItem(e);
  }
};
const $G = "wc_storage_version",
  YP = 1,
  MG = async (t, e, n) => {
    const r = $G,
      i = await e.getItem(r);
    if (i && i >= YP) {
      n(e);
      return;
    }
    const s = await t.getKeys();
    if (!s.length) {
      n(e);
      return;
    }
    const o = [];
    for (; s.length; ) {
      const a = s.shift();
      if (!a) continue;
      const l = a.toLowerCase();
      if (
        l.includes("wc@") ||
        l.includes("walletconnect") ||
        l.includes("wc_") ||
        l.includes("wallet_connect")
      ) {
        const d = await t.getItem(a);
        await e.setItem(a, d), o.push(a);
      }
    }
    await e.setItem(r, YP), n(e), LG(t, o);
  },
  LG = async (t, e) => {
    e.length &&
      e.forEach(async (n) => {
        await t.removeItem(n);
      });
  };
let UG = class {
  constructor() {
    (this.initialized = !1),
      (this.setInitialized = (n) => {
        (this.storage = n), (this.initialized = !0);
      });
    const e = new DG();
    this.storage = e;
    try {
      const n = new OG();
      MG(e, n, this.setInitialized);
    } catch {
      this.initialized = !0;
    }
  }
  async getKeys() {
    return await this.initialize(), this.storage.getKeys();
  }
  async getEntries() {
    return await this.initialize(), this.storage.getEntries();
  }
  async getItem(e) {
    return await this.initialize(), this.storage.getItem(e);
  }
  async setItem(e, n) {
    return await this.initialize(), this.storage.setItem(e, n);
  }
  async removeItem(e) {
    return await this.initialize(), this.storage.removeItem(e);
  }
  async initialize() {
    this.initialized ||
      (await new Promise((e) => {
        const n = setInterval(() => {
          this.initialized && (clearInterval(n), e());
        }, 20);
      }));
  }
};
var bE, ZP;
function BG() {
  if (ZP) return bE;
  ZP = 1;
  function t(n) {
    try {
      return JSON.stringify(n);
    } catch {
      return '"[Circular]"';
    }
  }
  bE = e;
  function e(n, r, i) {
    var s = (i && i.stringify) || t,
      o = 1;
    if (typeof n == "object" && n !== null) {
      var a = r.length + o;
      if (a === 1) return n;
      var l = new Array(a);
      l[0] = s(n);
      for (var d = 1; d < a; d++) l[d] = s(r[d]);
      return l.join(" ");
    }
    if (typeof n != "string") return n;
    var p = r.length;
    if (p === 0) return n;
    for (
      var f = "", m = 1 - o, y = -1, g = (n && n.length) || 0, v = 0;
      v < g;

    ) {
      if (n.charCodeAt(v) === 37 && v + 1 < g) {
        switch (((y = y > -1 ? y : 0), n.charCodeAt(v + 1))) {
          case 100:
          case 102:
            if (m >= p || r[m] == null) break;
            y < v && (f += n.slice(y, v)),
              (f += Number(r[m])),
              (y = v + 2),
              v++;
            break;
          case 105:
            if (m >= p || r[m] == null) break;
            y < v && (f += n.slice(y, v)),
              (f += Math.floor(Number(r[m]))),
              (y = v + 2),
              v++;
            break;
          case 79:
          case 111:
          case 106:
            if (m >= p || r[m] === void 0) break;
            y < v && (f += n.slice(y, v));
            var b = typeof r[m];
            if (b === "string") {
              (f += "'" + r[m] + "'"), (y = v + 2), v++;
              break;
            }
            if (b === "function") {
              (f += r[m].name || "<anonymous>"), (y = v + 2), v++;
              break;
            }
            (f += s(r[m])), (y = v + 2), v++;
            break;
          case 115:
            if (m >= p) break;
            y < v && (f += n.slice(y, v)),
              (f += String(r[m])),
              (y = v + 2),
              v++;
            break;
          case 37:
            y < v && (f += n.slice(y, v)), (f += "%"), (y = v + 2), v++, m--;
            break;
        }
        ++m;
      }
      ++v;
    }
    return y === -1 ? n : (y < g && (f += n.slice(y)), f);
  }
  return bE;
}
var EE, QP;
function jG() {
  if (QP) return EE;
  QP = 1;
  const t = BG();
  EE = i;
  const e = A().console || {},
    n = {
      mapHttpRequest: g,
      mapHttpResponse: g,
      wrapRequestSerializer: v,
      wrapResponseSerializer: v,
      wrapErrorSerializer: v,
      req: g,
      res: g,
      err: m,
    };
  function r(I, R) {
    return Array.isArray(I)
      ? I.filter(function (k) {
          return k !== "!stdSerializers.err";
        })
      : I === !0
      ? Object.keys(R)
      : !1;
  }
  function i(I) {
    (I = I || {}), (I.browser = I.browser || {});
    const R = I.browser.transmit;
    if (R && typeof R.send != "function")
      throw Error("pino: transmit option must have a send function");
    const D = I.browser.write || e;
    I.browser.write && (I.browser.asObject = !0);
    const k = I.serializers || {},
      T = r(I.browser.serialize, k);
    let U = I.browser.serialize;
    Array.isArray(I.browser.serialize) &&
      I.browser.serialize.indexOf("!stdSerializers.err") > -1 &&
      (U = !1);
    const q = ["error", "fatal", "warn", "info", "debug", "trace"];
    typeof D == "function" &&
      (D.error = D.fatal = D.warn = D.info = D.debug = D.trace = D),
      I.enabled === !1 && (I.level = "silent");
    const K = I.level || "info",
      H = Object.create(D);
    H.log || (H.log = b),
      Object.defineProperty(H, "levelVal", { get: M }),
      Object.defineProperty(H, "level", { get: z, set: B });
    const $ = {
      transmit: R,
      serialize: T,
      asObject: I.browser.asObject,
      levels: q,
      timestamp: y(I),
    };
    (H.levels = i.levels),
      (H.level = K),
      (H.setMaxListeners =
        H.getMaxListeners =
        H.emit =
        H.addListener =
        H.on =
        H.prependListener =
        H.once =
        H.prependOnceListener =
        H.removeListener =
        H.removeAllListeners =
        H.listeners =
        H.listenerCount =
        H.eventNames =
        H.write =
        H.flush =
          b),
      (H.serializers = k),
      (H._serialize = T),
      (H._stdErrSerialize = U),
      (H.child = j),
      R && (H._logEvent = f());
    function M() {
      return this.level === "silent" ? 1 / 0 : this.levels.values[this.level];
    }
    function z() {
      return this._level;
    }
    function B(V) {
      if (V !== "silent" && !this.levels.values[V])
        throw Error("unknown level " + V);
      (this._level = V),
        s($, H, "error", "log"),
        s($, H, "fatal", "error"),
        s($, H, "warn", "error"),
        s($, H, "info", "log"),
        s($, H, "debug", "log"),
        s($, H, "trace", "log");
    }
    function j(V, W) {
      if (!V) throw new Error("missing bindings for child Pino");
      (W = W || {}), T && V.serializers && (W.serializers = V.serializers);
      const Z = W.serializers;
      if (T && Z) {
        var ee = Object.assign({}, k, Z),
          J = I.browser.serialize === !0 ? Object.keys(ee) : T;
        delete V.serializers, l([V], J, ee, this._stdErrSerialize);
      }
      function se(re) {
        (this._childLevel = (re._childLevel | 0) + 1),
          (this.error = d(re, V, "error")),
          (this.fatal = d(re, V, "fatal")),
          (this.warn = d(re, V, "warn")),
          (this.info = d(re, V, "info")),
          (this.debug = d(re, V, "debug")),
          (this.trace = d(re, V, "trace")),
          ee && ((this.serializers = ee), (this._serialize = J)),
          R && (this._logEvent = f([].concat(re._logEvent.bindings, V)));
      }
      return (se.prototype = this), new se(this);
    }
    return H;
  }
  (i.levels = {
    values: { fatal: 60, error: 50, warn: 40, info: 30, debug: 20, trace: 10 },
    labels: {
      10: "trace",
      20: "debug",
      30: "info",
      40: "warn",
      50: "error",
      60: "fatal",
    },
  }),
    (i.stdSerializers = n),
    (i.stdTimeFunctions = Object.assign(
      {},
      { nullTime: E, epochTime: S, unixTime: C, isoTime: _ }
    ));
  function s(I, R, D, k) {
    const T = Object.getPrototypeOf(R);
    (R[D] =
      R.levelVal > R.levels.values[D] ? b : T[D] ? T[D] : e[D] || e[k] || b),
      o(I, R, D);
  }
  function o(I, R, D) {
    (!I.transmit && R[D] === b) ||
      (R[D] = (function (k) {
        return function () {
          const U = I.timestamp(),
            q = new Array(arguments.length),
            K =
              Object.getPrototypeOf && Object.getPrototypeOf(this) === e
                ? e
                : this;
          for (var H = 0; H < q.length; H++) q[H] = arguments[H];
          if (
            (I.serialize &&
              !I.asObject &&
              l(q, this._serialize, this.serializers, this._stdErrSerialize),
            I.asObject ? k.call(K, a(this, D, q, U)) : k.apply(K, q),
            I.transmit)
          ) {
            const $ = I.transmit.level || R.level,
              M = i.levels.values[$],
              z = i.levels.values[D];
            if (z < M) return;
            p(
              this,
              {
                ts: U,
                methodLevel: D,
                methodValue: z,
                transmitLevel: $,
                transmitValue: i.levels.values[I.transmit.level || R.level],
                send: I.transmit.send,
                val: R.levelVal,
              },
              q
            );
          }
        };
      })(R[D]));
  }
  function a(I, R, D, k) {
    I._serialize && l(D, I._serialize, I.serializers, I._stdErrSerialize);
    const T = D.slice();
    let U = T[0];
    const q = {};
    k && (q.time = k), (q.level = i.levels.values[R]);
    let K = (I._childLevel | 0) + 1;
    if ((K < 1 && (K = 1), U !== null && typeof U == "object")) {
      for (; K-- && typeof T[0] == "object"; ) Object.assign(q, T.shift());
      U = T.length ? t(T.shift(), T) : void 0;
    } else typeof U == "string" && (U = t(T.shift(), T));
    return U !== void 0 && (q.msg = U), q;
  }
  function l(I, R, D, k) {
    for (const T in I)
      if (k && I[T] instanceof Error) I[T] = i.stdSerializers.err(I[T]);
      else if (typeof I[T] == "object" && !Array.isArray(I[T]))
        for (const U in I[T])
          R && R.indexOf(U) > -1 && U in D && (I[T][U] = D[U](I[T][U]));
  }
  function d(I, R, D) {
    return function () {
      const k = new Array(1 + arguments.length);
      k[0] = R;
      for (var T = 1; T < k.length; T++) k[T] = arguments[T - 1];
      return I[D].apply(this, k);
    };
  }
  function p(I, R, D) {
    const k = R.send,
      T = R.ts,
      U = R.methodLevel,
      q = R.methodValue,
      K = R.val,
      H = I._logEvent.bindings;
    l(
      D,
      I._serialize || Object.keys(I.serializers),
      I.serializers,
      I._stdErrSerialize === void 0 ? !0 : I._stdErrSerialize
    ),
      (I._logEvent.ts = T),
      (I._logEvent.messages = D.filter(function ($) {
        return H.indexOf($) === -1;
      })),
      (I._logEvent.level.label = U),
      (I._logEvent.level.value = q),
      k(U, I._logEvent, K),
      (I._logEvent = f(H));
  }
  function f(I) {
    return {
      ts: 0,
      messages: [],
      bindings: I || [],
      level: { label: "", value: 0 },
    };
  }
  function m(I) {
    const R = { type: I.constructor.name, msg: I.message, stack: I.stack };
    for (const D in I) R[D] === void 0 && (R[D] = I[D]);
    return R;
  }
  function y(I) {
    return typeof I.timestamp == "function"
      ? I.timestamp
      : I.timestamp === !1
      ? E
      : S;
  }
  function g() {
    return {};
  }
  function v(I) {
    return I;
  }
  function b() {}
  function E() {
    return !1;
  }
  function S() {
    return Date.now();
  }
  function C() {
    return Math.round(Date.now() / 1e3);
  }
  function _() {
    return new Date(Date.now()).toISOString();
  }
  function A() {
    function I(R) {
      return typeof R < "u" && R;
    }
    try {
      return (
        typeof globalThis < "u" ||
          Object.defineProperty(Object.prototype, "globalThis", {
            get: function () {
              return (
                delete Object.prototype.globalThis, (this.globalThis = this)
              );
            },
            configurable: !0,
          }),
        globalThis
      );
    } catch {
      return I(self) || I(window) || I(this) || {};
    }
  }
  return EE;
}
var wd = jG();
const Ym = Hc(wd),
  FG = { level: "info" },
  Zm = "custom_context",
  gA = 1e3 * 1024;
let zG = class {
    constructor(e) {
      (this.nodeValue = e),
        (this.sizeInBytes = new TextEncoder().encode(this.nodeValue).length),
        (this.next = null);
    }
    get value() {
      return this.nodeValue;
    }
    get size() {
      return this.sizeInBytes;
    }
  },
  XP = class {
    constructor(e) {
      (this.head = null),
        (this.tail = null),
        (this.lengthInNodes = 0),
        (this.maxSizeInBytes = e),
        (this.sizeInBytes = 0);
    }
    append(e) {
      const n = new zG(e);
      if (n.size > this.maxSizeInBytes)
        throw new Error(
          `[LinkedList] Value too big to insert into list: ${e} with size ${n.size}`
        );
      for (; this.size + n.size > this.maxSizeInBytes; ) this.shift();
      this.head
        ? (this.tail && (this.tail.next = n), (this.tail = n))
        : ((this.head = n), (this.tail = n)),
        this.lengthInNodes++,
        (this.sizeInBytes += n.size);
    }
    shift() {
      if (!this.head) return;
      const e = this.head;
      (this.head = this.head.next),
        this.head || (this.tail = null),
        this.lengthInNodes--,
        (this.sizeInBytes -= e.size);
    }
    toArray() {
      const e = [];
      let n = this.head;
      for (; n !== null; ) e.push(n.value), (n = n.next);
      return e;
    }
    get length() {
      return this.lengthInNodes;
    }
    get size() {
      return this.sizeInBytes;
    }
    toOrderedArray() {
      return Array.from(this);
    }
    [Symbol.iterator]() {
      let e = this.head;
      return {
        next: () => {
          if (!e) return { done: !0, value: null };
          const n = e.value;
          return (e = e.next), { done: !1, value: n };
        },
      };
    }
  },
  eD = class {
    constructor(e, n = gA) {
      (this.level = e ?? "error"),
        (this.levelValue = wd.levels.values[this.level]),
        (this.MAX_LOG_SIZE_IN_BYTES = n),
        (this.logs = new XP(this.MAX_LOG_SIZE_IN_BYTES));
    }
    forwardToConsole(e, n) {
      n === wd.levels.values.error
        ? console.error(e)
        : n === wd.levels.values.warn
        ? console.warn(e)
        : n === wd.levels.values.debug
        ? console.debug(e)
        : n === wd.levels.values.trace
        ? console.trace(e)
        : console.log(e);
    }
    appendToLogs(e) {
      this.logs.append(Aa({ timestamp: new Date().toISOString(), log: e }));
      const n = typeof e == "string" ? JSON.parse(e).level : e.level;
      n >= this.levelValue && this.forwardToConsole(e, n);
    }
    getLogs() {
      return this.logs;
    }
    clearLogs() {
      this.logs = new XP(this.MAX_LOG_SIZE_IN_BYTES);
    }
    getLogArray() {
      return Array.from(this.logs);
    }
    logsToBlob(e) {
      const n = this.getLogArray();
      return (
        n.push(Aa({ extraMetadata: e })),
        new Blob(n, { type: "application/json" })
      );
    }
  },
  WG = class {
    constructor(e, n = gA) {
      this.baseChunkLogger = new eD(e, n);
    }
    write(e) {
      this.baseChunkLogger.appendToLogs(e);
    }
    getLogs() {
      return this.baseChunkLogger.getLogs();
    }
    clearLogs() {
      this.baseChunkLogger.clearLogs();
    }
    getLogArray() {
      return this.baseChunkLogger.getLogArray();
    }
    logsToBlob(e) {
      return this.baseChunkLogger.logsToBlob(e);
    }
    downloadLogsBlobInBrowser(e) {
      const n = URL.createObjectURL(this.logsToBlob(e)),
        r = document.createElement("a");
      (r.href = n),
        (r.download = `walletconnect-logs-${new Date().toISOString()}.txt`),
        document.body.appendChild(r),
        r.click(),
        document.body.removeChild(r),
        URL.revokeObjectURL(n);
    }
  },
  HG = class {
    constructor(e, n = gA) {
      this.baseChunkLogger = new eD(e, n);
    }
    write(e) {
      this.baseChunkLogger.appendToLogs(e);
    }
    getLogs() {
      return this.baseChunkLogger.getLogs();
    }
    clearLogs() {
      this.baseChunkLogger.clearLogs();
    }
    getLogArray() {
      return this.baseChunkLogger.getLogArray();
    }
    logsToBlob(e) {
      return this.baseChunkLogger.logsToBlob(e);
    }
  };
var qG = Object.defineProperty,
  VG = Object.defineProperties,
  GG = Object.getOwnPropertyDescriptors,
  JP = Object.getOwnPropertySymbols,
  KG = Object.prototype.hasOwnProperty,
  YG = Object.prototype.propertyIsEnumerable,
  eR = (t, e, n) =>
    e in t
      ? qG(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n })
      : (t[e] = n),
  lw = (t, e) => {
    for (var n in e || (e = {})) KG.call(e, n) && eR(t, n, e[n]);
    if (JP) for (var n of JP(e)) YG.call(e, n) && eR(t, n, e[n]);
    return t;
  },
  uw = (t, e) => VG(t, GG(e));
function _p(t) {
  return uw(lw({}, t), { level: (t == null ? void 0 : t.level) || FG.level });
}
function ZG(t, e = Zm) {
  return t[e] || "";
}
function QG(t, e, n = Zm) {
  return (t[n] = e), t;
}
function Ti(t, e = Zm) {
  let n = "";
  return (
    typeof t.bindings > "u" ? (n = ZG(t, e)) : (n = t.bindings().context || ""),
    n
  );
}
function XG(t, e, n = Zm) {
  const r = Ti(t, n);
  return r.trim() ? `${r}/${e}` : e;
}
function Gr(t, e, n = Zm) {
  const r = XG(t, e, n),
    i = t.child({ context: r });
  return QG(i, r, n);
}
function JG(t) {
  var e, n;
  const r = new WG((e = t.opts) == null ? void 0 : e.level, t.maxSizeInBytes);
  return {
    logger: Ym(
      uw(lw({}, t.opts), {
        level: "trace",
        browser: uw(lw({}, (n = t.opts) == null ? void 0 : n.browser), {
          write: (i) => r.write(i),
        }),
      })
    ),
    chunkLoggerController: r,
  };
}
function eK(t) {
  var e;
  const n = new HG((e = t.opts) == null ? void 0 : e.level, t.maxSizeInBytes);
  return {
    logger: Ym(uw(lw({}, t.opts), { level: "trace" }), n),
    chunkLoggerController: n,
  };
}
function yA(t) {
  return typeof t.loggerOverride < "u" && typeof t.loggerOverride != "string"
    ? { logger: t.loggerOverride, chunkLoggerController: null }
    : typeof window < "u"
    ? JG(t)
    : eK(t);
}
var tK = Object.defineProperty,
  nK = (t, e, n) =>
    e in t
      ? tK(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n })
      : (t[e] = n),
  tR = (t, e, n) => nK(t, typeof e != "symbol" ? e + "" : e, n);
let rK = class extends fu {
  constructor(e) {
    super(),
      (this.opts = e),
      tR(this, "protocol", "wc"),
      tR(this, "version", 2);
  }
};
var iK = Object.defineProperty,
  sK = (t, e, n) =>
    e in t
      ? iK(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n })
      : (t[e] = n),
  oK = (t, e, n) => sK(t, e + "", n);
let aK = class extends fu {
    constructor(e, n) {
      super(),
        (this.core = e),
        (this.logger = n),
        oK(this, "records", new Map());
    }
  },
  cK = class {
    constructor(e, n) {
      (this.logger = e), (this.core = n);
    }
  },
  lK = class extends fu {
    constructor(e, n) {
      super(), (this.relayer = e), (this.logger = n);
    }
  },
  uK = class extends fu {
    constructor(e) {
      super();
    }
  },
  dK = class {
    constructor(e, n, r, i) {
      (this.core = e), (this.logger = n), (this.name = r);
    }
  },
  pK = class extends fu {
    constructor(e, n) {
      super(), (this.relayer = e), (this.logger = n);
    }
  },
  fK = class extends fu {
    constructor(e, n) {
      super(), (this.core = e), (this.logger = n);
    }
  },
  hK = class {
    constructor(e, n, r) {
      (this.core = e), (this.logger = n), (this.store = r);
    }
  },
  mK = class {
    constructor(e, n) {
      (this.projectId = e), (this.logger = n);
    }
  },
  gK = class {
    constructor(e, n, r) {
      (this.core = e), (this.logger = n), (this.telemetryEnabled = r);
    }
  };
var yK = Object.defineProperty,
  wK = (t, e, n) =>
    e in t
      ? yK(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n })
      : (t[e] = n),
  nR = (t, e, n) => wK(t, typeof e != "symbol" ? e + "" : e, n);
let vK = class {
    constructor(e) {
      (this.opts = e), nR(this, "protocol", "wc"), nR(this, "version", 2);
    }
  },
  bK = class {
    constructor(e) {
      this.client = e;
    }
  };
function EK(t) {
  return (
    t instanceof Uint8Array ||
    (ArrayBuffer.isView(t) && t.constructor.name === "Uint8Array")
  );
}
function tD(t, ...e) {
  if (!EK(t)) throw new Error("Uint8Array expected");
  if (e.length > 0 && !e.includes(t.length))
    throw new Error(
      "Uint8Array expected of length " + e + ", got length=" + t.length
    );
}
function rR(t, e = !0) {
  if (t.destroyed) throw new Error("Hash instance has been destroyed");
  if (e && t.finished) throw new Error("Hash#digest() has already been called");
}
function CK(t, e) {
  tD(t);
  const n = e.outputLen;
  if (t.length < n)
    throw new Error(
      "digestInto() expects output buffer of length at least " + n
    );
}
const Ku =
  typeof globalThis == "object" && "crypto" in globalThis
    ? globalThis.crypto
    : void 0;
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const CE =
  (t) => new DataView(t.buffer, t.byteOffset, t.byteLength);
function xK(t) {
  if (typeof t != "string")
    throw new Error("utf8ToBytes expected string, got " + typeof t);
  return new Uint8Array(new TextEncoder().encode(t));
}
function nD(t) {
  return typeof t == "string" && (t = xK(t)), tD(t), t;
}
let SK = class {
  clone() {
    return this._cloneInto();
  }
};
function AK(t) {
  const e = (r) => t().update(nD(r)).digest(),
    n = t();
  return (
    (e.outputLen = n.outputLen),
    (e.blockLen = n.blockLen),
    (e.create = () => t()),
    e
  );
}
function rD(t = 32) {
  if (Ku && typeof Ku.getRandomValues == "function")
    return Ku.getRandomValues(new Uint8Array(t));
  if (Ku && typeof Ku.randomBytes == "function") return Ku.randomBytes(t);
  throw new Error("crypto.getRandomValues must be defined");
}
function _K(t, e, n, r) {
  if (typeof t.setBigUint64 == "function") return t.setBigUint64(e, n, r);
  const i = BigInt(32),
    s = BigInt(4294967295),
    o = Number((n >> i) & s),
    a = Number(n & s),
    l = r ? 4 : 0,
    d = r ? 0 : 4;
  t.setUint32(e + l, o, r), t.setUint32(e + d, a, r);
}
let IK = class extends SK {
  constructor(e, n, r, i) {
    super(),
      (this.blockLen = e),
      (this.outputLen = n),
      (this.padOffset = r),
      (this.isLE = i),
      (this.finished = !1),
      (this.length = 0),
      (this.pos = 0),
      (this.destroyed = !1),
      (this.buffer = new Uint8Array(e)),
      (this.view = CE(this.buffer));
  }
  update(e) {
    rR(this);
    const { view: n, buffer: r, blockLen: i } = this;
    e = nD(e);
    const s = e.length;
    for (let o = 0; o < s; ) {
      const a = Math.min(i - this.pos, s - o);
      if (a === i) {
        const l = CE(e);
        for (; i <= s - o; o += i) this.process(l, o);
        continue;
      }
      r.set(e.subarray(o, o + a), this.pos),
        (this.pos += a),
        (o += a),
        this.pos === i && (this.process(n, 0), (this.pos = 0));
    }
    return (this.length += e.length), this.roundClean(), this;
  }
  digestInto(e) {
    rR(this), CK(e, this), (this.finished = !0);
    const { buffer: n, view: r, blockLen: i, isLE: s } = this;
    let { pos: o } = this;
    (n[o++] = 128),
      this.buffer.subarray(o).fill(0),
      this.padOffset > i - o && (this.process(r, 0), (o = 0));
    for (let f = o; f < i; f++) n[f] = 0;
    _K(r, i - 8, BigInt(this.length * 8), s), this.process(r, 0);
    const a = CE(e),
      l = this.outputLen;
    if (l % 4) throw new Error("_sha2: outputLen should be aligned to 32bit");
    const d = l / 4,
      p = this.get();
    if (d > p.length) throw new Error("_sha2: outputLen bigger than state");
    for (let f = 0; f < d; f++) a.setUint32(4 * f, p[f], s);
  }
  digest() {
    const { buffer: e, outputLen: n } = this;
    this.digestInto(e);
    const r = e.slice(0, n);
    return this.destroy(), r;
  }
  _cloneInto(e) {
    e || (e = new this.constructor()), e.set(...this.get());
    const {
      blockLen: n,
      buffer: r,
      length: i,
      finished: s,
      destroyed: o,
      pos: a,
    } = this;
    return (
      (e.length = i),
      (e.pos = a),
      (e.finished = s),
      (e.destroyed = o),
      i % n && e.buffer.set(r),
      e
    );
  }
};
const Gy = BigInt(2 ** 32 - 1),
  hx = BigInt(32);
function iD(t, e = !1) {
  return e
    ? { h: Number(t & Gy), l: Number((t >> hx) & Gy) }
    : { h: Number((t >> hx) & Gy) | 0, l: Number(t & Gy) | 0 };
}
function TK(t, e = !1) {
  let n = new Uint32Array(t.length),
    r = new Uint32Array(t.length);
  for (let i = 0; i < t.length; i++) {
    const { h: s, l: o } = iD(t[i], e);
    [n[i], r[i]] = [s, o];
  }
  return [n, r];
}
const PK = (t, e) => (BigInt(t >>> 0) << hx) | BigInt(e >>> 0),
  RK = (t, e, n) => t >>> n,
  NK = (t, e, n) => (t << (32 - n)) | (e >>> n),
  OK = (t, e, n) => (t >>> n) | (e << (32 - n)),
  kK = (t, e, n) => (t << (32 - n)) | (e >>> n),
  DK = (t, e, n) => (t << (64 - n)) | (e >>> (n - 32)),
  $K = (t, e, n) => (t >>> (n - 32)) | (e << (64 - n)),
  MK = (t, e) => e,
  LK = (t, e) => t,
  UK = (t, e, n) => (t << n) | (e >>> (32 - n)),
  BK = (t, e, n) => (e << n) | (t >>> (32 - n)),
  jK = (t, e, n) => (e << (n - 32)) | (t >>> (64 - n)),
  FK = (t, e, n) => (t << (n - 32)) | (e >>> (64 - n));
function zK(t, e, n, r) {
  const i = (e >>> 0) + (r >>> 0);
  return { h: (t + n + ((i / 2 ** 32) | 0)) | 0, l: i | 0 };
}
const WK = (t, e, n) => (t >>> 0) + (e >>> 0) + (n >>> 0),
  HK = (t, e, n, r) => (e + n + r + ((t / 2 ** 32) | 0)) | 0,
  qK = (t, e, n, r) => (t >>> 0) + (e >>> 0) + (n >>> 0) + (r >>> 0),
  VK = (t, e, n, r, i) => (e + n + r + i + ((t / 2 ** 32) | 0)) | 0,
  GK = (t, e, n, r, i) =>
    (t >>> 0) + (e >>> 0) + (n >>> 0) + (r >>> 0) + (i >>> 0),
  KK = (t, e, n, r, i, s) => (e + n + r + i + s + ((t / 2 ** 32) | 0)) | 0,
  mt = {
    fromBig: iD,
    split: TK,
    toBig: PK,
    shrSH: RK,
    shrSL: NK,
    rotrSH: OK,
    rotrSL: kK,
    rotrBH: DK,
    rotrBL: $K,
    rotr32H: MK,
    rotr32L: LK,
    rotlSH: UK,
    rotlSL: BK,
    rotlBH: jK,
    rotlBL: FK,
    add: zK,
    add3L: WK,
    add3H: HK,
    add4L: qK,
    add4H: VK,
    add5H: KK,
    add5L: GK,
  },
  [YK, ZK] = mt.split(
    [
      "0x428a2f98d728ae22",
      "0x7137449123ef65cd",
      "0xb5c0fbcfec4d3b2f",
      "0xe9b5dba58189dbbc",
      "0x3956c25bf348b538",
      "0x59f111f1b605d019",
      "0x923f82a4af194f9b",
      "0xab1c5ed5da6d8118",
      "0xd807aa98a3030242",
      "0x12835b0145706fbe",
      "0x243185be4ee4b28c",
      "0x550c7dc3d5ffb4e2",
      "0x72be5d74f27b896f",
      "0x80deb1fe3b1696b1",
      "0x9bdc06a725c71235",
      "0xc19bf174cf692694",
      "0xe49b69c19ef14ad2",
      "0xefbe4786384f25e3",
      "0x0fc19dc68b8cd5b5",
      "0x240ca1cc77ac9c65",
      "0x2de92c6f592b0275",
      "0x4a7484aa6ea6e483",
      "0x5cb0a9dcbd41fbd4",
      "0x76f988da831153b5",
      "0x983e5152ee66dfab",
      "0xa831c66d2db43210",
      "0xb00327c898fb213f",
      "0xbf597fc7beef0ee4",
      "0xc6e00bf33da88fc2",
      "0xd5a79147930aa725",
      "0x06ca6351e003826f",
      "0x142929670a0e6e70",
      "0x27b70a8546d22ffc",
      "0x2e1b21385c26c926",
      "0x4d2c6dfc5ac42aed",
      "0x53380d139d95b3df",
      "0x650a73548baf63de",
      "0x766a0abb3c77b2a8",
      "0x81c2c92e47edaee6",
      "0x92722c851482353b",
      "0xa2bfe8a14cf10364",
      "0xa81a664bbc423001",
      "0xc24b8b70d0f89791",
      "0xc76c51a30654be30",
      "0xd192e819d6ef5218",
      "0xd69906245565a910",
      "0xf40e35855771202a",
      "0x106aa07032bbd1b8",
      "0x19a4c116b8d2d0c8",
      "0x1e376c085141ab53",
      "0x2748774cdf8eeb99",
      "0x34b0bcb5e19b48a8",
      "0x391c0cb3c5c95a63",
      "0x4ed8aa4ae3418acb",
      "0x5b9cca4f7763e373",
      "0x682e6ff3d6b2b8a3",
      "0x748f82ee5defb2fc",
      "0x78a5636f43172f60",
      "0x84c87814a1f0ab72",
      "0x8cc702081a6439ec",
      "0x90befffa23631e28",
      "0xa4506cebde82bde9",
      "0xbef9a3f7b2c67915",
      "0xc67178f2e372532b",
      "0xca273eceea26619c",
      "0xd186b8c721c0c207",
      "0xeada7dd6cde0eb1e",
      "0xf57d4f7fee6ed178",
      "0x06f067aa72176fba",
      "0x0a637dc5a2c898a6",
      "0x113f9804bef90dae",
      "0x1b710b35131c471b",
      "0x28db77f523047d84",
      "0x32caab7b40c72493",
      "0x3c9ebe0a15c9bebc",
      "0x431d67c49c100d4c",
      "0x4cc5d4becb3e42b6",
      "0x597f299cfc657e2a",
      "0x5fcb6fab3ad6faec",
      "0x6c44198c4a475817",
    ].map((t) => BigInt(t))
  ),
  rc = new Uint32Array(80),
  ic = new Uint32Array(80);
let QK = class extends IK {
  constructor() {
    super(128, 64, 16, !1),
      (this.Ah = 1779033703),
      (this.Al = -205731576),
      (this.Bh = -1150833019),
      (this.Bl = -2067093701),
      (this.Ch = 1013904242),
      (this.Cl = -23791573),
      (this.Dh = -1521486534),
      (this.Dl = 1595750129),
      (this.Eh = 1359893119),
      (this.El = -1377402159),
      (this.Fh = -1694144372),
      (this.Fl = 725511199),
      (this.Gh = 528734635),
      (this.Gl = -79577749),
      (this.Hh = 1541459225),
      (this.Hl = 327033209);
  }
  get() {
    const {
      Ah: e,
      Al: n,
      Bh: r,
      Bl: i,
      Ch: s,
      Cl: o,
      Dh: a,
      Dl: l,
      Eh: d,
      El: p,
      Fh: f,
      Fl: m,
      Gh: y,
      Gl: g,
      Hh: v,
      Hl: b,
    } = this;
    return [e, n, r, i, s, o, a, l, d, p, f, m, y, g, v, b];
  }
  set(e, n, r, i, s, o, a, l, d, p, f, m, y, g, v, b) {
    (this.Ah = e | 0),
      (this.Al = n | 0),
      (this.Bh = r | 0),
      (this.Bl = i | 0),
      (this.Ch = s | 0),
      (this.Cl = o | 0),
      (this.Dh = a | 0),
      (this.Dl = l | 0),
      (this.Eh = d | 0),
      (this.El = p | 0),
      (this.Fh = f | 0),
      (this.Fl = m | 0),
      (this.Gh = y | 0),
      (this.Gl = g | 0),
      (this.Hh = v | 0),
      (this.Hl = b | 0);
  }
  process(e, n) {
    for (let C = 0; C < 16; C++, n += 4)
      (rc[C] = e.getUint32(n)), (ic[C] = e.getUint32((n += 4)));
    for (let C = 16; C < 80; C++) {
      const _ = rc[C - 15] | 0,
        A = ic[C - 15] | 0,
        I = mt.rotrSH(_, A, 1) ^ mt.rotrSH(_, A, 8) ^ mt.shrSH(_, A, 7),
        R = mt.rotrSL(_, A, 1) ^ mt.rotrSL(_, A, 8) ^ mt.shrSL(_, A, 7),
        D = rc[C - 2] | 0,
        k = ic[C - 2] | 0,
        T = mt.rotrSH(D, k, 19) ^ mt.rotrBH(D, k, 61) ^ mt.shrSH(D, k, 6),
        U = mt.rotrSL(D, k, 19) ^ mt.rotrBL(D, k, 61) ^ mt.shrSL(D, k, 6),
        q = mt.add4L(R, U, ic[C - 7], ic[C - 16]),
        K = mt.add4H(q, I, T, rc[C - 7], rc[C - 16]);
      (rc[C] = K | 0), (ic[C] = q | 0);
    }
    let {
      Ah: r,
      Al: i,
      Bh: s,
      Bl: o,
      Ch: a,
      Cl: l,
      Dh: d,
      Dl: p,
      Eh: f,
      El: m,
      Fh: y,
      Fl: g,
      Gh: v,
      Gl: b,
      Hh: E,
      Hl: S,
    } = this;
    for (let C = 0; C < 80; C++) {
      const _ = mt.rotrSH(f, m, 14) ^ mt.rotrSH(f, m, 18) ^ mt.rotrBH(f, m, 41),
        A = mt.rotrSL(f, m, 14) ^ mt.rotrSL(f, m, 18) ^ mt.rotrBL(f, m, 41),
        I = (f & y) ^ (~f & v),
        R = (m & g) ^ (~m & b),
        D = mt.add5L(S, A, R, ZK[C], ic[C]),
        k = mt.add5H(D, E, _, I, YK[C], rc[C]),
        T = D | 0,
        U = mt.rotrSH(r, i, 28) ^ mt.rotrBH(r, i, 34) ^ mt.rotrBH(r, i, 39),
        q = mt.rotrSL(r, i, 28) ^ mt.rotrBL(r, i, 34) ^ mt.rotrBL(r, i, 39),
        K = (r & s) ^ (r & a) ^ (s & a),
        H = (i & o) ^ (i & l) ^ (o & l);
      (E = v | 0),
        (S = b | 0),
        (v = y | 0),
        (b = g | 0),
        (y = f | 0),
        (g = m | 0),
        ({ h: f, l: m } = mt.add(d | 0, p | 0, k | 0, T | 0)),
        (d = a | 0),
        (p = l | 0),
        (a = s | 0),
        (l = o | 0),
        (s = r | 0),
        (o = i | 0);
      const $ = mt.add3L(T, q, H);
      (r = mt.add3H($, k, U, K)), (i = $ | 0);
    }
    ({ h: r, l: i } = mt.add(this.Ah | 0, this.Al | 0, r | 0, i | 0)),
      ({ h: s, l: o } = mt.add(this.Bh | 0, this.Bl | 0, s | 0, o | 0)),
      ({ h: a, l } = mt.add(this.Ch | 0, this.Cl | 0, a | 0, l | 0)),
      ({ h: d, l: p } = mt.add(this.Dh | 0, this.Dl | 0, d | 0, p | 0)),
      ({ h: f, l: m } = mt.add(this.Eh | 0, this.El | 0, f | 0, m | 0)),
      ({ h: y, l: g } = mt.add(this.Fh | 0, this.Fl | 0, y | 0, g | 0)),
      ({ h: v, l: b } = mt.add(this.Gh | 0, this.Gl | 0, v | 0, b | 0)),
      ({ h: E, l: S } = mt.add(this.Hh | 0, this.Hl | 0, E | 0, S | 0)),
      this.set(r, i, s, o, a, l, d, p, f, m, y, g, v, b, E, S);
  }
  roundClean() {
    rc.fill(0), ic.fill(0);
  }
  destroy() {
    this.buffer.fill(0),
      this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
};
const XK = AK(() => new QK());
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const wA =
    BigInt(0),
  sD = BigInt(1),
  JK = BigInt(2);
function vA(t) {
  return (
    t instanceof Uint8Array ||
    (ArrayBuffer.isView(t) && t.constructor.name === "Uint8Array")
  );
}
function bA(t) {
  if (!vA(t)) throw new Error("Uint8Array expected");
}
function xE(t, e) {
  if (typeof e != "boolean") throw new Error(t + " boolean expected, got " + e);
}
const eY = Array.from({ length: 256 }, (t, e) =>
  e.toString(16).padStart(2, "0")
);
function EA(t) {
  bA(t);
  let e = "";
  for (let n = 0; n < t.length; n++) e += eY[t[n]];
  return e;
}
function oD(t) {
  if (typeof t != "string")
    throw new Error("hex string expected, got " + typeof t);
  return t === "" ? wA : BigInt("0x" + t);
}
const Jo = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
function iR(t) {
  if (t >= Jo._0 && t <= Jo._9) return t - Jo._0;
  if (t >= Jo.A && t <= Jo.F) return t - (Jo.A - 10);
  if (t >= Jo.a && t <= Jo.f) return t - (Jo.a - 10);
}
function aD(t) {
  if (typeof t != "string")
    throw new Error("hex string expected, got " + typeof t);
  const e = t.length,
    n = e / 2;
  if (e % 2)
    throw new Error("hex string expected, got unpadded hex of length " + e);
  const r = new Uint8Array(n);
  for (let i = 0, s = 0; i < n; i++, s += 2) {
    const o = iR(t.charCodeAt(s)),
      a = iR(t.charCodeAt(s + 1));
    if (o === void 0 || a === void 0) {
      const l = t[s] + t[s + 1];
      throw new Error(
        'hex string expected, got non-hex character "' + l + '" at index ' + s
      );
    }
    r[i] = o * 16 + a;
  }
  return r;
}
function tY(t) {
  return oD(EA(t));
}
function D0(t) {
  return bA(t), oD(EA(Uint8Array.from(t).reverse()));
}
function cD(t, e) {
  return aD(t.toString(16).padStart(e * 2, "0"));
}
function mx(t, e) {
  return cD(t, e).reverse();
}
function ea(t, e, n) {
  let r;
  if (typeof e == "string")
    try {
      r = aD(e);
    } catch (s) {
      throw new Error(t + " must be hex string or Uint8Array, cause: " + s);
    }
  else if (vA(e)) r = Uint8Array.from(e);
  else throw new Error(t + " must be hex string or Uint8Array");
  const i = r.length;
  if (typeof n == "number" && i !== n)
    throw new Error(t + " of length " + n + " expected, got " + i);
  return r;
}
function sR(...t) {
  let e = 0;
  for (let r = 0; r < t.length; r++) {
    const i = t[r];
    bA(i), (e += i.length);
  }
  const n = new Uint8Array(e);
  for (let r = 0, i = 0; r < t.length; r++) {
    const s = t[r];
    n.set(s, i), (i += s.length);
  }
  return n;
}
const SE = (t) => typeof t == "bigint" && wA <= t;
function nY(t, e, n) {
  return SE(t) && SE(e) && SE(n) && e <= t && t < n;
}
function Mf(t, e, n, r) {
  if (!nY(e, n, r))
    throw new Error(
      "expected valid " + t + ": " + n + " <= n < " + r + ", got " + e
    );
}
function rY(t) {
  let e;
  for (e = 0; t > wA; t >>= sD, e += 1);
  return e;
}
const iY = (t) => (JK << BigInt(t - 1)) - sD,
  sY = {
    bigint: (t) => typeof t == "bigint",
    function: (t) => typeof t == "function",
    boolean: (t) => typeof t == "boolean",
    string: (t) => typeof t == "string",
    stringOrUint8Array: (t) => typeof t == "string" || vA(t),
    isSafeInteger: (t) => Number.isSafeInteger(t),
    array: (t) => Array.isArray(t),
    field: (t, e) => e.Fp.isValid(t),
    hash: (t) => typeof t == "function" && Number.isSafeInteger(t.outputLen),
  };
function CA(t, e, n = {}) {
  const r = (i, s, o) => {
    const a = sY[s];
    if (typeof a != "function") throw new Error("invalid validator function");
    const l = t[i];
    if (!(o && l === void 0) && !a(l, t))
      throw new Error(
        "param " + String(i) + " is invalid. Expected " + s + ", got " + l
      );
  };
  for (const [i, s] of Object.entries(e)) r(i, s, !1);
  for (const [i, s] of Object.entries(n)) r(i, s, !0);
  return t;
}
function oR(t) {
  const e = new WeakMap();
  return (n, ...r) => {
    const i = e.get(n);
    if (i !== void 0) return i;
    const s = t(n, ...r);
    return e.set(n, s), s;
  };
}
const mr = BigInt(0),
  Un = BigInt(1),
  Cl = BigInt(2),
  oY = BigInt(3),
  gx = BigInt(4),
  aR = BigInt(5),
  cR = BigInt(8);
function Xn(t, e) {
  const n = t % e;
  return n >= mr ? n : e + n;
}
function aY(t, e, n) {
  if (e < mr) throw new Error("invalid exponent, negatives unsupported");
  if (n <= mr) throw new Error("invalid modulus");
  if (n === Un) return mr;
  let r = Un;
  for (; e > mr; ) e & Un && (r = (r * t) % n), (t = (t * t) % n), (e >>= Un);
  return r;
}
function lo(t, e, n) {
  let r = t;
  for (; e-- > mr; ) (r *= r), (r %= n);
  return r;
}
function lR(t, e) {
  if (t === mr) throw new Error("invert: expected non-zero number");
  if (e <= mr) throw new Error("invert: expected positive modulus, got " + e);
  let n = Xn(t, e),
    r = e,
    i = mr,
    s = Un;
  for (; n !== mr; ) {
    const o = r / n,
      a = r % n,
      l = i - s * o;
    (r = n), (n = a), (i = s), (s = l);
  }
  if (r !== Un) throw new Error("invert: does not exist");
  return Xn(i, e);
}
function cY(t) {
  const e = (t - Un) / Cl;
  let n, r, i;
  for (n = t - Un, r = 0; n % Cl === mr; n /= Cl, r++);
  for (i = Cl; i < t && aY(i, e, t) !== t - Un; i++)
    if (i > 1e3) throw new Error("Cannot find square root: likely non-prime P");
  if (r === 1) {
    const o = (t + Un) / gx;
    return function (a, l) {
      const d = a.pow(l, o);
      if (!a.eql(a.sqr(d), l)) throw new Error("Cannot find square root");
      return d;
    };
  }
  const s = (n + Un) / Cl;
  return function (o, a) {
    if (o.pow(a, e) === o.neg(o.ONE))
      throw new Error("Cannot find square root");
    let l = r,
      d = o.pow(o.mul(o.ONE, i), n),
      p = o.pow(a, s),
      f = o.pow(a, n);
    for (; !o.eql(f, o.ONE); ) {
      if (o.eql(f, o.ZERO)) return o.ZERO;
      let m = 1;
      for (let g = o.sqr(f); m < l && !o.eql(g, o.ONE); m++) g = o.sqr(g);
      const y = o.pow(d, Un << BigInt(l - m - 1));
      (d = o.sqr(y)), (p = o.mul(p, y)), (f = o.mul(f, d)), (l = m);
    }
    return p;
  };
}
function lY(t) {
  if (t % gx === oY) {
    const e = (t + Un) / gx;
    return function (n, r) {
      const i = n.pow(r, e);
      if (!n.eql(n.sqr(i), r)) throw new Error("Cannot find square root");
      return i;
    };
  }
  if (t % cR === aR) {
    const e = (t - aR) / cR;
    return function (n, r) {
      const i = n.mul(r, Cl),
        s = n.pow(i, e),
        o = n.mul(r, s),
        a = n.mul(n.mul(o, Cl), s),
        l = n.mul(o, n.sub(a, n.ONE));
      if (!n.eql(n.sqr(l), r)) throw new Error("Cannot find square root");
      return l;
    };
  }
  return cY(t);
}
const uY = (t, e) => (Xn(t, e) & Un) === Un,
  dY = [
    "create",
    "isValid",
    "is0",
    "neg",
    "inv",
    "sqrt",
    "sqr",
    "eql",
    "add",
    "sub",
    "mul",
    "pow",
    "div",
    "addN",
    "subN",
    "mulN",
    "sqrN",
  ];
function pY(t) {
  const e = {
      ORDER: "bigint",
      MASK: "bigint",
      BYTES: "isSafeInteger",
      BITS: "isSafeInteger",
    },
    n = dY.reduce((r, i) => ((r[i] = "function"), r), e);
  return CA(t, n);
}
function fY(t, e, n) {
  if (n < mr) throw new Error("invalid exponent, negatives unsupported");
  if (n === mr) return t.ONE;
  if (n === Un) return e;
  let r = t.ONE,
    i = e;
  for (; n > mr; ) n & Un && (r = t.mul(r, i)), (i = t.sqr(i)), (n >>= Un);
  return r;
}
function hY(t, e) {
  const n = new Array(e.length),
    r = e.reduce(
      (s, o, a) => (t.is0(o) ? s : ((n[a] = s), t.mul(s, o))),
      t.ONE
    ),
    i = t.inv(r);
  return (
    e.reduceRight(
      (s, o, a) => (t.is0(o) ? s : ((n[a] = t.mul(s, n[a])), t.mul(s, o))),
      i
    ),
    n
  );
}
function lD(t, e) {
  const n = e !== void 0 ? e : t.toString(2).length,
    r = Math.ceil(n / 8);
  return { nBitLength: n, nByteLength: r };
}
function uD(t, e, n = !1, r = {}) {
  if (t <= mr) throw new Error("invalid field: expected ORDER > 0, got " + t);
  const { nBitLength: i, nByteLength: s } = lD(t, e);
  if (s > 2048)
    throw new Error("invalid field: expected ORDER of <= 2048 bytes");
  let o;
  const a = Object.freeze({
    ORDER: t,
    isLE: n,
    BITS: i,
    BYTES: s,
    MASK: iY(i),
    ZERO: mr,
    ONE: Un,
    create: (l) => Xn(l, t),
    isValid: (l) => {
      if (typeof l != "bigint")
        throw new Error(
          "invalid field element: expected bigint, got " + typeof l
        );
      return mr <= l && l < t;
    },
    is0: (l) => l === mr,
    isOdd: (l) => (l & Un) === Un,
    neg: (l) => Xn(-l, t),
    eql: (l, d) => l === d,
    sqr: (l) => Xn(l * l, t),
    add: (l, d) => Xn(l + d, t),
    sub: (l, d) => Xn(l - d, t),
    mul: (l, d) => Xn(l * d, t),
    pow: (l, d) => fY(a, l, d),
    div: (l, d) => Xn(l * lR(d, t), t),
    sqrN: (l) => l * l,
    addN: (l, d) => l + d,
    subN: (l, d) => l - d,
    mulN: (l, d) => l * d,
    inv: (l) => lR(l, t),
    sqrt: r.sqrt || ((l) => (o || (o = lY(t)), o(a, l))),
    invertBatch: (l) => hY(a, l),
    cmov: (l, d, p) => (p ? d : l),
    toBytes: (l) => (n ? mx(l, s) : cD(l, s)),
    fromBytes: (l) => {
      if (l.length !== s)
        throw new Error(
          "Field.fromBytes: expected " + s + " bytes, got " + l.length
        );
      return n ? D0(l) : tY(l);
    },
  });
  return Object.freeze(a);
}
const uR = BigInt(0),
  Ky = BigInt(1);
function AE(t, e) {
  const n = e.negate();
  return t ? n : e;
}
function dD(t, e) {
  if (!Number.isSafeInteger(t) || t <= 0 || t > e)
    throw new Error("invalid window size, expected [1.." + e + "], got W=" + t);
}
function _E(t, e) {
  dD(t, e);
  const n = Math.ceil(e / t) + 1,
    r = 2 ** (t - 1);
  return { windows: n, windowSize: r };
}
function mY(t, e) {
  if (!Array.isArray(t)) throw new Error("array expected");
  t.forEach((n, r) => {
    if (!(n instanceof e)) throw new Error("invalid point at index " + r);
  });
}
function gY(t, e) {
  if (!Array.isArray(t)) throw new Error("array of scalars expected");
  t.forEach((n, r) => {
    if (!e.isValid(n)) throw new Error("invalid scalar at index " + r);
  });
}
const IE = new WeakMap(),
  pD = new WeakMap();
function TE(t) {
  return pD.get(t) || 1;
}
function yY(t, e) {
  return {
    constTimeNegate: AE,
    hasPrecomputes(n) {
      return TE(n) !== 1;
    },
    unsafeLadder(n, r, i = t.ZERO) {
      let s = n;
      for (; r > uR; ) r & Ky && (i = i.add(s)), (s = s.double()), (r >>= Ky);
      return i;
    },
    precomputeWindow(n, r) {
      const { windows: i, windowSize: s } = _E(r, e),
        o = [];
      let a = n,
        l = a;
      for (let d = 0; d < i; d++) {
        (l = a), o.push(l);
        for (let p = 1; p < s; p++) (l = l.add(a)), o.push(l);
        a = l.double();
      }
      return o;
    },
    wNAF(n, r, i) {
      const { windows: s, windowSize: o } = _E(n, e);
      let a = t.ZERO,
        l = t.BASE;
      const d = BigInt(2 ** n - 1),
        p = 2 ** n,
        f = BigInt(n);
      for (let m = 0; m < s; m++) {
        const y = m * o;
        let g = Number(i & d);
        (i >>= f), g > o && ((g -= p), (i += Ky));
        const v = y,
          b = y + Math.abs(g) - 1,
          E = m % 2 !== 0,
          S = g < 0;
        g === 0 ? (l = l.add(AE(E, r[v]))) : (a = a.add(AE(S, r[b])));
      }
      return { p: a, f: l };
    },
    wNAFUnsafe(n, r, i, s = t.ZERO) {
      const { windows: o, windowSize: a } = _E(n, e),
        l = BigInt(2 ** n - 1),
        d = 2 ** n,
        p = BigInt(n);
      for (let f = 0; f < o; f++) {
        const m = f * a;
        if (i === uR) break;
        let y = Number(i & l);
        if (((i >>= p), y > a && ((y -= d), (i += Ky)), y === 0)) continue;
        let g = r[m + Math.abs(y) - 1];
        y < 0 && (g = g.negate()), (s = s.add(g));
      }
      return s;
    },
    getPrecomputes(n, r, i) {
      let s = IE.get(r);
      return (
        s || ((s = this.precomputeWindow(r, n)), n !== 1 && IE.set(r, i(s))), s
      );
    },
    wNAFCached(n, r, i) {
      const s = TE(n);
      return this.wNAF(s, this.getPrecomputes(s, n, i), r);
    },
    wNAFCachedUnsafe(n, r, i, s) {
      const o = TE(n);
      return o === 1
        ? this.unsafeLadder(n, r, s)
        : this.wNAFUnsafe(o, this.getPrecomputes(o, n, i), r, s);
    },
    setWindowSize(n, r) {
      dD(r, e), pD.set(n, r), IE.delete(n);
    },
  };
}
function wY(t, e, n, r) {
  if ((mY(n, t), gY(r, e), n.length !== r.length))
    throw new Error("arrays of points and scalars must have equal length");
  const i = t.ZERO,
    s = rY(BigInt(n.length)),
    o = s > 12 ? s - 3 : s > 4 ? s - 2 : s ? 2 : 1,
    a = (1 << o) - 1,
    l = new Array(a + 1).fill(i),
    d = Math.floor((e.BITS - 1) / o) * o;
  let p = i;
  for (let f = d; f >= 0; f -= o) {
    l.fill(i);
    for (let y = 0; y < r.length; y++) {
      const g = r[y],
        v = Number((g >> BigInt(f)) & BigInt(a));
      l[v] = l[v].add(n[y]);
    }
    let m = i;
    for (let y = l.length - 1, g = i; y > 0; y--)
      (g = g.add(l[y])), (m = m.add(g));
    if (((p = p.add(m)), f !== 0)) for (let y = 0; y < o; y++) p = p.double();
  }
  return p;
}
function vY(t) {
  return (
    pY(t.Fp),
    CA(
      t,
      { n: "bigint", h: "bigint", Gx: "field", Gy: "field" },
      { nBitLength: "isSafeInteger", nByteLength: "isSafeInteger" }
    ),
    Object.freeze({ ...lD(t.n, t.nBitLength), ...t, p: t.Fp.ORDER })
  );
}
const $s = BigInt(0),
  fi = BigInt(1),
  Yy = BigInt(2),
  bY = BigInt(8),
  EY = { zip215: !0 };
function CY(t) {
  const e = vY(t);
  return (
    CA(
      t,
      { hash: "function", a: "bigint", d: "bigint", randomBytes: "function" },
      {
        adjustScalarBytes: "function",
        domain: "function",
        uvRatio: "function",
        mapToCurve: "function",
      }
    ),
    Object.freeze({ ...e })
  );
}
function xY(t) {
  const e = CY(t),
    {
      Fp: n,
      n: r,
      prehash: i,
      hash: s,
      randomBytes: o,
      nByteLength: a,
      h: l,
    } = e,
    d = Yy << (BigInt(a * 8) - fi),
    p = n.create,
    f = uD(e.n, e.nBitLength),
    m =
      e.uvRatio ||
      (($, M) => {
        try {
          return { isValid: !0, value: n.sqrt($ * n.inv(M)) };
        } catch {
          return { isValid: !1, value: $s };
        }
      }),
    y = e.adjustScalarBytes || (($) => $),
    g =
      e.domain ||
      (($, M, z) => {
        if ((xE("phflag", z), M.length || z))
          throw new Error("Contexts/pre-hash are not supported");
        return $;
      });
  function v($, M) {
    Mf("coordinate " + $, M, $s, d);
  }
  function b($) {
    if (!($ instanceof C)) throw new Error("ExtendedPoint expected");
  }
  const E = oR(($, M) => {
      const { ex: z, ey: B, ez: j } = $,
        V = $.is0();
      M == null && (M = V ? bY : n.inv(j));
      const W = p(z * M),
        Z = p(B * M),
        ee = p(j * M);
      if (V) return { x: $s, y: fi };
      if (ee !== fi) throw new Error("invZ was invalid");
      return { x: W, y: Z };
    }),
    S = oR(($) => {
      const { a: M, d: z } = e;
      if ($.is0()) throw new Error("bad point: ZERO");
      const { ex: B, ey: j, ez: V, et: W } = $,
        Z = p(B * B),
        ee = p(j * j),
        J = p(V * V),
        se = p(J * J),
        re = p(Z * M),
        fe = p(J * p(re + ee)),
        ce = p(se + p(z * p(Z * ee)));
      if (fe !== ce) throw new Error("bad point: equation left != right (1)");
      const le = p(B * j),
        Se = p(V * W);
      if (le !== Se) throw new Error("bad point: equation left != right (2)");
      return !0;
    });
  class C {
    constructor(M, z, B, j) {
      (this.ex = M),
        (this.ey = z),
        (this.ez = B),
        (this.et = j),
        v("x", M),
        v("y", z),
        v("z", B),
        v("t", j),
        Object.freeze(this);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    static fromAffine(M) {
      if (M instanceof C) throw new Error("extended point not allowed");
      const { x: z, y: B } = M || {};
      return v("x", z), v("y", B), new C(z, B, fi, p(z * B));
    }
    static normalizeZ(M) {
      const z = n.invertBatch(M.map((B) => B.ez));
      return M.map((B, j) => B.toAffine(z[j])).map(C.fromAffine);
    }
    static msm(M, z) {
      return wY(C, f, M, z);
    }
    _setWindowSize(M) {
      I.setWindowSize(this, M);
    }
    assertValidity() {
      S(this);
    }
    equals(M) {
      b(M);
      const { ex: z, ey: B, ez: j } = this,
        { ex: V, ey: W, ez: Z } = M,
        ee = p(z * Z),
        J = p(V * j),
        se = p(B * Z),
        re = p(W * j);
      return ee === J && se === re;
    }
    is0() {
      return this.equals(C.ZERO);
    }
    negate() {
      return new C(p(-this.ex), this.ey, this.ez, p(-this.et));
    }
    double() {
      const { a: M } = e,
        { ex: z, ey: B, ez: j } = this,
        V = p(z * z),
        W = p(B * B),
        Z = p(Yy * p(j * j)),
        ee = p(M * V),
        J = z + B,
        se = p(p(J * J) - V - W),
        re = ee + W,
        fe = re - Z,
        ce = ee - W,
        le = p(se * fe),
        Se = p(re * ce),
        je = p(se * ce),
        Pe = p(fe * re);
      return new C(le, Se, Pe, je);
    }
    add(M) {
      b(M);
      const { a: z, d: B } = e,
        { ex: j, ey: V, ez: W, et: Z } = this,
        { ex: ee, ey: J, ez: se, et: re } = M;
      if (z === BigInt(-1)) {
        const vn = p((V - j) * (J + ee)),
          At = p((V + j) * (J - ee)),
          vt = p(At - vn);
        if (vt === $s) return this.double();
        const Le = p(W * Yy * re),
          nr = p(Z * Yy * se),
          tn = nr + Le,
          wr = At + vn,
          Dr = nr - Le,
          rr = p(tn * vt),
          ir = p(wr * Dr),
          vr = p(tn * Dr),
          Vn = p(vt * wr);
        return new C(rr, ir, Vn, vr);
      }
      const fe = p(j * ee),
        ce = p(V * J),
        le = p(Z * B * re),
        Se = p(W * se),
        je = p((j + V) * (ee + J) - fe - ce),
        Pe = Se - le,
        We = Se + le,
        Ne = p(ce - z * fe),
        pt = p(je * Pe),
        hn = p(We * Ne),
        Wt = p(je * Ne),
        Lt = p(Pe * We);
      return new C(pt, hn, Lt, Wt);
    }
    subtract(M) {
      return this.add(M.negate());
    }
    wNAF(M) {
      return I.wNAFCached(this, M, C.normalizeZ);
    }
    multiply(M) {
      const z = M;
      Mf("scalar", z, fi, r);
      const { p: B, f: j } = this.wNAF(z);
      return C.normalizeZ([B, j])[0];
    }
    multiplyUnsafe(M, z = C.ZERO) {
      const B = M;
      return (
        Mf("scalar", B, $s, r),
        B === $s
          ? A
          : this.is0() || B === fi
          ? this
          : I.wNAFCachedUnsafe(this, B, C.normalizeZ, z)
      );
    }
    isSmallOrder() {
      return this.multiplyUnsafe(l).is0();
    }
    isTorsionFree() {
      return I.unsafeLadder(this, r).is0();
    }
    toAffine(M) {
      return E(this, M);
    }
    clearCofactor() {
      const { h: M } = e;
      return M === fi ? this : this.multiplyUnsafe(M);
    }
    static fromHex(M, z = !1) {
      const { d: B, a: j } = e,
        V = n.BYTES;
      (M = ea("pointHex", M, V)), xE("zip215", z);
      const W = M.slice(),
        Z = M[V - 1];
      W[V - 1] = Z & -129;
      const ee = D0(W),
        J = z ? d : n.ORDER;
      Mf("pointHex.y", ee, $s, J);
      const se = p(ee * ee),
        re = p(se - fi),
        fe = p(B * se - j);
      let { isValid: ce, value: le } = m(re, fe);
      if (!ce) throw new Error("Point.fromHex: invalid y coordinate");
      const Se = (le & fi) === fi,
        je = (Z & 128) !== 0;
      if (!z && le === $s && je)
        throw new Error("Point.fromHex: x=0 and x_0=1");
      return je !== Se && (le = p(-le)), C.fromAffine({ x: le, y: ee });
    }
    static fromPrivateKey(M) {
      return k(M).point;
    }
    toRawBytes() {
      const { x: M, y: z } = this.toAffine(),
        B = mx(z, n.BYTES);
      return (B[B.length - 1] |= M & fi ? 128 : 0), B;
    }
    toHex() {
      return EA(this.toRawBytes());
    }
  }
  (C.BASE = new C(e.Gx, e.Gy, fi, p(e.Gx * e.Gy))),
    (C.ZERO = new C($s, fi, fi, $s));
  const { BASE: _, ZERO: A } = C,
    I = yY(C, a * 8);
  function R($) {
    return Xn($, r);
  }
  function D($) {
    return R(D0($));
  }
  function k($) {
    const M = n.BYTES;
    $ = ea("private key", $, M);
    const z = ea("hashed private key", s($), 2 * M),
      B = y(z.slice(0, M)),
      j = z.slice(M, 2 * M),
      V = D(B),
      W = _.multiply(V),
      Z = W.toRawBytes();
    return { head: B, prefix: j, scalar: V, point: W, pointBytes: Z };
  }
  function T($) {
    return k($).pointBytes;
  }
  function U($ = new Uint8Array(), ...M) {
    const z = sR(...M);
    return D(s(g(z, ea("context", $), !!i)));
  }
  function q($, M, z = {}) {
    ($ = ea("message", $)), i && ($ = i($));
    const { prefix: B, scalar: j, pointBytes: V } = k(M),
      W = U(z.context, B, $),
      Z = _.multiply(W).toRawBytes(),
      ee = U(z.context, Z, V, $),
      J = R(W + ee * j);
    Mf("signature.s", J, $s, r);
    const se = sR(Z, mx(J, n.BYTES));
    return ea("result", se, n.BYTES * 2);
  }
  const K = EY;
  function H($, M, z, B = K) {
    const { context: j, zip215: V } = B,
      W = n.BYTES;
    ($ = ea("signature", $, 2 * W)),
      (M = ea("message", M)),
      (z = ea("publicKey", z, W)),
      V !== void 0 && xE("zip215", V),
      i && (M = i(M));
    const Z = D0($.slice(W, 2 * W));
    let ee, J, se;
    try {
      (ee = C.fromHex(z, V)),
        (J = C.fromHex($.slice(0, W), V)),
        (se = _.multiplyUnsafe(Z));
    } catch {
      return !1;
    }
    if (!V && ee.isSmallOrder()) return !1;
    const re = U(j, J.toRawBytes(), ee.toRawBytes(), M);
    return J.add(ee.multiplyUnsafe(re))
      .subtract(se)
      .clearCofactor()
      .equals(C.ZERO);
  }
  return (
    _._setWindowSize(8),
    {
      CURVE: e,
      getPublicKey: T,
      sign: q,
      verify: H,
      ExtendedPoint: C,
      utils: {
        getExtendedPublicKey: k,
        randomPrivateKey: () => o(n.BYTES),
        precompute($ = 8, M = C.BASE) {
          return M._setWindowSize($), M.multiply(BigInt(3)), M;
        },
      },
    }
  );
}
BigInt(0), BigInt(1);
const xA = BigInt(
    "57896044618658097711785492504343953926634992332820282019728792003956564819949"
  ),
  dR = BigInt(
    "19681161376707505956807079304988542015446066515923890162744021073123829784752"
  );
BigInt(0);
const SY = BigInt(1),
  pR = BigInt(2);
BigInt(3);
const AY = BigInt(5),
  _Y = BigInt(8);
function IY(t) {
  const e = BigInt(10),
    n = BigInt(20),
    r = BigInt(40),
    i = BigInt(80),
    s = xA,
    o = (((t * t) % s) * t) % s,
    a = (lo(o, pR, s) * o) % s,
    l = (lo(a, SY, s) * t) % s,
    d = (lo(l, AY, s) * l) % s,
    p = (lo(d, e, s) * d) % s,
    f = (lo(p, n, s) * p) % s,
    m = (lo(f, r, s) * f) % s,
    y = (lo(m, i, s) * m) % s,
    g = (lo(y, i, s) * m) % s,
    v = (lo(g, e, s) * d) % s;
  return { pow_p_5_8: (lo(v, pR, s) * t) % s, b2: o };
}
function TY(t) {
  return (t[0] &= 248), (t[31] &= 127), (t[31] |= 64), t;
}
function PY(t, e) {
  const n = xA,
    r = Xn(e * e * e, n),
    i = Xn(r * r * e, n),
    s = IY(t * i).pow_p_5_8;
  let o = Xn(t * r * s, n);
  const a = Xn(e * o * o, n),
    l = o,
    d = Xn(o * dR, n),
    p = a === t,
    f = a === Xn(-t, n),
    m = a === Xn(-t * dR, n);
  return (
    p && (o = l),
    (f || m) && (o = d),
    uY(o, n) && (o = Xn(-o, n)),
    { isValid: p || f, value: o }
  );
}
const RY = uD(xA, void 0, !0),
  NY = {
    a: BigInt(-1),
    d: BigInt(
      "37095705934669439343138083508754565189542113879843219016388785533085940283555"
    ),
    Fp: RY,
    n: BigInt(
      "7237005577332262213973186563042994240857116359379907606001950938285454250989"
    ),
    h: _Y,
    Gx: BigInt(
      "15112221349535400772501151409588531511454012693041857206046113283949847762202"
    ),
    Gy: BigInt(
      "46316835694926478169428394003475163141307993866256225615783033603165251855960"
    ),
    hash: XK,
    randomBytes: rD,
    adjustScalarBytes: TY,
    uvRatio: PY,
  },
  fD = xY(NY),
  OY = "EdDSA",
  kY = "JWT",
  dw = ".",
  yv = "base64url",
  hD = "utf8",
  mD = "utf8",
  DY = ":",
  $Y = "did",
  MY = "key",
  fR = "base58btc",
  LY = "z",
  UY = "K36",
  BY = 32;
function SA(t) {
  return globalThis.Buffer != null
    ? new Uint8Array(t.buffer, t.byteOffset, t.byteLength)
    : t;
}
function gD(t = 0) {
  return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null
    ? SA(globalThis.Buffer.allocUnsafe(t))
    : new Uint8Array(t);
}
function yD(t, e) {
  e || (e = t.reduce((i, s) => i + s.length, 0));
  const n = gD(e);
  let r = 0;
  for (const i of t) n.set(i, r), (r += i.length);
  return SA(n);
}
function jY(t, e) {
  if (t.length >= 255) throw new TypeError("Alphabet too long");
  for (var n = new Uint8Array(256), r = 0; r < n.length; r++) n[r] = 255;
  for (var i = 0; i < t.length; i++) {
    var s = t.charAt(i),
      o = s.charCodeAt(0);
    if (n[o] !== 255) throw new TypeError(s + " is ambiguous");
    n[o] = i;
  }
  var a = t.length,
    l = t.charAt(0),
    d = Math.log(a) / Math.log(256),
    p = Math.log(256) / Math.log(a);
  function f(g) {
    if (
      (g instanceof Uint8Array ||
        (ArrayBuffer.isView(g)
          ? (g = new Uint8Array(g.buffer, g.byteOffset, g.byteLength))
          : Array.isArray(g) && (g = Uint8Array.from(g))),
      !(g instanceof Uint8Array))
    )
      throw new TypeError("Expected Uint8Array");
    if (g.length === 0) return "";
    for (var v = 0, b = 0, E = 0, S = g.length; E !== S && g[E] === 0; )
      E++, v++;
    for (var C = ((S - E) * p + 1) >>> 0, _ = new Uint8Array(C); E !== S; ) {
      for (
        var A = g[E], I = 0, R = C - 1;
        (A !== 0 || I < b) && R !== -1;
        R--, I++
      )
        (A += (256 * _[R]) >>> 0), (_[R] = A % a >>> 0), (A = (A / a) >>> 0);
      if (A !== 0) throw new Error("Non-zero carry");
      (b = I), E++;
    }
    for (var D = C - b; D !== C && _[D] === 0; ) D++;
    for (var k = l.repeat(v); D < C; ++D) k += t.charAt(_[D]);
    return k;
  }
  function m(g) {
    if (typeof g != "string") throw new TypeError("Expected String");
    if (g.length === 0) return new Uint8Array();
    var v = 0;
    if (g[v] !== " ") {
      for (var b = 0, E = 0; g[v] === l; ) b++, v++;
      for (
        var S = ((g.length - v) * d + 1) >>> 0, C = new Uint8Array(S);
        g[v];

      ) {
        var _ = n[g.charCodeAt(v)];
        if (_ === 255) return;
        for (var A = 0, I = S - 1; (_ !== 0 || A < E) && I !== -1; I--, A++)
          (_ += (a * C[I]) >>> 0),
            (C[I] = _ % 256 >>> 0),
            (_ = (_ / 256) >>> 0);
        if (_ !== 0) throw new Error("Non-zero carry");
        (E = A), v++;
      }
      if (g[v] !== " ") {
        for (var R = S - E; R !== S && C[R] === 0; ) R++;
        for (var D = new Uint8Array(b + (S - R)), k = b; R !== S; )
          D[k++] = C[R++];
        return D;
      }
    }
  }
  function y(g) {
    var v = m(g);
    if (v) return v;
    throw new Error(`Non-${e} character`);
  }
  return { encode: f, decodeUnsafe: m, decode: y };
}
var FY = jY,
  zY = FY;
const wD = (t) => {
    if (t instanceof Uint8Array && t.constructor.name === "Uint8Array")
      return t;
    if (t instanceof ArrayBuffer) return new Uint8Array(t);
    if (ArrayBuffer.isView(t))
      return new Uint8Array(t.buffer, t.byteOffset, t.byteLength);
    throw new Error("Unknown type, must be binary type");
  },
  WY = (t) => new TextEncoder().encode(t),
  HY = (t) => new TextDecoder().decode(t);
let qY = class {
    constructor(e, n, r) {
      (this.name = e), (this.prefix = n), (this.baseEncode = r);
    }
    encode(e) {
      if (e instanceof Uint8Array) return `${this.prefix}${this.baseEncode(e)}`;
      throw Error("Unknown type, must be binary type");
    }
  },
  VY = class {
    constructor(e, n, r) {
      if (((this.name = e), (this.prefix = n), n.codePointAt(0) === void 0))
        throw new Error("Invalid prefix character");
      (this.prefixCodePoint = n.codePointAt(0)), (this.baseDecode = r);
    }
    decode(e) {
      if (typeof e == "string") {
        if (e.codePointAt(0) !== this.prefixCodePoint)
          throw Error(
            `Unable to decode multibase string ${JSON.stringify(e)}, ${
              this.name
            } decoder only supports inputs prefixed with ${this.prefix}`
          );
        return this.baseDecode(e.slice(this.prefix.length));
      } else throw Error("Can only multibase decode strings");
    }
    or(e) {
      return vD(this, e);
    }
  },
  GY = class {
    constructor(e) {
      this.decoders = e;
    }
    or(e) {
      return vD(this, e);
    }
    decode(e) {
      const n = e[0],
        r = this.decoders[n];
      if (r) return r.decode(e);
      throw RangeError(
        `Unable to decode multibase string ${JSON.stringify(
          e
        )}, only inputs prefixed with ${Object.keys(
          this.decoders
        )} are supported`
      );
    }
  };
const vD = (t, e) =>
  new GY({
    ...(t.decoders || { [t.prefix]: t }),
    ...(e.decoders || { [e.prefix]: e }),
  });
let KY = class {
  constructor(e, n, r, i) {
    (this.name = e),
      (this.prefix = n),
      (this.baseEncode = r),
      (this.baseDecode = i),
      (this.encoder = new qY(e, n, r)),
      (this.decoder = new VY(e, n, i));
  }
  encode(e) {
    return this.encoder.encode(e);
  }
  decode(e) {
    return this.decoder.decode(e);
  }
};
const wv = ({ name: t, prefix: e, encode: n, decode: r }) => new KY(t, e, n, r),
  Qm = ({ prefix: t, name: e, alphabet: n }) => {
    const { encode: r, decode: i } = zY(n, e);
    return wv({ prefix: t, name: e, encode: r, decode: (s) => wD(i(s)) });
  },
  YY = (t, e, n, r) => {
    const i = {};
    for (let p = 0; p < e.length; ++p) i[e[p]] = p;
    let s = t.length;
    for (; t[s - 1] === "="; ) --s;
    const o = new Uint8Array(((s * n) / 8) | 0);
    let a = 0,
      l = 0,
      d = 0;
    for (let p = 0; p < s; ++p) {
      const f = i[t[p]];
      if (f === void 0) throw new SyntaxError(`Non-${r} character`);
      (l = (l << n) | f),
        (a += n),
        a >= 8 && ((a -= 8), (o[d++] = 255 & (l >> a)));
    }
    if (a >= n || 255 & (l << (8 - a)))
      throw new SyntaxError("Unexpected end of data");
    return o;
  },
  ZY = (t, e, n) => {
    const r = e[e.length - 1] === "=",
      i = (1 << n) - 1;
    let s = "",
      o = 0,
      a = 0;
    for (let l = 0; l < t.length; ++l)
      for (a = (a << 8) | t[l], o += 8; o > n; )
        (o -= n), (s += e[i & (a >> o)]);
    if ((o && (s += e[i & (a << (n - o))]), r))
      for (; (s.length * n) & 7; ) s += "=";
    return s;
  },
  Nr = ({ name: t, prefix: e, bitsPerChar: n, alphabet: r }) =>
    wv({
      prefix: e,
      name: t,
      encode(i) {
        return ZY(i, r, n);
      },
      decode(i) {
        return YY(i, r, n, t);
      },
    }),
  QY = wv({
    prefix: "\0",
    name: "identity",
    encode: (t) => HY(t),
    decode: (t) => WY(t),
  });
var XY = Object.freeze({ __proto__: null, identity: QY });
const JY = Nr({ prefix: "0", name: "base2", alphabet: "01", bitsPerChar: 1 });
var eZ = Object.freeze({ __proto__: null, base2: JY });
const tZ = Nr({
  prefix: "7",
  name: "base8",
  alphabet: "01234567",
  bitsPerChar: 3,
});
var nZ = Object.freeze({ __proto__: null, base8: tZ });
const rZ = Qm({ prefix: "9", name: "base10", alphabet: "0123456789" });
var iZ = Object.freeze({ __proto__: null, base10: rZ });
const sZ = Nr({
    prefix: "f",
    name: "base16",
    alphabet: "0123456789abcdef",
    bitsPerChar: 4,
  }),
  oZ = Nr({
    prefix: "F",
    name: "base16upper",
    alphabet: "0123456789ABCDEF",
    bitsPerChar: 4,
  });
var aZ = Object.freeze({ __proto__: null, base16: sZ, base16upper: oZ });
const cZ = Nr({
    prefix: "b",
    name: "base32",
    alphabet: "abcdefghijklmnopqrstuvwxyz234567",
    bitsPerChar: 5,
  }),
  lZ = Nr({
    prefix: "B",
    name: "base32upper",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
    bitsPerChar: 5,
  }),
  uZ = Nr({
    prefix: "c",
    name: "base32pad",
    alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
    bitsPerChar: 5,
  }),
  dZ = Nr({
    prefix: "C",
    name: "base32padupper",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
    bitsPerChar: 5,
  }),
  pZ = Nr({
    prefix: "v",
    name: "base32hex",
    alphabet: "0123456789abcdefghijklmnopqrstuv",
    bitsPerChar: 5,
  }),
  fZ = Nr({
    prefix: "V",
    name: "base32hexupper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
    bitsPerChar: 5,
  }),
  hZ = Nr({
    prefix: "t",
    name: "base32hexpad",
    alphabet: "0123456789abcdefghijklmnopqrstuv=",
    bitsPerChar: 5,
  }),
  mZ = Nr({
    prefix: "T",
    name: "base32hexpadupper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
    bitsPerChar: 5,
  }),
  gZ = Nr({
    prefix: "h",
    name: "base32z",
    alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
    bitsPerChar: 5,
  });
var yZ = Object.freeze({
  __proto__: null,
  base32: cZ,
  base32upper: lZ,
  base32pad: uZ,
  base32padupper: dZ,
  base32hex: pZ,
  base32hexupper: fZ,
  base32hexpad: hZ,
  base32hexpadupper: mZ,
  base32z: gZ,
});
const wZ = Qm({
    prefix: "k",
    name: "base36",
    alphabet: "0123456789abcdefghijklmnopqrstuvwxyz",
  }),
  vZ = Qm({
    prefix: "K",
    name: "base36upper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ",
  });
var bZ = Object.freeze({ __proto__: null, base36: wZ, base36upper: vZ });
const EZ = Qm({
    name: "base58btc",
    prefix: "z",
    alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz",
  }),
  CZ = Qm({
    name: "base58flickr",
    prefix: "Z",
    alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ",
  });
var xZ = Object.freeze({ __proto__: null, base58btc: EZ, base58flickr: CZ });
const SZ = Nr({
    prefix: "m",
    name: "base64",
    alphabet:
      "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
    bitsPerChar: 6,
  }),
  AZ = Nr({
    prefix: "M",
    name: "base64pad",
    alphabet:
      "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
    bitsPerChar: 6,
  }),
  _Z = Nr({
    prefix: "u",
    name: "base64url",
    alphabet:
      "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
    bitsPerChar: 6,
  }),
  IZ = Nr({
    prefix: "U",
    name: "base64urlpad",
    alphabet:
      "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
    bitsPerChar: 6,
  });
var TZ = Object.freeze({
  __proto__: null,
  base64: SZ,
  base64pad: AZ,
  base64url: _Z,
  base64urlpad: IZ,
});
const bD = Array.from(
    ""
  ),
  PZ = bD.reduce((t, e, n) => ((t[n] = e), t), []),
  RZ = bD.reduce((t, e, n) => ((t[e.codePointAt(0)] = n), t), []);
function NZ(t) {
  return t.reduce((e, n) => ((e += PZ[n]), e), "");
}
function OZ(t) {
  const e = [];
  for (const n of t) {
    const r = RZ[n.codePointAt(0)];
    if (r === void 0) throw new Error(`Non-base256emoji character: ${n}`);
    e.push(r);
  }
  return new Uint8Array(e);
}
const kZ = wv({ prefix: "", name: "base256emoji", encode: NZ, decode: OZ });
var DZ = Object.freeze({ __proto__: null, base256emoji: kZ }),
  $Z = ED,
  hR = 128,
  MZ = 127,
  LZ = ~MZ,
  UZ = Math.pow(2, 31);
function ED(t, e, n) {
  (e = e || []), (n = n || 0);
  for (var r = n; t >= UZ; ) (e[n++] = (t & 255) | hR), (t /= 128);
  for (; t & LZ; ) (e[n++] = (t & 255) | hR), (t >>>= 7);
  return (e[n] = t | 0), (ED.bytes = n - r + 1), e;
}
var BZ = yx,
  jZ = 128,
  mR = 127;
function yx(t, r) {
  var n = 0,
    r = r || 0,
    i = 0,
    s = r,
    o,
    a = t.length;
  do {
    if (s >= a)
      throw ((yx.bytes = 0), new RangeError("Could not decode varint"));
    (o = t[s++]),
      (n += i < 28 ? (o & mR) << i : (o & mR) * Math.pow(2, i)),
      (i += 7);
  } while (o >= jZ);
  return (yx.bytes = s - r), n;
}
var FZ = Math.pow(2, 7),
  zZ = Math.pow(2, 14),
  WZ = Math.pow(2, 21),
  HZ = Math.pow(2, 28),
  qZ = Math.pow(2, 35),
  VZ = Math.pow(2, 42),
  GZ = Math.pow(2, 49),
  KZ = Math.pow(2, 56),
  YZ = Math.pow(2, 63),
  ZZ = function (t) {
    return t < FZ
      ? 1
      : t < zZ
      ? 2
      : t < WZ
      ? 3
      : t < HZ
      ? 4
      : t < qZ
      ? 5
      : t < VZ
      ? 6
      : t < GZ
      ? 7
      : t < KZ
      ? 8
      : t < YZ
      ? 9
      : 10;
  },
  QZ = { encode: $Z, decode: BZ, encodingLength: ZZ },
  CD = QZ;
const gR = (t, e, n = 0) => (CD.encode(t, e, n), e),
  yR = (t) => CD.encodingLength(t),
  wx = (t, e) => {
    const n = e.byteLength,
      r = yR(t),
      i = r + yR(n),
      s = new Uint8Array(i + n);
    return gR(t, s, 0), gR(n, s, r), s.set(e, i), new XZ(t, n, e, s);
  };
let XZ = class {
  constructor(e, n, r, i) {
    (this.code = e), (this.size = n), (this.digest = r), (this.bytes = i);
  }
};
const xD = ({ name: t, code: e, encode: n }) => new JZ(t, e, n);
let JZ = class {
  constructor(e, n, r) {
    (this.name = e), (this.code = n), (this.encode = r);
  }
  digest(e) {
    if (e instanceof Uint8Array) {
      const n = this.encode(e);
      return n instanceof Uint8Array
        ? wx(this.code, n)
        : n.then((r) => wx(this.code, r));
    } else throw Error("Unknown type, must be binary type");
  }
};
const SD = (t) => async (e) => new Uint8Array(await crypto.subtle.digest(t, e)),
  eQ = xD({ name: "sha2-256", code: 18, encode: SD("SHA-256") }),
  tQ = xD({ name: "sha2-512", code: 19, encode: SD("SHA-512") });
var nQ = Object.freeze({ __proto__: null, sha256: eQ, sha512: tQ });
const AD = 0,
  rQ = "identity",
  _D = wD,
  iQ = (t) => wx(AD, _D(t)),
  sQ = { code: AD, name: rQ, encode: _D, digest: iQ };
var oQ = Object.freeze({ __proto__: null, identity: sQ });
new TextEncoder(), new TextDecoder();
const wR = {
  ...XY,
  ...eZ,
  ...nZ,
  ...iZ,
  ...aZ,
  ...yZ,
  ...bZ,
  ...xZ,
  ...TZ,
  ...DZ,
};
({ ...nQ, ...oQ });
function ID(t, e, n, r) {
  return {
    name: t,
    prefix: e,
    encoder: { name: t, prefix: e, encode: n },
    decoder: { decode: r },
  };
}
const vR = ID(
    "utf8",
    "u",
    (t) => "u" + new TextDecoder("utf8").decode(t),
    (t) => new TextEncoder().encode(t.substring(1))
  ),
  PE = ID(
    "ascii",
    "a",
    (t) => {
      let e = "a";
      for (let n = 0; n < t.length; n++) e += String.fromCharCode(t[n]);
      return e;
    },
    (t) => {
      t = t.substring(1);
      const e = gD(t.length);
      for (let n = 0; n < t.length; n++) e[n] = t.charCodeAt(n);
      return e;
    }
  ),
  TD = {
    utf8: vR,
    "utf-8": vR,
    hex: wR.base16,
    latin1: PE,
    ascii: PE,
    binary: PE,
    ...wR,
  };
function vv(t, e = "utf8") {
  const n = TD[e];
  if (!n) throw new Error(`Unsupported encoding "${e}"`);
  return (e === "utf8" || e === "utf-8") &&
    globalThis.Buffer != null &&
    globalThis.Buffer.from != null
    ? globalThis.Buffer.from(t.buffer, t.byteOffset, t.byteLength).toString(
        "utf8"
      )
    : n.encoder.encode(t).substring(1);
}
function Ip(t, e = "utf8") {
  const n = TD[e];
  if (!n) throw new Error(`Unsupported encoding "${e}"`);
  return (e === "utf8" || e === "utf-8") &&
    globalThis.Buffer != null &&
    globalThis.Buffer.from != null
    ? SA(globalThis.Buffer.from(t, "utf-8"))
    : n.decoder.decode(`${n.prefix}${t}`);
}
function bR(t) {
  return Zl(vv(Ip(t, yv), hD));
}
function pw(t) {
  return vv(Ip(Aa(t), hD), yv);
}
function PD(t) {
  const e = Ip(UY, fR),
    n = LY + vv(yD([e, t]), fR);
  return [$Y, MY, n].join(DY);
}
function aQ(t) {
  return vv(t, yv);
}
function cQ(t) {
  return Ip(t, yv);
}
function lQ(t) {
  return Ip([pw(t.header), pw(t.payload)].join(dw), mD);
}
function uQ(t) {
  return [pw(t.header), pw(t.payload), aQ(t.signature)].join(dw);
}
function vx(t) {
  const e = t.split(dw),
    n = bR(e[0]),
    r = bR(e[1]),
    i = cQ(e[2]),
    s = Ip(e.slice(0, 2).join(dw), mD);
  return { header: n, payload: r, signature: i, data: s };
}
function ER(t = rD(BY)) {
  const e = fD.getPublicKey(t);
  return { secretKey: yD([t, e]), publicKey: e };
}
async function dQ(t, e, n, r, i = Ee.fromMiliseconds(Date.now())) {
  const s = { alg: OY, typ: kY },
    o = PD(r.publicKey),
    a = i + n,
    l = { iss: o, sub: t, aud: e, iat: i, exp: a },
    d = lQ({ header: s, payload: l }),
    p = fD.sign(d, r.secretKey.slice(0, 32));
  return uQ({ header: s, payload: l, signature: p });
}
var CR = function (t, e, n) {
    if (n || arguments.length === 2)
      for (var r = 0, i = e.length, s; r < i; r++)
        (s || !(r in e)) &&
          (s || (s = Array.prototype.slice.call(e, 0, r)), (s[r] = e[r]));
    return t.concat(s || Array.prototype.slice.call(e));
  },
  pQ = (function () {
    function t(e, n, r) {
      (this.name = e),
        (this.version = n),
        (this.os = r),
        (this.type = "browser");
    }
    return t;
  })(),
  fQ = (function () {
    function t(e) {
      (this.version = e),
        (this.type = "node"),
        (this.name = "node"),
        (this.os = process.platform);
    }
    return t;
  })(),
  hQ = (function () {
    function t(e, n, r, i) {
      (this.name = e),
        (this.version = n),
        (this.os = r),
        (this.bot = i),
        (this.type = "bot-device");
    }
    return t;
  })(),
  mQ = (function () {
    function t() {
      (this.type = "bot"),
        (this.bot = !0),
        (this.name = "bot"),
        (this.version = null),
        (this.os = null);
    }
    return t;
  })(),
  gQ = (function () {
    function t() {
      (this.type = "react-native"),
        (this.name = "react-native"),
        (this.version = null),
        (this.os = null);
    }
    return t;
  })(),
  yQ =
    /alexa|bot|crawl(er|ing)|facebookexternalhit|feedburner|google web preview|nagios|postrank|pingdom|slurp|spider|yahoo!|yandex/,
  wQ =
    /(nuhk|curl|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask\ Jeeves\/Teoma|ia_archiver)/,
  xR = 3,
  vQ = [
    ["aol", /AOLShield\/([0-9\._]+)/],
    ["edge", /Edge\/([0-9\._]+)/],
    ["edge-ios", /EdgiOS\/([0-9\._]+)/],
    ["yandexbrowser", /YaBrowser\/([0-9\._]+)/],
    ["kakaotalk", /KAKAOTALK\s([0-9\.]+)/],
    ["samsung", /SamsungBrowser\/([0-9\.]+)/],
    ["silk", /\bSilk\/([0-9._-]+)\b/],
    ["miui", /MiuiBrowser\/([0-9\.]+)$/],
    ["beaker", /BeakerBrowser\/([0-9\.]+)/],
    ["edge-chromium", /EdgA?\/([0-9\.]+)/],
    [
      "chromium-webview",
      /(?!Chrom.*OPR)wv\).*Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/,
    ],
    ["chrome", /(?!Chrom.*OPR)Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/],
    ["phantomjs", /PhantomJS\/([0-9\.]+)(:?\s|$)/],
    ["crios", /CriOS\/([0-9\.]+)(:?\s|$)/],
    ["firefox", /Firefox\/([0-9\.]+)(?:\s|$)/],
    ["fxios", /FxiOS\/([0-9\.]+)/],
    ["opera-mini", /Opera Mini.*Version\/([0-9\.]+)/],
    ["opera", /Opera\/([0-9\.]+)(?:\s|$)/],
    ["opera", /OPR\/([0-9\.]+)(:?\s|$)/],
    ["pie", /^Microsoft Pocket Internet Explorer\/(\d+\.\d+)$/],
    [
      "pie",
      /^Mozilla\/\d\.\d+\s\(compatible;\s(?:MSP?IE|MSInternet Explorer) (\d+\.\d+);.*Windows CE.*\)$/,
    ],
    ["netfront", /^Mozilla\/\d\.\d+.*NetFront\/(\d.\d)/],
    ["ie", /Trident\/7\.0.*rv\:([0-9\.]+).*\).*Gecko$/],
    ["ie", /MSIE\s([0-9\.]+);.*Trident\/[4-7].0/],
    ["ie", /MSIE\s(7\.0)/],
    ["bb10", /BB10;\sTouch.*Version\/([0-9\.]+)/],
    ["android", /Android\s([0-9\.]+)/],
    ["ios", /Version\/([0-9\._]+).*Mobile.*Safari.*/],
    ["safari", /Version\/([0-9\._]+).*Safari/],
    ["facebook", /FB[AS]V\/([0-9\.]+)/],
    ["instagram", /Instagram\s([0-9\.]+)/],
    ["ios-webview", /AppleWebKit\/([0-9\.]+).*Mobile/],
    ["ios-webview", /AppleWebKit\/([0-9\.]+).*Gecko\)$/],
    ["curl", /^curl\/([0-9\.]+)$/],
    ["searchbot", yQ],
  ],
  SR = [
    ["iOS", /iP(hone|od|ad)/],
    ["Android OS", /Android/],
    ["BlackBerry OS", /BlackBerry|BB10/],
    ["Windows Mobile", /IEMobile/],
    ["Amazon OS", /Kindle/],
    ["Windows 3.11", /Win16/],
    ["Windows 95", /(Windows 95)|(Win95)|(Windows_95)/],
    ["Windows 98", /(Windows 98)|(Win98)/],
    ["Windows 2000", /(Windows NT 5.0)|(Windows 2000)/],
    ["Windows XP", /(Windows NT 5.1)|(Windows XP)/],
    ["Windows Server 2003", /(Windows NT 5.2)/],
    ["Windows Vista", /(Windows NT 6.0)/],
    ["Windows 7", /(Windows NT 6.1)/],
    ["Windows 8", /(Windows NT 6.2)/],
    ["Windows 8.1", /(Windows NT 6.3)/],
    ["Windows 10", /(Windows NT 10.0)/],
    ["Windows ME", /Windows ME/],
    ["Windows CE", /Windows CE|WinCE|Microsoft Pocket Internet Explorer/],
    ["Open BSD", /OpenBSD/],
    ["Sun OS", /SunOS/],
    ["Chrome OS", /CrOS/],
    ["Linux", /(Linux)|(X11)/],
    ["Mac OS", /(Mac_PowerPC)|(Macintosh)/],
    ["QNX", /QNX/],
    ["BeOS", /BeOS/],
    ["OS/2", /OS\/2/],
  ];
function bQ(t) {
  return typeof document > "u" &&
    typeof navigator < "u" &&
    navigator.product === "ReactNative"
    ? new gQ()
    : typeof navigator < "u"
    ? CQ(navigator.userAgent)
    : SQ();
}
function EQ(t) {
  return (
    t !== "" &&
    vQ.reduce(function (e, n) {
      var r = n[0],
        i = n[1];
      if (e) return e;
      var s = i.exec(t);
      return !!s && [r, s];
    }, !1)
  );
}
function CQ(t) {
  var e = EQ(t);
  if (!e) return null;
  var n = e[0],
    r = e[1];
  if (n === "searchbot") return new mQ();
  var i = r[1] && r[1].split(".").join("_").split("_").slice(0, 3);
  i
    ? i.length < xR && (i = CR(CR([], i, !0), AQ(xR - i.length), !0))
    : (i = []);
  var s = i.join("."),
    o = xQ(t),
    a = wQ.exec(t);
  return a && a[1] ? new hQ(n, s, o, a[1]) : new pQ(n, s, o);
}
function xQ(t) {
  for (var e = 0, n = SR.length; e < n; e++) {
    var r = SR[e],
      i = r[0],
      s = r[1],
      o = s.exec(t);
    if (o) return i;
  }
  return null;
}
function SQ() {
  var t = typeof process < "u" && process.version;
  return t ? new fQ(process.version.slice(1)) : null;
}
function AQ(t) {
  for (var e = [], n = 0; n < t; n++) e.push("0");
  return e;
}
var Xt = {},
  AR;
function RD() {
  if (AR) return Xt;
  (AR = 1),
    Object.defineProperty(Xt, "__esModule", { value: !0 }),
    (Xt.getLocalStorage =
      Xt.getLocalStorageOrThrow =
      Xt.getCrypto =
      Xt.getCryptoOrThrow =
      Xt.getLocation =
      Xt.getLocationOrThrow =
      Xt.getNavigator =
      Xt.getNavigatorOrThrow =
      Xt.getDocument =
      Xt.getDocumentOrThrow =
      Xt.getFromWindowOrThrow =
      Xt.getFromWindow =
        void 0);
  function t(m) {
    let y;
    return typeof window < "u" && typeof window[m] < "u" && (y = window[m]), y;
  }
  Xt.getFromWindow = t;
  function e(m) {
    const y = t(m);
    if (!y) throw new Error(`${m} is not defined in Window`);
    return y;
  }
  Xt.getFromWindowOrThrow = e;
  function n() {
    return e("document");
  }
  Xt.getDocumentOrThrow = n;
  function r() {
    return t("document");
  }
  Xt.getDocument = r;
  function i() {
    return e("navigator");
  }
  Xt.getNavigatorOrThrow = i;
  function s() {
    return t("navigator");
  }
  Xt.getNavigator = s;
  function o() {
    return e("location");
  }
  Xt.getLocationOrThrow = o;
  function a() {
    return t("location");
  }
  Xt.getLocation = a;
  function l() {
    return e("crypto");
  }
  Xt.getCryptoOrThrow = l;
  function d() {
    return t("crypto");
  }
  Xt.getCrypto = d;
  function p() {
    return e("localStorage");
  }
  Xt.getLocalStorageOrThrow = p;
  function f() {
    return t("localStorage");
  }
  return (Xt.getLocalStorage = f), Xt;
}
var Ql = RD(),
  Lf = {},
  _R;
function _Q() {
  if (_R) return Lf;
  (_R = 1),
    Object.defineProperty(Lf, "__esModule", { value: !0 }),
    (Lf.getWindowMetadata = void 0);
  const t = RD();
  function e() {
    let n, r;
    try {
      (n = t.getDocumentOrThrow()), (r = t.getLocationOrThrow());
    } catch {
      return null;
    }
    function i() {
      const y = n.getElementsByTagName("link"),
        g = [];
      for (let v = 0; v < y.length; v++) {
        const b = y[v],
          E = b.getAttribute("rel");
        if (E && E.toLowerCase().indexOf("icon") > -1) {
          const S = b.getAttribute("href");
          if (S)
            if (
              S.toLowerCase().indexOf("https:") === -1 &&
              S.toLowerCase().indexOf("http:") === -1 &&
              S.indexOf("//") !== 0
            ) {
              let C = r.protocol + "//" + r.host;
              if (S.indexOf("/") === 0) C += S;
              else {
                const _ = r.pathname.split("/");
                _.pop();
                const A = _.join("/");
                C += A + "/" + S;
              }
              g.push(C);
            } else if (S.indexOf("//") === 0) {
              const C = r.protocol + S;
              g.push(C);
            } else g.push(S);
        }
      }
      return g;
    }
    function s(...y) {
      const g = n.getElementsByTagName("meta");
      for (let v = 0; v < g.length; v++) {
        const b = g[v],
          E = ["itemprop", "property", "name"]
            .map((S) => b.getAttribute(S))
            .filter((S) => (S ? y.includes(S) : !1));
        if (E.length && E) {
          const S = b.getAttribute("content");
          if (S) return S;
        }
      }
      return "";
    }
    function o() {
      let y = s("name", "og:site_name", "og:title", "twitter:title");
      return y || (y = n.title), y;
    }
    function a() {
      return s(
        "description",
        "og:description",
        "twitter:description",
        "keywords"
      );
    }
    const l = o(),
      d = a(),
      p = r.origin,
      f = i();
    return { description: d, url: p, icons: f, name: l };
  }
  return (Lf.getWindowMetadata = e), Lf;
}
var IQ = _Q();
const TQ = "1.0.8";
let As = class bx extends Error {
  constructor(e, n = {}) {
    var o;
    const r =
        n.cause instanceof bx
          ? n.cause.details
          : (o = n.cause) != null && o.message
          ? n.cause.message
          : n.details,
      i = (n.cause instanceof bx && n.cause.docsPath) || n.docsPath,
      s = [
        e || "An error occurred.",
        "",
        ...(n.metaMessages ? [...n.metaMessages, ""] : []),
        ...(i ? [`Docs: https://abitype.dev${i}`] : []),
        ...(r ? [`Details: ${r}`] : []),
        `Version: abitype@${TQ}`,
      ].join(`
`);
    super(s),
      Object.defineProperty(this, "details", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0,
      }),
      Object.defineProperty(this, "docsPath", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0,
      }),
      Object.defineProperty(this, "metaMessages", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0,
      }),
      Object.defineProperty(this, "shortMessage", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0,
      }),
      Object.defineProperty(this, "name", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: "AbiTypeError",
      }),
      n.cause && (this.cause = n.cause),
      (this.details = r),
      (this.docsPath = i),
      (this.metaMessages = n.metaMessages),
      (this.shortMessage = e);
  }
};
function Ra(t, e) {
  const n = t.exec(e);
  return n == null ? void 0 : n.groups;
}
const ND = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/,
  OD =
    /^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/,
  kD = /^\(.+?\).*?$/,
  IR = /^tuple(?<array>(\[(\d*)\])*)$/;
function Ex(t) {
  let e = t.type;
  if (IR.test(t.type) && "components" in t) {
    e = "(";
    const n = t.components.length;
    for (let i = 0; i < n; i++) {
      const s = t.components[i];
      (e += Ex(s)), i < n - 1 && (e += ", ");
    }
    const r = Ra(IR, t.type);
    return (
      (e += `)${(r == null ? void 0 : r.array) ?? ""}`), Ex({ ...t, type: e })
    );
  }
  return (
    "indexed" in t && t.indexed && (e = `${e} indexed`),
    t.name ? `${e} ${t.name}` : e
  );
}
function Uf(t) {
  let e = "";
  const n = t.length;
  for (let r = 0; r < n; r++) {
    const i = t[r];
    (e += Ex(i)), r !== n - 1 && (e += ", ");
  }
  return e;
}
function PQ(t) {
  var e;
  return t.type === "function"
    ? `function ${t.name}(${Uf(t.inputs)})${
        t.stateMutability && t.stateMutability !== "nonpayable"
          ? ` ${t.stateMutability}`
          : ""
      }${
        (e = t.outputs) != null && e.length ? ` returns (${Uf(t.outputs)})` : ""
      }`
    : t.type === "event"
    ? `event ${t.name}(${Uf(t.inputs)})`
    : t.type === "error"
    ? `error ${t.name}(${Uf(t.inputs)})`
    : t.type === "constructor"
    ? `constructor(${Uf(t.inputs)})${
        t.stateMutability === "payable" ? " payable" : ""
      }`
    : t.type === "fallback"
    ? `fallback() external${t.stateMutability === "payable" ? " payable" : ""}`
    : "receive() external payable";
}
const DD = /^error (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*)\((?<parameters>.*?)\)$/;
function RQ(t) {
  return DD.test(t);
}
function NQ(t) {
  return Ra(DD, t);
}
const $D = /^event (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*)\((?<parameters>.*?)\)$/;
function OQ(t) {
  return $D.test(t);
}
function kQ(t) {
  return Ra($D, t);
}
const MD =
  /^function (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*)\((?<parameters>.*?)\)(?: (?<scope>external|public{1}))?(?: (?<stateMutability>pure|view|nonpayable|payable{1}))?(?: returns\s?\((?<returns>.*?)\))?$/;
function DQ(t) {
  return MD.test(t);
}
function $Q(t) {
  return Ra(MD, t);
}
const LD = /^struct (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*) \{(?<properties>.*?)\}$/;
function UD(t) {
  return LD.test(t);
}
function MQ(t) {
  return Ra(LD, t);
}
const BD =
  /^constructor\((?<parameters>.*?)\)(?:\s(?<stateMutability>payable{1}))?$/;
function LQ(t) {
  return BD.test(t);
}
function UQ(t) {
  return Ra(BD, t);
}
const jD = /^fallback\(\) external(?:\s(?<stateMutability>payable{1}))?$/;
function BQ(t) {
  return jD.test(t);
}
function jQ(t) {
  return Ra(jD, t);
}
const FQ = /^receive\(\) external payable$/;
function zQ(t) {
  return FQ.test(t);
}
const WQ = new Set(["indexed"]),
  Cx = new Set(["calldata", "memory", "storage"]);
class HQ extends As {
  constructor({ type: e }) {
    super("Unknown type.", {
      metaMessages: [
        `Type "${e}" is not a valid ABI type. Perhaps you forgot to include a struct signature?`,
      ],
    }),
      Object.defineProperty(this, "name", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: "UnknownTypeError",
      });
  }
}
class qQ extends As {
  constructor({ type: e }) {
    super("Unknown type.", {
      metaMessages: [`Type "${e}" is not a valid ABI type.`],
    }),
      Object.defineProperty(this, "name", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: "UnknownSolidityTypeError",
      });
  }
}
class VQ extends As {
  constructor({ param: e }) {
    super("Invalid ABI parameter.", { details: e }),
      Object.defineProperty(this, "name", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: "InvalidParameterError",
      });
  }
}
class GQ extends As {
  constructor({ param: e, name: n }) {
    super("Invalid ABI parameter.", {
      details: e,
      metaMessages: [
        `"${n}" is a protected Solidity keyword. More info: https://docs.soliditylang.org/en/latest/cheatsheet.html`,
      ],
    }),
      Object.defineProperty(this, "name", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: "SolidityProtectedKeywordError",
      });
  }
}
class KQ extends As {
  constructor({ param: e, type: n, modifier: r }) {
    super("Invalid ABI parameter.", {
      details: e,
      metaMessages: [
        `Modifier "${r}" not allowed${n ? ` in "${n}" type` : ""}.`,
      ],
    }),
      Object.defineProperty(this, "name", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: "InvalidModifierError",
      });
  }
}
class YQ extends As {
  constructor({ param: e, type: n, modifier: r }) {
    super("Invalid ABI parameter.", {
      details: e,
      metaMessages: [
        `Modifier "${r}" not allowed${n ? ` in "${n}" type` : ""}.`,
        `Data location can only be specified for array, struct, or mapping types, but "${r}" was given.`,
      ],
    }),
      Object.defineProperty(this, "name", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: "InvalidFunctionModifierError",
      });
  }
}
class ZQ extends As {
  constructor({ abiParameter: e }) {
    super("Invalid ABI parameter.", {
      details: JSON.stringify(e, null, 2),
      metaMessages: ["ABI parameter type is invalid."],
    }),
      Object.defineProperty(this, "name", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: "InvalidAbiTypeParameterError",
      });
  }
}
class Tp extends As {
  constructor({ signature: e, type: n }) {
    super(`Invalid ${n} signature.`, { details: e }),
      Object.defineProperty(this, "name", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: "InvalidSignatureError",
      });
  }
}
class QQ extends As {
  constructor({ signature: e }) {
    super("Unknown signature.", { details: e }),
      Object.defineProperty(this, "name", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: "UnknownSignatureError",
      });
  }
}
class XQ extends As {
  constructor({ signature: e }) {
    super("Invalid struct signature.", {
      details: e,
      metaMessages: ["No properties exist."],
    }),
      Object.defineProperty(this, "name", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: "InvalidStructSignatureError",
      });
  }
}
class JQ extends As {
  constructor({ type: e }) {
    super("Circular reference detected.", {
      metaMessages: [`Struct "${e}" is a circular reference.`],
    }),
      Object.defineProperty(this, "name", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: "CircularReferenceError",
      });
  }
}
class eX extends As {
  constructor({ current: e, depth: n }) {
    super("Unbalanced parentheses.", {
      metaMessages: [
        `"${e.trim()}" has too many ${
          n > 0 ? "opening" : "closing"
        } parentheses.`,
      ],
      details: `Depth "${n}"`,
    }),
      Object.defineProperty(this, "name", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: "InvalidParenthesisError",
      });
  }
}
function tX(t, e, n) {
  let r = "";
  if (n)
    for (const i of Object.entries(n)) {
      if (!i) continue;
      let s = "";
      for (const o of i[1]) s += `[${o.type}${o.name ? `:${o.name}` : ""}]`;
      r += `(${i[0]}{${s}})`;
    }
  return e ? `${e}:${t}${r}` : t;
}
const RE = new Map([
  ["address", { type: "address" }],
  ["bool", { type: "bool" }],
  ["bytes", { type: "bytes" }],
  ["bytes32", { type: "bytes32" }],
  ["int", { type: "int256" }],
  ["int256", { type: "int256" }],
  ["string", { type: "string" }],
  ["uint", { type: "uint256" }],
  ["uint8", { type: "uint8" }],
  ["uint16", { type: "uint16" }],
  ["uint24", { type: "uint24" }],
  ["uint32", { type: "uint32" }],
  ["uint64", { type: "uint64" }],
  ["uint96", { type: "uint96" }],
  ["uint112", { type: "uint112" }],
  ["uint160", { type: "uint160" }],
  ["uint192", { type: "uint192" }],
  ["uint256", { type: "uint256" }],
  ["address owner", { type: "address", name: "owner" }],
  ["address to", { type: "address", name: "to" }],
  ["bool approved", { type: "bool", name: "approved" }],
  ["bytes _data", { type: "bytes", name: "_data" }],
  ["bytes data", { type: "bytes", name: "data" }],
  ["bytes signature", { type: "bytes", name: "signature" }],
  ["bytes32 hash", { type: "bytes32", name: "hash" }],
  ["bytes32 r", { type: "bytes32", name: "r" }],
  ["bytes32 root", { type: "bytes32", name: "root" }],
  ["bytes32 s", { type: "bytes32", name: "s" }],
  ["string name", { type: "string", name: "name" }],
  ["string symbol", { type: "string", name: "symbol" }],
  ["string tokenURI", { type: "string", name: "tokenURI" }],
  ["uint tokenId", { type: "uint256", name: "tokenId" }],
  ["uint8 v", { type: "uint8", name: "v" }],
  ["uint256 balance", { type: "uint256", name: "balance" }],
  ["uint256 tokenId", { type: "uint256", name: "tokenId" }],
  ["uint256 value", { type: "uint256", name: "value" }],
  [
    "event:address indexed from",
    { type: "address", name: "from", indexed: !0 },
  ],
  ["event:address indexed to", { type: "address", name: "to", indexed: !0 }],
  [
    "event:uint indexed tokenId",
    { type: "uint256", name: "tokenId", indexed: !0 },
  ],
  [
    "event:uint256 indexed tokenId",
    { type: "uint256", name: "tokenId", indexed: !0 },
  ],
]);
function nX(t, e = {}) {
  if (DQ(t)) return rX(t, e);
  if (OQ(t)) return iX(t, e);
  if (RQ(t)) return sX(t, e);
  if (LQ(t)) return oX(t, e);
  if (BQ(t)) return aX(t);
  if (zQ(t)) return { type: "receive", stateMutability: "payable" };
  throw new QQ({ signature: t });
}
function rX(t, e = {}) {
  const n = $Q(t);
  if (!n) throw new Tp({ signature: t, type: "function" });
  const r = Hs(n.parameters),
    i = [],
    s = r.length;
  for (let a = 0; a < s; a++)
    i.push(Xl(r[a], { modifiers: Cx, structs: e, type: "function" }));
  const o = [];
  if (n.returns) {
    const a = Hs(n.returns),
      l = a.length;
    for (let d = 0; d < l; d++)
      o.push(Xl(a[d], { modifiers: Cx, structs: e, type: "function" }));
  }
  return {
    name: n.name,
    type: "function",
    stateMutability: n.stateMutability ?? "nonpayable",
    inputs: i,
    outputs: o,
  };
}
function iX(t, e = {}) {
  const n = kQ(t);
  if (!n) throw new Tp({ signature: t, type: "event" });
  const r = Hs(n.parameters),
    i = [],
    s = r.length;
  for (let o = 0; o < s; o++)
    i.push(Xl(r[o], { modifiers: WQ, structs: e, type: "event" }));
  return { name: n.name, type: "event", inputs: i };
}
function sX(t, e = {}) {
  const n = NQ(t);
  if (!n) throw new Tp({ signature: t, type: "error" });
  const r = Hs(n.parameters),
    i = [],
    s = r.length;
  for (let o = 0; o < s; o++) i.push(Xl(r[o], { structs: e, type: "error" }));
  return { name: n.name, type: "error", inputs: i };
}
function oX(t, e = {}) {
  const n = UQ(t);
  if (!n) throw new Tp({ signature: t, type: "constructor" });
  const r = Hs(n.parameters),
    i = [],
    s = r.length;
  for (let o = 0; o < s; o++)
    i.push(Xl(r[o], { structs: e, type: "constructor" }));
  return {
    type: "constructor",
    stateMutability: n.stateMutability ?? "nonpayable",
    inputs: i,
  };
}
function aX(t) {
  const e = jQ(t);
  if (!e) throw new Tp({ signature: t, type: "fallback" });
  return {
    type: "fallback",
    stateMutability: e.stateMutability ?? "nonpayable",
  };
}
const cX =
    /^(?<type>[a-zA-Z$_][a-zA-Z0-9$_]*)(?<array>(?:\[\d*?\])+?)?(?:\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\s(?<name>[a-zA-Z$_][a-zA-Z0-9$_]*))?$/,
  lX =
    /^\((?<type>.+?)\)(?<array>(?:\[\d*?\])+?)?(?:\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\s(?<name>[a-zA-Z$_][a-zA-Z0-9$_]*))?$/,
  uX = /^u?int$/;
function Xl(t, e) {
  var f, m;
  const n = tX(t, e == null ? void 0 : e.type, e == null ? void 0 : e.structs);
  if (RE.has(n)) return RE.get(n);
  const r = kD.test(t),
    i = Ra(r ? lX : cX, t);
  if (!i) throw new VQ({ param: t });
  if (i.name && pX(i.name)) throw new GQ({ param: t, name: i.name });
  const s = i.name ? { name: i.name } : {},
    o = i.modifier === "indexed" ? { indexed: !0 } : {},
    a = (e == null ? void 0 : e.structs) ?? {};
  let l,
    d = {};
  if (r) {
    l = "tuple";
    const y = Hs(i.type),
      g = [],
      v = y.length;
    for (let b = 0; b < v; b++) g.push(Xl(y[b], { structs: a }));
    d = { components: g };
  } else if (i.type in a) (l = "tuple"), (d = { components: a[i.type] });
  else if (uX.test(i.type)) l = `${i.type}256`;
  else if (((l = i.type), (e == null ? void 0 : e.type) !== "struct" && !FD(l)))
    throw new qQ({ type: l });
  if (i.modifier) {
    if (
      !(
        (m = (f = e == null ? void 0 : e.modifiers) == null ? void 0 : f.has) !=
          null && m.call(f, i.modifier)
      )
    )
      throw new KQ({
        param: t,
        type: e == null ? void 0 : e.type,
        modifier: i.modifier,
      });
    if (Cx.has(i.modifier) && !fX(l, !!i.array))
      throw new YQ({
        param: t,
        type: e == null ? void 0 : e.type,
        modifier: i.modifier,
      });
  }
  const p = { type: `${l}${i.array ?? ""}`, ...s, ...o, ...d };
  return RE.set(n, p), p;
}
function Hs(t, e = [], n = "", r = 0) {
  const i = t.trim().length;
  for (let s = 0; s < i; s++) {
    const o = t[s],
      a = t.slice(s + 1);
    switch (o) {
      case ",":
        return r === 0 ? Hs(a, [...e, n.trim()]) : Hs(a, e, `${n}${o}`, r);
      case "(":
        return Hs(a, e, `${n}${o}`, r + 1);
      case ")":
        return Hs(a, e, `${n}${o}`, r - 1);
      default:
        return Hs(a, e, `${n}${o}`, r);
    }
  }
  if (n === "") return e;
  if (r !== 0) throw new eX({ current: n, depth: r });
  return e.push(n.trim()), e;
}
function FD(t) {
  return (
    t === "address" ||
    t === "bool" ||
    t === "function" ||
    t === "string" ||
    ND.test(t) ||
    OD.test(t)
  );
}
const dX =
  /^(?:after|alias|anonymous|apply|auto|byte|calldata|case|catch|constant|copyof|default|defined|error|event|external|false|final|function|immutable|implements|in|indexed|inline|internal|let|mapping|match|memory|mutable|null|of|override|partial|private|promise|public|pure|reference|relocatable|return|returns|sizeof|static|storage|struct|super|supports|switch|this|true|try|typedef|typeof|var|view|virtual)$/;
function pX(t) {
  return (
    t === "address" ||
    t === "bool" ||
    t === "function" ||
    t === "string" ||
    t === "tuple" ||
    ND.test(t) ||
    OD.test(t) ||
    dX.test(t)
  );
}
function fX(t, e) {
  return e || t === "bytes" || t === "string" || t === "tuple";
}
function hX(t) {
  const e = {},
    n = t.length;
  for (let o = 0; o < n; o++) {
    const a = t[o];
    if (!UD(a)) continue;
    const l = MQ(a);
    if (!l) throw new Tp({ signature: a, type: "struct" });
    const d = l.properties.split(";"),
      p = [],
      f = d.length;
    for (let m = 0; m < f; m++) {
      const g = d[m].trim();
      if (!g) continue;
      const v = Xl(g, { type: "struct" });
      p.push(v);
    }
    if (!p.length) throw new XQ({ signature: a });
    e[l.name] = p;
  }
  const r = {},
    i = Object.entries(e),
    s = i.length;
  for (let o = 0; o < s; o++) {
    const [a, l] = i[o];
    r[a] = zD(l, e);
  }
  return r;
}
const mX = /^(?<type>[a-zA-Z$_][a-zA-Z0-9$_]*)(?<array>(?:\[\d*?\])+?)?$/;
function zD(t, e, n = new Set()) {
  const r = [],
    i = t.length;
  for (let s = 0; s < i; s++) {
    const o = t[s];
    if (kD.test(o.type)) r.push(o);
    else {
      const l = Ra(mX, o.type);
      if (!(l != null && l.type)) throw new ZQ({ abiParameter: o });
      const { array: d, type: p } = l;
      if (p in e) {
        if (n.has(p)) throw new JQ({ type: p });
        r.push({
          ...o,
          type: `tuple${d ?? ""}`,
          components: zD(e[p] ?? [], e, new Set([...n, p])),
        });
      } else if (FD(p)) r.push(o);
      else throw new HQ({ type: p });
    }
  }
  return r;
}
function WD(t) {
  const e = hX(t),
    n = [],
    r = t.length;
  for (let i = 0; i < r; i++) {
    const s = t[i];
    UD(s) || n.push(nX(s, e));
  }
  return n;
}
function zh(t, { strict: e = !0 } = {}) {
  return !t || typeof t != "string"
    ? !1
    : e
    ? /^0x[0-9a-fA-F]*$/.test(t)
    : t.startsWith("0x");
}
function TR(t) {
  return zh(t, { strict: !1 }) ? Math.ceil((t.length - 2) / 2) : t.length;
}
const HD = "2.23.2";
let Bf = {
    getDocsUrl: ({ docsBaseUrl: t, docsPath: e = "", docsSlug: n }) =>
      e ? `${t ?? "https://viem.sh"}${e}${n ? `#${n}` : ""}` : void 0,
    version: `viem@${HD}`,
  },
  bv = class xx extends Error {
    constructor(e, n = {}) {
      var a;
      const r = (() => {
          var l;
          return n.cause instanceof xx
            ? n.cause.details
            : (l = n.cause) != null && l.message
            ? n.cause.message
            : n.details;
        })(),
        i = (n.cause instanceof xx && n.cause.docsPath) || n.docsPath,
        s =
          (a = Bf.getDocsUrl) == null
            ? void 0
            : a.call(Bf, { ...n, docsPath: i }),
        o = [
          e || "An error occurred.",
          "",
          ...(n.metaMessages ? [...n.metaMessages, ""] : []),
          ...(s ? [`Docs: ${s}`] : []),
          ...(r ? [`Details: ${r}`] : []),
          ...(Bf.version ? [`Version: ${Bf.version}`] : []),
        ].join(`
`);
      super(o, n.cause ? { cause: n.cause } : void 0),
        Object.defineProperty(this, "details", {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: void 0,
        }),
        Object.defineProperty(this, "docsPath", {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: void 0,
        }),
        Object.defineProperty(this, "metaMessages", {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: void 0,
        }),
        Object.defineProperty(this, "shortMessage", {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: void 0,
        }),
        Object.defineProperty(this, "version", {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: void 0,
        }),
        Object.defineProperty(this, "name", {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: "BaseError",
        }),
        (this.details = r),
        (this.docsPath = i),
        (this.metaMessages = n.metaMessages),
        (this.name = n.name ?? this.name),
        (this.shortMessage = e),
        (this.version = HD);
    }
    walk(e) {
      return qD(this, e);
    }
  };
function qD(t, e) {
  return e != null && e(t)
    ? t
    : t && typeof t == "object" && "cause" in t && t.cause !== void 0
    ? qD(t.cause, e)
    : e
    ? null
    : t;
}
let VD = class extends bv {
  constructor({ size: e, targetSize: n, type: r }) {
    super(
      `${r.charAt(0).toUpperCase()}${r
        .slice(1)
        .toLowerCase()} size (${e}) exceeds padding size (${n}).`,
      { name: "SizeExceedsPaddingSizeError" }
    );
  }
};
function Pp(t, { dir: e, size: n = 32 } = {}) {
  return typeof t == "string"
    ? gX(t, { dir: e, size: n })
    : yX(t, { dir: e, size: n });
}
function gX(t, { dir: e, size: n = 32 } = {}) {
  if (n === null) return t;
  const r = t.replace("0x", "");
  if (r.length > n * 2)
    throw new VD({ size: Math.ceil(r.length / 2), targetSize: n, type: "hex" });
  return `0x${r[e === "right" ? "padEnd" : "padStart"](n * 2, "0")}`;
}
function yX(t, { dir: e, size: n = 32 } = {}) {
  if (n === null) return t;
  if (t.length > n)
    throw new VD({ size: t.length, targetSize: n, type: "bytes" });
  const r = new Uint8Array(n);
  for (let i = 0; i < n; i++) {
    const s = e === "right";
    r[s ? i : n - i - 1] = t[s ? i : t.length - i - 1];
  }
  return r;
}
let wX = class extends bv {
    constructor({ max: e, min: n, signed: r, size: i, value: s }) {
      super(
        `Number "${s}" is not in safe ${
          i ? `${i * 8}-bit ${r ? "signed" : "unsigned"} ` : ""
        }integer range ${e ? `(${n} to ${e})` : `(above ${n})`}`,
        { name: "IntegerOutOfRangeError" }
      );
    }
  },
  vX = class extends bv {
    constructor({ givenSize: e, maxSize: n }) {
      super(`Size cannot exceed ${n} bytes. Given size: ${e} bytes.`, {
        name: "SizeOverflowError",
      });
    }
  };
function Rp(t, { size: e }) {
  if (TR(t) > e) throw new vX({ givenSize: TR(t), maxSize: e });
}
function Sx(t, e = {}) {
  const { signed: n } = e;
  e.size && Rp(t, { size: e.size });
  const r = BigInt(t);
  if (!n) return r;
  const i = (t.length - 2) / 2,
    s = (1n << (BigInt(i) * 8n - 1n)) - 1n;
  return r <= s ? r : r - BigInt(`0x${"f".padStart(i * 2, "f")}`) - 1n;
}
function bX(t, e = {}) {
  return Number(Sx(t, e));
}
const EX = Array.from({ length: 256 }, (t, e) =>
  e.toString(16).padStart(2, "0")
);
function Ax(t, e = {}) {
  return typeof t == "number" || typeof t == "bigint"
    ? KD(t, e)
    : typeof t == "string"
    ? SX(t, e)
    : typeof t == "boolean"
    ? CX(t, e)
    : GD(t, e);
}
function CX(t, e = {}) {
  const n = `0x${Number(t)}`;
  return typeof e.size == "number"
    ? (Rp(n, { size: e.size }), Pp(n, { size: e.size }))
    : n;
}
function GD(t, e = {}) {
  let n = "";
  for (let i = 0; i < t.length; i++) n += EX[t[i]];
  const r = `0x${n}`;
  return typeof e.size == "number"
    ? (Rp(r, { size: e.size }), Pp(r, { dir: "right", size: e.size }))
    : r;
}
function KD(t, e = {}) {
  const { signed: n, size: r } = e,
    i = BigInt(t);
  let s;
  r
    ? n
      ? (s = (1n << (BigInt(r) * 8n - 1n)) - 1n)
      : (s = 2n ** (BigInt(r) * 8n) - 1n)
    : typeof t == "number" && (s = BigInt(Number.MAX_SAFE_INTEGER));
  const o = typeof s == "bigint" && n ? -s - 1n : 0;
  if ((s && i > s) || i < o) {
    const l = typeof t == "bigint" ? "n" : "";
    throw new wX({
      max: s ? `${s}${l}` : void 0,
      min: `${o}${l}`,
      signed: n,
      size: r,
      value: `${t}${l}`,
    });
  }
  const a = `0x${(n && i < 0 ? (1n << BigInt(r * 8)) + BigInt(i) : i).toString(
    16
  )}`;
  return r ? Pp(a, { size: r }) : a;
}
const xX = new TextEncoder();
function SX(t, e = {}) {
  const n = xX.encode(t);
  return GD(n, e);
}
const AX = new TextEncoder();
function _X(t, e = {}) {
  return typeof t == "number" || typeof t == "bigint"
    ? TX(t, e)
    : typeof t == "boolean"
    ? IX(t, e)
    : zh(t)
    ? YD(t, e)
    : ZD(t, e);
}
function IX(t, e = {}) {
  const n = new Uint8Array(1);
  return (
    (n[0] = Number(t)),
    typeof e.size == "number"
      ? (Rp(n, { size: e.size }), Pp(n, { size: e.size }))
      : n
  );
}
const ta = { zero: 48, nine: 57, A: 65, F: 70, a: 97, f: 102 };
function PR(t) {
  if (t >= ta.zero && t <= ta.nine) return t - ta.zero;
  if (t >= ta.A && t <= ta.F) return t - (ta.A - 10);
  if (t >= ta.a && t <= ta.f) return t - (ta.a - 10);
}
function YD(t, e = {}) {
  let n = t;
  e.size &&
    (Rp(n, { size: e.size }), (n = Pp(n, { dir: "right", size: e.size })));
  let r = n.slice(2);
  r.length % 2 && (r = `0${r}`);
  const i = r.length / 2,
    s = new Uint8Array(i);
  for (let o = 0, a = 0; o < i; o++) {
    const l = PR(r.charCodeAt(a++)),
      d = PR(r.charCodeAt(a++));
    if (l === void 0 || d === void 0)
      throw new bv(
        `Invalid byte sequence ("${r[a - 2]}${r[a - 1]}" in "${r}").`
      );
    s[o] = l * 16 + d;
  }
  return s;
}
function TX(t, e) {
  const n = KD(t, e);
  return YD(n);
}
function ZD(t, e = {}) {
  const n = AX.encode(t);
  return typeof e.size == "number"
    ? (Rp(n, { size: e.size }), Pp(n, { dir: "right", size: e.size }))
    : n;
}
function fw(t) {
  if (!Number.isSafeInteger(t) || t < 0)
    throw new Error("positive integer expected, got " + t);
}
function PX(t) {
  return (
    t instanceof Uint8Array ||
    (ArrayBuffer.isView(t) && t.constructor.name === "Uint8Array")
  );
}
function Ev(t, ...e) {
  if (!PX(t)) throw new Error("Uint8Array expected");
  if (e.length > 0 && !e.includes(t.length))
    throw new Error(
      "Uint8Array expected of length " + e + ", got length=" + t.length
    );
}
function u1e(t) {
  if (typeof t != "function" || typeof t.create != "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  fw(t.outputLen), fw(t.blockLen);
}
function RR(t, e = !0) {
  if (t.destroyed) throw new Error("Hash instance has been destroyed");
  if (e && t.finished) throw new Error("Hash#digest() has already been called");
}
function RX(t, e) {
  Ev(t);
  const n = e.outputLen;
  if (t.length < n)
    throw new Error(
      "digestInto() expects output buffer of length at least " + n
    );
}
const Zy = BigInt(2 ** 32 - 1),
  NR = BigInt(32);
function NX(t, e = !1) {
  return e
    ? { h: Number(t & Zy), l: Number((t >> NR) & Zy) }
    : { h: Number((t >> NR) & Zy) | 0, l: Number(t & Zy) | 0 };
}
function OX(t, e = !1) {
  let n = new Uint32Array(t.length),
    r = new Uint32Array(t.length);
  for (let i = 0; i < t.length; i++) {
    const { h: s, l: o } = NX(t[i], e);
    [n[i], r[i]] = [s, o];
  }
  return [n, r];
}
const kX = (t, e, n) => (t << n) | (e >>> (32 - n)),
  DX = (t, e, n) => (e << n) | (t >>> (32 - n)),
  $X = (t, e, n) => (e << (n - 32)) | (t >>> (64 - n)),
  MX = (t, e, n) => (t << (n - 32)) | (e >>> (64 - n)),
  Yu =
    typeof globalThis == "object" && "crypto" in globalThis
      ? globalThis.crypto
      : void 0;
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */ function LX(
  t
) {
  return new Uint32Array(t.buffer, t.byteOffset, Math.floor(t.byteLength / 4));
}
function d1e(t) {
  return new DataView(t.buffer, t.byteOffset, t.byteLength);
}
function p1e(t, e) {
  return (t << (32 - e)) | (t >>> e);
}
const OR = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
function UX(t) {
  return (
    ((t << 24) & 4278190080) |
    ((t << 8) & 16711680) |
    ((t >>> 8) & 65280) |
    ((t >>> 24) & 255)
  );
}
function kR(t) {
  for (let e = 0; e < t.length; e++) t[e] = UX(t[e]);
}
function BX(t) {
  if (typeof t != "string")
    throw new Error("utf8ToBytes expected string, got " + typeof t);
  return new Uint8Array(new TextEncoder().encode(t));
}
function QD(t) {
  return typeof t == "string" && (t = BX(t)), Ev(t), t;
}
function f1e(...t) {
  let e = 0;
  for (let r = 0; r < t.length; r++) {
    const i = t[r];
    Ev(i), (e += i.length);
  }
  const n = new Uint8Array(e);
  for (let r = 0, i = 0; r < t.length; r++) {
    const s = t[r];
    n.set(s, i), (i += s.length);
  }
  return n;
}
let jX = class {
  clone() {
    return this._cloneInto();
  }
};
function FX(t) {
  const e = (r) => t().update(QD(r)).digest(),
    n = t();
  return (
    (e.outputLen = n.outputLen),
    (e.blockLen = n.blockLen),
    (e.create = () => t()),
    e
  );
}
function m1e(t = 32) {
  if (Yu && typeof Yu.getRandomValues == "function")
    return Yu.getRandomValues(new Uint8Array(t));
  if (Yu && typeof Yu.randomBytes == "function") return Yu.randomBytes(t);
  throw new Error("crypto.getRandomValues must be defined");
}
const XD = [],
  JD = [],
  e$ = [],
  zX = BigInt(0),
  jf = BigInt(1),
  WX = BigInt(2),
  HX = BigInt(7),
  qX = BigInt(256),
  VX = BigInt(113);
for (let t = 0, e = jf, n = 1, r = 0; t < 24; t++) {
  ([n, r] = [r, (2 * n + 3 * r) % 5]),
    XD.push(2 * (5 * r + n)),
    JD.push((((t + 1) * (t + 2)) / 2) % 64);
  let i = zX;
  for (let s = 0; s < 7; s++)
    (e = ((e << jf) ^ ((e >> HX) * VX)) % qX),
      e & WX && (i ^= jf << ((jf << BigInt(s)) - jf));
  e$.push(i);
}
const [GX, KX] = OX(e$, !0),
  DR = (t, e, n) => (n > 32 ? $X(t, e, n) : kX(t, e, n)),
  $R = (t, e, n) => (n > 32 ? MX(t, e, n) : DX(t, e, n));
function YX(t, e = 24) {
  const n = new Uint32Array(10);
  for (let r = 24 - e; r < 24; r++) {
    for (let o = 0; o < 10; o++)
      n[o] = t[o] ^ t[o + 10] ^ t[o + 20] ^ t[o + 30] ^ t[o + 40];
    for (let o = 0; o < 10; o += 2) {
      const a = (o + 8) % 10,
        l = (o + 2) % 10,
        d = n[l],
        p = n[l + 1],
        f = DR(d, p, 1) ^ n[a],
        m = $R(d, p, 1) ^ n[a + 1];
      for (let y = 0; y < 50; y += 10) (t[o + y] ^= f), (t[o + y + 1] ^= m);
    }
    let i = t[2],
      s = t[3];
    for (let o = 0; o < 24; o++) {
      const a = JD[o],
        l = DR(i, s, a),
        d = $R(i, s, a),
        p = XD[o];
      (i = t[p]), (s = t[p + 1]), (t[p] = l), (t[p + 1] = d);
    }
    for (let o = 0; o < 50; o += 10) {
      for (let a = 0; a < 10; a++) n[a] = t[o + a];
      for (let a = 0; a < 10; a++)
        t[o + a] ^= ~n[(a + 2) % 10] & n[(a + 4) % 10];
    }
    (t[0] ^= GX[r]), (t[1] ^= KX[r]);
  }
  n.fill(0);
}
let ZX = class t$ extends jX {
  constructor(e, n, r, i = !1, s = 24) {
    if (
      (super(),
      (this.blockLen = e),
      (this.suffix = n),
      (this.outputLen = r),
      (this.enableXOF = i),
      (this.rounds = s),
      (this.pos = 0),
      (this.posOut = 0),
      (this.finished = !1),
      (this.destroyed = !1),
      fw(r),
      0 >= this.blockLen || this.blockLen >= 200)
    )
      throw new Error("Sha3 supports only keccak-f1600 function");
    (this.state = new Uint8Array(200)), (this.state32 = LX(this.state));
  }
  keccak() {
    OR || kR(this.state32),
      YX(this.state32, this.rounds),
      OR || kR(this.state32),
      (this.posOut = 0),
      (this.pos = 0);
  }
  update(e) {
    RR(this);
    const { blockLen: n, state: r } = this;
    e = QD(e);
    const i = e.length;
    for (let s = 0; s < i; ) {
      const o = Math.min(n - this.pos, i - s);
      for (let a = 0; a < o; a++) r[this.pos++] ^= e[s++];
      this.pos === n && this.keccak();
    }
    return this;
  }
  finish() {
    if (this.finished) return;
    this.finished = !0;
    const { state: e, suffix: n, pos: r, blockLen: i } = this;
    (e[r] ^= n),
      n & 128 && r === i - 1 && this.keccak(),
      (e[i - 1] ^= 128),
      this.keccak();
  }
  writeInto(e) {
    RR(this, !1), Ev(e), this.finish();
    const n = this.state,
      { blockLen: r } = this;
    for (let i = 0, s = e.length; i < s; ) {
      this.posOut >= r && this.keccak();
      const o = Math.min(r - this.posOut, s - i);
      e.set(n.subarray(this.posOut, this.posOut + o), i),
        (this.posOut += o),
        (i += o);
    }
    return e;
  }
  xofInto(e) {
    if (!this.enableXOF)
      throw new Error("XOF is not possible for this instance");
    return this.writeInto(e);
  }
  xof(e) {
    return fw(e), this.xofInto(new Uint8Array(e));
  }
  digestInto(e) {
    if ((RX(e, this), this.finished))
      throw new Error("digest() was already called");
    return this.writeInto(e), this.destroy(), e;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
  destroy() {
    (this.destroyed = !0), this.state.fill(0);
  }
  _cloneInto(e) {
    const {
      blockLen: n,
      suffix: r,
      outputLen: i,
      rounds: s,
      enableXOF: o,
    } = this;
    return (
      e || (e = new t$(n, r, i, o, s)),
      e.state32.set(this.state32),
      (e.pos = this.pos),
      (e.posOut = this.posOut),
      (e.finished = this.finished),
      (e.rounds = s),
      (e.suffix = r),
      (e.outputLen = i),
      (e.enableXOF = o),
      (e.destroyed = this.destroyed),
      e
    );
  }
};
const QX = (t, e, n) => FX(() => new ZX(e, t, n)),
  XX = QX(1, 136, 256 / 8);
function n$(t, e) {
  const n = e || "hex",
    r = XX(zh(t, { strict: !1 }) ? _X(t) : t);
  return n === "bytes" ? r : Ax(r);
}
let JX = class extends Map {
  constructor(e) {
    super(),
      Object.defineProperty(this, "maxSize", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0,
      }),
      (this.maxSize = e);
  }
  get(e) {
    const n = super.get(e);
    return super.has(e) && n !== void 0 && (this.delete(e), super.set(e, n)), n;
  }
  set(e, n) {
    if ((super.set(e, n), this.maxSize && this.size > this.maxSize)) {
      const r = this.keys().next().value;
      r && this.delete(r);
    }
    return this;
  }
};
const NE = new JX(8192);
function eJ(t, e) {
  if (NE.has(`${t}.${e}`)) return NE.get(`${t}.${e}`);
  const n = t.substring(2).toLowerCase(),
    r = n$(ZD(n), "bytes"),
    i = n.split("");
  for (let o = 0; o < 40; o += 2)
    r[o >> 1] >> 4 >= 8 && i[o] && (i[o] = i[o].toUpperCase()),
      (r[o >> 1] & 15) >= 8 && i[o + 1] && (i[o + 1] = i[o + 1].toUpperCase());
  const s = `0x${i.join("")}`;
  return NE.set(`${t}.${e}`, s), s;
}
function tJ(t) {
  const e = n$(`0x${t.substring(4)}`).substring(26);
  return eJ(`0x${e}`);
}
const nJ = "modulepreload",
  rJ = function (t) {
    return "/" + t;
  },
  MR = {},
  ei = function (e, n, r) {
    let i = Promise.resolve();
    if (n && n.length > 0) {
      document.getElementsByTagName("link");
      const o = document.querySelector("meta[property=csp-nonce]"),
        a =
          (o == null ? void 0 : o.nonce) ||
          (o == null ? void 0 : o.getAttribute("nonce"));
      i = Promise.allSettled(
        n.map((l) => {
          if (((l = rJ(l)), l in MR)) return;
          MR[l] = !0;
          const d = l.endsWith(".css"),
            p = d ? '[rel="stylesheet"]' : "";
          if (document.querySelector(`link[href="${l}"]${p}`)) return;
          const f = document.createElement("link");
          if (
            ((f.rel = d ? "stylesheet" : nJ),
            d || (f.as = "script"),
            (f.crossOrigin = ""),
            (f.href = l),
            a && f.setAttribute("nonce", a),
            document.head.appendChild(f),
            d)
          )
            return new Promise((m, y) => {
              f.addEventListener("load", m),
                f.addEventListener("error", () =>
                  y(new Error(`Unable to preload CSS for ${l}`))
                );
            });
        })
      );
    }
    function s(o) {
      const a = new Event("vite:preloadError", { cancelable: !0 });
      if (((a.payload = o), window.dispatchEvent(a), !a.defaultPrevented))
        throw o;
    }
    return i.then((o) => {
      for (const a of o || []) a.status === "rejected" && s(a.reason);
      return e().catch(s);
    });
  };
async function iJ({ hash: t, signature: e }) {
  const n = zh(t) ? t : Ax(t),
    { secp256k1: r } = await ei(async () => {
      const { secp256k1: o } = await import("./secp256k1-t_wH3HBn.js");
      return { secp256k1: o };
    }, []);
  return `0x${(() => {
    if (typeof e == "object" && "r" in e && "s" in e) {
      const { r: d, s: p, v: f, yParity: m } = e,
        y = Number(m ?? f),
        g = LR(y);
      return new r.Signature(Sx(d), Sx(p)).addRecoveryBit(g);
    }
    const o = zh(e) ? e : Ax(e),
      a = bX(`0x${o.slice(130)}`),
      l = LR(a);
    return r.Signature.fromCompact(o.substring(2, 130)).addRecoveryBit(l);
  })()
    .recoverPublicKey(n.substring(2))
    .toHex(!1)}`;
}
function LR(t) {
  if (t === 0 || t === 1) return t;
  if (t === 27) return 0;
  if (t === 28) return 1;
  throw new Error("Invalid yParityOrV value");
}
async function sJ({ hash: t, signature: e }) {
  return tJ(await iJ({ hash: t, signature: e }));
}
function oJ(t) {
  if (t.length >= 255) throw new TypeError("Alphabet too long");
  const e = new Uint8Array(256);
  for (let d = 0; d < e.length; d++) e[d] = 255;
  for (let d = 0; d < t.length; d++) {
    const p = t.charAt(d),
      f = p.charCodeAt(0);
    if (e[f] !== 255) throw new TypeError(p + " is ambiguous");
    e[f] = d;
  }
  const n = t.length,
    r = t.charAt(0),
    i = Math.log(n) / Math.log(256),
    s = Math.log(256) / Math.log(n);
  function o(d) {
    if (
      (d instanceof Uint8Array ||
        (ArrayBuffer.isView(d)
          ? (d = new Uint8Array(d.buffer, d.byteOffset, d.byteLength))
          : Array.isArray(d) && (d = Uint8Array.from(d))),
      !(d instanceof Uint8Array))
    )
      throw new TypeError("Expected Uint8Array");
    if (d.length === 0) return "";
    let p = 0,
      f = 0,
      m = 0;
    const y = d.length;
    for (; m !== y && d[m] === 0; ) m++, p++;
    const g = ((y - m) * s + 1) >>> 0,
      v = new Uint8Array(g);
    for (; m !== y; ) {
      let S = d[m],
        C = 0;
      for (let _ = g - 1; (S !== 0 || C < f) && _ !== -1; _--, C++)
        (S += (256 * v[_]) >>> 0), (v[_] = S % n >>> 0), (S = (S / n) >>> 0);
      if (S !== 0) throw new Error("Non-zero carry");
      (f = C), m++;
    }
    let b = g - f;
    for (; b !== g && v[b] === 0; ) b++;
    let E = r.repeat(p);
    for (; b < g; ++b) E += t.charAt(v[b]);
    return E;
  }
  function a(d) {
    if (typeof d != "string") throw new TypeError("Expected String");
    if (d.length === 0) return new Uint8Array();
    let p = 0,
      f = 0,
      m = 0;
    for (; d[p] === r; ) f++, p++;
    const y = ((d.length - p) * i + 1) >>> 0,
      g = new Uint8Array(y);
    for (; d[p]; ) {
      let S = e[d.charCodeAt(p)];
      if (S === 255) return;
      let C = 0;
      for (let _ = y - 1; (S !== 0 || C < m) && _ !== -1; _--, C++)
        (S += (n * g[_]) >>> 0), (g[_] = S % 256 >>> 0), (S = (S / 256) >>> 0);
      if (S !== 0) throw new Error("Non-zero carry");
      (m = C), p++;
    }
    let v = y - m;
    for (; v !== y && g[v] === 0; ) v++;
    const b = new Uint8Array(f + (y - v));
    let E = f;
    for (; v !== y; ) b[E++] = g[v++];
    return b;
  }
  function l(d) {
    const p = a(d);
    if (p) return p;
    throw new Error("Non-base" + n + " character");
  }
  return { encode: o, decodeUnsafe: a, decode: l };
}
var aJ = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
const r$ = oJ(aJ);
function i$(t = 0) {
  return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null
    ? globalThis.Buffer.allocUnsafe(t)
    : new Uint8Array(t);
}
function yh(t, e) {
  e || (e = t.reduce((i, s) => i + s.length, 0));
  const n = i$(e);
  let r = 0;
  for (const i of t) n.set(i, r), (r += i.length);
  return n;
}
function cJ(t, e) {
  if (t.length >= 255) throw new TypeError("Alphabet too long");
  for (var n = new Uint8Array(256), r = 0; r < n.length; r++) n[r] = 255;
  for (var i = 0; i < t.length; i++) {
    var s = t.charAt(i),
      o = s.charCodeAt(0);
    if (n[o] !== 255) throw new TypeError(s + " is ambiguous");
    n[o] = i;
  }
  var a = t.length,
    l = t.charAt(0),
    d = Math.log(a) / Math.log(256),
    p = Math.log(256) / Math.log(a);
  function f(g) {
    if (
      (g instanceof Uint8Array ||
        (ArrayBuffer.isView(g)
          ? (g = new Uint8Array(g.buffer, g.byteOffset, g.byteLength))
          : Array.isArray(g) && (g = Uint8Array.from(g))),
      !(g instanceof Uint8Array))
    )
      throw new TypeError("Expected Uint8Array");
    if (g.length === 0) return "";
    for (var v = 0, b = 0, E = 0, S = g.length; E !== S && g[E] === 0; )
      E++, v++;
    for (var C = ((S - E) * p + 1) >>> 0, _ = new Uint8Array(C); E !== S; ) {
      for (
        var A = g[E], I = 0, R = C - 1;
        (A !== 0 || I < b) && R !== -1;
        R--, I++
      )
        (A += (256 * _[R]) >>> 0), (_[R] = A % a >>> 0), (A = (A / a) >>> 0);
      if (A !== 0) throw new Error("Non-zero carry");
      (b = I), E++;
    }
    for (var D = C - b; D !== C && _[D] === 0; ) D++;
    for (var k = l.repeat(v); D < C; ++D) k += t.charAt(_[D]);
    return k;
  }
  function m(g) {
    if (typeof g != "string") throw new TypeError("Expected String");
    if (g.length === 0) return new Uint8Array();
    var v = 0;
    if (g[v] !== " ") {
      for (var b = 0, E = 0; g[v] === l; ) b++, v++;
      for (
        var S = ((g.length - v) * d + 1) >>> 0, C = new Uint8Array(S);
        g[v];

      ) {
        var _ = n[g.charCodeAt(v)];
        if (_ === 255) return;
        for (var A = 0, I = S - 1; (_ !== 0 || A < E) && I !== -1; I--, A++)
          (_ += (a * C[I]) >>> 0),
            (C[I] = _ % 256 >>> 0),
            (_ = (_ / 256) >>> 0);
        if (_ !== 0) throw new Error("Non-zero carry");
        (E = A), v++;
      }
      if (g[v] !== " ") {
        for (var R = S - E; R !== S && C[R] === 0; ) R++;
        for (var D = new Uint8Array(b + (S - R)), k = b; R !== S; )
          D[k++] = C[R++];
        return D;
      }
    }
  }
  function y(g) {
    var v = m(g);
    if (v) return v;
    throw new Error(`Non-${e} character`);
  }
  return { encode: f, decodeUnsafe: m, decode: y };
}
var lJ = cJ,
  uJ = lJ;
const dJ = (t) => {
    if (t instanceof Uint8Array && t.constructor.name === "Uint8Array")
      return t;
    if (t instanceof ArrayBuffer) return new Uint8Array(t);
    if (ArrayBuffer.isView(t))
      return new Uint8Array(t.buffer, t.byteOffset, t.byteLength);
    throw new Error("Unknown type, must be binary type");
  },
  pJ = (t) => new TextEncoder().encode(t),
  fJ = (t) => new TextDecoder().decode(t);
class hJ {
  constructor(e, n, r) {
    (this.name = e), (this.prefix = n), (this.baseEncode = r);
  }
  encode(e) {
    if (e instanceof Uint8Array) return `${this.prefix}${this.baseEncode(e)}`;
    throw Error("Unknown type, must be binary type");
  }
}
class mJ {
  constructor(e, n, r) {
    if (((this.name = e), (this.prefix = n), n.codePointAt(0) === void 0))
      throw new Error("Invalid prefix character");
    (this.prefixCodePoint = n.codePointAt(0)), (this.baseDecode = r);
  }
  decode(e) {
    if (typeof e == "string") {
      if (e.codePointAt(0) !== this.prefixCodePoint)
        throw Error(
          `Unable to decode multibase string ${JSON.stringify(e)}, ${
            this.name
          } decoder only supports inputs prefixed with ${this.prefix}`
        );
      return this.baseDecode(e.slice(this.prefix.length));
    } else throw Error("Can only multibase decode strings");
  }
  or(e) {
    return s$(this, e);
  }
}
class gJ {
  constructor(e) {
    this.decoders = e;
  }
  or(e) {
    return s$(this, e);
  }
  decode(e) {
    const n = e[0],
      r = this.decoders[n];
    if (r) return r.decode(e);
    throw RangeError(
      `Unable to decode multibase string ${JSON.stringify(
        e
      )}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`
    );
  }
}
const s$ = (t, e) =>
  new gJ({
    ...(t.decoders || { [t.prefix]: t }),
    ...(e.decoders || { [e.prefix]: e }),
  });
class yJ {
  constructor(e, n, r, i) {
    (this.name = e),
      (this.prefix = n),
      (this.baseEncode = r),
      (this.baseDecode = i),
      (this.encoder = new hJ(e, n, r)),
      (this.decoder = new mJ(e, n, i));
  }
  encode(e) {
    return this.encoder.encode(e);
  }
  decode(e) {
    return this.decoder.decode(e);
  }
}
const Cv = ({ name: t, prefix: e, encode: n, decode: r }) => new yJ(t, e, n, r),
  Xm = ({ prefix: t, name: e, alphabet: n }) => {
    const { encode: r, decode: i } = uJ(n, e);
    return Cv({ prefix: t, name: e, encode: r, decode: (s) => dJ(i(s)) });
  },
  wJ = (t, e, n, r) => {
    const i = {};
    for (let p = 0; p < e.length; ++p) i[e[p]] = p;
    let s = t.length;
    for (; t[s - 1] === "="; ) --s;
    const o = new Uint8Array(((s * n) / 8) | 0);
    let a = 0,
      l = 0,
      d = 0;
    for (let p = 0; p < s; ++p) {
      const f = i[t[p]];
      if (f === void 0) throw new SyntaxError(`Non-${r} character`);
      (l = (l << n) | f),
        (a += n),
        a >= 8 && ((a -= 8), (o[d++] = 255 & (l >> a)));
    }
    if (a >= n || 255 & (l << (8 - a)))
      throw new SyntaxError("Unexpected end of data");
    return o;
  },
  vJ = (t, e, n) => {
    const r = e[e.length - 1] === "=",
      i = (1 << n) - 1;
    let s = "",
      o = 0,
      a = 0;
    for (let l = 0; l < t.length; ++l)
      for (a = (a << 8) | t[l], o += 8; o > n; )
        (o -= n), (s += e[i & (a >> o)]);
    if ((o && (s += e[i & (a << (n - o))]), r))
      for (; (s.length * n) & 7; ) s += "=";
    return s;
  },
  Or = ({ name: t, prefix: e, bitsPerChar: n, alphabet: r }) =>
    Cv({
      prefix: e,
      name: t,
      encode(i) {
        return vJ(i, r, n);
      },
      decode(i) {
        return wJ(i, r, n, t);
      },
    }),
  bJ = Cv({
    prefix: "\0",
    name: "identity",
    encode: (t) => fJ(t),
    decode: (t) => pJ(t),
  }),
  EJ = Object.freeze(
    Object.defineProperty(
      { __proto__: null, identity: bJ },
      Symbol.toStringTag,
      { value: "Module" }
    )
  ),
  CJ = Or({ prefix: "0", name: "base2", alphabet: "01", bitsPerChar: 1 }),
  xJ = Object.freeze(
    Object.defineProperty({ __proto__: null, base2: CJ }, Symbol.toStringTag, {
      value: "Module",
    })
  ),
  SJ = Or({ prefix: "7", name: "base8", alphabet: "01234567", bitsPerChar: 3 }),
  AJ = Object.freeze(
    Object.defineProperty({ __proto__: null, base8: SJ }, Symbol.toStringTag, {
      value: "Module",
    })
  ),
  _J = Xm({ prefix: "9", name: "base10", alphabet: "0123456789" }),
  IJ = Object.freeze(
    Object.defineProperty({ __proto__: null, base10: _J }, Symbol.toStringTag, {
      value: "Module",
    })
  ),
  TJ = Or({
    prefix: "f",
    name: "base16",
    alphabet: "0123456789abcdef",
    bitsPerChar: 4,
  }),
  PJ = Or({
    prefix: "F",
    name: "base16upper",
    alphabet: "0123456789ABCDEF",
    bitsPerChar: 4,
  }),
  RJ = Object.freeze(
    Object.defineProperty(
      { __proto__: null, base16: TJ, base16upper: PJ },
      Symbol.toStringTag,
      { value: "Module" }
    )
  ),
  NJ = Or({
    prefix: "b",
    name: "base32",
    alphabet: "abcdefghijklmnopqrstuvwxyz234567",
    bitsPerChar: 5,
  }),
  OJ = Or({
    prefix: "B",
    name: "base32upper",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
    bitsPerChar: 5,
  }),
  kJ = Or({
    prefix: "c",
    name: "base32pad",
    alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
    bitsPerChar: 5,
  }),
  DJ = Or({
    prefix: "C",
    name: "base32padupper",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
    bitsPerChar: 5,
  }),
  $J = Or({
    prefix: "v",
    name: "base32hex",
    alphabet: "0123456789abcdefghijklmnopqrstuv",
    bitsPerChar: 5,
  }),
  MJ = Or({
    prefix: "V",
    name: "base32hexupper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
    bitsPerChar: 5,
  }),
  LJ = Or({
    prefix: "t",
    name: "base32hexpad",
    alphabet: "0123456789abcdefghijklmnopqrstuv=",
    bitsPerChar: 5,
  }),
  UJ = Or({
    prefix: "T",
    name: "base32hexpadupper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
    bitsPerChar: 5,
  }),
  BJ = Or({
    prefix: "h",
    name: "base32z",
    alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
    bitsPerChar: 5,
  }),
  jJ = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        base32: NJ,
        base32hex: $J,
        base32hexpad: LJ,
        base32hexpadupper: UJ,
        base32hexupper: MJ,
        base32pad: kJ,
        base32padupper: DJ,
        base32upper: OJ,
        base32z: BJ,
      },
      Symbol.toStringTag,
      { value: "Module" }
    )
  ),
  FJ = Xm({
    prefix: "k",
    name: "base36",
    alphabet: "0123456789abcdefghijklmnopqrstuvwxyz",
  }),
  zJ = Xm({
    prefix: "K",
    name: "base36upper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ",
  }),
  WJ = Object.freeze(
    Object.defineProperty(
      { __proto__: null, base36: FJ, base36upper: zJ },
      Symbol.toStringTag,
      { value: "Module" }
    )
  ),
  HJ = Xm({
    name: "base58btc",
    prefix: "z",
    alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz",
  }),
  qJ = Xm({
    name: "base58flickr",
    prefix: "Z",
    alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ",
  }),
  VJ = Object.freeze(
    Object.defineProperty(
      { __proto__: null, base58btc: HJ, base58flickr: qJ },
      Symbol.toStringTag,
      { value: "Module" }
    )
  ),
  GJ = Or({
    prefix: "m",
    name: "base64",
    alphabet:
      "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
    bitsPerChar: 6,
  }),
  KJ = Or({
    prefix: "M",
    name: "base64pad",
    alphabet:
      "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
    bitsPerChar: 6,
  }),
  YJ = Or({
    prefix: "u",
    name: "base64url",
    alphabet:
      "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
    bitsPerChar: 6,
  }),
  ZJ = Or({
    prefix: "U",
    name: "base64urlpad",
    alphabet:
      "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
    bitsPerChar: 6,
  }),
  QJ = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        base64: GJ,
        base64pad: KJ,
        base64url: YJ,
        base64urlpad: ZJ,
      },
      Symbol.toStringTag,
      { value: "Module" }
    )
  ),
  o$ = Array.from(
    ""
  ),
  XJ = o$.reduce((t, e, n) => ((t[n] = e), t), []),
  JJ = o$.reduce((t, e, n) => ((t[e.codePointAt(0)] = n), t), []);
function eee(t) {
  return t.reduce((e, n) => ((e += XJ[n]), e), "");
}
function tee(t) {
  const e = [];
  for (const n of t) {
    const r = JJ[n.codePointAt(0)];
    if (r === void 0) throw new Error(`Non-base256emoji character: ${n}`);
    e.push(r);
  }
  return new Uint8Array(e);
}
const nee = Cv({
    prefix: "",
    name: "base256emoji",
    encode: eee,
    decode: tee,
  }),
  ree = Object.freeze(
    Object.defineProperty(
      { __proto__: null, base256emoji: nee },
      Symbol.toStringTag,
      { value: "Module" }
    )
  );
new TextEncoder();
new TextDecoder();
const UR = {
  ...EJ,
  ...xJ,
  ...AJ,
  ...IJ,
  ...RJ,
  ...jJ,
  ...WJ,
  ...VJ,
  ...QJ,
  ...ree,
};
function a$(t, e, n, r) {
  return {
    name: t,
    prefix: e,
    encoder: { name: t, prefix: e, encode: n },
    decoder: { decode: r },
  };
}
const BR = a$(
    "utf8",
    "u",
    (t) => "u" + new TextDecoder("utf8").decode(t),
    (t) => new TextEncoder().encode(t.substring(1))
  ),
  OE = a$(
    "ascii",
    "a",
    (t) => {
      let e = "a";
      for (let n = 0; n < t.length; n++) e += String.fromCharCode(t[n]);
      return e;
    },
    (t) => {
      t = t.substring(1);
      const e = i$(t.length);
      for (let n = 0; n < t.length; n++) e[n] = t.charCodeAt(n);
      return e;
    }
  ),
  c$ = {
    utf8: BR,
    "utf-8": BR,
    hex: UR.base16,
    latin1: OE,
    ascii: OE,
    binary: OE,
    ...UR,
  };
function fs(t, e = "utf8") {
  const n = c$[e];
  if (!n) throw new Error(`Unsupported encoding "${e}"`);
  return (e === "utf8" || e === "utf-8") &&
    globalThis.Buffer != null &&
    globalThis.Buffer.from != null
    ? globalThis.Buffer.from(t, "utf8")
    : n.decoder.decode(`${n.prefix}${t}`);
}
function xi(t, e = "utf8") {
  const n = c$[e];
  if (!n) throw new Error(`Unsupported encoding "${e}"`);
  return (e === "utf8" || e === "utf-8") &&
    globalThis.Buffer != null &&
    globalThis.Buffer.from != null
    ? globalThis.Buffer.from(t.buffer, t.byteOffset, t.byteLength).toString(
        "utf8"
      )
    : n.encoder.encode(t).substring(1);
}
const iee = {
  waku: {
    publish: "waku_publish",
    batchPublish: "waku_batchPublish",
    subscribe: "waku_subscribe",
    batchSubscribe: "waku_batchSubscribe",
    subscription: "waku_subscription",
    unsubscribe: "waku_unsubscribe",
    batchUnsubscribe: "waku_batchUnsubscribe",
    batchFetchMessages: "waku_batchFetchMessages",
  },
  irn: {
    publish: "irn_publish",
    batchPublish: "irn_batchPublish",
    subscribe: "irn_subscribe",
    batchSubscribe: "irn_batchSubscribe",
    subscription: "irn_subscription",
    unsubscribe: "irn_unsubscribe",
    batchUnsubscribe: "irn_batchUnsubscribe",
    batchFetchMessages: "irn_batchFetchMessages",
  },
  iridium: {
    publish: "iridium_publish",
    batchPublish: "iridium_batchPublish",
    subscribe: "iridium_subscribe",
    batchSubscribe: "iridium_batchSubscribe",
    subscription: "iridium_subscription",
    unsubscribe: "iridium_unsubscribe",
    batchUnsubscribe: "iridium_batchUnsubscribe",
    batchFetchMessages: "iridium_batchFetchMessages",
  },
};
var see = {};
const oee = ":";
function Nd(t) {
  const [e, n] = t.split(oee);
  return { namespace: e, reference: n };
}
function l$(t, e) {
  return t.includes(":") ? [t] : e.chains || [];
}
var aee = Object.defineProperty,
  cee = Object.defineProperties,
  lee = Object.getOwnPropertyDescriptors,
  jR = Object.getOwnPropertySymbols,
  uee = Object.prototype.hasOwnProperty,
  dee = Object.prototype.propertyIsEnumerable,
  FR = (t, e, n) =>
    e in t
      ? aee(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n })
      : (t[e] = n),
  zR = (t, e) => {
    for (var n in e || (e = {})) uee.call(e, n) && FR(t, n, e[n]);
    if (jR) for (var n of jR(e)) dee.call(e, n) && FR(t, n, e[n]);
    return t;
  },
  pee = (t, e) => cee(t, lee(e));
const fee = "ReactNative",
  Wi = {
    reactNative: "react-native",
    node: "node",
    browser: "browser",
    unknown: "unknown",
  },
  hee = "js";
function hw() {
  return (
    typeof process < "u" &&
    typeof process.versions < "u" &&
    typeof process.versions.node < "u"
  );
}
function Yc() {
  return !Ql.getDocument() && !!Ql.getNavigator() && navigator.product === fee;
}
function mee() {
  return (
    Yc() &&
    typeof global < "u" &&
    typeof (global == null ? void 0 : global.Platform) < "u" &&
    (global == null ? void 0 : global.Platform.OS) === "android"
  );
}
function gee() {
  return (
    Yc() &&
    typeof global < "u" &&
    typeof (global == null ? void 0 : global.Platform) < "u" &&
    (global == null ? void 0 : global.Platform.OS) === "ios"
  );
}
function Jm() {
  return !hw() && !!Ql.getNavigator() && !!Ql.getDocument();
}
function eg() {
  return Yc()
    ? Wi.reactNative
    : hw()
    ? Wi.node
    : Jm()
    ? Wi.browser
    : Wi.unknown;
}
function WR() {
  var t;
  try {
    return Yc() &&
      typeof global < "u" &&
      typeof (global == null ? void 0 : global.Application) < "u"
      ? (t = global.Application) == null
        ? void 0
        : t.applicationId
      : void 0;
  } catch {
    return;
  }
}
function yee(t, e) {
  const n = new URLSearchParams(t);
  for (const r of Object.keys(e).sort())
    if (e.hasOwnProperty(r)) {
      const i = e[r];
      i !== void 0 && n.set(r, i);
    }
  return n.toString();
}
function wee(t) {
  var e, n;
  const r = u$();
  try {
    return (
      t != null &&
        t.url &&
        r.url &&
        t.url !== r.url &&
        (console.warn(
          `The configured WalletConnect 'metadata.url':${t.url} differs from the actual page url:${r.url}. This is probably unintended and can lead to issues.`
        ),
        (t.url = r.url)),
      (e = t == null ? void 0 : t.icons) != null &&
        e.length &&
        t.icons.length > 0 &&
        (t.icons = t.icons.filter((i) => i !== "")),
      pee(zR(zR({}, r), t), {
        url: (t == null ? void 0 : t.url) || r.url,
        name: (t == null ? void 0 : t.name) || r.name,
        description: (t == null ? void 0 : t.description) || r.description,
        icons:
          (n = t == null ? void 0 : t.icons) != null &&
          n.length &&
          t.icons.length > 0
            ? t.icons
            : r.icons,
      })
    );
  } catch (i) {
    return console.warn("Error populating app metadata", i), t || r;
  }
}
function u$() {
  return (
    IQ.getWindowMetadata() || {
      name: "",
      description: "",
      url: "",
      icons: [""],
    }
  );
}
function vee() {
  if (
    eg() === Wi.reactNative &&
    typeof global < "u" &&
    typeof (global == null ? void 0 : global.Platform) < "u"
  ) {
    const { OS: n, Version: r } = global.Platform;
    return [n, r].join("-");
  }
  const t = bQ();
  if (t === null) return "unknown";
  const e = t.os ? t.os.replace(" ", "").toLowerCase() : "unknown";
  return t.type === "browser"
    ? [e, t.name, t.version].join("-")
    : [e, t.version].join("-");
}
function bee() {
  var t;
  const e = eg();
  return e === Wi.browser
    ? [e, ((t = Ql.getLocation()) == null ? void 0 : t.host) || "unknown"].join(
        ":"
      )
    : e;
}
function d$(t, e, n) {
  const r = vee(),
    i = bee();
  return [[t, e].join("-"), [hee, n].join("-"), r, i].join("/");
}
function Eee({
  protocol: t,
  version: e,
  relayUrl: n,
  sdkVersion: r,
  auth: i,
  projectId: s,
  useOnCloseEvent: o,
  bundleId: a,
  packageName: l,
}) {
  const d = n.split("?"),
    p = d$(t, e, r),
    f = {
      auth: i,
      ua: p,
      projectId: s,
      useOnCloseEvent: o || void 0,
      packageName: l || void 0,
      bundleId: a || void 0,
    },
    m = yee(d[1] || "", f);
  return d[0] + "?" + m;
}
function Pl(t, e) {
  return t.filter((n) => e.includes(n)).length === t.length;
}
function _x(t) {
  return Object.fromEntries(t.entries());
}
function Ix(t) {
  return new Map(Object.entries(t));
}
function vl(t = Ee.FIVE_MINUTES, e) {
  const n = Ee.toMiliseconds(t || Ee.FIVE_MINUTES);
  let r, i, s, o;
  return {
    resolve: (a) => {
      s && r && (clearTimeout(s), r(a), (o = Promise.resolve(a)));
    },
    reject: (a) => {
      s && i && (clearTimeout(s), i(a));
    },
    done: () =>
      new Promise((a, l) => {
        if (o) return a(o);
        (s = setTimeout(() => {
          const d = new Error(e);
          (o = Promise.reject(d)), l(d);
        }, n)),
          (r = a),
          (i = l);
      }),
  };
}
function Ic(t, e, n) {
  return new Promise(async (r, i) => {
    const s = setTimeout(() => i(new Error(n)), e);
    try {
      const o = await t;
      r(o);
    } catch (o) {
      i(o);
    }
    clearTimeout(s);
  });
}
function p$(t, e) {
  if (typeof e == "string" && e.startsWith(`${t}:`)) return e;
  if (t.toLowerCase() === "topic") {
    if (typeof e != "string")
      throw new Error('Value must be "string" for expirer target type: topic');
    return `topic:${e}`;
  } else if (t.toLowerCase() === "id") {
    if (typeof e != "number")
      throw new Error('Value must be "number" for expirer target type: id');
    return `id:${e}`;
  }
  throw new Error(`Unknown expirer target type: ${t}`);
}
function Cee(t) {
  return p$("topic", t);
}
function xee(t) {
  return p$("id", t);
}
function f$(t) {
  const [e, n] = t.split(":"),
    r = { id: void 0, topic: void 0 };
  if (e === "topic" && typeof n == "string") r.topic = n;
  else if (e === "id" && Number.isInteger(Number(n))) r.id = Number(n);
  else
    throw new Error(
      `Invalid target, expected id:number or topic:string, got ${e}:${n}`
    );
  return r;
}
function Zn(t, e) {
  return Ee.fromMiliseconds(Date.now() + Ee.toMiliseconds(t));
}
function fc(t) {
  return Date.now() >= Ee.toMiliseconds(t);
}
function jt(t, e) {
  return `${t}${e ? `:${e}` : ""}`;
}
function $0(t = [], e = []) {
  return [...new Set([...t, ...e])];
}
async function See({ id: t, topic: e, wcDeepLink: n }) {
  var r;
  try {
    if (!n) return;
    const i = typeof n == "string" ? JSON.parse(n) : n,
      s = i == null ? void 0 : i.href;
    if (typeof s != "string") return;
    const o = Aee(s, t, e),
      a = eg();
    if (a === Wi.browser) {
      if (!((r = Ql.getDocument()) != null && r.hasFocus())) {
        console.warn("Document does not have focus, skipping deeplink.");
        return;
      }
      _ee(o);
    } else
      a === Wi.reactNative &&
        typeof (global == null ? void 0 : global.Linking) < "u" &&
        (await global.Linking.openURL(o));
  } catch (i) {
    console.error(i);
  }
}
function Aee(t, e, n) {
  const r = `requestId=${e}&sessionTopic=${n}`;
  t.endsWith("/") && (t = t.slice(0, -1));
  let i = `${t}`;
  if (t.startsWith("https://t.me")) {
    const s = t.includes("?") ? "&startapp=" : "?startapp=";
    i = `${i}${s}${Ree(r, !0)}`;
  } else i = `${i}/wc?${r}`;
  return i;
}
function _ee(t) {
  let e = "_self";
  Pee()
    ? (e = "_top")
    : (Tee() || t.startsWith("https://") || t.startsWith("http://")) &&
      (e = "_blank"),
    window.open(t, e, "noreferrer noopener");
}
async function Iee(t, e) {
  let n = "";
  try {
    if (Jm() && ((n = localStorage.getItem(e)), n)) return n;
    n = await t.getItem(e);
  } catch (r) {
    console.error(r);
  }
  return n;
}
function HR(t, e) {
  if (!t.includes(e)) return null;
  const n = t.split(/([&,?,=])/),
    r = n.indexOf(e);
  return n[r + 2];
}
function qR() {
  return typeof crypto < "u" && crypto != null && crypto.randomUUID
    ? crypto.randomUUID()
    : "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/gu, (t) => {
        const e = (Math.random() * 16) | 0;
        return (t === "x" ? e : (e & 3) | 8).toString(16);
      });
}
function AA() {
  return typeof process < "u" && see.IS_VITEST === "true";
}
function Tee() {
  return (
    typeof window < "u" &&
    (!!window.TelegramWebviewProxy ||
      !!window.Telegram ||
      !!window.TelegramWebviewProxyProto)
  );
}
function Pee() {
  try {
    return window.self !== window.top;
  } catch {
    return !1;
  }
}
function Ree(t, e = !1) {
  const n = Buffer.from(t).toString("base64");
  return e ? n.replace(/[=]/g, "") : n;
}
function h$(t) {
  return Buffer.from(t, "base64").toString("utf-8");
}
function Nee(t) {
  return new Promise((e) => setTimeout(e, t));
}
function Wh(t) {
  if (!Number.isSafeInteger(t) || t < 0)
    throw new Error("positive integer expected, got " + t);
}
function Oee(t) {
  return (
    t instanceof Uint8Array ||
    (ArrayBuffer.isView(t) && t.constructor.name === "Uint8Array")
  );
}
function tg(t, ...e) {
  if (!Oee(t)) throw new Error("Uint8Array expected");
  if (e.length > 0 && !e.includes(t.length))
    throw new Error(
      "Uint8Array expected of length " + e + ", got length=" + t.length
    );
}
function _A(t) {
  if (typeof t != "function" || typeof t.create != "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  Wh(t.outputLen), Wh(t.blockLen);
}
function Jd(t, e = !0) {
  if (t.destroyed) throw new Error("Hash instance has been destroyed");
  if (e && t.finished) throw new Error("Hash#digest() has already been called");
}
function m$(t, e) {
  tg(t);
  const n = e.outputLen;
  if (t.length < n)
    throw new Error(
      "digestInto() expects output buffer of length at least " + n
    );
}
const Qy = BigInt(2 ** 32 - 1),
  VR = BigInt(32);
function kee(t, e = !1) {
  return e
    ? { h: Number(t & Qy), l: Number((t >> VR) & Qy) }
    : { h: Number((t >> VR) & Qy) | 0, l: Number(t & Qy) | 0 };
}
function Dee(t, e = !1) {
  let n = new Uint32Array(t.length),
    r = new Uint32Array(t.length);
  for (let i = 0; i < t.length; i++) {
    const { h: s, l: o } = kee(t[i], e);
    [n[i], r[i]] = [s, o];
  }
  return [n, r];
}
const $ee = (t, e, n) => (t << n) | (e >>> (32 - n)),
  Mee = (t, e, n) => (e << n) | (t >>> (32 - n)),
  Lee = (t, e, n) => (e << (n - 32)) | (t >>> (64 - n)),
  Uee = (t, e, n) => (t << (n - 32)) | (e >>> (64 - n)),
  Zu =
    typeof globalThis == "object" && "crypto" in globalThis
      ? globalThis.crypto
      : void 0;
function Bee(t) {
  return new Uint32Array(t.buffer, t.byteOffset, Math.floor(t.byteLength / 4));
}
function kE(t) {
  return new DataView(t.buffer, t.byteOffset, t.byteLength);
}
function uo(t, e) {
  return (t << (32 - e)) | (t >>> e);
}
const GR = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
function jee(t) {
  return (
    ((t << 24) & 4278190080) |
    ((t << 8) & 16711680) |
    ((t >>> 8) & 65280) |
    ((t >>> 24) & 255)
  );
}
function KR(t) {
  for (let e = 0; e < t.length; e++) t[e] = jee(t[e]);
}
function Fee(t) {
  if (typeof t != "string")
    throw new Error("utf8ToBytes expected string, got " + typeof t);
  return new Uint8Array(new TextEncoder().encode(t));
}
function ep(t) {
  return typeof t == "string" && (t = Fee(t)), tg(t), t;
}
function zee(...t) {
  let e = 0;
  for (let r = 0; r < t.length; r++) {
    const i = t[r];
    tg(i), (e += i.length);
  }
  const n = new Uint8Array(e);
  for (let r = 0, i = 0; r < t.length; r++) {
    const s = t[r];
    n.set(s, i), (i += s.length);
  }
  return n;
}
let IA = class {
  clone() {
    return this._cloneInto();
  }
};
function g$(t) {
  const e = (r) => t().update(ep(r)).digest(),
    n = t();
  return (
    (e.outputLen = n.outputLen),
    (e.blockLen = n.blockLen),
    (e.create = () => t()),
    e
  );
}
function Np(t = 32) {
  if (Zu && typeof Zu.getRandomValues == "function")
    return Zu.getRandomValues(new Uint8Array(t));
  if (Zu && typeof Zu.randomBytes == "function") return Zu.randomBytes(t);
  throw new Error("crypto.getRandomValues must be defined");
}
const y$ = [],
  w$ = [],
  v$ = [],
  Wee = BigInt(0),
  Ff = BigInt(1),
  Hee = BigInt(2),
  qee = BigInt(7),
  Vee = BigInt(256),
  Gee = BigInt(113);
for (let t = 0, e = Ff, n = 1, r = 0; t < 24; t++) {
  ([n, r] = [r, (2 * n + 3 * r) % 5]),
    y$.push(2 * (5 * r + n)),
    w$.push((((t + 1) * (t + 2)) / 2) % 64);
  let i = Wee;
  for (let s = 0; s < 7; s++)
    (e = ((e << Ff) ^ ((e >> qee) * Gee)) % Vee),
      e & Hee && (i ^= Ff << ((Ff << BigInt(s)) - Ff));
  v$.push(i);
}
const [Kee, Yee] = Dee(v$, !0),
  YR = (t, e, n) => (n > 32 ? Lee(t, e, n) : $ee(t, e, n)),
  ZR = (t, e, n) => (n > 32 ? Uee(t, e, n) : Mee(t, e, n));
function Zee(t, e = 24) {
  const n = new Uint32Array(10);
  for (let r = 24 - e; r < 24; r++) {
    for (let o = 0; o < 10; o++)
      n[o] = t[o] ^ t[o + 10] ^ t[o + 20] ^ t[o + 30] ^ t[o + 40];
    for (let o = 0; o < 10; o += 2) {
      const a = (o + 8) % 10,
        l = (o + 2) % 10,
        d = n[l],
        p = n[l + 1],
        f = YR(d, p, 1) ^ n[a],
        m = ZR(d, p, 1) ^ n[a + 1];
      for (let y = 0; y < 50; y += 10) (t[o + y] ^= f), (t[o + y + 1] ^= m);
    }
    let i = t[2],
      s = t[3];
    for (let o = 0; o < 24; o++) {
      const a = w$[o],
        l = YR(i, s, a),
        d = ZR(i, s, a),
        p = y$[o];
      (i = t[p]), (s = t[p + 1]), (t[p] = l), (t[p + 1] = d);
    }
    for (let o = 0; o < 50; o += 10) {
      for (let a = 0; a < 10; a++) n[a] = t[o + a];
      for (let a = 0; a < 10; a++)
        t[o + a] ^= ~n[(a + 2) % 10] & n[(a + 4) % 10];
    }
    (t[0] ^= Kee[r]), (t[1] ^= Yee[r]);
  }
  n.fill(0);
}
let Qee = class b$ extends IA {
  constructor(e, n, r, i = !1, s = 24) {
    if (
      (super(),
      (this.blockLen = e),
      (this.suffix = n),
      (this.outputLen = r),
      (this.enableXOF = i),
      (this.rounds = s),
      (this.pos = 0),
      (this.posOut = 0),
      (this.finished = !1),
      (this.destroyed = !1),
      Wh(r),
      0 >= this.blockLen || this.blockLen >= 200)
    )
      throw new Error("Sha3 supports only keccak-f1600 function");
    (this.state = new Uint8Array(200)), (this.state32 = Bee(this.state));
  }
  keccak() {
    GR || KR(this.state32),
      Zee(this.state32, this.rounds),
      GR || KR(this.state32),
      (this.posOut = 0),
      (this.pos = 0);
  }
  update(e) {
    Jd(this);
    const { blockLen: n, state: r } = this;
    e = ep(e);
    const i = e.length;
    for (let s = 0; s < i; ) {
      const o = Math.min(n - this.pos, i - s);
      for (let a = 0; a < o; a++) r[this.pos++] ^= e[s++];
      this.pos === n && this.keccak();
    }
    return this;
  }
  finish() {
    if (this.finished) return;
    this.finished = !0;
    const { state: e, suffix: n, pos: r, blockLen: i } = this;
    (e[r] ^= n),
      n & 128 && r === i - 1 && this.keccak(),
      (e[i - 1] ^= 128),
      this.keccak();
  }
  writeInto(e) {
    Jd(this, !1), tg(e), this.finish();
    const n = this.state,
      { blockLen: r } = this;
    for (let i = 0, s = e.length; i < s; ) {
      this.posOut >= r && this.keccak();
      const o = Math.min(r - this.posOut, s - i);
      e.set(n.subarray(this.posOut, this.posOut + o), i),
        (this.posOut += o),
        (i += o);
    }
    return e;
  }
  xofInto(e) {
    if (!this.enableXOF)
      throw new Error("XOF is not possible for this instance");
    return this.writeInto(e);
  }
  xof(e) {
    return Wh(e), this.xofInto(new Uint8Array(e));
  }
  digestInto(e) {
    if ((m$(e, this), this.finished))
      throw new Error("digest() was already called");
    return this.writeInto(e), this.destroy(), e;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
  destroy() {
    (this.destroyed = !0), this.state.fill(0);
  }
  _cloneInto(e) {
    const {
      blockLen: n,
      suffix: r,
      outputLen: i,
      rounds: s,
      enableXOF: o,
    } = this;
    return (
      e || (e = new b$(n, r, i, o, s)),
      e.state32.set(this.state32),
      (e.pos = this.pos),
      (e.posOut = this.posOut),
      (e.finished = this.finished),
      (e.rounds = s),
      (e.suffix = r),
      (e.outputLen = i),
      (e.enableXOF = o),
      (e.destroyed = this.destroyed),
      e
    );
  }
};
const Xee = (t, e, n) => g$(() => new Qee(e, t, n)),
  Jee = Xee(1, 136, 256 / 8),
  ete = "https://rpc.walletconnect.org/v1";
function E$(t) {
  const e = `Ethereum Signed Message:
${t.length}`,
    n = new TextEncoder().encode(e + t);
  return "0x" + Buffer.from(Jee(n)).toString("hex");
}
async function tte(t, e, n, r, i, s) {
  switch (n.t) {
    case "eip191":
      return await nte(t, e, n.s);
    case "eip1271":
      return await rte(t, e, n.s, r, i, s);
    default:
      throw new Error(
        `verifySignature failed: Attempted to verify CacaoSignature with unknown type: ${n.t}`
      );
  }
}
async function nte(t, e, n) {
  return (
    (await sJ({ hash: E$(e), signature: n })).toLowerCase() === t.toLowerCase()
  );
}
async function rte(t, e, n, r, i, s) {
  const o = Nd(r);
  if (!o.namespace || !o.reference)
    throw new Error(
      `isValidEip1271Signature failed: chainId must be in CAIP-2 format, received: ${r}`
    );
  try {
    const a = "0x1626ba7e",
      l = "0000000000000000000000000000000000000000000000000000000000000040",
      d = "0000000000000000000000000000000000000000000000000000000000000041",
      p = n.substring(2),
      f = E$(e).substring(2),
      m = a + f + l + d + p,
      y = await fetch(`${s || ete}/?chainId=${r}&projectId=${i}`, {
        method: "POST",
        body: JSON.stringify({
          id: ite(),
          jsonrpc: "2.0",
          method: "eth_call",
          params: [{ to: t, data: m }, "latest"],
        }),
      }),
      { result: g } = await y.json();
    return g ? g.slice(0, a.length).toLowerCase() === a.toLowerCase() : !1;
  } catch (a) {
    return console.error("isValidEip1271Signature: ", a), !1;
  }
}
function ite() {
  return Date.now() + Math.floor(Math.random() * 1e3);
}
function ste(t) {
  const e = atob(t),
    n = new Uint8Array(e.length);
  for (let o = 0; o < e.length; o++) n[o] = e.charCodeAt(o);
  const r = n[0];
  if (r === 0) throw new Error("No signatures found");
  const i = 1 + r * 64;
  if (n.length < i)
    throw new Error("Transaction data too short for claimed signature count");
  if (n.length < 100) throw new Error("Transaction too short");
  const s = Buffer.from(t, "base64").slice(1, 65);
  return r$.encode(s);
}
var ote = Object.defineProperty,
  ate = Object.defineProperties,
  cte = Object.getOwnPropertyDescriptors,
  QR = Object.getOwnPropertySymbols,
  lte = Object.prototype.hasOwnProperty,
  ute = Object.prototype.propertyIsEnumerable,
  XR = (t, e, n) =>
    e in t
      ? ote(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n })
      : (t[e] = n),
  dte = (t, e) => {
    for (var n in e || (e = {})) lte.call(e, n) && XR(t, n, e[n]);
    if (QR) for (var n of QR(e)) ute.call(e, n) && XR(t, n, e[n]);
    return t;
  },
  pte = (t, e) => ate(t, cte(e));
const fte = "did:pkh:",
  TA = (t) => (t == null ? void 0 : t.split(":")),
  hte = (t) => {
    const e = t && TA(t);
    if (e) return t.includes(fte) ? e[3] : e[1];
  },
  Tx = (t) => {
    const e = t && TA(t);
    if (e) return e[2] + ":" + e[3];
  },
  mw = (t) => {
    const e = t && TA(t);
    if (e) return e.pop();
  };
async function JR(t) {
  const { cacao: e, projectId: n } = t,
    { s: r, p: i } = e,
    s = C$(i, i.iss),
    o = mw(i.iss);
  return await tte(o, s, r, Tx(i.iss), n);
}
const C$ = (t, e) => {
  const n = `${t.domain} wants you to sign in with your Ethereum account:`,
    r = mw(e);
  if (!t.aud && !t.uri)
    throw new Error(
      "Either `aud` or `uri` is required to construct the message"
    );
  let i = t.statement || void 0;
  const s = `URI: ${t.aud || t.uri}`,
    o = `Version: ${t.version}`,
    a = `Chain ID: ${hte(e)}`,
    l = `Nonce: ${t.nonce}`,
    d = `Issued At: ${t.iat}`,
    p = t.exp ? `Expiration Time: ${t.exp}` : void 0,
    f = t.nbf ? `Not Before: ${t.nbf}` : void 0,
    m = t.requestId ? `Request ID: ${t.requestId}` : void 0,
    y = t.resources
      ? `Resources:${t.resources
          .map(
            (v) => `
- ${v}`
          )
          .join("")}`
      : void 0,
    g = M0(t.resources);
  if (g) {
    const v = Hh(g);
    i = xte(i, v);
  }
  return [n, r, "", i, "", s, o, a, l, d, p, f, m, y].filter((v) => v != null)
    .join(`
`);
};
function mte(t) {
  return Buffer.from(JSON.stringify(t)).toString("base64");
}
function gte(t) {
  return JSON.parse(Buffer.from(t, "base64").toString("utf-8"));
}
function Jl(t) {
  if (!t) throw new Error("No recap provided, value is undefined");
  if (!t.att) throw new Error("No `att` property found");
  const e = Object.keys(t.att);
  if (!(e != null && e.length))
    throw new Error("No resources found in `att` property");
  e.forEach((n) => {
    const r = t.att[n];
    if (Array.isArray(r)) throw new Error(`Resource must be an object: ${n}`);
    if (typeof r != "object")
      throw new Error(`Resource must be an object: ${n}`);
    if (!Object.keys(r).length)
      throw new Error(`Resource object is empty: ${n}`);
    Object.keys(r).forEach((i) => {
      const s = r[i];
      if (!Array.isArray(s))
        throw new Error(
          `Ability limits ${i} must be an array of objects, found: ${s}`
        );
      if (!s.length)
        throw new Error(
          `Value of ${i} is empty array, must be an array with objects`
        );
      s.forEach((o) => {
        if (typeof o != "object")
          throw new Error(
            `Ability limits (${i}) must be an array of objects, found: ${o}`
          );
      });
    });
  });
}
function yte(t, e, n, r = {}) {
  return (
    n == null || n.sort((i, s) => i.localeCompare(s)),
    { att: { [t]: wte(e, n, r) } }
  );
}
function wte(t, e, n = {}) {
  e = e == null ? void 0 : e.sort((i, s) => i.localeCompare(s));
  const r = e.map((i) => ({ [`${t}/${i}`]: [n] }));
  return Object.assign({}, ...r);
}
function x$(t) {
  return Jl(t), `urn:recap:${mte(t).replace(/=/g, "")}`;
}
function Hh(t) {
  const e = gte(t.replace("urn:recap:", ""));
  return Jl(e), e;
}
function vte(t, e, n) {
  const r = yte(t, e, n);
  return x$(r);
}
function bte(t) {
  return t && t.includes("urn:recap:");
}
function Ete(t, e) {
  const n = Hh(t),
    r = Hh(e),
    i = Cte(n, r);
  return x$(i);
}
function Cte(t, e) {
  Jl(t), Jl(e);
  const n = Object.keys(t.att)
      .concat(Object.keys(e.att))
      .sort((i, s) => i.localeCompare(s)),
    r = { att: {} };
  return (
    n.forEach((i) => {
      var s, o;
      Object.keys(((s = t.att) == null ? void 0 : s[i]) || {})
        .concat(Object.keys(((o = e.att) == null ? void 0 : o[i]) || {}))
        .sort((a, l) => a.localeCompare(l))
        .forEach((a) => {
          var l, d;
          r.att[i] = pte(dte({}, r.att[i]), {
            [a]:
              ((l = t.att[i]) == null ? void 0 : l[a]) ||
              ((d = e.att[i]) == null ? void 0 : d[a]),
          });
        });
    }),
    r
  );
}
function xte(t = "", e) {
  Jl(e);
  const n =
    "I further authorize the stated URI to perform the following actions on my behalf: ";
  if (t.includes(n)) return t;
  const r = [];
  let i = 0;
  Object.keys(e.att).forEach((a) => {
    const l = Object.keys(e.att[a]).map((f) => ({
      ability: f.split("/")[0],
      action: f.split("/")[1],
    }));
    l.sort((f, m) => f.action.localeCompare(m.action));
    const d = {};
    l.forEach((f) => {
      d[f.ability] || (d[f.ability] = []), d[f.ability].push(f.action);
    });
    const p = Object.keys(d).map(
      (f) => (i++, `(${i}) '${f}': '${d[f].join("', '")}' for '${a}'.`)
    );
    r.push(p.join(", ").replace(".,", "."));
  });
  const s = r.join(" "),
    o = `${n}${s}`;
  return `${t ? t + " " : ""}${o}`;
}
function eN(t) {
  var e;
  const n = Hh(t);
  Jl(n);
  const r = (e = n.att) == null ? void 0 : e.eip155;
  return r ? Object.keys(r).map((i) => i.split("/")[1]) : [];
}
function tN(t) {
  const e = Hh(t);
  Jl(e);
  const n = [];
  return (
    Object.values(e.att).forEach((r) => {
      Object.values(r).forEach((i) => {
        var s;
        (s = i == null ? void 0 : i[0]) != null &&
          s.chains &&
          n.push(i[0].chains);
      });
    }),
    [...new Set(n.flat())]
  );
}
function M0(t) {
  if (!t) return;
  const e = t == null ? void 0 : t[t.length - 1];
  return bte(e) ? e : void 0;
}
function DE(t) {
  if (!Number.isSafeInteger(t) || t < 0)
    throw new Error("positive integer expected, got " + t);
}
function S$(t) {
  return (
    t instanceof Uint8Array ||
    (ArrayBuffer.isView(t) && t.constructor.name === "Uint8Array")
  );
}
function ji(t, ...e) {
  if (!S$(t)) throw new Error("Uint8Array expected");
  if (e.length > 0 && !e.includes(t.length))
    throw new Error(
      "Uint8Array expected of length " + e + ", got length=" + t.length
    );
}
function nN(t, e = !0) {
  if (t.destroyed) throw new Error("Hash instance has been destroyed");
  if (e && t.finished) throw new Error("Hash#digest() has already been called");
}
function Ste(t, e) {
  ji(t);
  const n = e.outputLen;
  if (t.length < n)
    throw new Error(
      "digestInto() expects output buffer of length at least " + n
    );
}
function rN(t) {
  if (typeof t != "boolean") throw new Error(`boolean expected, not ${t}`);
}
const Rc = (t) =>
    new Uint32Array(t.buffer, t.byteOffset, Math.floor(t.byteLength / 4)),
  Ate = (t) => new DataView(t.buffer, t.byteOffset, t.byteLength),
  _te = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!_te) throw new Error("Non little-endian hardware is not supported");
function Ite(t) {
  if (typeof t != "string") throw new Error("string expected");
  return new Uint8Array(new TextEncoder().encode(t));
}
function Px(t) {
  if (typeof t == "string") t = Ite(t);
  else if (S$(t)) t = Rx(t);
  else throw new Error("Uint8Array expected, got " + typeof t);
  return t;
}
function Tte(t, e) {
  if (e == null || typeof e != "object")
    throw new Error("options must be defined");
  return Object.assign(t, e);
}
function Pte(t, e) {
  if (t.length !== e.length) return !1;
  let n = 0;
  for (let r = 0; r < t.length; r++) n |= t[r] ^ e[r];
  return n === 0;
}
const Rte = (t, e) => {
  function n(r, ...i) {
    if ((ji(r), t.nonceLength !== void 0)) {
      const d = i[0];
      if (!d) throw new Error("nonce / iv required");
      t.varSizeNonce ? ji(d) : ji(d, t.nonceLength);
    }
    const s = t.tagLength;
    s && i[1] !== void 0 && ji(i[1]);
    const o = e(r, ...i),
      a = (d, p) => {
        if (p !== void 0) {
          if (d !== 2) throw new Error("cipher output not supported");
          ji(p);
        }
      };
    let l = !1;
    return {
      encrypt(d, p) {
        if (l) throw new Error("cannot encrypt() twice with same key + nonce");
        return (l = !0), ji(d), a(o.encrypt.length, p), o.encrypt(d, p);
      },
      decrypt(d, p) {
        if ((ji(d), s && d.length < s))
          throw new Error(
            "invalid ciphertext length: smaller than tagLength=" + s
          );
        return a(o.decrypt.length, p), o.decrypt(d, p);
      },
    };
  }
  return Object.assign(n, t), n;
};
function iN(t, e, n = !0) {
  if (e === void 0) return new Uint8Array(t);
  if (e.length !== t)
    throw new Error(
      "invalid output length, expected " + t + ", got: " + e.length
    );
  if (n && !Nte(e)) throw new Error("invalid output, must be aligned");
  return e;
}
function sN(t, e, n, r) {
  if (typeof t.setBigUint64 == "function") return t.setBigUint64(e, n, r);
  const i = BigInt(32),
    s = BigInt(4294967295),
    o = Number((n >> i) & s),
    a = Number(n & s);
  t.setUint32(e + 4, o, r), t.setUint32(e + 0, a, r);
}
function Nte(t) {
  return t.byteOffset % 4 === 0;
}
function Rx(t) {
  return Uint8Array.from(t);
}
function tp(...t) {
  for (let e = 0; e < t.length; e++) t[e].fill(0);
}
const A$ = (t) => Uint8Array.from(t.split("").map((e) => e.charCodeAt(0))),
  Ote = A$("expand 16-byte k"),
  kte = A$("expand 32-byte k"),
  Dte = Rc(Ote),
  $te = Rc(kte);
function Nt(t, e) {
  return (t << e) | (t >>> (32 - e));
}
function Nx(t) {
  return t.byteOffset % 4 === 0;
}
const Xy = 64,
  Mte = 16,
  _$ = 2 ** 32 - 1,
  oN = new Uint32Array();
function Lte(t, e, n, r, i, s, o, a) {
  const l = i.length,
    d = new Uint8Array(Xy),
    p = Rc(d),
    f = Nx(i) && Nx(s),
    m = f ? Rc(i) : oN,
    y = f ? Rc(s) : oN;
  for (let g = 0; g < l; o++) {
    if ((t(e, n, r, p, o, a), o >= _$))
      throw new Error("arx: counter overflow");
    const v = Math.min(Xy, l - g);
    if (f && v === Xy) {
      const b = g / 4;
      if (g % 4 !== 0) throw new Error("arx: invalid block position");
      for (let E = 0, S; E < Mte; E++) (S = b + E), (y[S] = m[S] ^ p[E]);
      g += Xy;
      continue;
    }
    for (let b = 0, E; b < v; b++) (E = g + b), (s[E] = i[E] ^ d[b]);
    g += v;
  }
}
function Ute(t, e) {
  const {
    allowShortKeys: n,
    extendNonceFn: r,
    counterLength: i,
    counterRight: s,
    rounds: o,
  } = Tte(
    { allowShortKeys: !1, counterLength: 8, counterRight: !1, rounds: 20 },
    e
  );
  if (typeof t != "function") throw new Error("core must be a function");
  return (
    DE(i),
    DE(o),
    rN(s),
    rN(n),
    (a, l, d, p, f = 0) => {
      ji(a), ji(l), ji(d);
      const m = d.length;
      if (
        (p === void 0 && (p = new Uint8Array(m)),
        ji(p),
        DE(f),
        f < 0 || f >= _$)
      )
        throw new Error("arx: counter overflow");
      if (p.length < m)
        throw new Error(
          `arx: output (${p.length}) is shorter than data (${m})`
        );
      const y = [];
      let g = a.length,
        v,
        b;
      if (g === 32) y.push((v = Rx(a))), (b = $te);
      else if (g === 16 && n)
        (v = new Uint8Array(32)), v.set(a), v.set(a, 16), (b = Dte), y.push(v);
      else throw new Error(`arx: invalid 32-byte key, got length=${g}`);
      Nx(l) || y.push((l = Rx(l)));
      const E = Rc(v);
      if (r) {
        if (l.length !== 24)
          throw new Error("arx: extended nonce must be 24 bytes");
        r(b, E, Rc(l.subarray(0, 16)), E), (l = l.subarray(16));
      }
      const S = 16 - i;
      if (S !== l.length)
        throw new Error(`arx: nonce must be ${S} or 16 bytes`);
      if (S !== 12) {
        const _ = new Uint8Array(12);
        _.set(l, s ? 0 : 12 - l.length), (l = _), y.push(l);
      }
      const C = Rc(l);
      return Lte(t, b, E, C, d, p, f, o), tp(...y), p;
    }
  );
}
const xr = (t, e) => (t[e++] & 255) | ((t[e++] & 255) << 8);
class Bte {
  constructor(e) {
    (this.blockLen = 16),
      (this.outputLen = 16),
      (this.buffer = new Uint8Array(16)),
      (this.r = new Uint16Array(10)),
      (this.h = new Uint16Array(10)),
      (this.pad = new Uint16Array(8)),
      (this.pos = 0),
      (this.finished = !1),
      (e = Px(e)),
      ji(e, 32);
    const n = xr(e, 0),
      r = xr(e, 2),
      i = xr(e, 4),
      s = xr(e, 6),
      o = xr(e, 8),
      a = xr(e, 10),
      l = xr(e, 12),
      d = xr(e, 14);
    (this.r[0] = n & 8191),
      (this.r[1] = ((n >>> 13) | (r << 3)) & 8191),
      (this.r[2] = ((r >>> 10) | (i << 6)) & 7939),
      (this.r[3] = ((i >>> 7) | (s << 9)) & 8191),
      (this.r[4] = ((s >>> 4) | (o << 12)) & 255),
      (this.r[5] = (o >>> 1) & 8190),
      (this.r[6] = ((o >>> 14) | (a << 2)) & 8191),
      (this.r[7] = ((a >>> 11) | (l << 5)) & 8065),
      (this.r[8] = ((l >>> 8) | (d << 8)) & 8191),
      (this.r[9] = (d >>> 5) & 127);
    for (let p = 0; p < 8; p++) this.pad[p] = xr(e, 16 + 2 * p);
  }
  process(e, n, r = !1) {
    const i = r ? 0 : 2048,
      { h: s, r: o } = this,
      a = o[0],
      l = o[1],
      d = o[2],
      p = o[3],
      f = o[4],
      m = o[5],
      y = o[6],
      g = o[7],
      v = o[8],
      b = o[9],
      E = xr(e, n + 0),
      S = xr(e, n + 2),
      C = xr(e, n + 4),
      _ = xr(e, n + 6),
      A = xr(e, n + 8),
      I = xr(e, n + 10),
      R = xr(e, n + 12),
      D = xr(e, n + 14);
    let k = s[0] + (E & 8191),
      T = s[1] + (((E >>> 13) | (S << 3)) & 8191),
      U = s[2] + (((S >>> 10) | (C << 6)) & 8191),
      q = s[3] + (((C >>> 7) | (_ << 9)) & 8191),
      K = s[4] + (((_ >>> 4) | (A << 12)) & 8191),
      H = s[5] + ((A >>> 1) & 8191),
      $ = s[6] + (((A >>> 14) | (I << 2)) & 8191),
      M = s[7] + (((I >>> 11) | (R << 5)) & 8191),
      z = s[8] + (((R >>> 8) | (D << 8)) & 8191),
      B = s[9] + ((D >>> 5) | i),
      j = 0,
      V = j + k * a + T * (5 * b) + U * (5 * v) + q * (5 * g) + K * (5 * y);
    (j = V >>> 13),
      (V &= 8191),
      (V +=
        H * (5 * m) + $ * (5 * f) + M * (5 * p) + z * (5 * d) + B * (5 * l)),
      (j += V >>> 13),
      (V &= 8191);
    let W = j + k * l + T * a + U * (5 * b) + q * (5 * v) + K * (5 * g);
    (j = W >>> 13),
      (W &= 8191),
      (W +=
        H * (5 * y) + $ * (5 * m) + M * (5 * f) + z * (5 * p) + B * (5 * d)),
      (j += W >>> 13),
      (W &= 8191);
    let Z = j + k * d + T * l + U * a + q * (5 * b) + K * (5 * v);
    (j = Z >>> 13),
      (Z &= 8191),
      (Z +=
        H * (5 * g) + $ * (5 * y) + M * (5 * m) + z * (5 * f) + B * (5 * p)),
      (j += Z >>> 13),
      (Z &= 8191);
    let ee = j + k * p + T * d + U * l + q * a + K * (5 * b);
    (j = ee >>> 13),
      (ee &= 8191),
      (ee +=
        H * (5 * v) + $ * (5 * g) + M * (5 * y) + z * (5 * m) + B * (5 * f)),
      (j += ee >>> 13),
      (ee &= 8191);
    let J = j + k * f + T * p + U * d + q * l + K * a;
    (j = J >>> 13),
      (J &= 8191),
      (J +=
        H * (5 * b) + $ * (5 * v) + M * (5 * g) + z * (5 * y) + B * (5 * m)),
      (j += J >>> 13),
      (J &= 8191);
    let se = j + k * m + T * f + U * p + q * d + K * l;
    (j = se >>> 13),
      (se &= 8191),
      (se += H * a + $ * (5 * b) + M * (5 * v) + z * (5 * g) + B * (5 * y)),
      (j += se >>> 13),
      (se &= 8191);
    let re = j + k * y + T * m + U * f + q * p + K * d;
    (j = re >>> 13),
      (re &= 8191),
      (re += H * l + $ * a + M * (5 * b) + z * (5 * v) + B * (5 * g)),
      (j += re >>> 13),
      (re &= 8191);
    let fe = j + k * g + T * y + U * m + q * f + K * p;
    (j = fe >>> 13),
      (fe &= 8191),
      (fe += H * d + $ * l + M * a + z * (5 * b) + B * (5 * v)),
      (j += fe >>> 13),
      (fe &= 8191);
    let ce = j + k * v + T * g + U * y + q * m + K * f;
    (j = ce >>> 13),
      (ce &= 8191),
      (ce += H * p + $ * d + M * l + z * a + B * (5 * b)),
      (j += ce >>> 13),
      (ce &= 8191);
    let le = j + k * b + T * v + U * g + q * y + K * m;
    (j = le >>> 13),
      (le &= 8191),
      (le += H * f + $ * p + M * d + z * l + B * a),
      (j += le >>> 13),
      (le &= 8191),
      (j = ((j << 2) + j) | 0),
      (j = (j + V) | 0),
      (V = j & 8191),
      (j = j >>> 13),
      (W += j),
      (s[0] = V),
      (s[1] = W),
      (s[2] = Z),
      (s[3] = ee),
      (s[4] = J),
      (s[5] = se),
      (s[6] = re),
      (s[7] = fe),
      (s[8] = ce),
      (s[9] = le);
  }
  finalize() {
    const { h: e, pad: n } = this,
      r = new Uint16Array(10);
    let i = e[1] >>> 13;
    e[1] &= 8191;
    for (let a = 2; a < 10; a++) (e[a] += i), (i = e[a] >>> 13), (e[a] &= 8191);
    (e[0] += i * 5),
      (i = e[0] >>> 13),
      (e[0] &= 8191),
      (e[1] += i),
      (i = e[1] >>> 13),
      (e[1] &= 8191),
      (e[2] += i),
      (r[0] = e[0] + 5),
      (i = r[0] >>> 13),
      (r[0] &= 8191);
    for (let a = 1; a < 10; a++)
      (r[a] = e[a] + i), (i = r[a] >>> 13), (r[a] &= 8191);
    r[9] -= 8192;
    let s = (i ^ 1) - 1;
    for (let a = 0; a < 10; a++) r[a] &= s;
    s = ~s;
    for (let a = 0; a < 10; a++) e[a] = (e[a] & s) | r[a];
    (e[0] = (e[0] | (e[1] << 13)) & 65535),
      (e[1] = ((e[1] >>> 3) | (e[2] << 10)) & 65535),
      (e[2] = ((e[2] >>> 6) | (e[3] << 7)) & 65535),
      (e[3] = ((e[3] >>> 9) | (e[4] << 4)) & 65535),
      (e[4] = ((e[4] >>> 12) | (e[5] << 1) | (e[6] << 14)) & 65535),
      (e[5] = ((e[6] >>> 2) | (e[7] << 11)) & 65535),
      (e[6] = ((e[7] >>> 5) | (e[8] << 8)) & 65535),
      (e[7] = ((e[8] >>> 8) | (e[9] << 5)) & 65535);
    let o = e[0] + n[0];
    e[0] = o & 65535;
    for (let a = 1; a < 8; a++)
      (o = (((e[a] + n[a]) | 0) + (o >>> 16)) | 0), (e[a] = o & 65535);
    tp(r);
  }
  update(e) {
    nN(this);
    const { buffer: n, blockLen: r } = this;
    e = Px(e);
    const i = e.length;
    for (let s = 0; s < i; ) {
      const o = Math.min(r - this.pos, i - s);
      if (o === r) {
        for (; r <= i - s; s += r) this.process(e, s);
        continue;
      }
      n.set(e.subarray(s, s + o), this.pos),
        (this.pos += o),
        (s += o),
        this.pos === r && (this.process(n, 0, !1), (this.pos = 0));
    }
    return this;
  }
  destroy() {
    tp(this.h, this.r, this.buffer, this.pad);
  }
  digestInto(e) {
    nN(this), Ste(e, this), (this.finished = !0);
    const { buffer: n, h: r } = this;
    let { pos: i } = this;
    if (i) {
      for (n[i++] = 1; i < 16; i++) n[i] = 0;
      this.process(n, 0, !0);
    }
    this.finalize();
    let s = 0;
    for (let o = 0; o < 8; o++) (e[s++] = r[o] >>> 0), (e[s++] = r[o] >>> 8);
    return e;
  }
  digest() {
    const { buffer: e, outputLen: n } = this;
    this.digestInto(e);
    const r = e.slice(0, n);
    return this.destroy(), r;
  }
}
function jte(t) {
  const e = (r, i) => t(i).update(Px(r)).digest(),
    n = t(new Uint8Array(32));
  return (
    (e.outputLen = n.outputLen),
    (e.blockLen = n.blockLen),
    (e.create = (r) => t(r)),
    e
  );
}
const Fte = jte((t) => new Bte(t));
function zte(t, e, n, r, i, s = 20) {
  let o = t[0],
    a = t[1],
    l = t[2],
    d = t[3],
    p = e[0],
    f = e[1],
    m = e[2],
    y = e[3],
    g = e[4],
    v = e[5],
    b = e[6],
    E = e[7],
    S = i,
    C = n[0],
    _ = n[1],
    A = n[2],
    I = o,
    R = a,
    D = l,
    k = d,
    T = p,
    U = f,
    q = m,
    K = y,
    H = g,
    $ = v,
    M = b,
    z = E,
    B = S,
    j = C,
    V = _,
    W = A;
  for (let ee = 0; ee < s; ee += 2)
    (I = (I + T) | 0),
      (B = Nt(B ^ I, 16)),
      (H = (H + B) | 0),
      (T = Nt(T ^ H, 12)),
      (I = (I + T) | 0),
      (B = Nt(B ^ I, 8)),
      (H = (H + B) | 0),
      (T = Nt(T ^ H, 7)),
      (R = (R + U) | 0),
      (j = Nt(j ^ R, 16)),
      ($ = ($ + j) | 0),
      (U = Nt(U ^ $, 12)),
      (R = (R + U) | 0),
      (j = Nt(j ^ R, 8)),
      ($ = ($ + j) | 0),
      (U = Nt(U ^ $, 7)),
      (D = (D + q) | 0),
      (V = Nt(V ^ D, 16)),
      (M = (M + V) | 0),
      (q = Nt(q ^ M, 12)),
      (D = (D + q) | 0),
      (V = Nt(V ^ D, 8)),
      (M = (M + V) | 0),
      (q = Nt(q ^ M, 7)),
      (k = (k + K) | 0),
      (W = Nt(W ^ k, 16)),
      (z = (z + W) | 0),
      (K = Nt(K ^ z, 12)),
      (k = (k + K) | 0),
      (W = Nt(W ^ k, 8)),
      (z = (z + W) | 0),
      (K = Nt(K ^ z, 7)),
      (I = (I + U) | 0),
      (W = Nt(W ^ I, 16)),
      (M = (M + W) | 0),
      (U = Nt(U ^ M, 12)),
      (I = (I + U) | 0),
      (W = Nt(W ^ I, 8)),
      (M = (M + W) | 0),
      (U = Nt(U ^ M, 7)),
      (R = (R + q) | 0),
      (B = Nt(B ^ R, 16)),
      (z = (z + B) | 0),
      (q = Nt(q ^ z, 12)),
      (R = (R + q) | 0),
      (B = Nt(B ^ R, 8)),
      (z = (z + B) | 0),
      (q = Nt(q ^ z, 7)),
      (D = (D + K) | 0),
      (j = Nt(j ^ D, 16)),
      (H = (H + j) | 0),
      (K = Nt(K ^ H, 12)),
      (D = (D + K) | 0),
      (j = Nt(j ^ D, 8)),
      (H = (H + j) | 0),
      (K = Nt(K ^ H, 7)),
      (k = (k + T) | 0),
      (V = Nt(V ^ k, 16)),
      ($ = ($ + V) | 0),
      (T = Nt(T ^ $, 12)),
      (k = (k + T) | 0),
      (V = Nt(V ^ k, 8)),
      ($ = ($ + V) | 0),
      (T = Nt(T ^ $, 7));
  let Z = 0;
  (r[Z++] = (o + I) | 0),
    (r[Z++] = (a + R) | 0),
    (r[Z++] = (l + D) | 0),
    (r[Z++] = (d + k) | 0),
    (r[Z++] = (p + T) | 0),
    (r[Z++] = (f + U) | 0),
    (r[Z++] = (m + q) | 0),
    (r[Z++] = (y + K) | 0),
    (r[Z++] = (g + H) | 0),
    (r[Z++] = (v + $) | 0),
    (r[Z++] = (b + M) | 0),
    (r[Z++] = (E + z) | 0),
    (r[Z++] = (S + B) | 0),
    (r[Z++] = (C + j) | 0),
    (r[Z++] = (_ + V) | 0),
    (r[Z++] = (A + W) | 0);
}
const Wte = Ute(zte, {
    counterRight: !1,
    counterLength: 4,
    allowShortKeys: !1,
  }),
  Hte = new Uint8Array(16),
  aN = (t, e) => {
    t.update(e);
    const n = e.length % 16;
    n && t.update(Hte.subarray(n));
  },
  qte = new Uint8Array(32);
function cN(t, e, n, r, i) {
  const s = t(e, n, qte),
    o = Fte.create(s);
  i && aN(o, i), aN(o, r);
  const a = new Uint8Array(16),
    l = Ate(a);
  sN(l, 0, BigInt(i ? i.length : 0), !0),
    sN(l, 8, BigInt(r.length), !0),
    o.update(a);
  const d = o.digest();
  return tp(s, a), d;
}
const Vte = (t) => (e, n, r) => ({
    encrypt(i, s) {
      const o = i.length;
      (s = iN(o + 16, s, !1)), s.set(i);
      const a = s.subarray(0, -16);
      t(e, n, a, a, 1);
      const l = cN(t, e, n, a, r);
      return s.set(l, o), tp(l), s;
    },
    decrypt(i, s) {
      s = iN(i.length - 16, s, !1);
      const o = i.subarray(0, -16),
        a = i.subarray(-16),
        l = cN(t, e, n, o, r);
      if (!Pte(a, l)) throw new Error("invalid tag");
      return s.set(i.subarray(0, -16)), t(e, n, s, s, 1), tp(l), s;
    },
  }),
  I$ = Rte({ blockSize: 64, nonceLength: 12, tagLength: 16 }, Vte(Wte));
let T$ = class extends IA {
  constructor(e, n) {
    super(), (this.finished = !1), (this.destroyed = !1), _A(e);
    const r = ep(n);
    if (((this.iHash = e.create()), typeof this.iHash.update != "function"))
      throw new Error("Expected instance of class which extends utils.Hash");
    (this.blockLen = this.iHash.blockLen),
      (this.outputLen = this.iHash.outputLen);
    const i = this.blockLen,
      s = new Uint8Array(i);
    s.set(r.length > i ? e.create().update(r).digest() : r);
    for (let o = 0; o < s.length; o++) s[o] ^= 54;
    this.iHash.update(s), (this.oHash = e.create());
    for (let o = 0; o < s.length; o++) s[o] ^= 106;
    this.oHash.update(s), s.fill(0);
  }
  update(e) {
    return Jd(this), this.iHash.update(e), this;
  }
  digestInto(e) {
    Jd(this),
      tg(e, this.outputLen),
      (this.finished = !0),
      this.iHash.digestInto(e),
      this.oHash.update(e),
      this.oHash.digestInto(e),
      this.destroy();
  }
  digest() {
    const e = new Uint8Array(this.oHash.outputLen);
    return this.digestInto(e), e;
  }
  _cloneInto(e) {
    e || (e = Object.create(Object.getPrototypeOf(this), {}));
    const {
      oHash: n,
      iHash: r,
      finished: i,
      destroyed: s,
      blockLen: o,
      outputLen: a,
    } = this;
    return (
      (e = e),
      (e.finished = i),
      (e.destroyed = s),
      (e.blockLen = o),
      (e.outputLen = a),
      (e.oHash = n._cloneInto(e.oHash)),
      (e.iHash = r._cloneInto(e.iHash)),
      e
    );
  }
  destroy() {
    (this.destroyed = !0), this.oHash.destroy(), this.iHash.destroy();
  }
};
const xv = (t, e, n) => new T$(t, e).update(n).digest();
xv.create = (t, e) => new T$(t, e);
function Gte(t, e, n) {
  return (
    _A(t),
    n === void 0 && (n = new Uint8Array(t.outputLen)),
    xv(t, ep(n), ep(e))
  );
}
const $E = new Uint8Array([0]),
  lN = new Uint8Array();
function Kte(t, e, n, r = 32) {
  if ((_A(t), Wh(r), r > 255 * t.outputLen))
    throw new Error("Length should be <= 255*HashLen");
  const i = Math.ceil(r / t.outputLen);
  n === void 0 && (n = lN);
  const s = new Uint8Array(i * t.outputLen),
    o = xv.create(t, e),
    a = o._cloneInto(),
    l = new Uint8Array(o.outputLen);
  for (let d = 0; d < i; d++)
    ($E[0] = d + 1),
      a
        .update(d === 0 ? lN : l)
        .update(n)
        .update($E)
        .digestInto(l),
      s.set(l, t.outputLen * d),
      o._cloneInto(a);
  return o.destroy(), a.destroy(), l.fill(0), $E.fill(0), s.slice(0, r);
}
const Yte = (t, e, n, r, i) => Kte(t, Gte(t, e, n), r, i);
function Zte(t, e, n, r) {
  if (typeof t.setBigUint64 == "function") return t.setBigUint64(e, n, r);
  const i = BigInt(32),
    s = BigInt(4294967295),
    o = Number((n >> i) & s),
    a = Number(n & s),
    l = r ? 4 : 0,
    d = r ? 0 : 4;
  t.setUint32(e + l, o, r), t.setUint32(e + d, a, r);
}
function Qte(t, e, n) {
  return (t & e) ^ (~t & n);
}
function Xte(t, e, n) {
  return (t & e) ^ (t & n) ^ (e & n);
}
let Jte = class extends IA {
  constructor(e, n, r, i) {
    super(),
      (this.blockLen = e),
      (this.outputLen = n),
      (this.padOffset = r),
      (this.isLE = i),
      (this.finished = !1),
      (this.length = 0),
      (this.pos = 0),
      (this.destroyed = !1),
      (this.buffer = new Uint8Array(e)),
      (this.view = kE(this.buffer));
  }
  update(e) {
    Jd(this);
    const { view: n, buffer: r, blockLen: i } = this;
    e = ep(e);
    const s = e.length;
    for (let o = 0; o < s; ) {
      const a = Math.min(i - this.pos, s - o);
      if (a === i) {
        const l = kE(e);
        for (; i <= s - o; o += i) this.process(l, o);
        continue;
      }
      r.set(e.subarray(o, o + a), this.pos),
        (this.pos += a),
        (o += a),
        this.pos === i && (this.process(n, 0), (this.pos = 0));
    }
    return (this.length += e.length), this.roundClean(), this;
  }
  digestInto(e) {
    Jd(this), m$(e, this), (this.finished = !0);
    const { buffer: n, view: r, blockLen: i, isLE: s } = this;
    let { pos: o } = this;
    (n[o++] = 128),
      this.buffer.subarray(o).fill(0),
      this.padOffset > i - o && (this.process(r, 0), (o = 0));
    for (let f = o; f < i; f++) n[f] = 0;
    Zte(r, i - 8, BigInt(this.length * 8), s), this.process(r, 0);
    const a = kE(e),
      l = this.outputLen;
    if (l % 4) throw new Error("_sha2: outputLen should be aligned to 32bit");
    const d = l / 4,
      p = this.get();
    if (d > p.length) throw new Error("_sha2: outputLen bigger than state");
    for (let f = 0; f < d; f++) a.setUint32(4 * f, p[f], s);
  }
  digest() {
    const { buffer: e, outputLen: n } = this;
    this.digestInto(e);
    const r = e.slice(0, n);
    return this.destroy(), r;
  }
  _cloneInto(e) {
    e || (e = new this.constructor()), e.set(...this.get());
    const {
      blockLen: n,
      buffer: r,
      length: i,
      finished: s,
      destroyed: o,
      pos: a,
    } = this;
    return (
      (e.length = i),
      (e.pos = a),
      (e.finished = s),
      (e.destroyed = o),
      i % n && e.buffer.set(r),
      e
    );
  }
};
const ene = new Uint32Array([
    1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993,
    2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987,
    1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774,
    264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986,
    2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711,
    113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291,
    1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411,
    3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344,
    430227734, 506948616, 659060556, 883997877, 958139571, 1322822218,
    1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424,
    2428436474, 2756734187, 3204031479, 3329325298,
  ]),
  sc = new Uint32Array([
    1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924,
    528734635, 1541459225,
  ]),
  oc = new Uint32Array(64);
class tne extends Jte {
  constructor() {
    super(64, 32, 8, !1),
      (this.A = sc[0] | 0),
      (this.B = sc[1] | 0),
      (this.C = sc[2] | 0),
      (this.D = sc[3] | 0),
      (this.E = sc[4] | 0),
      (this.F = sc[5] | 0),
      (this.G = sc[6] | 0),
      (this.H = sc[7] | 0);
  }
  get() {
    const { A: e, B: n, C: r, D: i, E: s, F: o, G: a, H: l } = this;
    return [e, n, r, i, s, o, a, l];
  }
  set(e, n, r, i, s, o, a, l) {
    (this.A = e | 0),
      (this.B = n | 0),
      (this.C = r | 0),
      (this.D = i | 0),
      (this.E = s | 0),
      (this.F = o | 0),
      (this.G = a | 0),
      (this.H = l | 0);
  }
  process(e, n) {
    for (let f = 0; f < 16; f++, n += 4) oc[f] = e.getUint32(n, !1);
    for (let f = 16; f < 64; f++) {
      const m = oc[f - 15],
        y = oc[f - 2],
        g = uo(m, 7) ^ uo(m, 18) ^ (m >>> 3),
        v = uo(y, 17) ^ uo(y, 19) ^ (y >>> 10);
      oc[f] = (v + oc[f - 7] + g + oc[f - 16]) | 0;
    }
    let { A: r, B: i, C: s, D: o, E: a, F: l, G: d, H: p } = this;
    for (let f = 0; f < 64; f++) {
      const m = uo(a, 6) ^ uo(a, 11) ^ uo(a, 25),
        y = (p + m + Qte(a, l, d) + ene[f] + oc[f]) | 0,
        g = ((uo(r, 2) ^ uo(r, 13) ^ uo(r, 22)) + Xte(r, i, s)) | 0;
      (p = d),
        (d = l),
        (l = a),
        (a = (o + y) | 0),
        (o = s),
        (s = i),
        (i = r),
        (r = (y + g) | 0);
    }
    (r = (r + this.A) | 0),
      (i = (i + this.B) | 0),
      (s = (s + this.C) | 0),
      (o = (o + this.D) | 0),
      (a = (a + this.E) | 0),
      (l = (l + this.F) | 0),
      (d = (d + this.G) | 0),
      (p = (p + this.H) | 0),
      this.set(r, i, s, o, a, l, d, p);
  }
  roundClean() {
    oc.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
  }
}
const ng = g$(() => new tne());
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const Sv =
    BigInt(0),
  Av = BigInt(1),
  nne = BigInt(2);
function eu(t) {
  return (
    t instanceof Uint8Array ||
    (ArrayBuffer.isView(t) && t.constructor.name === "Uint8Array")
  );
}
function rg(t) {
  if (!eu(t)) throw new Error("Uint8Array expected");
}
function np(t, e) {
  if (typeof e != "boolean") throw new Error(t + " boolean expected, got " + e);
}
const rne = Array.from({ length: 256 }, (t, e) =>
  e.toString(16).padStart(2, "0")
);
function rp(t) {
  rg(t);
  let e = "";
  for (let n = 0; n < t.length; n++) e += rne[t[n]];
  return e;
}
function Sd(t) {
  const e = t.toString(16);
  return e.length & 1 ? "0" + e : e;
}
function PA(t) {
  if (typeof t != "string")
    throw new Error("hex string expected, got " + typeof t);
  return t === "" ? Sv : BigInt("0x" + t);
}
const na = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
function uN(t) {
  if (t >= na._0 && t <= na._9) return t - na._0;
  if (t >= na.A && t <= na.F) return t - (na.A - 10);
  if (t >= na.a && t <= na.f) return t - (na.a - 10);
}
function ip(t) {
  if (typeof t != "string")
    throw new Error("hex string expected, got " + typeof t);
  const e = t.length,
    n = e / 2;
  if (e % 2)
    throw new Error("hex string expected, got unpadded hex of length " + e);
  const r = new Uint8Array(n);
  for (let i = 0, s = 0; i < n; i++, s += 2) {
    const o = uN(t.charCodeAt(s)),
      a = uN(t.charCodeAt(s + 1));
    if (o === void 0 || a === void 0) {
      const l = t[s] + t[s + 1];
      throw new Error(
        'hex string expected, got non-hex character "' + l + '" at index ' + s
      );
    }
    r[i] = o * 16 + a;
  }
  return r;
}
function Fl(t) {
  return PA(rp(t));
}
function qh(t) {
  return rg(t), PA(rp(Uint8Array.from(t).reverse()));
}
function sp(t, e) {
  return ip(t.toString(16).padStart(e * 2, "0"));
}
function _v(t, e) {
  return sp(t, e).reverse();
}
function ine(t) {
  return ip(Sd(t));
}
function Bi(t, e, n) {
  let r;
  if (typeof e == "string")
    try {
      r = ip(e);
    } catch (s) {
      throw new Error(t + " must be hex string or Uint8Array, cause: " + s);
    }
  else if (eu(e)) r = Uint8Array.from(e);
  else throw new Error(t + " must be hex string or Uint8Array");
  const i = r.length;
  if (typeof n == "number" && i !== n)
    throw new Error(t + " of length " + n + " expected, got " + i);
  return r;
}
function Vh(...t) {
  let e = 0;
  for (let r = 0; r < t.length; r++) {
    const i = t[r];
    rg(i), (e += i.length);
  }
  const n = new Uint8Array(e);
  for (let r = 0, i = 0; r < t.length; r++) {
    const s = t[r];
    n.set(s, i), (i += s.length);
  }
  return n;
}
function sne(t, e) {
  if (t.length !== e.length) return !1;
  let n = 0;
  for (let r = 0; r < t.length; r++) n |= t[r] ^ e[r];
  return n === 0;
}
function one(t) {
  if (typeof t != "string") throw new Error("string expected");
  return new Uint8Array(new TextEncoder().encode(t));
}
const ME = (t) => typeof t == "bigint" && Sv <= t;
function Iv(t, e, n) {
  return ME(t) && ME(e) && ME(n) && e <= t && t < n;
}
function ya(t, e, n, r) {
  if (!Iv(e, n, r))
    throw new Error(
      "expected valid " + t + ": " + n + " <= n < " + r + ", got " + e
    );
}
function P$(t) {
  let e;
  for (e = 0; t > Sv; t >>= Av, e += 1);
  return e;
}
function ane(t, e) {
  return (t >> BigInt(e)) & Av;
}
function cne(t, e, n) {
  return t | ((n ? Av : Sv) << BigInt(e));
}
const RA = (t) => (nne << BigInt(t - 1)) - Av,
  LE = (t) => new Uint8Array(t),
  dN = (t) => Uint8Array.from(t);
function R$(t, e, n) {
  if (typeof t != "number" || t < 2)
    throw new Error("hashLen must be a number");
  if (typeof e != "number" || e < 2)
    throw new Error("qByteLen must be a number");
  if (typeof n != "function") throw new Error("hmacFn must be a function");
  let r = LE(t),
    i = LE(t),
    s = 0;
  const o = () => {
      r.fill(1), i.fill(0), (s = 0);
    },
    a = (...p) => n(i, r, ...p),
    l = (p = LE()) => {
      (i = a(dN([0]), p)),
        (r = a()),
        p.length !== 0 && ((i = a(dN([1]), p)), (r = a()));
    },
    d = () => {
      if (s++ >= 1e3) throw new Error("drbg: tried 1000 values");
      let p = 0;
      const f = [];
      for (; p < e; ) {
        r = a();
        const m = r.slice();
        f.push(m), (p += r.length);
      }
      return Vh(...f);
    };
  return (p, f) => {
    o(), l(p);
    let m;
    for (; !(m = f(d())); ) l();
    return o(), m;
  };
}
const lne = {
  bigint: (t) => typeof t == "bigint",
  function: (t) => typeof t == "function",
  boolean: (t) => typeof t == "boolean",
  string: (t) => typeof t == "string",
  stringOrUint8Array: (t) => typeof t == "string" || eu(t),
  isSafeInteger: (t) => Number.isSafeInteger(t),
  array: (t) => Array.isArray(t),
  field: (t, e) => e.Fp.isValid(t),
  hash: (t) => typeof t == "function" && Number.isSafeInteger(t.outputLen),
};
function Op(t, e, n = {}) {
  const r = (i, s, o) => {
    const a = lne[s];
    if (typeof a != "function") throw new Error("invalid validator function");
    const l = t[i];
    if (!(o && l === void 0) && !a(l, t))
      throw new Error(
        "param " + String(i) + " is invalid. Expected " + s + ", got " + l
      );
  };
  for (const [i, s] of Object.entries(e)) r(i, s, !1);
  for (const [i, s] of Object.entries(n)) r(i, s, !0);
  return t;
}
const une = () => {
  throw new Error("not implemented");
};
function Ox(t) {
  const e = new WeakMap();
  return (n, ...r) => {
    const i = e.get(n);
    if (i !== void 0) return i;
    const s = t(n, ...r);
    return e.set(n, s), s;
  };
}
var dne = Object.freeze({
  __proto__: null,
  isBytes: eu,
  abytes: rg,
  abool: np,
  bytesToHex: rp,
  numberToHexUnpadded: Sd,
  hexToNumber: PA,
  hexToBytes: ip,
  bytesToNumberBE: Fl,
  bytesToNumberLE: qh,
  numberToBytesBE: sp,
  numberToBytesLE: _v,
  numberToVarBytesBE: ine,
  ensureBytes: Bi,
  concatBytes: Vh,
  equalBytes: sne,
  utf8ToBytes: one,
  inRange: Iv,
  aInRange: ya,
  bitLen: P$,
  bitGet: ane,
  bitSet: cne,
  bitMask: RA,
  createHmacDrbg: R$,
  validateObject: Op,
  notImplemented: une,
  memoized: Ox,
});
const gr = BigInt(0),
  Bn = BigInt(1),
  xl = BigInt(2),
  pne = BigInt(3),
  kx = BigInt(4),
  pN = BigInt(5),
  fN = BigInt(8);
function bi(t, e) {
  const n = t % e;
  return n >= gr ? n : e + n;
}
function N$(t, e, n) {
  if (e < gr) throw new Error("invalid exponent, negatives unsupported");
  if (n <= gr) throw new Error("invalid modulus");
  if (n === Bn) return gr;
  let r = Bn;
  for (; e > gr; ) e & Bn && (r = (r * t) % n), (t = (t * t) % n), (e >>= Bn);
  return r;
}
function Bs(t, e, n) {
  let r = t;
  for (; e-- > gr; ) (r *= r), (r %= n);
  return r;
}
function Dx(t, e) {
  if (t === gr) throw new Error("invert: expected non-zero number");
  if (e <= gr) throw new Error("invert: expected positive modulus, got " + e);
  let n = bi(t, e),
    r = e,
    i = gr,
    s = Bn;
  for (; n !== gr; ) {
    const o = r / n,
      a = r % n,
      l = i - s * o;
    (r = n), (n = a), (i = s), (s = l);
  }
  if (r !== Bn) throw new Error("invert: does not exist");
  return bi(i, e);
}
function fne(t) {
  const e = (t - Bn) / xl;
  let n, r, i;
  for (n = t - Bn, r = 0; n % xl === gr; n /= xl, r++);
  for (i = xl; i < t && N$(i, e, t) !== t - Bn; i++)
    if (i > 1e3) throw new Error("Cannot find square root: likely non-prime P");
  if (r === 1) {
    const o = (t + Bn) / kx;
    return function (a, l) {
      const d = a.pow(l, o);
      if (!a.eql(a.sqr(d), l)) throw new Error("Cannot find square root");
      return d;
    };
  }
  const s = (n + Bn) / xl;
  return function (o, a) {
    if (o.pow(a, e) === o.neg(o.ONE))
      throw new Error("Cannot find square root");
    let l = r,
      d = o.pow(o.mul(o.ONE, i), n),
      p = o.pow(a, s),
      f = o.pow(a, n);
    for (; !o.eql(f, o.ONE); ) {
      if (o.eql(f, o.ZERO)) return o.ZERO;
      let m = 1;
      for (let g = o.sqr(f); m < l && !o.eql(g, o.ONE); m++) g = o.sqr(g);
      const y = o.pow(d, Bn << BigInt(l - m - 1));
      (d = o.sqr(y)), (p = o.mul(p, y)), (f = o.mul(f, d)), (l = m);
    }
    return p;
  };
}
function hne(t) {
  if (t % kx === pne) {
    const e = (t + Bn) / kx;
    return function (n, r) {
      const i = n.pow(r, e);
      if (!n.eql(n.sqr(i), r)) throw new Error("Cannot find square root");
      return i;
    };
  }
  if (t % fN === pN) {
    const e = (t - pN) / fN;
    return function (n, r) {
      const i = n.mul(r, xl),
        s = n.pow(i, e),
        o = n.mul(r, s),
        a = n.mul(n.mul(o, xl), s),
        l = n.mul(o, n.sub(a, n.ONE));
      if (!n.eql(n.sqr(l), r)) throw new Error("Cannot find square root");
      return l;
    };
  }
  return fne(t);
}
const mne = [
  "create",
  "isValid",
  "is0",
  "neg",
  "inv",
  "sqrt",
  "sqr",
  "eql",
  "add",
  "sub",
  "mul",
  "pow",
  "div",
  "addN",
  "subN",
  "mulN",
  "sqrN",
];
function gne(t) {
  const e = {
      ORDER: "bigint",
      MASK: "bigint",
      BYTES: "isSafeInteger",
      BITS: "isSafeInteger",
    },
    n = mne.reduce((r, i) => ((r[i] = "function"), r), e);
  return Op(t, n);
}
function yne(t, e, n) {
  if (n < gr) throw new Error("invalid exponent, negatives unsupported");
  if (n === gr) return t.ONE;
  if (n === Bn) return e;
  let r = t.ONE,
    i = e;
  for (; n > gr; ) n & Bn && (r = t.mul(r, i)), (i = t.sqr(i)), (n >>= Bn);
  return r;
}
function wne(t, e) {
  const n = new Array(e.length),
    r = e.reduce(
      (s, o, a) => (t.is0(o) ? s : ((n[a] = s), t.mul(s, o))),
      t.ONE
    ),
    i = t.inv(r);
  return (
    e.reduceRight(
      (s, o, a) => (t.is0(o) ? s : ((n[a] = t.mul(s, n[a])), t.mul(s, o))),
      i
    ),
    n
  );
}
function O$(t, e) {
  const n = e !== void 0 ? e : t.toString(2).length,
    r = Math.ceil(n / 8);
  return { nBitLength: n, nByteLength: r };
}
function k$(t, e, n = !1, r = {}) {
  if (t <= gr) throw new Error("invalid field: expected ORDER > 0, got " + t);
  const { nBitLength: i, nByteLength: s } = O$(t, e);
  if (s > 2048)
    throw new Error("invalid field: expected ORDER of <= 2048 bytes");
  let o;
  const a = Object.freeze({
    ORDER: t,
    isLE: n,
    BITS: i,
    BYTES: s,
    MASK: RA(i),
    ZERO: gr,
    ONE: Bn,
    create: (l) => bi(l, t),
    isValid: (l) => {
      if (typeof l != "bigint")
        throw new Error(
          "invalid field element: expected bigint, got " + typeof l
        );
      return gr <= l && l < t;
    },
    is0: (l) => l === gr,
    isOdd: (l) => (l & Bn) === Bn,
    neg: (l) => bi(-l, t),
    eql: (l, d) => l === d,
    sqr: (l) => bi(l * l, t),
    add: (l, d) => bi(l + d, t),
    sub: (l, d) => bi(l - d, t),
    mul: (l, d) => bi(l * d, t),
    pow: (l, d) => yne(a, l, d),
    div: (l, d) => bi(l * Dx(d, t), t),
    sqrN: (l) => l * l,
    addN: (l, d) => l + d,
    subN: (l, d) => l - d,
    mulN: (l, d) => l * d,
    inv: (l) => Dx(l, t),
    sqrt: r.sqrt || ((l) => (o || (o = hne(t)), o(a, l))),
    invertBatch: (l) => wne(a, l),
    cmov: (l, d, p) => (p ? d : l),
    toBytes: (l) => (n ? _v(l, s) : sp(l, s)),
    fromBytes: (l) => {
      if (l.length !== s)
        throw new Error(
          "Field.fromBytes: expected " + s + " bytes, got " + l.length
        );
      return n ? qh(l) : Fl(l);
    },
  });
  return Object.freeze(a);
}
function D$(t) {
  if (typeof t != "bigint") throw new Error("field order must be bigint");
  const e = t.toString(2).length;
  return Math.ceil(e / 8);
}
function $$(t) {
  const e = D$(t);
  return e + Math.ceil(e / 2);
}
function vne(t, e, n = !1) {
  const r = t.length,
    i = D$(e),
    s = $$(e);
  if (r < 16 || r < s || r > 1024)
    throw new Error("expected " + s + "-1024 bytes of input, got " + r);
  const o = n ? qh(t) : Fl(t),
    a = bi(o, e - Bn) + Bn;
  return n ? _v(a, i) : sp(a, i);
}
const hN = BigInt(0),
  Jy = BigInt(1);
function UE(t, e) {
  const n = e.negate();
  return t ? n : e;
}
function M$(t, e) {
  if (!Number.isSafeInteger(t) || t <= 0 || t > e)
    throw new Error("invalid window size, expected [1.." + e + "], got W=" + t);
}
function BE(t, e) {
  M$(t, e);
  const n = Math.ceil(e / t) + 1,
    r = 2 ** (t - 1);
  return { windows: n, windowSize: r };
}
function bne(t, e) {
  if (!Array.isArray(t)) throw new Error("array expected");
  t.forEach((n, r) => {
    if (!(n instanceof e)) throw new Error("invalid point at index " + r);
  });
}
function Ene(t, e) {
  if (!Array.isArray(t)) throw new Error("array of scalars expected");
  t.forEach((n, r) => {
    if (!e.isValid(n)) throw new Error("invalid scalar at index " + r);
  });
}
const jE = new WeakMap(),
  L$ = new WeakMap();
function FE(t) {
  return L$.get(t) || 1;
}
function Cne(t, e) {
  return {
    constTimeNegate: UE,
    hasPrecomputes(n) {
      return FE(n) !== 1;
    },
    unsafeLadder(n, r, i = t.ZERO) {
      let s = n;
      for (; r > hN; ) r & Jy && (i = i.add(s)), (s = s.double()), (r >>= Jy);
      return i;
    },
    precomputeWindow(n, r) {
      const { windows: i, windowSize: s } = BE(r, e),
        o = [];
      let a = n,
        l = a;
      for (let d = 0; d < i; d++) {
        (l = a), o.push(l);
        for (let p = 1; p < s; p++) (l = l.add(a)), o.push(l);
        a = l.double();
      }
      return o;
    },
    wNAF(n, r, i) {
      const { windows: s, windowSize: o } = BE(n, e);
      let a = t.ZERO,
        l = t.BASE;
      const d = BigInt(2 ** n - 1),
        p = 2 ** n,
        f = BigInt(n);
      for (let m = 0; m < s; m++) {
        const y = m * o;
        let g = Number(i & d);
        (i >>= f), g > o && ((g -= p), (i += Jy));
        const v = y,
          b = y + Math.abs(g) - 1,
          E = m % 2 !== 0,
          S = g < 0;
        g === 0 ? (l = l.add(UE(E, r[v]))) : (a = a.add(UE(S, r[b])));
      }
      return { p: a, f: l };
    },
    wNAFUnsafe(n, r, i, s = t.ZERO) {
      const { windows: o, windowSize: a } = BE(n, e),
        l = BigInt(2 ** n - 1),
        d = 2 ** n,
        p = BigInt(n);
      for (let f = 0; f < o; f++) {
        const m = f * a;
        if (i === hN) break;
        let y = Number(i & l);
        if (((i >>= p), y > a && ((y -= d), (i += Jy)), y === 0)) continue;
        let g = r[m + Math.abs(y) - 1];
        y < 0 && (g = g.negate()), (s = s.add(g));
      }
      return s;
    },
    getPrecomputes(n, r, i) {
      let s = jE.get(r);
      return (
        s || ((s = this.precomputeWindow(r, n)), n !== 1 && jE.set(r, i(s))), s
      );
    },
    wNAFCached(n, r, i) {
      const s = FE(n);
      return this.wNAF(s, this.getPrecomputes(s, n, i), r);
    },
    wNAFCachedUnsafe(n, r, i, s) {
      const o = FE(n);
      return o === 1
        ? this.unsafeLadder(n, r, s)
        : this.wNAFUnsafe(o, this.getPrecomputes(o, n, i), r, s);
    },
    setWindowSize(n, r) {
      M$(r, e), L$.set(n, r), jE.delete(n);
    },
  };
}
function xne(t, e, n, r) {
  if ((bne(n, t), Ene(r, e), n.length !== r.length))
    throw new Error("arrays of points and scalars must have equal length");
  const i = t.ZERO,
    s = P$(BigInt(n.length)),
    o = s > 12 ? s - 3 : s > 4 ? s - 2 : s ? 2 : 1,
    a = (1 << o) - 1,
    l = new Array(a + 1).fill(i),
    d = Math.floor((e.BITS - 1) / o) * o;
  let p = i;
  for (let f = d; f >= 0; f -= o) {
    l.fill(i);
    for (let y = 0; y < r.length; y++) {
      const g = r[y],
        v = Number((g >> BigInt(f)) & BigInt(a));
      l[v] = l[v].add(n[y]);
    }
    let m = i;
    for (let y = l.length - 1, g = i; y > 0; y--)
      (g = g.add(l[y])), (m = m.add(g));
    if (((p = p.add(m)), f !== 0)) for (let y = 0; y < o; y++) p = p.double();
  }
  return p;
}
function U$(t) {
  return (
    gne(t.Fp),
    Op(
      t,
      { n: "bigint", h: "bigint", Gx: "field", Gy: "field" },
      { nBitLength: "isSafeInteger", nByteLength: "isSafeInteger" }
    ),
    Object.freeze({ ...O$(t.n, t.nBitLength), ...t, p: t.Fp.ORDER })
  );
}
BigInt(0), BigInt(1), BigInt(2), BigInt(8);
const Qu = BigInt(0),
  zE = BigInt(1);
function Sne(t) {
  return (
    Op(
      t,
      { a: "bigint" },
      {
        montgomeryBits: "isSafeInteger",
        nByteLength: "isSafeInteger",
        adjustScalarBytes: "function",
        domain: "function",
        powPminus2: "function",
        Gu: "bigint",
      }
    ),
    Object.freeze({ ...t })
  );
}
function Ane(t) {
  const e = Sne(t),
    { P: n } = e,
    r = (S) => bi(S, n),
    i = e.montgomeryBits,
    s = Math.ceil(i / 8),
    o = e.nByteLength,
    a = e.adjustScalarBytes || ((S) => S),
    l = e.powPminus2 || ((S) => N$(S, n - BigInt(2), n));
  function d(S, C, _) {
    const A = r(S * (C - _));
    return (C = r(C - A)), (_ = r(_ + A)), [C, _];
  }
  const p = (e.a - BigInt(2)) / BigInt(4);
  function f(S, C) {
    ya("u", S, Qu, n), ya("scalar", C, Qu, n);
    const _ = C,
      A = S;
    let I = zE,
      R = Qu,
      D = S,
      k = zE,
      T = Qu,
      U;
    for (let K = BigInt(i - 1); K >= Qu; K--) {
      const H = (_ >> K) & zE;
      (T ^= H),
        (U = d(T, I, D)),
        (I = U[0]),
        (D = U[1]),
        (U = d(T, R, k)),
        (R = U[0]),
        (k = U[1]),
        (T = H);
      const $ = I + R,
        M = r($ * $),
        z = I - R,
        B = r(z * z),
        j = M - B,
        V = D + k,
        W = D - k,
        Z = r(W * $),
        ee = r(V * z),
        J = Z + ee,
        se = Z - ee;
      (D = r(J * J)),
        (k = r(A * r(se * se))),
        (I = r(M * B)),
        (R = r(j * (M + r(p * j))));
    }
    (U = d(T, I, D)),
      (I = U[0]),
      (D = U[1]),
      (U = d(T, R, k)),
      (R = U[0]),
      (k = U[1]);
    const q = l(R);
    return r(I * q);
  }
  function m(S) {
    return _v(r(S), s);
  }
  function y(S) {
    const C = Bi("u coordinate", S, s);
    return o === 32 && (C[31] &= 127), qh(C);
  }
  function g(S) {
    const C = Bi("scalar", S),
      _ = C.length;
    if (_ !== s && _ !== o) {
      let A = "" + s + " or " + o;
      throw new Error("invalid scalar, expected " + A + " bytes, got " + _);
    }
    return qh(a(C));
  }
  function v(S, C) {
    const _ = y(C),
      A = g(S),
      I = f(_, A);
    if (I === Qu) throw new Error("invalid private or public key received");
    return m(I);
  }
  const b = m(e.Gu);
  function E(S) {
    return v(S, b);
  }
  return {
    scalarMult: v,
    scalarMultBase: E,
    getSharedSecret: (S, C) => v(S, C),
    getPublicKey: (S) => E(S),
    utils: { randomPrivateKey: () => e.randomBytes(e.nByteLength) },
    GuBytes: b,
  };
}
const $x = BigInt(
  "57896044618658097711785492504343953926634992332820282019728792003956564819949"
);
BigInt(0);
const _ne = BigInt(1),
  mN = BigInt(2),
  Ine = BigInt(3),
  Tne = BigInt(5);
BigInt(8);
function Pne(t) {
  const e = BigInt(10),
    n = BigInt(20),
    r = BigInt(40),
    i = BigInt(80),
    s = $x,
    o = (((t * t) % s) * t) % s,
    a = (Bs(o, mN, s) * o) % s,
    l = (Bs(a, _ne, s) * t) % s,
    d = (Bs(l, Tne, s) * l) % s,
    p = (Bs(d, e, s) * d) % s,
    f = (Bs(p, n, s) * p) % s,
    m = (Bs(f, r, s) * f) % s,
    y = (Bs(m, i, s) * m) % s,
    g = (Bs(y, i, s) * m) % s,
    v = (Bs(g, e, s) * d) % s;
  return { pow_p_5_8: (Bs(v, mN, s) * t) % s, b2: o };
}
function Rne(t) {
  return (t[0] &= 248), (t[31] &= 127), (t[31] |= 64), t;
}
const Mx = Ane({
  P: $x,
  a: BigInt(486662),
  montgomeryBits: 255,
  nByteLength: 32,
  Gu: BigInt(9),
  powPminus2: (t) => {
    const e = $x,
      { pow_p_5_8: n, b2: r } = Pne(t);
    return bi(Bs(n, Ine, e) * r, e);
  },
  adjustScalarBytes: Rne,
  randomBytes: Np,
});
function gN(t) {
  t.lowS !== void 0 && np("lowS", t.lowS),
    t.prehash !== void 0 && np("prehash", t.prehash);
}
function Nne(t) {
  const e = U$(t);
  Op(
    e,
    { a: "field", b: "field" },
    {
      allowedPrivateKeyLengths: "array",
      wrapPrivateKey: "boolean",
      isTorsionFree: "function",
      clearCofactor: "function",
      allowInfinityPoint: "boolean",
      fromBytes: "function",
      toBytes: "function",
    }
  );
  const { endo: n, Fp: r, a: i } = e;
  if (n) {
    if (!r.eql(i, r.ZERO))
      throw new Error(
        "invalid endomorphism, can only be defined for Koblitz curves that have a=0"
      );
    if (
      typeof n != "object" ||
      typeof n.beta != "bigint" ||
      typeof n.splitScalar != "function"
    )
      throw new Error(
        "invalid endomorphism, expected beta: bigint and splitScalar: function"
      );
  }
  return Object.freeze({ ...e });
}
const { bytesToNumberBE: One, hexToBytes: kne } = dne;
class Dne extends Error {
  constructor(e = "") {
    super(e);
  }
}
const ua = {
    Err: Dne,
    _tlv: {
      encode: (t, e) => {
        const { Err: n } = ua;
        if (t < 0 || t > 256) throw new n("tlv.encode: wrong tag");
        if (e.length & 1) throw new n("tlv.encode: unpadded data");
        const r = e.length / 2,
          i = Sd(r);
        if ((i.length / 2) & 128)
          throw new n("tlv.encode: long form length too big");
        const s = r > 127 ? Sd((i.length / 2) | 128) : "";
        return Sd(t) + s + i + e;
      },
      decode(t, e) {
        const { Err: n } = ua;
        let r = 0;
        if (t < 0 || t > 256) throw new n("tlv.encode: wrong tag");
        if (e.length < 2 || e[r++] !== t) throw new n("tlv.decode: wrong tlv");
        const i = e[r++],
          s = !!(i & 128);
        let o = 0;
        if (!s) o = i;
        else {
          const l = i & 127;
          if (!l)
            throw new n("tlv.decode(long): indefinite length not supported");
          if (l > 4) throw new n("tlv.decode(long): byte length is too big");
          const d = e.subarray(r, r + l);
          if (d.length !== l)
            throw new n("tlv.decode: length bytes not complete");
          if (d[0] === 0) throw new n("tlv.decode(long): zero leftmost byte");
          for (const p of d) o = (o << 8) | p;
          if (((r += l), o < 128))
            throw new n("tlv.decode(long): not minimal encoding");
        }
        const a = e.subarray(r, r + o);
        if (a.length !== o) throw new n("tlv.decode: wrong value length");
        return { v: a, l: e.subarray(r + o) };
      },
    },
    _int: {
      encode(t) {
        const { Err: e } = ua;
        if (t < ma) throw new e("integer: negative integers are not allowed");
        let n = Sd(t);
        if ((Number.parseInt(n[0], 16) & 8 && (n = "00" + n), n.length & 1))
          throw new e("unexpected DER parsing assertion: unpadded hex");
        return n;
      },
      decode(t) {
        const { Err: e } = ua;
        if (t[0] & 128) throw new e("invalid signature integer: negative");
        if (t[0] === 0 && !(t[1] & 128))
          throw new e("invalid signature integer: unnecessary leading zero");
        return One(t);
      },
    },
    toSig(t) {
      const { Err: e, _int: n, _tlv: r } = ua,
        i = typeof t == "string" ? kne(t) : t;
      rg(i);
      const { v: s, l: o } = r.decode(48, i);
      if (o.length) throw new e("invalid signature: left bytes after parsing");
      const { v: a, l } = r.decode(2, s),
        { v: d, l: p } = r.decode(2, l);
      if (p.length) throw new e("invalid signature: left bytes after parsing");
      return { r: n.decode(a), s: n.decode(d) };
    },
    hexFromSig(t) {
      const { _tlv: e, _int: n } = ua,
        r = e.encode(2, n.encode(t.r)),
        i = e.encode(2, n.encode(t.s)),
        s = r + i;
      return e.encode(48, s);
    },
  },
  ma = BigInt(0),
  dr = BigInt(1);
BigInt(2);
const yN = BigInt(3);
BigInt(4);
function $ne(t) {
  const e = Nne(t),
    { Fp: n } = e,
    r = k$(e.n, e.nBitLength),
    i =
      e.toBytes ||
      ((v, b, E) => {
        const S = b.toAffine();
        return Vh(Uint8Array.from([4]), n.toBytes(S.x), n.toBytes(S.y));
      }),
    s =
      e.fromBytes ||
      ((v) => {
        const b = v.subarray(1),
          E = n.fromBytes(b.subarray(0, n.BYTES)),
          S = n.fromBytes(b.subarray(n.BYTES, 2 * n.BYTES));
        return { x: E, y: S };
      });
  function o(v) {
    const { a: b, b: E } = e,
      S = n.sqr(v),
      C = n.mul(S, v);
    return n.add(n.add(C, n.mul(v, b)), E);
  }
  if (!n.eql(n.sqr(e.Gy), o(e.Gx)))
    throw new Error("bad generator point: equation left != right");
  function a(v) {
    return Iv(v, dr, e.n);
  }
  function l(v) {
    const {
      allowedPrivateKeyLengths: b,
      nByteLength: E,
      wrapPrivateKey: S,
      n: C,
    } = e;
    if (b && typeof v != "bigint") {
      if ((eu(v) && (v = rp(v)), typeof v != "string" || !b.includes(v.length)))
        throw new Error("invalid private key");
      v = v.padStart(E * 2, "0");
    }
    let _;
    try {
      _ = typeof v == "bigint" ? v : Fl(Bi("private key", v, E));
    } catch {
      throw new Error(
        "invalid private key, expected hex or " + E + " bytes, got " + typeof v
      );
    }
    return S && (_ = bi(_, C)), ya("private key", _, dr, C), _;
  }
  function d(v) {
    if (!(v instanceof m)) throw new Error("ProjectivePoint expected");
  }
  const p = Ox((v, b) => {
      const { px: E, py: S, pz: C } = v;
      if (n.eql(C, n.ONE)) return { x: E, y: S };
      const _ = v.is0();
      b == null && (b = _ ? n.ONE : n.inv(C));
      const A = n.mul(E, b),
        I = n.mul(S, b),
        R = n.mul(C, b);
      if (_) return { x: n.ZERO, y: n.ZERO };
      if (!n.eql(R, n.ONE)) throw new Error("invZ was invalid");
      return { x: A, y: I };
    }),
    f = Ox((v) => {
      if (v.is0()) {
        if (e.allowInfinityPoint && !n.is0(v.py)) return;
        throw new Error("bad point: ZERO");
      }
      const { x: b, y: E } = v.toAffine();
      if (!n.isValid(b) || !n.isValid(E))
        throw new Error("bad point: x or y not FE");
      const S = n.sqr(E),
        C = o(b);
      if (!n.eql(S, C)) throw new Error("bad point: equation left != right");
      if (!v.isTorsionFree())
        throw new Error("bad point: not in prime-order subgroup");
      return !0;
    });
  class m {
    constructor(b, E, S) {
      if (
        ((this.px = b),
        (this.py = E),
        (this.pz = S),
        b == null || !n.isValid(b))
      )
        throw new Error("x required");
      if (E == null || !n.isValid(E)) throw new Error("y required");
      if (S == null || !n.isValid(S)) throw new Error("z required");
      Object.freeze(this);
    }
    static fromAffine(b) {
      const { x: E, y: S } = b || {};
      if (!b || !n.isValid(E) || !n.isValid(S))
        throw new Error("invalid affine point");
      if (b instanceof m) throw new Error("projective point not allowed");
      const C = (_) => n.eql(_, n.ZERO);
      return C(E) && C(S) ? m.ZERO : new m(E, S, n.ONE);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    static normalizeZ(b) {
      const E = n.invertBatch(b.map((S) => S.pz));
      return b.map((S, C) => S.toAffine(E[C])).map(m.fromAffine);
    }
    static fromHex(b) {
      const E = m.fromAffine(s(Bi("pointHex", b)));
      return E.assertValidity(), E;
    }
    static fromPrivateKey(b) {
      return m.BASE.multiply(l(b));
    }
    static msm(b, E) {
      return xne(m, r, b, E);
    }
    _setWindowSize(b) {
      g.setWindowSize(this, b);
    }
    assertValidity() {
      f(this);
    }
    hasEvenY() {
      const { y: b } = this.toAffine();
      if (n.isOdd) return !n.isOdd(b);
      throw new Error("Field doesn't support isOdd");
    }
    equals(b) {
      d(b);
      const { px: E, py: S, pz: C } = this,
        { px: _, py: A, pz: I } = b,
        R = n.eql(n.mul(E, I), n.mul(_, C)),
        D = n.eql(n.mul(S, I), n.mul(A, C));
      return R && D;
    }
    negate() {
      return new m(this.px, n.neg(this.py), this.pz);
    }
    double() {
      const { a: b, b: E } = e,
        S = n.mul(E, yN),
        { px: C, py: _, pz: A } = this;
      let I = n.ZERO,
        R = n.ZERO,
        D = n.ZERO,
        k = n.mul(C, C),
        T = n.mul(_, _),
        U = n.mul(A, A),
        q = n.mul(C, _);
      return (
        (q = n.add(q, q)),
        (D = n.mul(C, A)),
        (D = n.add(D, D)),
        (I = n.mul(b, D)),
        (R = n.mul(S, U)),
        (R = n.add(I, R)),
        (I = n.sub(T, R)),
        (R = n.add(T, R)),
        (R = n.mul(I, R)),
        (I = n.mul(q, I)),
        (D = n.mul(S, D)),
        (U = n.mul(b, U)),
        (q = n.sub(k, U)),
        (q = n.mul(b, q)),
        (q = n.add(q, D)),
        (D = n.add(k, k)),
        (k = n.add(D, k)),
        (k = n.add(k, U)),
        (k = n.mul(k, q)),
        (R = n.add(R, k)),
        (U = n.mul(_, A)),
        (U = n.add(U, U)),
        (k = n.mul(U, q)),
        (I = n.sub(I, k)),
        (D = n.mul(U, T)),
        (D = n.add(D, D)),
        (D = n.add(D, D)),
        new m(I, R, D)
      );
    }
    add(b) {
      d(b);
      const { px: E, py: S, pz: C } = this,
        { px: _, py: A, pz: I } = b;
      let R = n.ZERO,
        D = n.ZERO,
        k = n.ZERO;
      const T = e.a,
        U = n.mul(e.b, yN);
      let q = n.mul(E, _),
        K = n.mul(S, A),
        H = n.mul(C, I),
        $ = n.add(E, S),
        M = n.add(_, A);
      ($ = n.mul($, M)),
        (M = n.add(q, K)),
        ($ = n.sub($, M)),
        (M = n.add(E, C));
      let z = n.add(_, I);
      return (
        (M = n.mul(M, z)),
        (z = n.add(q, H)),
        (M = n.sub(M, z)),
        (z = n.add(S, C)),
        (R = n.add(A, I)),
        (z = n.mul(z, R)),
        (R = n.add(K, H)),
        (z = n.sub(z, R)),
        (k = n.mul(T, M)),
        (R = n.mul(U, H)),
        (k = n.add(R, k)),
        (R = n.sub(K, k)),
        (k = n.add(K, k)),
        (D = n.mul(R, k)),
        (K = n.add(q, q)),
        (K = n.add(K, q)),
        (H = n.mul(T, H)),
        (M = n.mul(U, M)),
        (K = n.add(K, H)),
        (H = n.sub(q, H)),
        (H = n.mul(T, H)),
        (M = n.add(M, H)),
        (q = n.mul(K, M)),
        (D = n.add(D, q)),
        (q = n.mul(z, M)),
        (R = n.mul($, R)),
        (R = n.sub(R, q)),
        (q = n.mul($, K)),
        (k = n.mul(z, k)),
        (k = n.add(k, q)),
        new m(R, D, k)
      );
    }
    subtract(b) {
      return this.add(b.negate());
    }
    is0() {
      return this.equals(m.ZERO);
    }
    wNAF(b) {
      return g.wNAFCached(this, b, m.normalizeZ);
    }
    multiplyUnsafe(b) {
      const { endo: E, n: S } = e;
      ya("scalar", b, ma, S);
      const C = m.ZERO;
      if (b === ma) return C;
      if (this.is0() || b === dr) return this;
      if (!E || g.hasPrecomputes(this))
        return g.wNAFCachedUnsafe(this, b, m.normalizeZ);
      let { k1neg: _, k1: A, k2neg: I, k2: R } = E.splitScalar(b),
        D = C,
        k = C,
        T = this;
      for (; A > ma || R > ma; )
        A & dr && (D = D.add(T)),
          R & dr && (k = k.add(T)),
          (T = T.double()),
          (A >>= dr),
          (R >>= dr);
      return (
        _ && (D = D.negate()),
        I && (k = k.negate()),
        (k = new m(n.mul(k.px, E.beta), k.py, k.pz)),
        D.add(k)
      );
    }
    multiply(b) {
      const { endo: E, n: S } = e;
      ya("scalar", b, dr, S);
      let C, _;
      if (E) {
        const { k1neg: A, k1: I, k2neg: R, k2: D } = E.splitScalar(b);
        let { p: k, f: T } = this.wNAF(I),
          { p: U, f: q } = this.wNAF(D);
        (k = g.constTimeNegate(A, k)),
          (U = g.constTimeNegate(R, U)),
          (U = new m(n.mul(U.px, E.beta), U.py, U.pz)),
          (C = k.add(U)),
          (_ = T.add(q));
      } else {
        const { p: A, f: I } = this.wNAF(b);
        (C = A), (_ = I);
      }
      return m.normalizeZ([C, _])[0];
    }
    multiplyAndAddUnsafe(b, E, S) {
      const C = m.BASE,
        _ = (I, R) =>
          R === ma || R === dr || !I.equals(C)
            ? I.multiplyUnsafe(R)
            : I.multiply(R),
        A = _(this, E).add(_(b, S));
      return A.is0() ? void 0 : A;
    }
    toAffine(b) {
      return p(this, b);
    }
    isTorsionFree() {
      const { h: b, isTorsionFree: E } = e;
      if (b === dr) return !0;
      if (E) return E(m, this);
      throw new Error(
        "isTorsionFree() has not been declared for the elliptic curve"
      );
    }
    clearCofactor() {
      const { h: b, clearCofactor: E } = e;
      return b === dr ? this : E ? E(m, this) : this.multiplyUnsafe(e.h);
    }
    toRawBytes(b = !0) {
      return np("isCompressed", b), this.assertValidity(), i(m, this, b);
    }
    toHex(b = !0) {
      return np("isCompressed", b), rp(this.toRawBytes(b));
    }
  }
  (m.BASE = new m(e.Gx, e.Gy, n.ONE)), (m.ZERO = new m(n.ZERO, n.ONE, n.ZERO));
  const y = e.nBitLength,
    g = Cne(m, e.endo ? Math.ceil(y / 2) : y);
  return {
    CURVE: e,
    ProjectivePoint: m,
    normPrivateKeyToScalar: l,
    weierstrassEquation: o,
    isWithinCurveOrder: a,
  };
}
function Mne(t) {
  const e = U$(t);
  return (
    Op(
      e,
      { hash: "hash", hmac: "function", randomBytes: "function" },
      { bits2int: "function", bits2int_modN: "function", lowS: "boolean" }
    ),
    Object.freeze({ lowS: !0, ...e })
  );
}
function Lne(t) {
  const e = Mne(t),
    { Fp: n, n: r } = e,
    i = n.BYTES + 1,
    s = 2 * n.BYTES + 1;
  function o(H) {
    return bi(H, r);
  }
  function a(H) {
    return Dx(H, r);
  }
  const {
      ProjectivePoint: l,
      normPrivateKeyToScalar: d,
      weierstrassEquation: p,
      isWithinCurveOrder: f,
    } = $ne({
      ...e,
      toBytes(H, $, M) {
        const z = $.toAffine(),
          B = n.toBytes(z.x),
          j = Vh;
        return (
          np("isCompressed", M),
          M
            ? j(Uint8Array.from([$.hasEvenY() ? 2 : 3]), B)
            : j(Uint8Array.from([4]), B, n.toBytes(z.y))
        );
      },
      fromBytes(H) {
        const $ = H.length,
          M = H[0],
          z = H.subarray(1);
        if ($ === i && (M === 2 || M === 3)) {
          const B = Fl(z);
          if (!Iv(B, dr, n.ORDER)) throw new Error("Point is not on curve");
          const j = p(B);
          let V;
          try {
            V = n.sqrt(j);
          } catch (Z) {
            const ee = Z instanceof Error ? ": " + Z.message : "";
            throw new Error("Point is not on curve" + ee);
          }
          const W = (V & dr) === dr;
          return ((M & 1) === 1) !== W && (V = n.neg(V)), { x: B, y: V };
        } else if ($ === s && M === 4) {
          const B = n.fromBytes(z.subarray(0, n.BYTES)),
            j = n.fromBytes(z.subarray(n.BYTES, 2 * n.BYTES));
          return { x: B, y: j };
        } else {
          const B = i,
            j = s;
          throw new Error(
            "invalid Point, expected length of " +
              B +
              ", or uncompressed " +
              j +
              ", got " +
              $
          );
        }
      },
    }),
    m = (H) => rp(sp(H, e.nByteLength));
  function y(H) {
    const $ = r >> dr;
    return H > $;
  }
  function g(H) {
    return y(H) ? o(-H) : H;
  }
  const v = (H, $, M) => Fl(H.slice($, M));
  class b {
    constructor($, M, z) {
      (this.r = $), (this.s = M), (this.recovery = z), this.assertValidity();
    }
    static fromCompact($) {
      const M = e.nByteLength;
      return (
        ($ = Bi("compactSignature", $, M * 2)),
        new b(v($, 0, M), v($, M, 2 * M))
      );
    }
    static fromDER($) {
      const { r: M, s: z } = ua.toSig(Bi("DER", $));
      return new b(M, z);
    }
    assertValidity() {
      ya("r", this.r, dr, r), ya("s", this.s, dr, r);
    }
    addRecoveryBit($) {
      return new b(this.r, this.s, $);
    }
    recoverPublicKey($) {
      const { r: M, s: z, recovery: B } = this,
        j = I(Bi("msgHash", $));
      if (B == null || ![0, 1, 2, 3].includes(B))
        throw new Error("recovery id invalid");
      const V = B === 2 || B === 3 ? M + e.n : M;
      if (V >= n.ORDER) throw new Error("recovery id 2 or 3 invalid");
      const W = B & 1 ? "03" : "02",
        Z = l.fromHex(W + m(V)),
        ee = a(V),
        J = o(-j * ee),
        se = o(z * ee),
        re = l.BASE.multiplyAndAddUnsafe(Z, J, se);
      if (!re) throw new Error("point at infinify");
      return re.assertValidity(), re;
    }
    hasHighS() {
      return y(this.s);
    }
    normalizeS() {
      return this.hasHighS() ? new b(this.r, o(-this.s), this.recovery) : this;
    }
    toDERRawBytes() {
      return ip(this.toDERHex());
    }
    toDERHex() {
      return ua.hexFromSig({ r: this.r, s: this.s });
    }
    toCompactRawBytes() {
      return ip(this.toCompactHex());
    }
    toCompactHex() {
      return m(this.r) + m(this.s);
    }
  }
  const E = {
    isValidPrivateKey(H) {
      try {
        return d(H), !0;
      } catch {
        return !1;
      }
    },
    normPrivateKeyToScalar: d,
    randomPrivateKey: () => {
      const H = $$(e.n);
      return vne(e.randomBytes(H), e.n);
    },
    precompute(H = 8, $ = l.BASE) {
      return $._setWindowSize(H), $.multiply(BigInt(3)), $;
    },
  };
  function S(H, $ = !0) {
    return l.fromPrivateKey(H).toRawBytes($);
  }
  function C(H) {
    const $ = eu(H),
      M = typeof H == "string",
      z = ($ || M) && H.length;
    return $
      ? z === i || z === s
      : M
      ? z === 2 * i || z === 2 * s
      : H instanceof l;
  }
  function _(H, $, M = !0) {
    if (C(H)) throw new Error("first arg must be private key");
    if (!C($)) throw new Error("second arg must be public key");
    return l.fromHex($).multiply(d(H)).toRawBytes(M);
  }
  const A =
      e.bits2int ||
      function (H) {
        if (H.length > 8192) throw new Error("input is too large");
        const $ = Fl(H),
          M = H.length * 8 - e.nBitLength;
        return M > 0 ? $ >> BigInt(M) : $;
      },
    I =
      e.bits2int_modN ||
      function (H) {
        return o(A(H));
      },
    R = RA(e.nBitLength);
  function D(H) {
    return ya("num < 2^" + e.nBitLength, H, ma, R), sp(H, e.nByteLength);
  }
  function k(H, $, M = T) {
    if (["recovered", "canonical"].some((ce) => ce in M))
      throw new Error("sign() legacy options not supported");
    const { hash: z, randomBytes: B } = e;
    let { lowS: j, prehash: V, extraEntropy: W } = M;
    j == null && (j = !0),
      (H = Bi("msgHash", H)),
      gN(M),
      V && (H = Bi("prehashed msgHash", z(H)));
    const Z = I(H),
      ee = d($),
      J = [D(ee), D(Z)];
    if (W != null && W !== !1) {
      const ce = W === !0 ? B(n.BYTES) : W;
      J.push(Bi("extraEntropy", ce));
    }
    const se = Vh(...J),
      re = Z;
    function fe(ce) {
      const le = A(ce);
      if (!f(le)) return;
      const Se = a(le),
        je = l.BASE.multiply(le).toAffine(),
        Pe = o(je.x);
      if (Pe === ma) return;
      const We = o(Se * o(re + Pe * ee));
      if (We === ma) return;
      let Ne = (je.x === Pe ? 0 : 2) | Number(je.y & dr),
        pt = We;
      return j && y(We) && ((pt = g(We)), (Ne ^= 1)), new b(Pe, pt, Ne);
    }
    return { seed: se, k2sig: fe };
  }
  const T = { lowS: e.lowS, prehash: !1 },
    U = { lowS: e.lowS, prehash: !1 };
  function q(H, $, M = T) {
    const { seed: z, k2sig: B } = k(H, $, M),
      j = e;
    return R$(j.hash.outputLen, j.nByteLength, j.hmac)(z, B);
  }
  l.BASE._setWindowSize(8);
  function K(H, $, M, z = U) {
    var We;
    const B = H;
    ($ = Bi("msgHash", $)), (M = Bi("publicKey", M));
    const { lowS: j, prehash: V, format: W } = z;
    if ((gN(z), "strict" in z))
      throw new Error("options.strict was renamed to lowS");
    if (W !== void 0 && W !== "compact" && W !== "der")
      throw new Error("format must be compact or der");
    const Z = typeof B == "string" || eu(B),
      ee =
        !Z &&
        !W &&
        typeof B == "object" &&
        B !== null &&
        typeof B.r == "bigint" &&
        typeof B.s == "bigint";
    if (!Z && !ee)
      throw new Error(
        "invalid signature, expected Uint8Array, hex string or Signature instance"
      );
    let J, se;
    try {
      if ((ee && (J = new b(B.r, B.s)), Z)) {
        try {
          W !== "compact" && (J = b.fromDER(B));
        } catch (Ne) {
          if (!(Ne instanceof ua.Err)) throw Ne;
        }
        !J && W !== "der" && (J = b.fromCompact(B));
      }
      se = l.fromHex(M);
    } catch {
      return !1;
    }
    if (!J || (j && J.hasHighS())) return !1;
    V && ($ = e.hash($));
    const { r: re, s: fe } = J,
      ce = I($),
      le = a(fe),
      Se = o(ce * le),
      je = o(re * le),
      Pe =
        (We = l.BASE.multiplyAndAddUnsafe(se, Se, je)) == null
          ? void 0
          : We.toAffine();
    return Pe ? o(Pe.x) === re : !1;
  }
  return {
    CURVE: e,
    getPublicKey: S,
    getSharedSecret: _,
    sign: q,
    verify: K,
    ProjectivePoint: l,
    Signature: b,
    utils: E,
  };
}
function Une(t) {
  return { hash: t, hmac: (e, ...n) => xv(t, e, zee(...n)), randomBytes: Np };
}
function Bne(t, e) {
  const n = (r) => Lne({ ...t, ...Une(r) });
  return { ...n(e), create: n };
}
const B$ = k$(
    BigInt("0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff")
  ),
  jne = B$.create(BigInt("-3")),
  Fne = BigInt(
    "0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b"
  ),
  zne = Bne(
    {
      a: jne,
      b: Fne,
      Fp: B$,
      n: BigInt(
        "0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551"
      ),
      Gx: BigInt(
        "0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296"
      ),
      Gy: BigInt(
        "0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5"
      ),
      h: BigInt(1),
      lowS: !1,
    },
    ng
  ),
  j$ = "base10",
  ni = "base16",
  Vs = "base64pad",
  mc = "base64url",
  ig = "utf8",
  F$ = 0,
  wa = 1,
  sg = 2,
  Wne = 0,
  wN = 1,
  wh = 12,
  NA = 32;
function Hne() {
  const t = Mx.utils.randomPrivateKey(),
    e = Mx.getPublicKey(t);
  return { privateKey: xi(t, ni), publicKey: xi(e, ni) };
}
function Lx() {
  const t = Np(NA);
  return xi(t, ni);
}
function qne(t, e) {
  const n = Mx.getSharedSecret(fs(t, ni), fs(e, ni)),
    r = Yte(ng, n, void 0, void 0, NA);
  return xi(r, ni);
}
function L0(t) {
  const e = ng(fs(t, ni));
  return xi(e, ni);
}
function So(t) {
  const e = ng(fs(t, ig));
  return xi(e, ni);
}
function z$(t) {
  return fs(`${t}`, j$);
}
function tu(t) {
  return Number(xi(t, j$));
}
function W$(t) {
  return t.replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
}
function H$(t) {
  const e = t.replace(/-/g, "+").replace(/_/g, "/"),
    n = (4 - (e.length % 4)) % 4;
  return e + "=".repeat(n);
}
function Vne(t) {
  const e = z$(typeof t.type < "u" ? t.type : F$);
  if (tu(e) === wa && typeof t.senderPublicKey > "u")
    throw new Error("Missing sender public key for type 1 envelope");
  const n = typeof t.senderPublicKey < "u" ? fs(t.senderPublicKey, ni) : void 0,
    r = typeof t.iv < "u" ? fs(t.iv, ni) : Np(wh),
    i = fs(t.symKey, ni),
    s = I$(i, r).encrypt(fs(t.message, ig)),
    o = q$({ type: e, sealed: s, iv: r, senderPublicKey: n });
  return t.encoding === mc ? W$(o) : o;
}
function Gne(t) {
  const e = fs(t.symKey, ni),
    { sealed: n, iv: r } = Gh({ encoded: t.encoded, encoding: t.encoding }),
    i = I$(e, r).decrypt(n);
  if (i === null) throw new Error("Failed to decrypt");
  return xi(i, ig);
}
function Kne(t, e) {
  const n = z$(sg),
    r = Np(wh),
    i = fs(t, ig),
    s = q$({ type: n, sealed: i, iv: r });
  return e === mc ? W$(s) : s;
}
function Yne(t, e) {
  const { sealed: n } = Gh({ encoded: t, encoding: e });
  return xi(n, ig);
}
function q$(t) {
  if (tu(t.type) === sg) return xi(yh([t.type, t.sealed]), Vs);
  if (tu(t.type) === wa) {
    if (typeof t.senderPublicKey > "u")
      throw new Error("Missing sender public key for type 1 envelope");
    return xi(yh([t.type, t.senderPublicKey, t.iv, t.sealed]), Vs);
  }
  return xi(yh([t.type, t.iv, t.sealed]), Vs);
}
function Gh(t) {
  const e = (t.encoding || Vs) === mc ? H$(t.encoded) : t.encoded,
    n = fs(e, Vs),
    r = n.slice(Wne, wN),
    i = wN;
  if (tu(r) === wa) {
    const l = i + NA,
      d = l + wh,
      p = n.slice(i, l),
      f = n.slice(l, d),
      m = n.slice(d);
    return { type: r, sealed: m, iv: f, senderPublicKey: p };
  }
  if (tu(r) === sg) {
    const l = n.slice(i),
      d = Np(wh);
    return { type: r, sealed: l, iv: d };
  }
  const s = i + wh,
    o = n.slice(i, s),
    a = n.slice(s);
  return { type: r, sealed: a, iv: o };
}
function Zne(t, e) {
  const n = Gh({ encoded: t, encoding: e == null ? void 0 : e.encoding });
  return V$({
    type: tu(n.type),
    senderPublicKey:
      typeof n.senderPublicKey < "u" ? xi(n.senderPublicKey, ni) : void 0,
    receiverPublicKey: e == null ? void 0 : e.receiverPublicKey,
  });
}
function V$(t) {
  const e = (t == null ? void 0 : t.type) || F$;
  if (e === wa) {
    if (typeof (t == null ? void 0 : t.senderPublicKey) > "u")
      throw new Error("missing sender public key");
    if (typeof (t == null ? void 0 : t.receiverPublicKey) > "u")
      throw new Error("missing receiver public key");
  }
  return {
    type: e,
    senderPublicKey: t == null ? void 0 : t.senderPublicKey,
    receiverPublicKey: t == null ? void 0 : t.receiverPublicKey,
  };
}
function vN(t) {
  return (
    t.type === wa &&
    typeof t.senderPublicKey == "string" &&
    typeof t.receiverPublicKey == "string"
  );
}
function bN(t) {
  return t.type === sg;
}
function Qne(t) {
  const e = Buffer.from(t.x, "base64"),
    n = Buffer.from(t.y, "base64");
  return yh([new Uint8Array([4]), e, n]);
}
function Xne(t, e) {
  const [n, r, i] = t.split("."),
    s = Buffer.from(H$(i), "base64");
  if (s.length !== 64) throw new Error("Invalid signature length");
  const o = s.slice(0, 32),
    a = s.slice(32, 64),
    l = `${n}.${r}`,
    d = ng(l),
    p = Qne(e);
  if (!zne.verify(yh([o, a]), d, p)) throw new Error("Invalid signature");
  return vx(t).payload;
}
const Jne = "irn";
function gw(t) {
  return (t == null ? void 0 : t.relay) || { protocol: Jne };
}
function ch(t) {
  const e = iee[t];
  if (typeof e > "u") throw new Error(`Relay Protocol not supported: ${t}`);
  return e;
}
function ere(t, e = "-") {
  const n = {},
    r = "relay" + e;
  return (
    Object.keys(t).forEach((i) => {
      if (i.startsWith(r)) {
        const s = i.replace(r, ""),
          o = t[i];
        n[s] = o;
      }
    }),
    n
  );
}
function EN(t) {
  if (!t.includes("wc:")) {
    const d = h$(t);
    d != null && d.includes("wc:") && (t = d);
  }
  (t = t.includes("wc://") ? t.replace("wc://", "") : t),
    (t = t.includes("wc:") ? t.replace("wc:", "") : t);
  const e = t.indexOf(":"),
    n = t.indexOf("?") !== -1 ? t.indexOf("?") : void 0,
    r = t.substring(0, e),
    i = t.substring(e + 1, n).split("@"),
    s = typeof n < "u" ? t.substring(n) : "",
    o = new URLSearchParams(s),
    a = {};
  o.forEach((d, p) => {
    a[p] = d;
  });
  const l = typeof a.methods == "string" ? a.methods.split(",") : void 0;
  return {
    protocol: r,
    topic: tre(i[0]),
    version: parseInt(i[1], 10),
    symKey: a.symKey,
    relay: ere(a),
    methods: l,
    expiryTimestamp: a.expiryTimestamp
      ? parseInt(a.expiryTimestamp, 10)
      : void 0,
  };
}
function tre(t) {
  return t.startsWith("//") ? t.substring(2) : t;
}
function nre(t, e = "-") {
  const n = "relay",
    r = {};
  return (
    Object.keys(t).forEach((i) => {
      const s = i,
        o = n + e + s;
      t[s] && (r[o] = t[s]);
    }),
    r
  );
}
function CN(t) {
  const e = new URLSearchParams(),
    n = nre(t.relay);
  Object.keys(n)
    .sort()
    .forEach((i) => {
      e.set(i, n[i]);
    }),
    e.set("symKey", t.symKey),
    t.expiryTimestamp && e.set("expiryTimestamp", t.expiryTimestamp.toString()),
    t.methods && e.set("methods", t.methods.join(","));
  const r = e.toString();
  return `${t.protocol}:${t.topic}@${t.version}?${r}`;
}
function e0(t, e, n) {
  return `${t}?wc_ev=${n}&topic=${e}`;
}
function kp(t) {
  const e = [];
  return (
    t.forEach((n) => {
      const [r, i] = n.split(":");
      e.push(`${r}:${i}`);
    }),
    e
  );
}
function rre(t) {
  const e = [];
  return (
    Object.values(t).forEach((n) => {
      e.push(...kp(n.accounts));
    }),
    e
  );
}
function ire(t, e) {
  const n = [];
  return (
    Object.values(t).forEach((r) => {
      kp(r.accounts).includes(e) && n.push(...r.methods);
    }),
    n
  );
}
function sre(t, e) {
  const n = [];
  return (
    Object.values(t).forEach((r) => {
      kp(r.accounts).includes(e) && n.push(...r.events);
    }),
    n
  );
}
function OA(t) {
  return t.includes(":");
}
function lh(t) {
  return OA(t) ? t.split(":")[0] : t;
}
function ore(t) {
  const e = {};
  return (
    t == null ||
      t.forEach((n) => {
        var r;
        const [i, s] = n.split(":");
        e[i] || (e[i] = { accounts: [], chains: [], events: [], methods: [] }),
          e[i].accounts.push(n),
          (r = e[i].chains) == null || r.push(`${i}:${s}`);
      }),
    e
  );
}
function xN(t, e) {
  e = e.map((r) => r.replace("did:pkh:", ""));
  const n = ore(e);
  for (const [r, i] of Object.entries(n))
    i.methods ? (i.methods = $0(i.methods, t)) : (i.methods = t),
      (i.events = ["chainChanged", "accountsChanged"]);
  return n;
}
const are = {
    INVALID_METHOD: { message: "Invalid method.", code: 1001 },
    INVALID_EVENT: { message: "Invalid event.", code: 1002 },
    INVALID_UPDATE_REQUEST: { message: "Invalid update request.", code: 1003 },
    INVALID_EXTEND_REQUEST: { message: "Invalid extend request.", code: 1004 },
    INVALID_SESSION_SETTLE_REQUEST: {
      message: "Invalid session settle request.",
      code: 1005,
    },
    UNAUTHORIZED_METHOD: { message: "Unauthorized method.", code: 3001 },
    UNAUTHORIZED_EVENT: { message: "Unauthorized event.", code: 3002 },
    UNAUTHORIZED_UPDATE_REQUEST: {
      message: "Unauthorized update request.",
      code: 3003,
    },
    UNAUTHORIZED_EXTEND_REQUEST: {
      message: "Unauthorized extend request.",
      code: 3004,
    },
    USER_REJECTED: { message: "User rejected.", code: 5e3 },
    USER_REJECTED_CHAINS: { message: "User rejected chains.", code: 5001 },
    USER_REJECTED_METHODS: { message: "User rejected methods.", code: 5002 },
    USER_REJECTED_EVENTS: { message: "User rejected events.", code: 5003 },
    UNSUPPORTED_CHAINS: { message: "Unsupported chains.", code: 5100 },
    UNSUPPORTED_METHODS: { message: "Unsupported methods.", code: 5101 },
    UNSUPPORTED_EVENTS: { message: "Unsupported events.", code: 5102 },
    UNSUPPORTED_ACCOUNTS: { message: "Unsupported accounts.", code: 5103 },
    UNSUPPORTED_NAMESPACE_KEY: {
      message: "Unsupported namespace key.",
      code: 5104,
    },
    USER_DISCONNECTED: { message: "User disconnected.", code: 6e3 },
    SESSION_SETTLEMENT_FAILED: {
      message: "Session settlement failed.",
      code: 7e3,
    },
    WC_METHOD_UNSUPPORTED: { message: "Unsupported wc_ method.", code: 10001 },
  },
  cre = {
    NOT_INITIALIZED: { message: "Not initialized.", code: 1 },
    NO_MATCHING_KEY: { message: "No matching key.", code: 2 },
    RESTORE_WILL_OVERRIDE: { message: "Restore will override.", code: 3 },
    RESUBSCRIBED: { message: "Resubscribed.", code: 4 },
    MISSING_OR_INVALID: { message: "Missing or invalid.", code: 5 },
    EXPIRED: { message: "Expired.", code: 6 },
    UNKNOWN_TYPE: { message: "Unknown type.", code: 7 },
    MISMATCHED_TOPIC: { message: "Mismatched topic.", code: 8 },
    NON_CONFORMING_NAMESPACES: {
      message: "Non conforming namespaces.",
      code: 9,
    },
  };
function xe(t, e) {
  const { message: n, code: r } = cre[t];
  return { message: e ? `${n} ${e}` : n, code: r };
}
function Kt(t, e) {
  const { message: n, code: r } = are[t];
  return { message: e ? `${n} ${e}` : n, code: r };
}
function Nc(t, e) {
  return !!Array.isArray(t);
}
function Kh(t) {
  return Object.getPrototypeOf(t) === Object.prototype && Object.keys(t).length;
}
function Tr(t) {
  return typeof t > "u";
}
function Hn(t, e) {
  return e && Tr(t) ? !0 : typeof t == "string" && !!t.trim().length;
}
function kA(t, e) {
  return e && Tr(t) ? !0 : typeof t == "number" && !isNaN(t);
}
function lre(t, e) {
  const { requiredNamespaces: n } = e,
    r = Object.keys(t.namespaces),
    i = Object.keys(n);
  let s = !0;
  return Pl(i, r)
    ? (r.forEach((o) => {
        const { accounts: a, methods: l, events: d } = t.namespaces[o],
          p = kp(a),
          f = n[o];
        (!Pl(l$(o, f), p) || !Pl(f.methods, l) || !Pl(f.events, d)) && (s = !1);
      }),
      s)
    : !1;
}
function yw(t) {
  return Hn(t, !1) && t.includes(":") ? t.split(":").length === 2 : !1;
}
function ure(t) {
  if (Hn(t, !1) && t.includes(":")) {
    const e = t.split(":");
    if (e.length === 3) {
      const n = e[0] + ":" + e[1];
      return !!e[2] && yw(n);
    }
  }
  return !1;
}
function dre(t) {
  function e(n) {
    try {
      return typeof new URL(n) < "u";
    } catch {
      return !1;
    }
  }
  try {
    if (Hn(t, !1)) {
      if (e(t)) return !0;
      const n = h$(t);
      return e(n);
    }
  } catch {}
  return !1;
}
function pre(t) {
  var e;
  return (e = t == null ? void 0 : t.proposer) == null ? void 0 : e.publicKey;
}
function fre(t) {
  return t == null ? void 0 : t.topic;
}
function hre(t, e) {
  let n = null;
  return (
    Hn(t == null ? void 0 : t.publicKey, !1) ||
      (n = xe(
        "MISSING_OR_INVALID",
        `${e} controller public key should be a string`
      )),
    n
  );
}
function SN(t) {
  let e = !0;
  return Nc(t) ? t.length && (e = t.every((n) => Hn(n, !1))) : (e = !1), e;
}
function mre(t, e, n) {
  let r = null;
  return (
    Nc(e) && e.length
      ? e.forEach((i) => {
          r ||
            yw(i) ||
            (r = Kt(
              "UNSUPPORTED_CHAINS",
              `${n}, chain ${i} should be a string and conform to "namespace:chainId" format`
            ));
        })
      : yw(t) ||
        (r = Kt(
          "UNSUPPORTED_CHAINS",
          `${n}, chains must be defined as "namespace:chainId" e.g. "eip155:1": {...} in the namespace key OR as an array of CAIP-2 chainIds e.g. eip155: { chains: ["eip155:1", "eip155:5"] }`
        )),
    r
  );
}
function gre(t, e, n) {
  let r = null;
  return (
    Object.entries(t).forEach(([i, s]) => {
      if (r) return;
      const o = mre(i, l$(i, s), `${e} ${n}`);
      o && (r = o);
    }),
    r
  );
}
function yre(t, e) {
  let n = null;
  return (
    Nc(t)
      ? t.forEach((r) => {
          n ||
            ure(r) ||
            (n = Kt(
              "UNSUPPORTED_ACCOUNTS",
              `${e}, account ${r} should be a string and conform to "namespace:chainId:address" format`
            ));
        })
      : (n = Kt(
          "UNSUPPORTED_ACCOUNTS",
          `${e}, accounts should be an array of strings conforming to "namespace:chainId:address" format`
        )),
    n
  );
}
function wre(t, e) {
  let n = null;
  return (
    Object.values(t).forEach((r) => {
      if (n) return;
      const i = yre(r == null ? void 0 : r.accounts, `${e} namespace`);
      i && (n = i);
    }),
    n
  );
}
function vre(t, e) {
  let n = null;
  return (
    SN(t == null ? void 0 : t.methods)
      ? SN(t == null ? void 0 : t.events) ||
        (n = Kt(
          "UNSUPPORTED_EVENTS",
          `${e}, events should be an array of strings or empty array for no events`
        ))
      : (n = Kt(
          "UNSUPPORTED_METHODS",
          `${e}, methods should be an array of strings or empty array for no methods`
        )),
    n
  );
}
function G$(t, e) {
  let n = null;
  return (
    Object.values(t).forEach((r) => {
      if (n) return;
      const i = vre(r, `${e}, namespace`);
      i && (n = i);
    }),
    n
  );
}
function bre(t, e, n) {
  let r = null;
  if (t && Kh(t)) {
    const i = G$(t, e);
    i && (r = i);
    const s = gre(t, e, n);
    s && (r = s);
  } else
    r = xe("MISSING_OR_INVALID", `${e}, ${n} should be an object with data`);
  return r;
}
function WE(t, e) {
  let n = null;
  if (t && Kh(t)) {
    const r = G$(t, e);
    r && (n = r);
    const i = wre(t, e);
    i && (n = i);
  } else
    n = xe(
      "MISSING_OR_INVALID",
      `${e}, namespaces should be an object with data`
    );
  return n;
}
function K$(t) {
  return Hn(t.protocol, !0);
}
function Ere(t, e) {
  let n = !1;
  return (
    t
      ? t &&
        Nc(t) &&
        t.length &&
        t.forEach((r) => {
          n = K$(r);
        })
      : (n = !0),
    n
  );
}
function Cre(t) {
  return typeof t == "number";
}
function wi(t) {
  return typeof t < "u" && typeof t !== null;
}
function xre(t) {
  return !(
    !t ||
    typeof t != "object" ||
    !t.code ||
    !kA(t.code, !1) ||
    !t.message ||
    !Hn(t.message, !1)
  );
}
function Sre(t) {
  return !(Tr(t) || !Hn(t.method, !1));
}
function Are(t) {
  return !(
    Tr(t) ||
    (Tr(t.result) && Tr(t.error)) ||
    !kA(t.id, !1) ||
    !Hn(t.jsonrpc, !1)
  );
}
function _re(t) {
  return !(Tr(t) || !Hn(t.name, !1));
}
function AN(t, e) {
  return !(!yw(e) || !rre(t).includes(e));
}
function Ire(t, e, n) {
  return Hn(n, !1) ? ire(t, e).includes(n) : !1;
}
function Tre(t, e, n) {
  return Hn(n, !1) ? sre(t, e).includes(n) : !1;
}
function _N(t, e, n) {
  let r = null;
  const i = Pre(t),
    s = Rre(e),
    o = Object.keys(i),
    a = Object.keys(s),
    l = IN(Object.keys(t)),
    d = IN(Object.keys(e)),
    p = l.filter((f) => !d.includes(f));
  return (
    p.length &&
      (r = xe(
        "NON_CONFORMING_NAMESPACES",
        `${n} namespaces keys don't satisfy requiredNamespaces.
      Required: ${p.toString()}
      Received: ${Object.keys(e).toString()}`
      )),
    Pl(o, a) ||
      (r = xe(
        "NON_CONFORMING_NAMESPACES",
        `${n} namespaces chains don't satisfy required namespaces.
      Required: ${o.toString()}
      Approved: ${a.toString()}`
      )),
    Object.keys(e).forEach((f) => {
      if (!f.includes(":") || r) return;
      const m = kp(e[f].accounts);
      m.includes(f) ||
        (r = xe(
          "NON_CONFORMING_NAMESPACES",
          `${n} namespaces accounts don't satisfy namespace accounts for ${f}
        Required: ${f}
        Approved: ${m.toString()}`
        ));
    }),
    o.forEach((f) => {
      r ||
        (Pl(i[f].methods, s[f].methods)
          ? Pl(i[f].events, s[f].events) ||
            (r = xe(
              "NON_CONFORMING_NAMESPACES",
              `${n} namespaces events don't satisfy namespace events for ${f}`
            ))
          : (r = xe(
              "NON_CONFORMING_NAMESPACES",
              `${n} namespaces methods don't satisfy namespace methods for ${f}`
            )));
    }),
    r
  );
}
function Pre(t) {
  const e = {};
  return (
    Object.keys(t).forEach((n) => {
      var r;
      n.includes(":")
        ? (e[n] = t[n])
        : (r = t[n].chains) == null ||
          r.forEach((i) => {
            e[i] = { methods: t[n].methods, events: t[n].events };
          });
    }),
    e
  );
}
function IN(t) {
  return [...new Set(t.map((e) => (e.includes(":") ? e.split(":")[0] : e)))];
}
function Rre(t) {
  const e = {};
  return (
    Object.keys(t).forEach((n) => {
      if (n.includes(":")) e[n] = t[n];
      else {
        const r = kp(t[n].accounts);
        r == null ||
          r.forEach((i) => {
            e[i] = {
              accounts: t[n].accounts.filter((s) => s.includes(`${i}:`)),
              methods: t[n].methods,
              events: t[n].events,
            };
          });
      }
    }),
    e
  );
}
function Nre(t, e) {
  return kA(t, !1) && t <= e.max && t >= e.min;
}
function TN() {
  const t = eg();
  return new Promise((e) => {
    switch (t) {
      case Wi.browser:
        e(Ore());
        break;
      case Wi.reactNative:
        e(kre());
        break;
      case Wi.node:
        e(Dre());
        break;
      default:
        e(!0);
    }
  });
}
function Ore() {
  return Jm() && (navigator == null ? void 0 : navigator.onLine);
}
async function kre() {
  if (Yc() && typeof global < "u" && global != null && global.NetInfo) {
    const t = await (global == null ? void 0 : global.NetInfo.fetch());
    return t == null ? void 0 : t.isConnected;
  }
  return !0;
}
function Dre() {
  return !0;
}
function $re(t) {
  switch (eg()) {
    case Wi.browser:
      Mre(t);
      break;
    case Wi.reactNative:
      Lre(t);
      break;
  }
}
function Mre(t) {
  !Yc() &&
    Jm() &&
    (window.addEventListener("online", () => t(!0)),
    window.addEventListener("offline", () => t(!1)));
}
function Lre(t) {
  Yc() &&
    typeof global < "u" &&
    global != null &&
    global.NetInfo &&
    (global == null ||
      global.NetInfo.addEventListener((e) =>
        t(e == null ? void 0 : e.isConnected)
      ));
}
const HE = {};
class zf {
  static get(e) {
    return HE[e];
  }
  static set(e, n) {
    HE[e] = n;
  }
  static delete(e) {
    delete HE[e];
  }
}
const Ure = "PARSE_ERROR",
  Bre = "INVALID_REQUEST",
  jre = "METHOD_NOT_FOUND",
  Fre = "INVALID_PARAMS",
  Y$ = "INTERNAL_ERROR",
  DA = "SERVER_ERROR",
  zre = [-32700, -32600, -32601, -32602, -32603],
  vh = {
    [Ure]: { code: -32700, message: "Parse error" },
    [Bre]: { code: -32600, message: "Invalid Request" },
    [jre]: { code: -32601, message: "Method not found" },
    [Fre]: { code: -32602, message: "Invalid params" },
    [Y$]: { code: -32603, message: "Internal error" },
    [DA]: { code: -32e3, message: "Server error" },
  },
  Z$ = DA;
function Wre(t) {
  return zre.includes(t);
}
function PN(t) {
  return Object.keys(vh).includes(t) ? vh[t] : vh[Z$];
}
function Hre(t) {
  const e = Object.values(vh).find((n) => n.code === t);
  return e || vh[Z$];
}
function Q$(t, e, n) {
  return t.message.includes("getaddrinfo ENOTFOUND") ||
    t.message.includes("connect ECONNREFUSED")
    ? new Error(`Unavailable ${n} RPC url at ${e}`)
    : t;
}
var qE = {},
  ra = {},
  RN;
function qre() {
  if (RN) return ra;
  (RN = 1),
    Object.defineProperty(ra, "__esModule", { value: !0 }),
    (ra.isBrowserCryptoAvailable =
      ra.getSubtleCrypto =
      ra.getBrowerCrypto =
        void 0);
  function t() {
    return (
      (Eo == null ? void 0 : Eo.crypto) ||
      (Eo == null ? void 0 : Eo.msCrypto) ||
      {}
    );
  }
  ra.getBrowerCrypto = t;
  function e() {
    const r = t();
    return r.subtle || r.webkitSubtle;
  }
  ra.getSubtleCrypto = e;
  function n() {
    return !!t() && !!e();
  }
  return (ra.isBrowserCryptoAvailable = n), ra;
}
var ia = {},
  NN;
function Vre() {
  if (NN) return ia;
  (NN = 1),
    Object.defineProperty(ia, "__esModule", { value: !0 }),
    (ia.isBrowser = ia.isNode = ia.isReactNative = void 0);
  function t() {
    return (
      typeof document > "u" &&
      typeof navigator < "u" &&
      navigator.product === "ReactNative"
    );
  }
  ia.isReactNative = t;
  function e() {
    return (
      typeof process < "u" &&
      typeof process.versions < "u" &&
      typeof process.versions.node < "u"
    );
  }
  ia.isNode = e;
  function n() {
    return !t() && !e();
  }
  return (ia.isBrowser = n), ia;
}
var ON;
function Gre() {
  return (
    ON ||
      ((ON = 1),
      (function (t) {
        Object.defineProperty(t, "__esModule", { value: !0 });
        const e = Gm;
        e.__exportStar(qre(), t), e.__exportStar(Vre(), t);
      })(qE)),
    qE
  );
}
var Kre = Gre();
function go(t = 3) {
  const e = Date.now() * Math.pow(10, t),
    n = Math.floor(Math.random() * Math.pow(10, t));
  return e + n;
}
function Rl(t = 6) {
  return BigInt(go(t));
}
function Tc(t, e, n) {
  return { id: n || go(), jsonrpc: "2.0", method: t, params: e };
}
function Tv(t, e) {
  return { id: t, jsonrpc: "2.0", result: e };
}
function Pv(t, e, n) {
  return { id: t, jsonrpc: "2.0", error: Yre(e) };
}
function Yre(t, e) {
  return typeof t > "u"
    ? PN(Y$)
    : (typeof t == "string" &&
        (t = Object.assign(Object.assign({}, PN(DA)), { message: t })),
      Wre(t.code) && (t = Hre(t.code)),
      t);
}
let Zre = class {},
  Qre = class extends Zre {
    constructor() {
      super();
    }
  },
  Xre = class extends Qre {
    constructor(e) {
      super();
    }
  };
const Jre = "^https?:",
  eie = "^wss?:";
function tie(t) {
  const e = t.match(new RegExp(/^\w+:/, "gi"));
  if (!(!e || !e.length)) return e[0];
}
function X$(t, e) {
  const n = tie(t);
  return typeof n > "u" ? !1 : new RegExp(e).test(n);
}
function kN(t) {
  return X$(t, Jre);
}
function DN(t) {
  return X$(t, eie);
}
function nie(t) {
  return new RegExp("wss?://localhost(:d{2,5})?").test(t);
}
function J$(t) {
  return (
    typeof t == "object" && "id" in t && "jsonrpc" in t && t.jsonrpc === "2.0"
  );
}
function $A(t) {
  return J$(t) && "method" in t;
}
function Rv(t) {
  return J$(t) && (yo(t) || ls(t));
}
function yo(t) {
  return "result" in t;
}
function ls(t) {
  return "error" in t;
}
let _s = class extends Xre {
  constructor(e) {
    super(e),
      (this.events = new Ss.EventEmitter()),
      (this.hasRegisteredEventListeners = !1),
      (this.connection = this.setConnection(e)),
      this.connection.connected && this.registerEventListeners();
  }
  async connect(e = this.connection) {
    await this.open(e);
  }
  async disconnect() {
    await this.close();
  }
  on(e, n) {
    this.events.on(e, n);
  }
  once(e, n) {
    this.events.once(e, n);
  }
  off(e, n) {
    this.events.off(e, n);
  }
  removeListener(e, n) {
    this.events.removeListener(e, n);
  }
  async request(e, n) {
    return this.requestStrict(
      Tc(e.method, e.params || [], e.id || Rl().toString()),
      n
    );
  }
  async requestStrict(e, n) {
    return new Promise(async (r, i) => {
      if (!this.connection.connected)
        try {
          await this.open();
        } catch (s) {
          i(s);
        }
      this.events.on(`${e.id}`, (s) => {
        ls(s) ? i(s.error) : r(s.result);
      });
      try {
        await this.connection.send(e, n);
      } catch (s) {
        i(s);
      }
    });
  }
  setConnection(e = this.connection) {
    return e;
  }
  onPayload(e) {
    this.events.emit("payload", e),
      Rv(e)
        ? this.events.emit(`${e.id}`, e)
        : this.events.emit("message", { type: e.method, data: e.params });
  }
  onClose(e) {
    e &&
      e.code === 3e3 &&
      this.events.emit(
        "error",
        new Error(
          `WebSocket connection closed abnormally with code: ${e.code} ${
            e.reason ? `(${e.reason})` : ""
          }`
        )
      ),
      this.events.emit("disconnect");
  }
  async open(e = this.connection) {
    (this.connection === e && this.connection.connected) ||
      (this.connection.connected && this.close(),
      typeof e == "string" &&
        (await this.connection.open(e), (e = this.connection)),
      (this.connection = this.setConnection(e)),
      await this.connection.open(),
      this.registerEventListeners(),
      this.events.emit("connect"));
  }
  async close() {
    await this.connection.close();
  }
  registerEventListeners() {
    this.hasRegisteredEventListeners ||
      (this.connection.on("payload", (e) => this.onPayload(e)),
      this.connection.on("close", (e) => this.onClose(e)),
      this.connection.on("error", (e) => this.events.emit("error", e)),
      this.connection.on("register_error", (e) => this.onClose()),
      (this.hasRegisteredEventListeners = !0));
  }
};
const rie = () =>
    typeof WebSocket < "u"
      ? WebSocket
      : typeof global < "u" && typeof global.WebSocket < "u"
      ? global.WebSocket
      : typeof window < "u" && typeof window.WebSocket < "u"
      ? window.WebSocket
      : typeof self < "u" && typeof self.WebSocket < "u"
      ? self.WebSocket
      : require("ws"),
  iie = () =>
    typeof WebSocket < "u" ||
    (typeof global < "u" && typeof global.WebSocket < "u") ||
    (typeof window < "u" && typeof window.WebSocket < "u") ||
    (typeof self < "u" && typeof self.WebSocket < "u"),
  $N = (t) => t.split("?")[0],
  MN = 10,
  sie = rie();
let oie = class {
  constructor(e) {
    if (
      ((this.url = e),
      (this.events = new Ss.EventEmitter()),
      (this.registering = !1),
      !DN(e))
    )
      throw new Error(
        `Provided URL is not compatible with WebSocket connection: ${e}`
      );
    this.url = e;
  }
  get connected() {
    return typeof this.socket < "u";
  }
  get connecting() {
    return this.registering;
  }
  on(e, n) {
    this.events.on(e, n);
  }
  once(e, n) {
    this.events.once(e, n);
  }
  off(e, n) {
    this.events.off(e, n);
  }
  removeListener(e, n) {
    this.events.removeListener(e, n);
  }
  async open(e = this.url) {
    await this.register(e);
  }
  async close() {
    return new Promise((e, n) => {
      if (typeof this.socket > "u") {
        n(new Error("Connection already closed"));
        return;
      }
      (this.socket.onclose = (r) => {
        this.onClose(r), e();
      }),
        this.socket.close();
    });
  }
  async send(e) {
    typeof this.socket > "u" && (this.socket = await this.register());
    try {
      this.socket.send(Aa(e));
    } catch (n) {
      this.onError(e.id, n);
    }
  }
  register(e = this.url) {
    if (!DN(e))
      throw new Error(
        `Provided URL is not compatible with WebSocket connection: ${e}`
      );
    if (this.registering) {
      const n = this.events.getMaxListeners();
      return (
        (this.events.listenerCount("register_error") >= n ||
          this.events.listenerCount("open") >= n) &&
          this.events.setMaxListeners(n + 1),
        new Promise((r, i) => {
          this.events.once("register_error", (s) => {
            this.resetMaxListeners(), i(s);
          }),
            this.events.once("open", () => {
              if ((this.resetMaxListeners(), typeof this.socket > "u"))
                return i(
                  new Error("WebSocket connection is missing or invalid")
                );
              r(this.socket);
            });
        })
      );
    }
    return (
      (this.url = e),
      (this.registering = !0),
      new Promise((n, r) => {
        const i = Kre.isReactNative()
            ? void 0
            : { rejectUnauthorized: !nie(e) },
          s = new sie(e, [], i);
        iie()
          ? (s.onerror = (o) => {
              const a = o;
              r(this.emitError(a.error));
            })
          : s.on("error", (o) => {
              r(this.emitError(o));
            }),
          (s.onopen = () => {
            this.onOpen(s), n(s);
          });
      })
    );
  }
  onOpen(e) {
    (e.onmessage = (n) => this.onPayload(n)),
      (e.onclose = (n) => this.onClose(n)),
      (this.socket = e),
      (this.registering = !1),
      this.events.emit("open");
  }
  onClose(e) {
    (this.socket = void 0),
      (this.registering = !1),
      this.events.emit("close", e);
  }
  onPayload(e) {
    if (typeof e.data > "u") return;
    const n = typeof e.data == "string" ? Zl(e.data) : e.data;
    this.events.emit("payload", n);
  }
  onError(e, n) {
    const r = this.parseError(n),
      i = r.message || r.toString(),
      s = Pv(e, i);
    this.events.emit("payload", s);
  }
  parseError(e, n = this.url) {
    return Q$(e, $N(n), "WS");
  }
  resetMaxListeners() {
    this.events.getMaxListeners() > MN && this.events.setMaxListeners(MN);
  }
  emitError(e) {
    const n = this.parseError(
      new Error(
        (e == null ? void 0 : e.message) ||
          `WebSocket connection failed for host: ${$N(this.url)}`
      )
    );
    return this.events.emit("register_error", n), n;
  }
};
var aie = {};
const eM = "wc",
  tM = 2,
  ww = "core",
  Oo = `${eM}@2:${ww}:`,
  cie = { name: ww, logger: "error" },
  lie = { database: ":memory:" },
  uie = "crypto",
  LN = "client_ed25519_seed",
  die = Ee.ONE_DAY,
  pie = "keychain",
  fie = "0.3",
  hie = "messages",
  mie = "0.3",
  UN = Ee.SIX_HOURS,
  gie = "publisher",
  nM = "irn",
  yie = "error",
  rM = "wss://relay.walletconnect.org",
  wie = "relayer",
  fr = {
    message: "relayer_message",
    message_ack: "relayer_message_ack",
    connect: "relayer_connect",
    disconnect: "relayer_disconnect",
    error: "relayer_error",
    connection_stalled: "relayer_connection_stalled",
    transport_closed: "relayer_transport_closed",
    publish: "relayer_publish",
  },
  vie = "_subscription",
  ns = {
    payload: "payload",
    connect: "connect",
    disconnect: "disconnect",
    error: "error",
  },
  bie = 0.1,
  Ux = "2.19.2",
  dn = { link_mode: "link_mode", relay: "relay" },
  U0 = { inbound: "inbound", outbound: "outbound" },
  Eie = "0.3",
  Cie = "WALLETCONNECT_CLIENT_ID",
  BN = "WALLETCONNECT_LINK_MODE_APPS",
  Ui = {
    created: "subscription_created",
    deleted: "subscription_deleted",
    expired: "subscription_expired",
    disabled: "subscription_disabled",
    sync: "subscription_sync",
    resubscribed: "subscription_resubscribed",
  },
  xie = "subscription",
  Sie = "0.3",
  Aie = "pairing",
  _ie = "0.3",
  Wf = {
    wc_pairingDelete: {
      req: { ttl: Ee.ONE_DAY, prompt: !1, tag: 1e3 },
      res: { ttl: Ee.ONE_DAY, prompt: !1, tag: 1001 },
    },
    wc_pairingPing: {
      req: { ttl: Ee.THIRTY_SECONDS, prompt: !1, tag: 1002 },
      res: { ttl: Ee.THIRTY_SECONDS, prompt: !1, tag: 1003 },
    },
    unregistered_method: {
      req: { ttl: Ee.ONE_DAY, prompt: !1, tag: 0 },
      res: { ttl: Ee.ONE_DAY, prompt: !1, tag: 0 },
    },
  },
  Sl = {
    create: "pairing_create",
    expire: "pairing_expire",
    delete: "pairing_delete",
    ping: "pairing_ping",
  },
  Ms = {
    created: "history_created",
    updated: "history_updated",
    deleted: "history_deleted",
    sync: "history_sync",
  },
  Iie = "history",
  Tie = "0.3",
  Pie = "expirer",
  as = {
    created: "expirer_created",
    deleted: "expirer_deleted",
    expired: "expirer_expired",
    sync: "expirer_sync",
  },
  Rie = "0.3",
  Nie = "verify-api",
  Oie = "https://verify.walletconnect.com",
  iM = "https://verify.walletconnect.org",
  bh = iM,
  kie = `${bh}/v3`,
  Die = [Oie, iM],
  $ie = "echo",
  Mie = "https://echo.walletconnect.com",
  mo = {
    pairing_started: "pairing_started",
    pairing_uri_validation_success: "pairing_uri_validation_success",
    pairing_uri_not_expired: "pairing_uri_not_expired",
    store_new_pairing: "store_new_pairing",
    subscribing_pairing_topic: "subscribing_pairing_topic",
    subscribe_pairing_topic_success: "subscribe_pairing_topic_success",
    existing_pairing: "existing_pairing",
    pairing_not_expired: "pairing_not_expired",
    emit_inactive_pairing: "emit_inactive_pairing",
    emit_session_proposal: "emit_session_proposal",
    subscribing_to_pairing_topic: "subscribing_to_pairing_topic",
  },
  ca = {
    no_wss_connection: "no_wss_connection",
    no_internet_connection: "no_internet_connection",
    malformed_pairing_uri: "malformed_pairing_uri",
    active_pairing_already_exists: "active_pairing_already_exists",
    subscribe_pairing_topic_failure: "subscribe_pairing_topic_failure",
    pairing_expired: "pairing_expired",
    proposal_expired: "proposal_expired",
    proposal_listener_not_found: "proposal_listener_not_found",
  },
  Ls = {
    session_approve_started: "session_approve_started",
    proposal_not_expired: "proposal_not_expired",
    session_namespaces_validation_success:
      "session_namespaces_validation_success",
    create_session_topic: "create_session_topic",
    subscribing_session_topic: "subscribing_session_topic",
    subscribe_session_topic_success: "subscribe_session_topic_success",
    publishing_session_approve: "publishing_session_approve",
    session_approve_publish_success: "session_approve_publish_success",
    store_session: "store_session",
    publishing_session_settle: "publishing_session_settle",
    session_settle_publish_success: "session_settle_publish_success",
  },
  pl = {
    no_internet_connection: "no_internet_connection",
    no_wss_connection: "no_wss_connection",
    proposal_expired: "proposal_expired",
    subscribe_session_topic_failure: "subscribe_session_topic_failure",
    session_approve_publish_failure: "session_approve_publish_failure",
    session_settle_publish_failure: "session_settle_publish_failure",
    session_approve_namespace_validation_failure:
      "session_approve_namespace_validation_failure",
    proposal_not_found: "proposal_not_found",
  },
  fl = {
    authenticated_session_approve_started:
      "authenticated_session_approve_started",
    authenticated_session_not_expired: "authenticated_session_not_expired",
    chains_caip2_compliant: "chains_caip2_compliant",
    chains_evm_compliant: "chains_evm_compliant",
    create_authenticated_session_topic: "create_authenticated_session_topic",
    cacaos_verified: "cacaos_verified",
    store_authenticated_session: "store_authenticated_session",
    subscribing_authenticated_session_topic:
      "subscribing_authenticated_session_topic",
    subscribe_authenticated_session_topic_success:
      "subscribe_authenticated_session_topic_success",
    publishing_authenticated_session_approve:
      "publishing_authenticated_session_approve",
    authenticated_session_approve_publish_success:
      "authenticated_session_approve_publish_success",
  },
  Hf = {
    no_internet_connection: "no_internet_connection",
    no_wss_connection: "no_wss_connection",
    missing_session_authenticate_request:
      "missing_session_authenticate_request",
    session_authenticate_request_expired:
      "session_authenticate_request_expired",
    chains_caip2_compliant_failure: "chains_caip2_compliant_failure",
    chains_evm_compliant_failure: "chains_evm_compliant_failure",
    invalid_cacao: "invalid_cacao",
    subscribe_authenticated_session_topic_failure:
      "subscribe_authenticated_session_topic_failure",
    authenticated_session_approve_publish_failure:
      "authenticated_session_approve_publish_failure",
    authenticated_session_pending_request_not_found:
      "authenticated_session_pending_request_not_found",
  },
  Lie = 0.1,
  Uie = "event-client",
  Bie = 86400,
  jie = "https://pulse.walletconnect.org/batch";
function Fie(t, e) {
  if (t.length >= 255) throw new TypeError("Alphabet too long");
  for (var n = new Uint8Array(256), r = 0; r < n.length; r++) n[r] = 255;
  for (var i = 0; i < t.length; i++) {
    var s = t.charAt(i),
      o = s.charCodeAt(0);
    if (n[o] !== 255) throw new TypeError(s + " is ambiguous");
    n[o] = i;
  }
  var a = t.length,
    l = t.charAt(0),
    d = Math.log(a) / Math.log(256),
    p = Math.log(256) / Math.log(a);
  function f(g) {
    if (
      (g instanceof Uint8Array ||
        (ArrayBuffer.isView(g)
          ? (g = new Uint8Array(g.buffer, g.byteOffset, g.byteLength))
          : Array.isArray(g) && (g = Uint8Array.from(g))),
      !(g instanceof Uint8Array))
    )
      throw new TypeError("Expected Uint8Array");
    if (g.length === 0) return "";
    for (var v = 0, b = 0, E = 0, S = g.length; E !== S && g[E] === 0; )
      E++, v++;
    for (var C = ((S - E) * p + 1) >>> 0, _ = new Uint8Array(C); E !== S; ) {
      for (
        var A = g[E], I = 0, R = C - 1;
        (A !== 0 || I < b) && R !== -1;
        R--, I++
      )
        (A += (256 * _[R]) >>> 0), (_[R] = A % a >>> 0), (A = (A / a) >>> 0);
      if (A !== 0) throw new Error("Non-zero carry");
      (b = I), E++;
    }
    for (var D = C - b; D !== C && _[D] === 0; ) D++;
    for (var k = l.repeat(v); D < C; ++D) k += t.charAt(_[D]);
    return k;
  }
  function m(g) {
    if (typeof g != "string") throw new TypeError("Expected String");
    if (g.length === 0) return new Uint8Array();
    var v = 0;
    if (g[v] !== " ") {
      for (var b = 0, E = 0; g[v] === l; ) b++, v++;
      for (
        var S = ((g.length - v) * d + 1) >>> 0, C = new Uint8Array(S);
        g[v];

      ) {
        var _ = n[g.charCodeAt(v)];
        if (_ === 255) return;
        for (var A = 0, I = S - 1; (_ !== 0 || A < E) && I !== -1; I--, A++)
          (_ += (a * C[I]) >>> 0),
            (C[I] = _ % 256 >>> 0),
            (_ = (_ / 256) >>> 0);
        if (_ !== 0) throw new Error("Non-zero carry");
        (E = A), v++;
      }
      if (g[v] !== " ") {
        for (var R = S - E; R !== S && C[R] === 0; ) R++;
        for (var D = new Uint8Array(b + (S - R)), k = b; R !== S; )
          D[k++] = C[R++];
        return D;
      }
    }
  }
  function y(g) {
    var v = m(g);
    if (v) return v;
    throw new Error(`Non-${e} character`);
  }
  return { encode: f, decodeUnsafe: m, decode: y };
}
var zie = Fie,
  Wie = zie;
const sM = (t) => {
    if (t instanceof Uint8Array && t.constructor.name === "Uint8Array")
      return t;
    if (t instanceof ArrayBuffer) return new Uint8Array(t);
    if (ArrayBuffer.isView(t))
      return new Uint8Array(t.buffer, t.byteOffset, t.byteLength);
    throw new Error("Unknown type, must be binary type");
  },
  Hie = (t) => new TextEncoder().encode(t),
  qie = (t) => new TextDecoder().decode(t);
class Vie {
  constructor(e, n, r) {
    (this.name = e), (this.prefix = n), (this.baseEncode = r);
  }
  encode(e) {
    if (e instanceof Uint8Array) return `${this.prefix}${this.baseEncode(e)}`;
    throw Error("Unknown type, must be binary type");
  }
}
class Gie {
  constructor(e, n, r) {
    if (((this.name = e), (this.prefix = n), n.codePointAt(0) === void 0))
      throw new Error("Invalid prefix character");
    (this.prefixCodePoint = n.codePointAt(0)), (this.baseDecode = r);
  }
  decode(e) {
    if (typeof e == "string") {
      if (e.codePointAt(0) !== this.prefixCodePoint)
        throw Error(
          `Unable to decode multibase string ${JSON.stringify(e)}, ${
            this.name
          } decoder only supports inputs prefixed with ${this.prefix}`
        );
      return this.baseDecode(e.slice(this.prefix.length));
    } else throw Error("Can only multibase decode strings");
  }
  or(e) {
    return oM(this, e);
  }
}
class Kie {
  constructor(e) {
    this.decoders = e;
  }
  or(e) {
    return oM(this, e);
  }
  decode(e) {
    const n = e[0],
      r = this.decoders[n];
    if (r) return r.decode(e);
    throw RangeError(
      `Unable to decode multibase string ${JSON.stringify(
        e
      )}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`
    );
  }
}
const oM = (t, e) =>
  new Kie({
    ...(t.decoders || { [t.prefix]: t }),
    ...(e.decoders || { [e.prefix]: e }),
  });
class Yie {
  constructor(e, n, r, i) {
    (this.name = e),
      (this.prefix = n),
      (this.baseEncode = r),
      (this.baseDecode = i),
      (this.encoder = new Vie(e, n, r)),
      (this.decoder = new Gie(e, n, i));
  }
  encode(e) {
    return this.encoder.encode(e);
  }
  decode(e) {
    return this.decoder.decode(e);
  }
}
const Nv = ({ name: t, prefix: e, encode: n, decode: r }) =>
    new Yie(t, e, n, r),
  og = ({ prefix: t, name: e, alphabet: n }) => {
    const { encode: r, decode: i } = Wie(n, e);
    return Nv({ prefix: t, name: e, encode: r, decode: (s) => sM(i(s)) });
  },
  Zie = (t, e, n, r) => {
    const i = {};
    for (let p = 0; p < e.length; ++p) i[e[p]] = p;
    let s = t.length;
    for (; t[s - 1] === "="; ) --s;
    const o = new Uint8Array(((s * n) / 8) | 0);
    let a = 0,
      l = 0,
      d = 0;
    for (let p = 0; p < s; ++p) {
      const f = i[t[p]];
      if (f === void 0) throw new SyntaxError(`Non-${r} character`);
      (l = (l << n) | f),
        (a += n),
        a >= 8 && ((a -= 8), (o[d++] = 255 & (l >> a)));
    }
    if (a >= n || 255 & (l << (8 - a)))
      throw new SyntaxError("Unexpected end of data");
    return o;
  },
  Qie = (t, e, n) => {
    const r = e[e.length - 1] === "=",
      i = (1 << n) - 1;
    let s = "",
      o = 0,
      a = 0;
    for (let l = 0; l < t.length; ++l)
      for (a = (a << 8) | t[l], o += 8; o > n; )
        (o -= n), (s += e[i & (a >> o)]);
    if ((o && (s += e[i & (a << (n - o))]), r))
      for (; (s.length * n) & 7; ) s += "=";
    return s;
  },
  kr = ({ name: t, prefix: e, bitsPerChar: n, alphabet: r }) =>
    Nv({
      prefix: e,
      name: t,
      encode(i) {
        return Qie(i, r, n);
      },
      decode(i) {
        return Zie(i, r, n, t);
      },
    }),
  Xie = Nv({
    prefix: "\0",
    name: "identity",
    encode: (t) => qie(t),
    decode: (t) => Hie(t),
  });
var Jie = Object.freeze({ __proto__: null, identity: Xie });
const ese = kr({ prefix: "0", name: "base2", alphabet: "01", bitsPerChar: 1 });
var tse = Object.freeze({ __proto__: null, base2: ese });
const nse = kr({
  prefix: "7",
  name: "base8",
  alphabet: "01234567",
  bitsPerChar: 3,
});
var rse = Object.freeze({ __proto__: null, base8: nse });
const ise = og({ prefix: "9", name: "base10", alphabet: "0123456789" });
var sse = Object.freeze({ __proto__: null, base10: ise });
const ose = kr({
    prefix: "f",
    name: "base16",
    alphabet: "0123456789abcdef",
    bitsPerChar: 4,
  }),
  ase = kr({
    prefix: "F",
    name: "base16upper",
    alphabet: "0123456789ABCDEF",
    bitsPerChar: 4,
  });
var cse = Object.freeze({ __proto__: null, base16: ose, base16upper: ase });
const lse = kr({
    prefix: "b",
    name: "base32",
    alphabet: "abcdefghijklmnopqrstuvwxyz234567",
    bitsPerChar: 5,
  }),
  use = kr({
    prefix: "B",
    name: "base32upper",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
    bitsPerChar: 5,
  }),
  dse = kr({
    prefix: "c",
    name: "base32pad",
    alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
    bitsPerChar: 5,
  }),
  pse = kr({
    prefix: "C",
    name: "base32padupper",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
    bitsPerChar: 5,
  }),
  fse = kr({
    prefix: "v",
    name: "base32hex",
    alphabet: "0123456789abcdefghijklmnopqrstuv",
    bitsPerChar: 5,
  }),
  hse = kr({
    prefix: "V",
    name: "base32hexupper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
    bitsPerChar: 5,
  }),
  mse = kr({
    prefix: "t",
    name: "base32hexpad",
    alphabet: "0123456789abcdefghijklmnopqrstuv=",
    bitsPerChar: 5,
  }),
  gse = kr({
    prefix: "T",
    name: "base32hexpadupper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
    bitsPerChar: 5,
  }),
  yse = kr({
    prefix: "h",
    name: "base32z",
    alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
    bitsPerChar: 5,
  });
var wse = Object.freeze({
  __proto__: null,
  base32: lse,
  base32upper: use,
  base32pad: dse,
  base32padupper: pse,
  base32hex: fse,
  base32hexupper: hse,
  base32hexpad: mse,
  base32hexpadupper: gse,
  base32z: yse,
});
const vse = og({
    prefix: "k",
    name: "base36",
    alphabet: "0123456789abcdefghijklmnopqrstuvwxyz",
  }),
  bse = og({
    prefix: "K",
    name: "base36upper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ",
  });
var Ese = Object.freeze({ __proto__: null, base36: vse, base36upper: bse });
const Cse = og({
    name: "base58btc",
    prefix: "z",
    alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz",
  }),
  xse = og({
    name: "base58flickr",
    prefix: "Z",
    alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ",
  });
var Sse = Object.freeze({ __proto__: null, base58btc: Cse, base58flickr: xse });
const Ase = kr({
    prefix: "m",
    name: "base64",
    alphabet:
      "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
    bitsPerChar: 6,
  }),
  _se = kr({
    prefix: "M",
    name: "base64pad",
    alphabet:
      "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
    bitsPerChar: 6,
  }),
  Ise = kr({
    prefix: "u",
    name: "base64url",
    alphabet:
      "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
    bitsPerChar: 6,
  }),
  Tse = kr({
    prefix: "U",
    name: "base64urlpad",
    alphabet:
      "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
    bitsPerChar: 6,
  });
var Pse = Object.freeze({
  __proto__: null,
  base64: Ase,
  base64pad: _se,
  base64url: Ise,
  base64urlpad: Tse,
});
const aM = Array.from(
    ""
  ),
  Rse = aM.reduce((t, e, n) => ((t[n] = e), t), []),
  Nse = aM.reduce((t, e, n) => ((t[e.codePointAt(0)] = n), t), []);
function Ose(t) {
  return t.reduce((e, n) => ((e += Rse[n]), e), "");
}
function kse(t) {
  const e = [];
  for (const n of t) {
    const r = Nse[n.codePointAt(0)];
    if (r === void 0) throw new Error(`Non-base256emoji character: ${n}`);
    e.push(r);
  }
  return new Uint8Array(e);
}
const Dse = Nv({
  prefix: "",
  name: "base256emoji",
  encode: Ose,
  decode: kse,
});
var $se = Object.freeze({ __proto__: null, base256emoji: Dse }),
  Mse = cM,
  jN = 128,
  Lse = 127,
  Use = ~Lse,
  Bse = Math.pow(2, 31);
function cM(t, e, n) {
  (e = e || []), (n = n || 0);
  for (var r = n; t >= Bse; ) (e[n++] = (t & 255) | jN), (t /= 128);
  for (; t & Use; ) (e[n++] = (t & 255) | jN), (t >>>= 7);
  return (e[n] = t | 0), (cM.bytes = n - r + 1), e;
}
var jse = Bx,
  Fse = 128,
  FN = 127;
function Bx(t, r) {
  var n = 0,
    r = r || 0,
    i = 0,
    s = r,
    o,
    a = t.length;
  do {
    if (s >= a)
      throw ((Bx.bytes = 0), new RangeError("Could not decode varint"));
    (o = t[s++]),
      (n += i < 28 ? (o & FN) << i : (o & FN) * Math.pow(2, i)),
      (i += 7);
  } while (o >= Fse);
  return (Bx.bytes = s - r), n;
}
var zse = Math.pow(2, 7),
  Wse = Math.pow(2, 14),
  Hse = Math.pow(2, 21),
  qse = Math.pow(2, 28),
  Vse = Math.pow(2, 35),
  Gse = Math.pow(2, 42),
  Kse = Math.pow(2, 49),
  Yse = Math.pow(2, 56),
  Zse = Math.pow(2, 63),
  Qse = function (t) {
    return t < zse
      ? 1
      : t < Wse
      ? 2
      : t < Hse
      ? 3
      : t < qse
      ? 4
      : t < Vse
      ? 5
      : t < Gse
      ? 6
      : t < Kse
      ? 7
      : t < Yse
      ? 8
      : t < Zse
      ? 9
      : 10;
  },
  Xse = { encode: Mse, decode: jse, encodingLength: Qse },
  lM = Xse;
const zN = (t, e, n = 0) => (lM.encode(t, e, n), e),
  WN = (t) => lM.encodingLength(t),
  jx = (t, e) => {
    const n = e.byteLength,
      r = WN(t),
      i = r + WN(n),
      s = new Uint8Array(i + n);
    return zN(t, s, 0), zN(n, s, r), s.set(e, i), new Jse(t, n, e, s);
  };
class Jse {
  constructor(e, n, r, i) {
    (this.code = e), (this.size = n), (this.digest = r), (this.bytes = i);
  }
}
const uM = ({ name: t, code: e, encode: n }) => new eoe(t, e, n);
class eoe {
  constructor(e, n, r) {
    (this.name = e), (this.code = n), (this.encode = r);
  }
  digest(e) {
    if (e instanceof Uint8Array) {
      const n = this.encode(e);
      return n instanceof Uint8Array
        ? jx(this.code, n)
        : n.then((r) => jx(this.code, r));
    } else throw Error("Unknown type, must be binary type");
  }
}
const dM = (t) => async (e) => new Uint8Array(await crypto.subtle.digest(t, e)),
  toe = uM({ name: "sha2-256", code: 18, encode: dM("SHA-256") }),
  noe = uM({ name: "sha2-512", code: 19, encode: dM("SHA-512") });
var roe = Object.freeze({ __proto__: null, sha256: toe, sha512: noe });
const pM = 0,
  ioe = "identity",
  fM = sM,
  soe = (t) => jx(pM, fM(t)),
  ooe = { code: pM, name: ioe, encode: fM, digest: soe };
var aoe = Object.freeze({ __proto__: null, identity: ooe });
new TextEncoder(), new TextDecoder();
const HN = {
  ...Jie,
  ...tse,
  ...rse,
  ...sse,
  ...cse,
  ...wse,
  ...Ese,
  ...Sse,
  ...Pse,
  ...$se,
};
({ ...roe, ...aoe });
function coe(t = 0) {
  return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null
    ? globalThis.Buffer.allocUnsafe(t)
    : new Uint8Array(t);
}
function hM(t, e, n, r) {
  return {
    name: t,
    prefix: e,
    encoder: { name: t, prefix: e, encode: n },
    decoder: { decode: r },
  };
}
const qN = hM(
    "utf8",
    "u",
    (t) => "u" + new TextDecoder("utf8").decode(t),
    (t) => new TextEncoder().encode(t.substring(1))
  ),
  VE = hM(
    "ascii",
    "a",
    (t) => {
      let e = "a";
      for (let n = 0; n < t.length; n++) e += String.fromCharCode(t[n]);
      return e;
    },
    (t) => {
      t = t.substring(1);
      const e = coe(t.length);
      for (let n = 0; n < t.length; n++) e[n] = t.charCodeAt(n);
      return e;
    }
  ),
  loe = {
    utf8: qN,
    "utf-8": qN,
    hex: HN.base16,
    latin1: VE,
    ascii: VE,
    binary: VE,
    ...HN,
  };
function uoe(t, e = "utf8") {
  const n = loe[e];
  if (!n) throw new Error(`Unsupported encoding "${e}"`);
  return (e === "utf8" || e === "utf-8") &&
    globalThis.Buffer != null &&
    globalThis.Buffer.from != null
    ? globalThis.Buffer.from(t, "utf8")
    : n.decoder.decode(`${n.prefix}${t}`);
}
var doe = Object.defineProperty,
  poe = (t, e, n) =>
    e in t
      ? doe(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n })
      : (t[e] = n),
  po = (t, e, n) => poe(t, typeof e != "symbol" ? e + "" : e, n);
class foe {
  constructor(e, n) {
    (this.core = e),
      (this.logger = n),
      po(this, "keychain", new Map()),
      po(this, "name", pie),
      po(this, "version", fie),
      po(this, "initialized", !1),
      po(this, "storagePrefix", Oo),
      po(this, "init", async () => {
        if (!this.initialized) {
          const r = await this.getKeyChain();
          typeof r < "u" && (this.keychain = r), (this.initialized = !0);
        }
      }),
      po(this, "has", (r) => (this.isInitialized(), this.keychain.has(r))),
      po(this, "set", async (r, i) => {
        this.isInitialized(), this.keychain.set(r, i), await this.persist();
      }),
      po(this, "get", (r) => {
        this.isInitialized();
        const i = this.keychain.get(r);
        if (typeof i > "u") {
          const { message: s } = xe("NO_MATCHING_KEY", `${this.name}: ${r}`);
          throw new Error(s);
        }
        return i;
      }),
      po(this, "del", async (r) => {
        this.isInitialized(), this.keychain.delete(r), await this.persist();
      }),
      (this.core = e),
      (this.logger = Gr(n, this.name));
  }
  get context() {
    return Ti(this.logger);
  }
  get storageKey() {
    return (
      this.storagePrefix +
      this.version +
      this.core.customStoragePrefix +
      "//" +
      this.name
    );
  }
  async setKeyChain(e) {
    await this.core.storage.setItem(this.storageKey, _x(e));
  }
  async getKeyChain() {
    const e = await this.core.storage.getItem(this.storageKey);
    return typeof e < "u" ? Ix(e) : void 0;
  }
  async persist() {
    await this.setKeyChain(this.keychain);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = xe("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
}
var hoe = Object.defineProperty,
  moe = (t, e, n) =>
    e in t
      ? hoe(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n })
      : (t[e] = n),
  Sr = (t, e, n) => moe(t, typeof e != "symbol" ? e + "" : e, n);
class goe {
  constructor(e, n, r) {
    (this.core = e),
      (this.logger = n),
      Sr(this, "name", uie),
      Sr(this, "keychain"),
      Sr(this, "randomSessionIdentifier", Lx()),
      Sr(this, "initialized", !1),
      Sr(this, "init", async () => {
        this.initialized ||
          (await this.keychain.init(), (this.initialized = !0));
      }),
      Sr(this, "hasKeys", (i) => (this.isInitialized(), this.keychain.has(i))),
      Sr(this, "getClientId", async () => {
        this.isInitialized();
        const i = await this.getClientSeed(),
          s = ER(i);
        return PD(s.publicKey);
      }),
      Sr(this, "generateKeyPair", () => {
        this.isInitialized();
        const i = Hne();
        return this.setPrivateKey(i.publicKey, i.privateKey);
      }),
      Sr(this, "signJWT", async (i) => {
        this.isInitialized();
        const s = await this.getClientSeed(),
          o = ER(s),
          a = this.randomSessionIdentifier;
        return await dQ(a, i, die, o);
      }),
      Sr(this, "generateSharedKey", (i, s, o) => {
        this.isInitialized();
        const a = this.getPrivateKey(i),
          l = qne(a, s);
        return this.setSymKey(l, o);
      }),
      Sr(this, "setSymKey", async (i, s) => {
        this.isInitialized();
        const o = s || L0(i);
        return await this.keychain.set(o, i), o;
      }),
      Sr(this, "deleteKeyPair", async (i) => {
        this.isInitialized(), await this.keychain.del(i);
      }),
      Sr(this, "deleteSymKey", async (i) => {
        this.isInitialized(), await this.keychain.del(i);
      }),
      Sr(this, "encode", async (i, s, o) => {
        this.isInitialized();
        const a = V$(o),
          l = Aa(s);
        if (bN(a)) return Kne(l, o == null ? void 0 : o.encoding);
        if (vN(a)) {
          const m = a.senderPublicKey,
            y = a.receiverPublicKey;
          i = await this.generateSharedKey(m, y);
        }
        const d = this.getSymKey(i),
          { type: p, senderPublicKey: f } = a;
        return Vne({
          type: p,
          symKey: d,
          message: l,
          senderPublicKey: f,
          encoding: o == null ? void 0 : o.encoding,
        });
      }),
      Sr(this, "decode", async (i, s, o) => {
        this.isInitialized();
        const a = Zne(s, o);
        if (bN(a)) {
          const l = Yne(s, o == null ? void 0 : o.encoding);
          return Zl(l);
        }
        if (vN(a)) {
          const l = a.receiverPublicKey,
            d = a.senderPublicKey;
          i = await this.generateSharedKey(l, d);
        }
        try {
          const l = this.getSymKey(i),
            d = Gne({
              symKey: l,
              encoded: s,
              encoding: o == null ? void 0 : o.encoding,
            });
          return Zl(d);
        } catch (l) {
          this.logger.error(
            `Failed to decode message from topic: '${i}', clientId: '${await this.getClientId()}'`
          ),
            this.logger.error(l);
        }
      }),
      Sr(this, "getPayloadType", (i, s = Vs) => {
        const o = Gh({ encoded: i, encoding: s });
        return tu(o.type);
      }),
      Sr(this, "getPayloadSenderPublicKey", (i, s = Vs) => {
        const o = Gh({ encoded: i, encoding: s });
        return o.senderPublicKey ? xi(o.senderPublicKey, ni) : void 0;
      }),
      (this.core = e),
      (this.logger = Gr(n, this.name)),
      (this.keychain = r || new foe(this.core, this.logger));
  }
  get context() {
    return Ti(this.logger);
  }
  async setPrivateKey(e, n) {
    return await this.keychain.set(e, n), e;
  }
  getPrivateKey(e) {
    return this.keychain.get(e);
  }
  async getClientSeed() {
    let e = "";
    try {
      e = this.keychain.get(LN);
    } catch {
      (e = Lx()), await this.keychain.set(LN, e);
    }
    return uoe(e, "base16");
  }
  getSymKey(e) {
    return this.keychain.get(e);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = xe("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
}
var yoe = Object.defineProperty,
  woe = Object.defineProperties,
  voe = Object.getOwnPropertyDescriptors,
  VN = Object.getOwnPropertySymbols,
  boe = Object.prototype.hasOwnProperty,
  Eoe = Object.prototype.propertyIsEnumerable,
  Fx = (t, e, n) =>
    e in t
      ? yoe(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n })
      : (t[e] = n),
  Coe = (t, e) => {
    for (var n in e) boe.call(e, n) && Fx(t, n, e[n]);
    if (VN) for (var n of VN(e)) Eoe.call(e, n) && Fx(t, n, e[n]);
    return t;
  },
  xoe = (t, e) => woe(t, voe(e)),
  Mi = (t, e, n) => Fx(t, typeof e != "symbol" ? e + "" : e, n);
class Soe extends cK {
  constructor(e, n) {
    super(e, n),
      (this.logger = e),
      (this.core = n),
      Mi(this, "messages", new Map()),
      Mi(this, "messagesWithoutClientAck", new Map()),
      Mi(this, "name", hie),
      Mi(this, "version", mie),
      Mi(this, "initialized", !1),
      Mi(this, "storagePrefix", Oo),
      Mi(this, "init", async () => {
        if (!this.initialized) {
          this.logger.trace("Initialized");
          try {
            const r = await this.getRelayerMessages();
            typeof r < "u" && (this.messages = r);
            const i = await this.getRelayerMessagesWithoutClientAck();
            typeof i < "u" && (this.messagesWithoutClientAck = i),
              this.logger.debug(
                `Successfully Restored records for ${this.name}`
              ),
              this.logger.trace({
                type: "method",
                method: "restore",
                size: this.messages.size,
              });
          } catch (r) {
            this.logger.debug(`Failed to Restore records for ${this.name}`),
              this.logger.error(r);
          } finally {
            this.initialized = !0;
          }
        }
      }),
      Mi(this, "set", async (r, i, s) => {
        this.isInitialized();
        const o = So(i);
        let a = this.messages.get(r);
        if ((typeof a > "u" && (a = {}), typeof a[o] < "u")) return o;
        if (((a[o] = i), this.messages.set(r, a), s === U0.inbound)) {
          const l = this.messagesWithoutClientAck.get(r) || {};
          this.messagesWithoutClientAck.set(r, xoe(Coe({}, l), { [o]: i }));
        }
        return await this.persist(), o;
      }),
      Mi(this, "get", (r) => {
        this.isInitialized();
        let i = this.messages.get(r);
        return typeof i > "u" && (i = {}), i;
      }),
      Mi(this, "getWithoutAck", (r) => {
        this.isInitialized();
        const i = {};
        for (const s of r) {
          const o = this.messagesWithoutClientAck.get(s) || {};
          i[s] = Object.values(o);
        }
        return i;
      }),
      Mi(this, "has", (r, i) => {
        this.isInitialized();
        const s = this.get(r),
          o = So(i);
        return typeof s[o] < "u";
      }),
      Mi(this, "ack", async (r, i) => {
        this.isInitialized();
        const s = this.messagesWithoutClientAck.get(r);
        if (typeof s > "u") return;
        const o = So(i);
        delete s[o],
          Object.keys(s).length === 0
            ? this.messagesWithoutClientAck.delete(r)
            : this.messagesWithoutClientAck.set(r, s),
          await this.persist();
      }),
      Mi(this, "del", async (r) => {
        this.isInitialized(),
          this.messages.delete(r),
          this.messagesWithoutClientAck.delete(r),
          await this.persist();
      }),
      (this.logger = Gr(e, this.name)),
      (this.core = n);
  }
  get context() {
    return Ti(this.logger);
  }
  get storageKey() {
    return (
      this.storagePrefix +
      this.version +
      this.core.customStoragePrefix +
      "//" +
      this.name
    );
  }
  get storageKeyWithoutClientAck() {
    return (
      this.storagePrefix +
      this.version +
      this.core.customStoragePrefix +
      "//" +
      this.name +
      "_withoutClientAck"
    );
  }
  async setRelayerMessages(e) {
    await this.core.storage.setItem(this.storageKey, _x(e));
  }
  async setRelayerMessagesWithoutClientAck(e) {
    await this.core.storage.setItem(this.storageKeyWithoutClientAck, _x(e));
  }
  async getRelayerMessages() {
    const e = await this.core.storage.getItem(this.storageKey);
    return typeof e < "u" ? Ix(e) : void 0;
  }
  async getRelayerMessagesWithoutClientAck() {
    const e = await this.core.storage.getItem(this.storageKeyWithoutClientAck);
    return typeof e < "u" ? Ix(e) : void 0;
  }
  async persist() {
    await this.setRelayerMessages(this.messages),
      await this.setRelayerMessagesWithoutClientAck(
        this.messagesWithoutClientAck
      );
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = xe("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
}
var Aoe = Object.defineProperty,
  _oe = Object.defineProperties,
  Ioe = Object.getOwnPropertyDescriptors,
  GN = Object.getOwnPropertySymbols,
  Toe = Object.prototype.hasOwnProperty,
  Poe = Object.prototype.propertyIsEnumerable,
  zx = (t, e, n) =>
    e in t
      ? Aoe(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n })
      : (t[e] = n),
  t0 = (t, e) => {
    for (var n in e || (e = {})) Toe.call(e, n) && zx(t, n, e[n]);
    if (GN) for (var n of GN(e)) Poe.call(e, n) && zx(t, n, e[n]);
    return t;
  },
  GE = (t, e) => _oe(t, Ioe(e)),
  Us = (t, e, n) => zx(t, typeof e != "symbol" ? e + "" : e, n);
class Roe extends lK {
  constructor(e, n) {
    super(e, n),
      (this.relayer = e),
      (this.logger = n),
      Us(this, "events", new Ss.EventEmitter()),
      Us(this, "name", gie),
      Us(this, "queue", new Map()),
      Us(this, "publishTimeout", Ee.toMiliseconds(Ee.ONE_MINUTE)),
      Us(this, "initialPublishTimeout", Ee.toMiliseconds(Ee.ONE_SECOND * 15)),
      Us(this, "needsTransportRestart", !1),
      Us(this, "publish", async (r, i, s) => {
        var o;
        this.logger.debug("Publishing Payload"),
          this.logger.trace({
            type: "method",
            method: "publish",
            params: { topic: r, message: i, opts: s },
          });
        const a = (s == null ? void 0 : s.ttl) || UN,
          l = gw(s),
          d = (s == null ? void 0 : s.prompt) || !1,
          p = (s == null ? void 0 : s.tag) || 0,
          f = (s == null ? void 0 : s.id) || Rl().toString(),
          m = {
            topic: r,
            message: i,
            opts: {
              ttl: a,
              relay: l,
              prompt: d,
              tag: p,
              id: f,
              attestation: s == null ? void 0 : s.attestation,
              tvf: s == null ? void 0 : s.tvf,
            },
          },
          y = `Failed to publish payload, please try again. id:${f} tag:${p}`;
        try {
          const g = new Promise(async (v) => {
            const b = ({ id: S }) => {
              m.opts.id === S &&
                (this.removeRequestFromQueue(S),
                this.relayer.events.removeListener(fr.publish, b),
                v(m));
            };
            this.relayer.events.on(fr.publish, b);
            const E = Ic(
              new Promise((S, C) => {
                this.rpcPublish({
                  topic: r,
                  message: i,
                  ttl: a,
                  prompt: d,
                  tag: p,
                  id: f,
                  attestation: s == null ? void 0 : s.attestation,
                  tvf: s == null ? void 0 : s.tvf,
                })
                  .then(S)
                  .catch((_) => {
                    this.logger.warn(_, _ == null ? void 0 : _.message), C(_);
                  });
              }),
              this.initialPublishTimeout,
              `Failed initial publish, retrying.... id:${f} tag:${p}`
            );
            try {
              await E, this.events.removeListener(fr.publish, b);
            } catch (S) {
              this.queue.set(f, GE(t0({}, m), { attempt: 1 })),
                this.logger.warn(S, S == null ? void 0 : S.message);
            }
          });
          this.logger.trace({
            type: "method",
            method: "publish",
            params: { id: f, topic: r, message: i, opts: s },
          }),
            await Ic(g, this.publishTimeout, y);
        } catch (g) {
          if (
            (this.logger.debug("Failed to Publish Payload"),
            this.logger.error(g),
            (o = s == null ? void 0 : s.internal) != null &&
              o.throwOnFailedPublish)
          )
            throw g;
        } finally {
          this.queue.delete(f);
        }
      }),
      Us(this, "on", (r, i) => {
        this.events.on(r, i);
      }),
      Us(this, "once", (r, i) => {
        this.events.once(r, i);
      }),
      Us(this, "off", (r, i) => {
        this.events.off(r, i);
      }),
      Us(this, "removeListener", (r, i) => {
        this.events.removeListener(r, i);
      }),
      (this.relayer = e),
      (this.logger = Gr(n, this.name)),
      this.registerEventListeners();
  }
  get context() {
    return Ti(this.logger);
  }
  async rpcPublish(e) {
    var n, r, i, s;
    const {
        topic: o,
        message: a,
        ttl: l = UN,
        prompt: d,
        tag: p,
        id: f,
        attestation: m,
        tvf: y,
      } = e,
      g = {
        method: ch(gw().protocol).publish,
        params: t0(
          { topic: o, message: a, ttl: l, prompt: d, tag: p, attestation: m },
          y
        ),
        id: f,
      };
    Tr((n = g.params) == null ? void 0 : n.prompt) &&
      ((r = g.params) == null || delete r.prompt),
      Tr((i = g.params) == null ? void 0 : i.tag) &&
        ((s = g.params) == null || delete s.tag),
      this.logger.debug("Outgoing Relay Payload"),
      this.logger.trace({ type: "message", direction: "outgoing", request: g });
    const v = await this.relayer.request(g);
    return (
      this.relayer.events.emit(fr.publish, e),
      this.logger.debug("Successfully Published Payload"),
      v
    );
  }
  removeRequestFromQueue(e) {
    this.queue.delete(e);
  }
  checkQueue() {
    this.queue.forEach(async (e, n) => {
      const r = e.attempt + 1;
      this.queue.set(n, GE(t0({}, e), { attempt: r }));
      const { topic: i, message: s, opts: o, attestation: a } = e;
      this.logger.warn(
        {},
        `Publisher: queue->publishing: ${e.opts.id}, tag: ${e.opts.tag}, attempt: ${r}`
      ),
        await this.rpcPublish(
          GE(t0({}, e), {
            topic: i,
            message: s,
            ttl: o.ttl,
            prompt: o.prompt,
            tag: o.tag,
            id: o.id,
            attestation: a,
            tvf: o.tvf,
          })
        ),
        this.logger.warn({}, `Publisher: queue->published: ${e.opts.id}`);
    });
  }
  registerEventListeners() {
    this.relayer.core.heartbeat.on(Ap.pulse, () => {
      if (this.needsTransportRestart) {
        (this.needsTransportRestart = !1),
          this.relayer.events.emit(fr.connection_stalled);
        return;
      }
      this.checkQueue();
    }),
      this.relayer.on(fr.message_ack, (e) => {
        this.removeRequestFromQueue(e.id.toString());
      });
  }
}
var Noe = Object.defineProperty,
  Ooe = (t, e, n) =>
    e in t
      ? Noe(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n })
      : (t[e] = n),
  Xu = (t, e, n) => Ooe(t, typeof e != "symbol" ? e + "" : e, n);
class koe {
  constructor() {
    Xu(this, "map", new Map()),
      Xu(this, "set", (e, n) => {
        const r = this.get(e);
        this.exists(e, n) || this.map.set(e, [...r, n]);
      }),
      Xu(this, "get", (e) => this.map.get(e) || []),
      Xu(this, "exists", (e, n) => this.get(e).includes(n)),
      Xu(this, "delete", (e, n) => {
        if (typeof n > "u") {
          this.map.delete(e);
          return;
        }
        if (!this.map.has(e)) return;
        const r = this.get(e);
        if (!this.exists(e, n)) return;
        const i = r.filter((s) => s !== n);
        if (!i.length) {
          this.map.delete(e);
          return;
        }
        this.map.set(e, i);
      }),
      Xu(this, "clear", () => {
        this.map.clear();
      });
  }
  get topics() {
    return Array.from(this.map.keys());
  }
}
var Doe = Object.defineProperty,
  $oe = Object.defineProperties,
  Moe = Object.getOwnPropertyDescriptors,
  KN = Object.getOwnPropertySymbols,
  Loe = Object.prototype.hasOwnProperty,
  Uoe = Object.prototype.propertyIsEnumerable,
  Wx = (t, e, n) =>
    e in t
      ? Doe(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n })
      : (t[e] = n),
  qf = (t, e) => {
    for (var n in e || (e = {})) Loe.call(e, n) && Wx(t, n, e[n]);
    if (KN) for (var n of KN(e)) Uoe.call(e, n) && Wx(t, n, e[n]);
    return t;
  },
  KE = (t, e) => $oe(t, Moe(e)),
  Jt = (t, e, n) => Wx(t, typeof e != "symbol" ? e + "" : e, n);
class Boe extends pK {
  constructor(e, n) {
    super(e, n),
      (this.relayer = e),
      (this.logger = n),
      Jt(this, "subscriptions", new Map()),
      Jt(this, "topicMap", new koe()),
      Jt(this, "events", new Ss.EventEmitter()),
      Jt(this, "name", xie),
      Jt(this, "version", Sie),
      Jt(this, "pending", new Map()),
      Jt(this, "cached", []),
      Jt(this, "initialized", !1),
      Jt(this, "storagePrefix", Oo),
      Jt(this, "subscribeTimeout", Ee.toMiliseconds(Ee.ONE_MINUTE)),
      Jt(this, "initialSubscribeTimeout", Ee.toMiliseconds(Ee.ONE_SECOND * 15)),
      Jt(this, "clientId"),
      Jt(this, "batchSubscribeTopicsLimit", 500),
      Jt(this, "init", async () => {
        this.initialized ||
          (this.logger.trace("Initialized"),
          this.registerEventListeners(),
          await this.restore()),
          (this.initialized = !0);
      }),
      Jt(this, "subscribe", async (r, i) => {
        this.isInitialized(),
          this.logger.debug("Subscribing Topic"),
          this.logger.trace({
            type: "method",
            method: "subscribe",
            params: { topic: r, opts: i },
          });
        try {
          const s = gw(i),
            o = {
              topic: r,
              relay: s,
              transportType: i == null ? void 0 : i.transportType,
            };
          this.pending.set(r, o);
          const a = await this.rpcSubscribe(r, s, i);
          return (
            typeof a == "string" &&
              (this.onSubscribe(a, o),
              this.logger.debug("Successfully Subscribed Topic"),
              this.logger.trace({
                type: "method",
                method: "subscribe",
                params: { topic: r, opts: i },
              })),
            a
          );
        } catch (s) {
          throw (
            (this.logger.debug("Failed to Subscribe Topic"),
            this.logger.error(s),
            s)
          );
        }
      }),
      Jt(this, "unsubscribe", async (r, i) => {
        this.isInitialized(),
          typeof (i == null ? void 0 : i.id) < "u"
            ? await this.unsubscribeById(r, i.id, i)
            : await this.unsubscribeByTopic(r, i);
      }),
      Jt(
        this,
        "isSubscribed",
        (r) =>
          new Promise((i) => {
            i(this.topicMap.topics.includes(r));
          })
      ),
      Jt(
        this,
        "isKnownTopic",
        (r) =>
          new Promise((i) => {
            i(
              this.topicMap.topics.includes(r) ||
                this.pending.has(r) ||
                this.cached.some((s) => s.topic === r)
            );
          })
      ),
      Jt(this, "on", (r, i) => {
        this.events.on(r, i);
      }),
      Jt(this, "once", (r, i) => {
        this.events.once(r, i);
      }),
      Jt(this, "off", (r, i) => {
        this.events.off(r, i);
      }),
      Jt(this, "removeListener", (r, i) => {
        this.events.removeListener(r, i);
      }),
      Jt(this, "start", async () => {
        await this.onConnect();
      }),
      Jt(this, "stop", async () => {
        await this.onDisconnect();
      }),
      Jt(this, "restart", async () => {
        await this.restore(), await this.onRestart();
      }),
      Jt(this, "checkPending", async () => {
        if (
          this.pending.size === 0 &&
          (!this.initialized || !this.relayer.connected)
        )
          return;
        const r = [];
        this.pending.forEach((i) => {
          r.push(i);
        }),
          await this.batchSubscribe(r);
      }),
      Jt(this, "registerEventListeners", () => {
        this.relayer.core.heartbeat.on(Ap.pulse, async () => {
          await this.checkPending();
        }),
          this.events.on(Ui.created, async (r) => {
            const i = Ui.created;
            this.logger.info(`Emitting ${i}`),
              this.logger.debug({ type: "event", event: i, data: r }),
              await this.persist();
          }),
          this.events.on(Ui.deleted, async (r) => {
            const i = Ui.deleted;
            this.logger.info(`Emitting ${i}`),
              this.logger.debug({ type: "event", event: i, data: r }),
              await this.persist();
          });
      }),
      (this.relayer = e),
      (this.logger = Gr(n, this.name)),
      (this.clientId = "");
  }
  get context() {
    return Ti(this.logger);
  }
  get storageKey() {
    return (
      this.storagePrefix +
      this.version +
      this.relayer.core.customStoragePrefix +
      "//" +
      this.name
    );
  }
  get length() {
    return this.subscriptions.size;
  }
  get ids() {
    return Array.from(this.subscriptions.keys());
  }
  get values() {
    return Array.from(this.subscriptions.values());
  }
  get topics() {
    return this.topicMap.topics;
  }
  get hasAnyTopics() {
    return (
      this.topicMap.topics.length > 0 ||
      this.pending.size > 0 ||
      this.cached.length > 0 ||
      this.subscriptions.size > 0
    );
  }
  hasSubscription(e, n) {
    let r = !1;
    try {
      r = this.getSubscription(e).topic === n;
    } catch {}
    return r;
  }
  reset() {
    (this.cached = []), (this.initialized = !0);
  }
  onDisable() {
    this.values.length > 0 && (this.cached = this.values),
      this.subscriptions.clear(),
      this.topicMap.clear();
  }
  async unsubscribeByTopic(e, n) {
    const r = this.topicMap.get(e);
    await Promise.all(r.map(async (i) => await this.unsubscribeById(e, i, n)));
  }
  async unsubscribeById(e, n, r) {
    this.logger.debug("Unsubscribing Topic"),
      this.logger.trace({
        type: "method",
        method: "unsubscribe",
        params: { topic: e, id: n, opts: r },
      });
    try {
      const i = gw(r);
      await this.restartToComplete({ topic: e, id: n, relay: i }),
        await this.rpcUnsubscribe(e, n, i);
      const s = Kt("USER_DISCONNECTED", `${this.name}, ${e}`);
      await this.onUnsubscribe(e, n, s),
        this.logger.debug("Successfully Unsubscribed Topic"),
        this.logger.trace({
          type: "method",
          method: "unsubscribe",
          params: { topic: e, id: n, opts: r },
        });
    } catch (i) {
      throw (
        (this.logger.debug("Failed to Unsubscribe Topic"),
        this.logger.error(i),
        i)
      );
    }
  }
  async rpcSubscribe(e, n, r) {
    var i;
    (!r || (r == null ? void 0 : r.transportType) === dn.relay) &&
      (await this.restartToComplete({ topic: e, id: e, relay: n }));
    const s = { method: ch(n.protocol).subscribe, params: { topic: e } };
    this.logger.debug("Outgoing Relay Payload"),
      this.logger.trace({ type: "payload", direction: "outgoing", request: s });
    const o =
      (i = r == null ? void 0 : r.internal) == null
        ? void 0
        : i.throwOnFailedPublish;
    try {
      const a = await this.getSubscriptionId(e);
      if ((r == null ? void 0 : r.transportType) === dn.link_mode)
        return (
          setTimeout(() => {
            (this.relayer.connected || this.relayer.connecting) &&
              this.relayer.request(s).catch((p) => this.logger.warn(p));
          }, Ee.toMiliseconds(Ee.ONE_SECOND)),
          a
        );
      const l = new Promise(async (p) => {
          const f = (m) => {
            m.topic === e &&
              (this.events.removeListener(Ui.created, f), p(m.id));
          };
          this.events.on(Ui.created, f);
          try {
            const m = await Ic(
              new Promise((y, g) => {
                this.relayer
                  .request(s)
                  .catch((v) => {
                    this.logger.warn(v, v == null ? void 0 : v.message), g(v);
                  })
                  .then(y);
              }),
              this.initialSubscribeTimeout,
              `Subscribing to ${e} failed, please try again`
            );
            this.events.removeListener(Ui.created, f), p(m);
          } catch {}
        }),
        d = await Ic(
          l,
          this.subscribeTimeout,
          `Subscribing to ${e} failed, please try again`
        );
      if (!d && o)
        throw new Error(`Subscribing to ${e} failed, please try again`);
      return d ? a : null;
    } catch (a) {
      if (
        (this.logger.debug("Outgoing Relay Subscribe Payload stalled"),
        this.relayer.events.emit(fr.connection_stalled),
        o)
      )
        throw a;
    }
    return null;
  }
  async rpcBatchSubscribe(e) {
    if (!e.length) return;
    const n = e[0].relay,
      r = {
        method: ch(n.protocol).batchSubscribe,
        params: { topics: e.map((i) => i.topic) },
      };
    this.logger.debug("Outgoing Relay Payload"),
      this.logger.trace({ type: "payload", direction: "outgoing", request: r });
    try {
      await await Ic(
        new Promise((i) => {
          this.relayer
            .request(r)
            .catch((s) => this.logger.warn(s))
            .then(i);
        }),
        this.subscribeTimeout,
        "rpcBatchSubscribe failed, please try again"
      );
    } catch {
      this.relayer.events.emit(fr.connection_stalled);
    }
  }
  async rpcBatchFetchMessages(e) {
    if (!e.length) return;
    const n = e[0].relay,
      r = {
        method: ch(n.protocol).batchFetchMessages,
        params: { topics: e.map((s) => s.topic) },
      };
    this.logger.debug("Outgoing Relay Payload"),
      this.logger.trace({ type: "payload", direction: "outgoing", request: r });
    let i;
    try {
      i = await await Ic(
        new Promise((s, o) => {
          this.relayer
            .request(r)
            .catch((a) => {
              this.logger.warn(a), o(a);
            })
            .then(s);
        }),
        this.subscribeTimeout,
        "rpcBatchFetchMessages failed, please try again"
      );
    } catch {
      this.relayer.events.emit(fr.connection_stalled);
    }
    return i;
  }
  rpcUnsubscribe(e, n, r) {
    const i = {
      method: ch(r.protocol).unsubscribe,
      params: { topic: e, id: n },
    };
    return (
      this.logger.debug("Outgoing Relay Payload"),
      this.logger.trace({ type: "payload", direction: "outgoing", request: i }),
      this.relayer.request(i)
    );
  }
  onSubscribe(e, n) {
    this.setSubscription(e, KE(qf({}, n), { id: e })),
      this.pending.delete(n.topic);
  }
  onBatchSubscribe(e) {
    e.length &&
      e.forEach((n) => {
        this.setSubscription(n.id, qf({}, n)), this.pending.delete(n.topic);
      });
  }
  async onUnsubscribe(e, n, r) {
    this.events.removeAllListeners(n),
      this.hasSubscription(n, e) && this.deleteSubscription(n, r),
      await this.relayer.messages.del(e);
  }
  async setRelayerSubscriptions(e) {
    await this.relayer.core.storage.setItem(this.storageKey, e);
  }
  async getRelayerSubscriptions() {
    return await this.relayer.core.storage.getItem(this.storageKey);
  }
  setSubscription(e, n) {
    this.logger.debug("Setting subscription"),
      this.logger.trace({
        type: "method",
        method: "setSubscription",
        id: e,
        subscription: n,
      }),
      this.addSubscription(e, n);
  }
  addSubscription(e, n) {
    this.subscriptions.set(e, qf({}, n)),
      this.topicMap.set(n.topic, e),
      this.events.emit(Ui.created, n);
  }
  getSubscription(e) {
    this.logger.debug("Getting subscription"),
      this.logger.trace({ type: "method", method: "getSubscription", id: e });
    const n = this.subscriptions.get(e);
    if (!n) {
      const { message: r } = xe("NO_MATCHING_KEY", `${this.name}: ${e}`);
      throw new Error(r);
    }
    return n;
  }
  deleteSubscription(e, n) {
    this.logger.debug("Deleting subscription"),
      this.logger.trace({
        type: "method",
        method: "deleteSubscription",
        id: e,
        reason: n,
      });
    const r = this.getSubscription(e);
    this.subscriptions.delete(e),
      this.topicMap.delete(r.topic, e),
      this.events.emit(Ui.deleted, KE(qf({}, r), { reason: n }));
  }
  async persist() {
    await this.setRelayerSubscriptions(this.values), this.events.emit(Ui.sync);
  }
  async onRestart() {
    if (this.cached.length) {
      const e = [...this.cached],
        n = Math.ceil(this.cached.length / this.batchSubscribeTopicsLimit);
      for (let r = 0; r < n; r++) {
        const i = e.splice(0, this.batchSubscribeTopicsLimit);
        await this.batchSubscribe(i);
      }
    }
    this.events.emit(Ui.resubscribed);
  }
  async restore() {
    try {
      const e = await this.getRelayerSubscriptions();
      if (typeof e > "u" || !e.length) return;
      if (this.subscriptions.size) {
        const { message: n } = xe("RESTORE_WILL_OVERRIDE", this.name);
        throw (
          (this.logger.error(n),
          this.logger.error(`${this.name}: ${JSON.stringify(this.values)}`),
          new Error(n))
        );
      }
      (this.cached = e),
        this.logger.debug(
          `Successfully Restored subscriptions for ${this.name}`
        ),
        this.logger.trace({
          type: "method",
          method: "restore",
          subscriptions: this.values,
        });
    } catch (e) {
      this.logger.debug(`Failed to Restore subscriptions for ${this.name}`),
        this.logger.error(e);
    }
  }
  async batchSubscribe(e) {
    e.length &&
      (await this.rpcBatchSubscribe(e),
      this.onBatchSubscribe(
        await Promise.all(
          e.map(async (n) =>
            KE(qf({}, n), { id: await this.getSubscriptionId(n.topic) })
          )
        )
      ));
  }
  async batchFetchMessages(e) {
    if (!e.length) return;
    this.logger.trace(`Fetching batch messages for ${e.length} subscriptions`);
    const n = await this.rpcBatchFetchMessages(e);
    n &&
      n.messages &&
      (await Nee(Ee.toMiliseconds(Ee.ONE_SECOND)),
      await this.relayer.handleBatchMessageEvents(n.messages));
  }
  async onConnect() {
    await this.restart(), this.reset();
  }
  onDisconnect() {
    this.onDisable();
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = xe("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
  async restartToComplete(e) {
    !this.relayer.connected &&
      !this.relayer.connecting &&
      (this.cached.push(e), await this.relayer.transportOpen());
  }
  async getClientId() {
    return (
      this.clientId ||
        (this.clientId = await this.relayer.core.crypto.getClientId()),
      this.clientId
    );
  }
  async getSubscriptionId(e) {
    return So(e + (await this.getClientId()));
  }
}
var joe = Object.defineProperty,
  YN = Object.getOwnPropertySymbols,
  Foe = Object.prototype.hasOwnProperty,
  zoe = Object.prototype.propertyIsEnumerable,
  Hx = (t, e, n) =>
    e in t
      ? joe(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n })
      : (t[e] = n),
  ZN = (t, e) => {
    for (var n in e || (e = {})) Foe.call(e, n) && Hx(t, n, e[n]);
    if (YN) for (var n of YN(e)) zoe.call(e, n) && Hx(t, n, e[n]);
    return t;
  },
  Ot = (t, e, n) => Hx(t, typeof e != "symbol" ? e + "" : e, n);
class Woe extends uK {
  constructor(e) {
    super(e),
      Ot(this, "protocol", "wc"),
      Ot(this, "version", 2),
      Ot(this, "core"),
      Ot(this, "logger"),
      Ot(this, "events", new Ss.EventEmitter()),
      Ot(this, "provider"),
      Ot(this, "messages"),
      Ot(this, "subscriber"),
      Ot(this, "publisher"),
      Ot(this, "name", wie),
      Ot(this, "transportExplicitlyClosed", !1),
      Ot(this, "initialized", !1),
      Ot(this, "connectionAttemptInProgress", !1),
      Ot(this, "relayUrl"),
      Ot(this, "projectId"),
      Ot(this, "packageName"),
      Ot(this, "bundleId"),
      Ot(this, "hasExperiencedNetworkDisruption", !1),
      Ot(this, "pingTimeout"),
      Ot(
        this,
        "heartBeatTimeout",
        Ee.toMiliseconds(Ee.THIRTY_SECONDS + Ee.FIVE_SECONDS)
      ),
      Ot(this, "reconnectTimeout"),
      Ot(this, "connectPromise"),
      Ot(this, "reconnectInProgress", !1),
      Ot(this, "requestsInFlight", []),
      Ot(this, "connectTimeout", Ee.toMiliseconds(Ee.ONE_SECOND * 15)),
      Ot(this, "request", async (n) => {
        var r, i;
        this.logger.debug("Publishing Request Payload");
        const s = n.id || Rl().toString();
        await this.toEstablishConnection();
        try {
          this.logger.trace(
            {
              id: s,
              method: n.method,
              topic: (r = n.params) == null ? void 0 : r.topic,
            },
            "relayer.request - publishing..."
          );
          const o = `${s}:${((i = n.params) == null ? void 0 : i.tag) || ""}`;
          this.requestsInFlight.push(o);
          const a = await this.provider.request(n);
          return (
            (this.requestsInFlight = this.requestsInFlight.filter(
              (l) => l !== o
            )),
            a
          );
        } catch (o) {
          throw (this.logger.debug(`Failed to Publish Request: ${s}`), o);
        }
      }),
      Ot(this, "resetPingTimeout", () => {
        hw() &&
          (clearTimeout(this.pingTimeout),
          (this.pingTimeout = setTimeout(() => {
            var n, r, i, s;
            try {
              this.logger.debug(
                {},
                "pingTimeout: Connection stalled, terminating..."
              ),
                (s =
                  (i =
                    (r = (n = this.provider) == null ? void 0 : n.connection) ==
                    null
                      ? void 0
                      : r.socket) == null
                    ? void 0
                    : i.terminate) == null || s.call(i);
            } catch (o) {
              this.logger.warn(o, o == null ? void 0 : o.message);
            }
          }, this.heartBeatTimeout)));
      }),
      Ot(this, "onPayloadHandler", (n) => {
        this.onProviderPayload(n), this.resetPingTimeout();
      }),
      Ot(this, "onConnectHandler", () => {
        this.logger.warn({}, "Relayer connected "),
          this.startPingTimeout(),
          this.events.emit(fr.connect);
      }),
      Ot(this, "onDisconnectHandler", () => {
        this.logger.warn({}, "Relayer disconnected "),
          (this.requestsInFlight = []),
          this.onProviderDisconnect();
      }),
      Ot(this, "onProviderErrorHandler", (n) => {
        this.logger.fatal(`Fatal socket error: ${n.message}`),
          this.events.emit(fr.error, n),
          this.logger.fatal("Fatal socket error received, closing transport"),
          this.transportClose();
      }),
      Ot(this, "registerProviderListeners", () => {
        this.provider.on(ns.payload, this.onPayloadHandler),
          this.provider.on(ns.connect, this.onConnectHandler),
          this.provider.on(ns.disconnect, this.onDisconnectHandler),
          this.provider.on(ns.error, this.onProviderErrorHandler);
      }),
      (this.core = e.core),
      (this.logger =
        typeof e.logger < "u" && typeof e.logger != "string"
          ? Gr(e.logger, this.name)
          : Ym(_p({ level: e.logger || yie }))),
      (this.messages = new Soe(this.logger, e.core)),
      (this.subscriber = new Boe(this, this.logger)),
      (this.publisher = new Roe(this, this.logger)),
      (this.relayUrl = (e == null ? void 0 : e.relayUrl) || rM),
      (this.projectId = e.projectId),
      mee() ? (this.packageName = WR()) : gee() && (this.bundleId = WR()),
      (this.provider = {});
  }
  async init() {
    if (
      (this.logger.trace("Initialized"),
      this.registerEventListeners(),
      await Promise.all([this.messages.init(), this.subscriber.init()]),
      (this.initialized = !0),
      this.subscriber.hasAnyTopics)
    )
      try {
        await this.transportOpen();
      } catch (e) {
        this.logger.warn(e, e == null ? void 0 : e.message);
      }
  }
  get context() {
    return Ti(this.logger);
  }
  get connected() {
    var e, n, r;
    return (
      ((r =
        (n = (e = this.provider) == null ? void 0 : e.connection) == null
          ? void 0
          : n.socket) == null
        ? void 0
        : r.readyState) === 1 || !1
    );
  }
  get connecting() {
    var e, n, r;
    return (
      ((r =
        (n = (e = this.provider) == null ? void 0 : e.connection) == null
          ? void 0
          : n.socket) == null
        ? void 0
        : r.readyState) === 0 ||
      this.connectPromise !== void 0 ||
      !1
    );
  }
  async publish(e, n, r) {
    this.isInitialized(),
      await this.publisher.publish(e, n, r),
      await this.recordMessageEvent(
        {
          topic: e,
          message: n,
          publishedAt: Date.now(),
          transportType: dn.relay,
        },
        U0.outbound
      );
  }
  async subscribe(e, n) {
    var r, i, s;
    this.isInitialized(),
      (!(n != null && n.transportType) ||
        (n == null ? void 0 : n.transportType) === "relay") &&
        (await this.toEstablishConnection());
    const o =
      typeof ((r = n == null ? void 0 : n.internal) == null
        ? void 0
        : r.throwOnFailedPublish) > "u"
        ? !0
        : (i = n == null ? void 0 : n.internal) == null
        ? void 0
        : i.throwOnFailedPublish;
    let a =
        ((s = this.subscriber.topicMap.get(e)) == null ? void 0 : s[0]) || "",
      l;
    const d = (p) => {
      p.topic === e && (this.subscriber.off(Ui.created, d), l());
    };
    return (
      await Promise.all([
        new Promise((p) => {
          (l = p), this.subscriber.on(Ui.created, d);
        }),
        new Promise(async (p, f) => {
          (a =
            (await this.subscriber
              .subscribe(e, ZN({ internal: { throwOnFailedPublish: o } }, n))
              .catch((m) => {
                o && f(m);
              })) || a),
            p();
        }),
      ]),
      a
    );
  }
  async unsubscribe(e, n) {
    this.isInitialized(), await this.subscriber.unsubscribe(e, n);
  }
  on(e, n) {
    this.events.on(e, n);
  }
  once(e, n) {
    this.events.once(e, n);
  }
  off(e, n) {
    this.events.off(e, n);
  }
  removeListener(e, n) {
    this.events.removeListener(e, n);
  }
  async transportDisconnect() {
    this.provider.disconnect &&
    (this.hasExperiencedNetworkDisruption || this.connected)
      ? await Ic(
          this.provider.disconnect(),
          2e3,
          "provider.disconnect()"
        ).catch(() => this.onProviderDisconnect())
      : this.onProviderDisconnect();
  }
  async transportClose() {
    (this.transportExplicitlyClosed = !0), await this.transportDisconnect();
  }
  async transportOpen(e) {
    if (!this.subscriber.hasAnyTopics) {
      this.logger.warn(
        "Starting WS connection skipped because the client has no topics to work with."
      );
      return;
    }
    if (
      (this.connectPromise
        ? (this.logger.debug(
            {},
            "Waiting for existing connection attempt to resolve..."
          ),
          await this.connectPromise,
          this.logger.debug({}, "Existing connection attempt resolved"))
        : ((this.connectPromise = new Promise(async (n, r) => {
            await this.connect(e)
              .then(n)
              .catch(r)
              .finally(() => {
                this.connectPromise = void 0;
              });
          })),
          await this.connectPromise),
      !this.connected)
    )
      throw new Error(
        `Couldn't establish socket connection to the relay server: ${this.relayUrl}`
      );
  }
  async restartTransport(e) {
    this.logger.debug({}, "Restarting transport..."),
      !this.connectionAttemptInProgress &&
        ((this.relayUrl = e || this.relayUrl),
        await this.confirmOnlineStateOrThrow(),
        await this.transportClose(),
        await this.transportOpen());
  }
  async confirmOnlineStateOrThrow() {
    if (!(await TN()))
      throw new Error(
        "No internet connection detected. Please restart your network and try again."
      );
  }
  async handleBatchMessageEvents(e) {
    if ((e == null ? void 0 : e.length) === 0) {
      this.logger.trace("Batch message events is empty. Ignoring...");
      return;
    }
    const n = e.sort((r, i) => r.publishedAt - i.publishedAt);
    this.logger.debug(`Batch of ${n.length} message events sorted`);
    for (const r of n)
      try {
        await this.onMessageEvent(r);
      } catch (i) {
        this.logger.warn(
          i,
          "Error while processing batch message event: " +
            (i == null ? void 0 : i.message)
        );
      }
    this.logger.trace(`Batch of ${n.length} message events processed`);
  }
  async onLinkMessageEvent(e, n) {
    const { topic: r } = e;
    if (!n.sessionExists) {
      const i = Zn(Ee.FIVE_MINUTES),
        s = { topic: r, expiry: i, relay: { protocol: "irn" }, active: !1 };
      await this.core.pairing.pairings.set(r, s);
    }
    this.events.emit(fr.message, e),
      await this.recordMessageEvent(e, U0.inbound);
  }
  async connect(e) {
    await this.confirmOnlineStateOrThrow(),
      e &&
        e !== this.relayUrl &&
        ((this.relayUrl = e), await this.transportDisconnect()),
      (this.connectionAttemptInProgress = !0),
      (this.transportExplicitlyClosed = !1);
    let n = 1;
    for (; n < 6; ) {
      try {
        if (this.transportExplicitlyClosed) break;
        this.logger.debug(
          {},
          `Connecting to ${this.relayUrl}, attempt: ${n}...`
        ),
          await this.createProvider(),
          await new Promise(async (r, i) => {
            const s = () => {
              i(new Error("Connection interrupted while trying to subscribe"));
            };
            this.provider.once(ns.disconnect, s),
              await Ic(
                new Promise((o, a) => {
                  this.provider.connect().then(o).catch(a);
                }),
                this.connectTimeout,
                `Socket stalled when trying to connect to ${this.relayUrl}`
              )
                .catch((o) => {
                  i(o);
                })
                .finally(() => {
                  this.provider.off(ns.disconnect, s),
                    clearTimeout(this.reconnectTimeout);
                }),
              await new Promise(async (o, a) => {
                const l = () => {
                  a(
                    new Error(
                      "Connection interrupted while trying to subscribe"
                    )
                  );
                };
                this.provider.once(ns.disconnect, l),
                  await this.subscriber
                    .start()
                    .then(o)
                    .catch(a)
                    .finally(() => {
                      this.provider.off(ns.disconnect, l);
                    });
              }),
              (this.hasExperiencedNetworkDisruption = !1),
              r();
          });
      } catch (r) {
        await this.subscriber.stop();
        const i = r;
        this.logger.warn({}, i.message),
          (this.hasExperiencedNetworkDisruption = !0);
      } finally {
        this.connectionAttemptInProgress = !1;
      }
      if (this.connected) {
        this.logger.debug(
          {},
          `Connected to ${this.relayUrl} successfully on attempt: ${n}`
        );
        break;
      }
      await new Promise((r) => setTimeout(r, Ee.toMiliseconds(n * 1))), n++;
    }
  }
  startPingTimeout() {
    var e, n, r, i, s;
    if (hw())
      try {
        (n = (e = this.provider) == null ? void 0 : e.connection) != null &&
          n.socket &&
          ((s =
            (i = (r = this.provider) == null ? void 0 : r.connection) == null
              ? void 0
              : i.socket) == null ||
            s.on("ping", () => {
              this.resetPingTimeout();
            })),
          this.resetPingTimeout();
      } catch (o) {
        this.logger.warn(o, o == null ? void 0 : o.message);
      }
  }
  async createProvider() {
    this.provider.connection && this.unregisterProviderListeners();
    const e = await this.core.crypto.signJWT(this.relayUrl);
    (this.provider = new _s(
      new oie(
        Eee({
          sdkVersion: Ux,
          protocol: this.protocol,
          version: this.version,
          relayUrl: this.relayUrl,
          projectId: this.projectId,
          auth: e,
          useOnCloseEvent: !0,
          bundleId: this.bundleId,
          packageName: this.packageName,
        })
      )
    )),
      this.registerProviderListeners();
  }
  async recordMessageEvent(e, n) {
    const { topic: r, message: i } = e;
    await this.messages.set(r, i, n);
  }
  async shouldIgnoreMessageEvent(e) {
    const { topic: n, message: r } = e;
    if (!r || r.length === 0)
      return this.logger.warn(`Ignoring invalid/empty message: ${r}`), !0;
    if (!(await this.subscriber.isKnownTopic(n)))
      return this.logger.warn(`Ignoring message for unknown topic ${n}`), !0;
    const i = this.messages.has(n, r);
    return i && this.logger.warn(`Ignoring duplicate message: ${r}`), i;
  }
  async onProviderPayload(e) {
    if (
      (this.logger.debug("Incoming Relay Payload"),
      this.logger.trace({ type: "payload", direction: "incoming", payload: e }),
      $A(e))
    ) {
      if (!e.method.endsWith(vie)) return;
      const n = e.params,
        { topic: r, message: i, publishedAt: s, attestation: o } = n.data,
        a = {
          topic: r,
          message: i,
          publishedAt: s,
          transportType: dn.relay,
          attestation: o,
        };
      this.logger.debug("Emitting Relayer Payload"),
        this.logger.trace(ZN({ type: "event", event: n.id }, a)),
        this.events.emit(n.id, a),
        await this.acknowledgePayload(e),
        await this.onMessageEvent(a);
    } else Rv(e) && this.events.emit(fr.message_ack, e);
  }
  async onMessageEvent(e) {
    (await this.shouldIgnoreMessageEvent(e)) ||
      (await this.recordMessageEvent(e, U0.inbound),
      this.events.emit(fr.message, e));
  }
  async acknowledgePayload(e) {
    const n = Tv(e.id, !0);
    await this.provider.connection.send(n);
  }
  unregisterProviderListeners() {
    this.provider.off(ns.payload, this.onPayloadHandler),
      this.provider.off(ns.connect, this.onConnectHandler),
      this.provider.off(ns.disconnect, this.onDisconnectHandler),
      this.provider.off(ns.error, this.onProviderErrorHandler),
      clearTimeout(this.pingTimeout);
  }
  async registerEventListeners() {
    let e = await TN();
    $re(async (n) => {
      e !== n &&
        ((e = n),
        n
          ? await this.transportOpen().catch((r) =>
              this.logger.error(r, r == null ? void 0 : r.message)
            )
          : ((this.hasExperiencedNetworkDisruption = !0),
            await this.transportDisconnect(),
            (this.transportExplicitlyClosed = !1)));
    });
  }
  async onProviderDisconnect() {
    clearTimeout(this.pingTimeout),
      this.events.emit(fr.disconnect),
      (this.connectionAttemptInProgress = !1),
      !this.reconnectInProgress &&
        ((this.reconnectInProgress = !0),
        await this.subscriber.stop(),
        this.subscriber.hasAnyTopics &&
          (this.transportExplicitlyClosed ||
            (this.reconnectTimeout = setTimeout(async () => {
              await this.transportOpen().catch((e) =>
                this.logger.error(e, e == null ? void 0 : e.message)
              ),
                (this.reconnectTimeout = void 0),
                (this.reconnectInProgress = !1);
            }, Ee.toMiliseconds(bie)))));
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = xe("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
  async toEstablishConnection() {
    if ((await this.confirmOnlineStateOrThrow(), !this.connected)) {
      if (this.connectPromise) {
        await this.connectPromise;
        return;
      }
      await this.connect();
    }
  }
}
function Hoe() {}
function QN(t) {
  if (!t || typeof t != "object") return !1;
  const e = Object.getPrototypeOf(t);
  return e === null ||
    e === Object.prototype ||
    Object.getPrototypeOf(e) === null
    ? Object.prototype.toString.call(t) === "[object Object]"
    : !1;
}
function XN(t) {
  return Object.getOwnPropertySymbols(t).filter((e) =>
    Object.prototype.propertyIsEnumerable.call(t, e)
  );
}
function JN(t) {
  return t == null
    ? t === void 0
      ? "[object Undefined]"
      : "[object Null]"
    : Object.prototype.toString.call(t);
}
const qoe = "[object RegExp]",
  Voe = "[object String]",
  Goe = "[object Number]",
  Koe = "[object Boolean]",
  eO = "[object Arguments]",
  Yoe = "[object Symbol]",
  Zoe = "[object Date]",
  Qoe = "[object Map]",
  Xoe = "[object Set]",
  Joe = "[object Array]",
  eae = "[object Function]",
  tae = "[object ArrayBuffer]",
  YE = "[object Object]",
  nae = "[object Error]",
  rae = "[object DataView]",
  iae = "[object Uint8Array]",
  sae = "[object Uint8ClampedArray]",
  oae = "[object Uint16Array]",
  aae = "[object Uint32Array]",
  cae = "[object BigUint64Array]",
  lae = "[object Int8Array]",
  uae = "[object Int16Array]",
  dae = "[object Int32Array]",
  pae = "[object BigInt64Array]",
  fae = "[object Float32Array]",
  hae = "[object Float64Array]";
function mae(t, e) {
  return t === e || (Number.isNaN(t) && Number.isNaN(e));
}
function gae(t, e, n) {
  return uh(t, e, void 0, void 0, void 0, void 0, n);
}
function uh(t, e, n, r, i, s, o) {
  const a = o(t, e, n, r, i, s);
  if (a !== void 0) return a;
  if (typeof t == typeof e)
    switch (typeof t) {
      case "bigint":
      case "string":
      case "boolean":
      case "symbol":
      case "undefined":
        return t === e;
      case "number":
        return t === e || Object.is(t, e);
      case "function":
        return t === e;
      case "object":
        return Eh(t, e, s, o);
    }
  return Eh(t, e, s, o);
}
function Eh(t, e, n, r) {
  if (Object.is(t, e)) return !0;
  let i = JN(t),
    s = JN(e);
  if ((i === eO && (i = YE), s === eO && (s = YE), i !== s)) return !1;
  switch (i) {
    case Voe:
      return t.toString() === e.toString();
    case Goe: {
      const l = t.valueOf(),
        d = e.valueOf();
      return mae(l, d);
    }
    case Koe:
    case Zoe:
    case Yoe:
      return Object.is(t.valueOf(), e.valueOf());
    case qoe:
      return t.source === e.source && t.flags === e.flags;
    case eae:
      return t === e;
  }
  n = n ?? new Map();
  const o = n.get(t),
    a = n.get(e);
  if (o != null && a != null) return o === e;
  n.set(t, e), n.set(e, t);
  try {
    switch (i) {
      case Qoe: {
        if (t.size !== e.size) return !1;
        for (const [l, d] of t.entries())
          if (!e.has(l) || !uh(d, e.get(l), l, t, e, n, r)) return !1;
        return !0;
      }
      case Xoe: {
        if (t.size !== e.size) return !1;
        const l = Array.from(t.values()),
          d = Array.from(e.values());
        for (let p = 0; p < l.length; p++) {
          const f = l[p],
            m = d.findIndex((y) => uh(f, y, void 0, t, e, n, r));
          if (m === -1) return !1;
          d.splice(m, 1);
        }
        return !0;
      }
      case Joe:
      case iae:
      case sae:
      case oae:
      case aae:
      case cae:
      case lae:
      case uae:
      case dae:
      case pae:
      case fae:
      case hae: {
        if (
          (typeof Buffer < "u" && Buffer.isBuffer(t) !== Buffer.isBuffer(e)) ||
          t.length !== e.length
        )
          return !1;
        for (let l = 0; l < t.length; l++)
          if (!uh(t[l], e[l], l, t, e, n, r)) return !1;
        return !0;
      }
      case tae:
        return t.byteLength !== e.byteLength
          ? !1
          : Eh(new Uint8Array(t), new Uint8Array(e), n, r);
      case rae:
        return t.byteLength !== e.byteLength || t.byteOffset !== e.byteOffset
          ? !1
          : Eh(new Uint8Array(t), new Uint8Array(e), n, r);
      case nae:
        return t.name === e.name && t.message === e.message;
      case YE: {
        if (!(Eh(t.constructor, e.constructor, n, r) || (QN(t) && QN(e))))
          return !1;
        const l = [...Object.keys(t), ...XN(t)],
          d = [...Object.keys(e), ...XN(e)];
        if (l.length !== d.length) return !1;
        for (let p = 0; p < l.length; p++) {
          const f = l[p],
            m = t[f];
          if (!Object.hasOwn(e, f)) return !1;
          const y = e[f];
          if (!uh(m, y, f, t, e, n, r)) return !1;
        }
        return !0;
      }
      default:
        return !1;
    }
  } finally {
    n.delete(t), n.delete(e);
  }
}
function yae(t, e) {
  return gae(t, e, Hoe);
}
var wae = Object.defineProperty,
  tO = Object.getOwnPropertySymbols,
  vae = Object.prototype.hasOwnProperty,
  bae = Object.prototype.propertyIsEnumerable,
  qx = (t, e, n) =>
    e in t
      ? wae(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n })
      : (t[e] = n),
  nO = (t, e) => {
    for (var n in e || (e = {})) vae.call(e, n) && qx(t, n, e[n]);
    if (tO) for (var n of tO(e)) bae.call(e, n) && qx(t, n, e[n]);
    return t;
  },
  hi = (t, e, n) => qx(t, typeof e != "symbol" ? e + "" : e, n);
class mu extends dK {
  constructor(e, n, r, i = Oo, s = void 0) {
    super(e, n, r, i),
      (this.core = e),
      (this.logger = n),
      (this.name = r),
      hi(this, "map", new Map()),
      hi(this, "version", Eie),
      hi(this, "cached", []),
      hi(this, "initialized", !1),
      hi(this, "getKey"),
      hi(this, "storagePrefix", Oo),
      hi(this, "recentlyDeleted", []),
      hi(this, "recentlyDeletedLimit", 200),
      hi(this, "init", async () => {
        this.initialized ||
          (this.logger.trace("Initialized"),
          await this.restore(),
          this.cached.forEach((o) => {
            this.getKey && o !== null && !Tr(o)
              ? this.map.set(this.getKey(o), o)
              : pre(o)
              ? this.map.set(o.id, o)
              : fre(o) && this.map.set(o.topic, o);
          }),
          (this.cached = []),
          (this.initialized = !0));
      }),
      hi(this, "set", async (o, a) => {
        this.isInitialized(),
          this.map.has(o)
            ? await this.update(o, a)
            : (this.logger.debug("Setting value"),
              this.logger.trace({
                type: "method",
                method: "set",
                key: o,
                value: a,
              }),
              this.map.set(o, a),
              await this.persist());
      }),
      hi(
        this,
        "get",
        (o) => (
          this.isInitialized(),
          this.logger.debug("Getting value"),
          this.logger.trace({ type: "method", method: "get", key: o }),
          this.getData(o)
        )
      ),
      hi(
        this,
        "getAll",
        (o) => (
          this.isInitialized(),
          o
            ? this.values.filter((a) =>
                Object.keys(o).every((l) => yae(a[l], o[l]))
              )
            : this.values
        )
      ),
      hi(this, "update", async (o, a) => {
        this.isInitialized(),
          this.logger.debug("Updating value"),
          this.logger.trace({
            type: "method",
            method: "update",
            key: o,
            update: a,
          });
        const l = nO(nO({}, this.getData(o)), a);
        this.map.set(o, l), await this.persist();
      }),
      hi(this, "delete", async (o, a) => {
        this.isInitialized(),
          this.map.has(o) &&
            (this.logger.debug("Deleting value"),
            this.logger.trace({
              type: "method",
              method: "delete",
              key: o,
              reason: a,
            }),
            this.map.delete(o),
            this.addToRecentlyDeleted(o),
            await this.persist());
      }),
      (this.logger = Gr(n, this.name)),
      (this.storagePrefix = i),
      (this.getKey = s);
  }
  get context() {
    return Ti(this.logger);
  }
  get storageKey() {
    return (
      this.storagePrefix +
      this.version +
      this.core.customStoragePrefix +
      "//" +
      this.name
    );
  }
  get length() {
    return this.map.size;
  }
  get keys() {
    return Array.from(this.map.keys());
  }
  get values() {
    return Array.from(this.map.values());
  }
  addToRecentlyDeleted(e) {
    this.recentlyDeleted.push(e),
      this.recentlyDeleted.length >= this.recentlyDeletedLimit &&
        this.recentlyDeleted.splice(0, this.recentlyDeletedLimit / 2);
  }
  async setDataStore(e) {
    await this.core.storage.setItem(this.storageKey, e);
  }
  async getDataStore() {
    return await this.core.storage.getItem(this.storageKey);
  }
  getData(e) {
    const n = this.map.get(e);
    if (!n) {
      if (this.recentlyDeleted.includes(e)) {
        const { message: i } = xe(
          "MISSING_OR_INVALID",
          `Record was recently deleted - ${this.name}: ${e}`
        );
        throw (this.logger.error(i), new Error(i));
      }
      const { message: r } = xe("NO_MATCHING_KEY", `${this.name}: ${e}`);
      throw (this.logger.error(r), new Error(r));
    }
    return n;
  }
  async persist() {
    await this.setDataStore(this.values);
  }
  async restore() {
    try {
      const e = await this.getDataStore();
      if (typeof e > "u" || !e.length) return;
      if (this.map.size) {
        const { message: n } = xe("RESTORE_WILL_OVERRIDE", this.name);
        throw (this.logger.error(n), new Error(n));
      }
      (this.cached = e),
        this.logger.debug(`Successfully Restored value for ${this.name}`),
        this.logger.trace({
          type: "method",
          method: "restore",
          value: this.values,
        });
    } catch (e) {
      this.logger.debug(`Failed to Restore value for ${this.name}`),
        this.logger.error(e);
    }
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = xe("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
}
var Eae = Object.defineProperty,
  Cae = (t, e, n) =>
    e in t
      ? Eae(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n })
      : (t[e] = n),
  xt = (t, e, n) => Cae(t, typeof e != "symbol" ? e + "" : e, n);
class xae {
  constructor(e, n) {
    (this.core = e),
      (this.logger = n),
      xt(this, "name", Aie),
      xt(this, "version", _ie),
      xt(this, "events", new mA()),
      xt(this, "pairings"),
      xt(this, "initialized", !1),
      xt(this, "storagePrefix", Oo),
      xt(this, "ignoredPayloadTypes", [wa]),
      xt(this, "registeredMethods", []),
      xt(this, "init", async () => {
        this.initialized ||
          (await this.pairings.init(),
          await this.cleanup(),
          this.registerRelayerEvents(),
          this.registerExpirerEvents(),
          (this.initialized = !0),
          this.logger.trace("Initialized"));
      }),
      xt(this, "register", ({ methods: r }) => {
        this.isInitialized(),
          (this.registeredMethods = [
            ...new Set([...this.registeredMethods, ...r]),
          ]);
      }),
      xt(this, "create", async (r) => {
        this.isInitialized();
        const i = Lx(),
          s = await this.core.crypto.setSymKey(i),
          o = Zn(Ee.FIVE_MINUTES),
          a = { protocol: nM },
          l = {
            topic: s,
            expiry: o,
            relay: a,
            active: !1,
            methods: r == null ? void 0 : r.methods,
          },
          d = CN({
            protocol: this.core.protocol,
            version: this.core.version,
            topic: s,
            symKey: i,
            relay: a,
            expiryTimestamp: o,
            methods: r == null ? void 0 : r.methods,
          });
        return (
          this.events.emit(Sl.create, l),
          this.core.expirer.set(s, o),
          await this.pairings.set(s, l),
          await this.core.relayer.subscribe(s, {
            transportType: r == null ? void 0 : r.transportType,
          }),
          { topic: s, uri: d }
        );
      }),
      xt(this, "pair", async (r) => {
        this.isInitialized();
        const i = this.core.eventClient.createEvent({
          properties: {
            topic: r == null ? void 0 : r.uri,
            trace: [mo.pairing_started],
          },
        });
        this.isValidPair(r, i);
        const {
          topic: s,
          symKey: o,
          relay: a,
          expiryTimestamp: l,
          methods: d,
        } = EN(r.uri);
        (i.props.properties.topic = s),
          i.addTrace(mo.pairing_uri_validation_success),
          i.addTrace(mo.pairing_uri_not_expired);
        let p;
        if (this.pairings.keys.includes(s)) {
          if (
            ((p = this.pairings.get(s)),
            i.addTrace(mo.existing_pairing),
            p.active)
          )
            throw (
              (i.setError(ca.active_pairing_already_exists),
              new Error(
                `Pairing already exists: ${s}. Please try again with a new connection URI.`
              ))
            );
          i.addTrace(mo.pairing_not_expired);
        }
        const f = l || Zn(Ee.FIVE_MINUTES),
          m = { topic: s, relay: a, expiry: f, active: !1, methods: d };
        this.core.expirer.set(s, f),
          await this.pairings.set(s, m),
          i.addTrace(mo.store_new_pairing),
          r.activatePairing && (await this.activate({ topic: s })),
          this.events.emit(Sl.create, m),
          i.addTrace(mo.emit_inactive_pairing),
          this.core.crypto.keychain.has(s) ||
            (await this.core.crypto.setSymKey(o, s)),
          i.addTrace(mo.subscribing_pairing_topic);
        try {
          await this.core.relayer.confirmOnlineStateOrThrow();
        } catch {
          i.setError(ca.no_internet_connection);
        }
        try {
          await this.core.relayer.subscribe(s, { relay: a });
        } catch (y) {
          throw (i.setError(ca.subscribe_pairing_topic_failure), y);
        }
        return i.addTrace(mo.subscribe_pairing_topic_success), m;
      }),
      xt(this, "activate", async ({ topic: r }) => {
        this.isInitialized();
        const i = Zn(Ee.FIVE_MINUTES);
        this.core.expirer.set(r, i),
          await this.pairings.update(r, { active: !0, expiry: i });
      }),
      xt(this, "ping", async (r) => {
        this.isInitialized(),
          await this.isValidPing(r),
          this.logger.warn(
            "ping() is deprecated and will be removed in the next major release."
          );
        const { topic: i } = r;
        if (this.pairings.keys.includes(i)) {
          const s = await this.sendRequest(i, "wc_pairingPing", {}),
            { done: o, resolve: a, reject: l } = vl();
          this.events.once(jt("pairing_ping", s), ({ error: d }) => {
            d ? l(d) : a();
          }),
            await o();
        }
      }),
      xt(this, "updateExpiry", async ({ topic: r, expiry: i }) => {
        this.isInitialized(), await this.pairings.update(r, { expiry: i });
      }),
      xt(this, "updateMetadata", async ({ topic: r, metadata: i }) => {
        this.isInitialized(),
          await this.pairings.update(r, { peerMetadata: i });
      }),
      xt(
        this,
        "getPairings",
        () => (this.isInitialized(), this.pairings.values)
      ),
      xt(this, "disconnect", async (r) => {
        this.isInitialized(), await this.isValidDisconnect(r);
        const { topic: i } = r;
        this.pairings.keys.includes(i) &&
          (await this.sendRequest(
            i,
            "wc_pairingDelete",
            Kt("USER_DISCONNECTED")
          ),
          await this.deletePairing(i));
      }),
      xt(this, "formatUriFromPairing", (r) => {
        this.isInitialized();
        const { topic: i, relay: s, expiry: o, methods: a } = r,
          l = this.core.crypto.keychain.get(i);
        return CN({
          protocol: this.core.protocol,
          version: this.core.version,
          topic: i,
          symKey: l,
          relay: s,
          expiryTimestamp: o,
          methods: a,
        });
      }),
      xt(this, "sendRequest", async (r, i, s) => {
        const o = Tc(i, s),
          a = await this.core.crypto.encode(r, o),
          l = Wf[i].req;
        return (
          this.core.history.set(r, o), this.core.relayer.publish(r, a, l), o.id
        );
      }),
      xt(this, "sendResult", async (r, i, s) => {
        const o = Tv(r, s),
          a = await this.core.crypto.encode(i, o),
          l = (await this.core.history.get(i, r)).request.method,
          d = Wf[l].res;
        await this.core.relayer.publish(i, a, d),
          await this.core.history.resolve(o);
      }),
      xt(this, "sendError", async (r, i, s) => {
        const o = Pv(r, s),
          a = await this.core.crypto.encode(i, o),
          l = (await this.core.history.get(i, r)).request.method,
          d = Wf[l] ? Wf[l].res : Wf.unregistered_method.res;
        await this.core.relayer.publish(i, a, d),
          await this.core.history.resolve(o);
      }),
      xt(this, "deletePairing", async (r, i) => {
        await this.core.relayer.unsubscribe(r),
          await Promise.all([
            this.pairings.delete(r, Kt("USER_DISCONNECTED")),
            this.core.crypto.deleteSymKey(r),
            i ? Promise.resolve() : this.core.expirer.del(r),
          ]);
      }),
      xt(this, "cleanup", async () => {
        const r = this.pairings.getAll().filter((i) => fc(i.expiry));
        await Promise.all(r.map((i) => this.deletePairing(i.topic)));
      }),
      xt(this, "onRelayEventRequest", async (r) => {
        const { topic: i, payload: s } = r;
        switch (s.method) {
          case "wc_pairingPing":
            return await this.onPairingPingRequest(i, s);
          case "wc_pairingDelete":
            return await this.onPairingDeleteRequest(i, s);
          default:
            return await this.onUnknownRpcMethodRequest(i, s);
        }
      }),
      xt(this, "onRelayEventResponse", async (r) => {
        const { topic: i, payload: s } = r,
          o = (await this.core.history.get(i, s.id)).request.method;
        switch (o) {
          case "wc_pairingPing":
            return this.onPairingPingResponse(i, s);
          default:
            return this.onUnknownRpcMethodResponse(o);
        }
      }),
      xt(this, "onPairingPingRequest", async (r, i) => {
        const { id: s } = i;
        try {
          this.isValidPing({ topic: r }),
            await this.sendResult(s, r, !0),
            this.events.emit(Sl.ping, { id: s, topic: r });
        } catch (o) {
          await this.sendError(s, r, o), this.logger.error(o);
        }
      }),
      xt(this, "onPairingPingResponse", (r, i) => {
        const { id: s } = i;
        setTimeout(() => {
          yo(i)
            ? this.events.emit(jt("pairing_ping", s), {})
            : ls(i) &&
              this.events.emit(jt("pairing_ping", s), { error: i.error });
        }, 500);
      }),
      xt(this, "onPairingDeleteRequest", async (r, i) => {
        const { id: s } = i;
        try {
          this.isValidDisconnect({ topic: r }),
            await this.deletePairing(r),
            this.events.emit(Sl.delete, { id: s, topic: r });
        } catch (o) {
          await this.sendError(s, r, o), this.logger.error(o);
        }
      }),
      xt(this, "onUnknownRpcMethodRequest", async (r, i) => {
        const { id: s, method: o } = i;
        try {
          if (this.registeredMethods.includes(o)) return;
          const a = Kt("WC_METHOD_UNSUPPORTED", o);
          await this.sendError(s, r, a), this.logger.error(a);
        } catch (a) {
          await this.sendError(s, r, a), this.logger.error(a);
        }
      }),
      xt(this, "onUnknownRpcMethodResponse", (r) => {
        this.registeredMethods.includes(r) ||
          this.logger.error(Kt("WC_METHOD_UNSUPPORTED", r));
      }),
      xt(this, "isValidPair", (r, i) => {
        var s;
        if (!wi(r)) {
          const { message: a } = xe(
            "MISSING_OR_INVALID",
            `pair() params: ${r}`
          );
          throw (i.setError(ca.malformed_pairing_uri), new Error(a));
        }
        if (!dre(r.uri)) {
          const { message: a } = xe(
            "MISSING_OR_INVALID",
            `pair() uri: ${r.uri}`
          );
          throw (i.setError(ca.malformed_pairing_uri), new Error(a));
        }
        const o = EN(r == null ? void 0 : r.uri);
        if (!((s = o == null ? void 0 : o.relay) != null && s.protocol)) {
          const { message: a } = xe(
            "MISSING_OR_INVALID",
            "pair() uri#relay-protocol"
          );
          throw (i.setError(ca.malformed_pairing_uri), new Error(a));
        }
        if (!(o != null && o.symKey)) {
          const { message: a } = xe("MISSING_OR_INVALID", "pair() uri#symKey");
          throw (i.setError(ca.malformed_pairing_uri), new Error(a));
        }
        if (
          o != null &&
          o.expiryTimestamp &&
          Ee.toMiliseconds(o == null ? void 0 : o.expiryTimestamp) < Date.now()
        ) {
          i.setError(ca.pairing_expired);
          const { message: a } = xe(
            "EXPIRED",
            "pair() URI has expired. Please try again with a new connection URI."
          );
          throw new Error(a);
        }
      }),
      xt(this, "isValidPing", async (r) => {
        if (!wi(r)) {
          const { message: s } = xe(
            "MISSING_OR_INVALID",
            `ping() params: ${r}`
          );
          throw new Error(s);
        }
        const { topic: i } = r;
        await this.isValidPairingTopic(i);
      }),
      xt(this, "isValidDisconnect", async (r) => {
        if (!wi(r)) {
          const { message: s } = xe(
            "MISSING_OR_INVALID",
            `disconnect() params: ${r}`
          );
          throw new Error(s);
        }
        const { topic: i } = r;
        await this.isValidPairingTopic(i);
      }),
      xt(this, "isValidPairingTopic", async (r) => {
        if (!Hn(r, !1)) {
          const { message: i } = xe(
            "MISSING_OR_INVALID",
            `pairing topic should be a string: ${r}`
          );
          throw new Error(i);
        }
        if (!this.pairings.keys.includes(r)) {
          const { message: i } = xe(
            "NO_MATCHING_KEY",
            `pairing topic doesn't exist: ${r}`
          );
          throw new Error(i);
        }
        if (fc(this.pairings.get(r).expiry)) {
          await this.deletePairing(r);
          const { message: i } = xe("EXPIRED", `pairing topic: ${r}`);
          throw new Error(i);
        }
      }),
      (this.core = e),
      (this.logger = Gr(n, this.name)),
      (this.pairings = new mu(
        this.core,
        this.logger,
        this.name,
        this.storagePrefix
      ));
  }
  get context() {
    return Ti(this.logger);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = xe("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
  registerRelayerEvents() {
    this.core.relayer.on(fr.message, async (e) => {
      const { topic: n, message: r, transportType: i } = e;
      if (
        this.pairings.keys.includes(n) &&
        i !== dn.link_mode &&
        !this.ignoredPayloadTypes.includes(this.core.crypto.getPayloadType(r))
      )
        try {
          const s = await this.core.crypto.decode(n, r);
          $A(s)
            ? (this.core.history.set(n, s),
              await this.onRelayEventRequest({ topic: n, payload: s }))
            : Rv(s) &&
              (await this.core.history.resolve(s),
              await this.onRelayEventResponse({ topic: n, payload: s }),
              this.core.history.delete(n, s.id)),
            await this.core.relayer.messages.ack(n, r);
        } catch (s) {
          this.logger.error(s);
        }
    });
  }
  registerExpirerEvents() {
    this.core.expirer.on(as.expired, async (e) => {
      const { topic: n } = f$(e.target);
      n &&
        this.pairings.keys.includes(n) &&
        (await this.deletePairing(n, !0),
        this.events.emit(Sl.expire, { topic: n }));
    });
  }
}
var Sae = Object.defineProperty,
  Aae = (t, e, n) =>
    e in t
      ? Sae(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n })
      : (t[e] = n),
  Ar = (t, e, n) => Aae(t, typeof e != "symbol" ? e + "" : e, n);
class _ae extends aK {
  constructor(e, n) {
    super(e, n),
      (this.core = e),
      (this.logger = n),
      Ar(this, "records", new Map()),
      Ar(this, "events", new Ss.EventEmitter()),
      Ar(this, "name", Iie),
      Ar(this, "version", Tie),
      Ar(this, "cached", []),
      Ar(this, "initialized", !1),
      Ar(this, "storagePrefix", Oo),
      Ar(this, "init", async () => {
        this.initialized ||
          (this.logger.trace("Initialized"),
          await this.restore(),
          this.cached.forEach((r) => this.records.set(r.id, r)),
          (this.cached = []),
          this.registerEventListeners(),
          (this.initialized = !0));
      }),
      Ar(this, "set", (r, i, s) => {
        if (
          (this.isInitialized(),
          this.logger.debug("Setting JSON-RPC request history record"),
          this.logger.trace({
            type: "method",
            method: "set",
            topic: r,
            request: i,
            chainId: s,
          }),
          this.records.has(i.id))
        )
          return;
        const o = {
          id: i.id,
          topic: r,
          request: { method: i.method, params: i.params || null },
          chainId: s,
          expiry: Zn(Ee.THIRTY_DAYS),
        };
        this.records.set(o.id, o),
          this.persist(),
          this.events.emit(Ms.created, o);
      }),
      Ar(this, "resolve", async (r) => {
        if (
          (this.isInitialized(),
          this.logger.debug("Updating JSON-RPC response history record"),
          this.logger.trace({ type: "method", method: "update", response: r }),
          !this.records.has(r.id))
        )
          return;
        const i = await this.getRecord(r.id);
        typeof i.response > "u" &&
          ((i.response = ls(r) ? { error: r.error } : { result: r.result }),
          this.records.set(i.id, i),
          this.persist(),
          this.events.emit(Ms.updated, i));
      }),
      Ar(
        this,
        "get",
        async (r, i) => (
          this.isInitialized(),
          this.logger.debug("Getting record"),
          this.logger.trace({ type: "method", method: "get", topic: r, id: i }),
          await this.getRecord(i)
        )
      ),
      Ar(this, "delete", (r, i) => {
        this.isInitialized(),
          this.logger.debug("Deleting record"),
          this.logger.trace({ type: "method", method: "delete", id: i }),
          this.values.forEach((s) => {
            if (s.topic === r) {
              if (typeof i < "u" && s.id !== i) return;
              this.records.delete(s.id), this.events.emit(Ms.deleted, s);
            }
          }),
          this.persist();
      }),
      Ar(
        this,
        "exists",
        async (r, i) => (
          this.isInitialized(),
          this.records.has(i) ? (await this.getRecord(i)).topic === r : !1
        )
      ),
      Ar(this, "on", (r, i) => {
        this.events.on(r, i);
      }),
      Ar(this, "once", (r, i) => {
        this.events.once(r, i);
      }),
      Ar(this, "off", (r, i) => {
        this.events.off(r, i);
      }),
      Ar(this, "removeListener", (r, i) => {
        this.events.removeListener(r, i);
      }),
      (this.logger = Gr(n, this.name));
  }
  get context() {
    return Ti(this.logger);
  }
  get storageKey() {
    return (
      this.storagePrefix +
      this.version +
      this.core.customStoragePrefix +
      "//" +
      this.name
    );
  }
  get size() {
    return this.records.size;
  }
  get keys() {
    return Array.from(this.records.keys());
  }
  get values() {
    return Array.from(this.records.values());
  }
  get pending() {
    const e = [];
    return (
      this.values.forEach((n) => {
        if (typeof n.response < "u") return;
        const r = {
          topic: n.topic,
          request: Tc(n.request.method, n.request.params, n.id),
          chainId: n.chainId,
        };
        return e.push(r);
      }),
      e
    );
  }
  async setJsonRpcRecords(e) {
    await this.core.storage.setItem(this.storageKey, e);
  }
  async getJsonRpcRecords() {
    return await this.core.storage.getItem(this.storageKey);
  }
  getRecord(e) {
    this.isInitialized();
    const n = this.records.get(e);
    if (!n) {
      const { message: r } = xe("NO_MATCHING_KEY", `${this.name}: ${e}`);
      throw new Error(r);
    }
    return n;
  }
  async persist() {
    await this.setJsonRpcRecords(this.values), this.events.emit(Ms.sync);
  }
  async restore() {
    try {
      const e = await this.getJsonRpcRecords();
      if (typeof e > "u" || !e.length) return;
      if (this.records.size) {
        const { message: n } = xe("RESTORE_WILL_OVERRIDE", this.name);
        throw (this.logger.error(n), new Error(n));
      }
      (this.cached = e),
        this.logger.debug(`Successfully Restored records for ${this.name}`),
        this.logger.trace({
          type: "method",
          method: "restore",
          records: this.values,
        });
    } catch (e) {
      this.logger.debug(`Failed to Restore records for ${this.name}`),
        this.logger.error(e);
    }
  }
  registerEventListeners() {
    this.events.on(Ms.created, (e) => {
      const n = Ms.created;
      this.logger.info(`Emitting ${n}`),
        this.logger.debug({ type: "event", event: n, record: e });
    }),
      this.events.on(Ms.updated, (e) => {
        const n = Ms.updated;
        this.logger.info(`Emitting ${n}`),
          this.logger.debug({ type: "event", event: n, record: e });
      }),
      this.events.on(Ms.deleted, (e) => {
        const n = Ms.deleted;
        this.logger.info(`Emitting ${n}`),
          this.logger.debug({ type: "event", event: n, record: e });
      }),
      this.core.heartbeat.on(Ap.pulse, () => {
        this.cleanup();
      });
  }
  cleanup() {
    try {
      this.isInitialized();
      let e = !1;
      this.records.forEach((n) => {
        Ee.toMiliseconds(n.expiry || 0) - Date.now() <= 0 &&
          (this.logger.info(`Deleting expired history log: ${n.id}`),
          this.records.delete(n.id),
          this.events.emit(Ms.deleted, n, !1),
          (e = !0));
      }),
        e && this.persist();
    } catch (e) {
      this.logger.warn(e);
    }
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = xe("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
}
var Iae = Object.defineProperty,
  Tae = (t, e, n) =>
    e in t
      ? Iae(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n })
      : (t[e] = n),
  Fr = (t, e, n) => Tae(t, typeof e != "symbol" ? e + "" : e, n);
class Pae extends fK {
  constructor(e, n) {
    super(e, n),
      (this.core = e),
      (this.logger = n),
      Fr(this, "expirations", new Map()),
      Fr(this, "events", new Ss.EventEmitter()),
      Fr(this, "name", Pie),
      Fr(this, "version", Rie),
      Fr(this, "cached", []),
      Fr(this, "initialized", !1),
      Fr(this, "storagePrefix", Oo),
      Fr(this, "init", async () => {
        this.initialized ||
          (this.logger.trace("Initialized"),
          await this.restore(),
          this.cached.forEach((r) => this.expirations.set(r.target, r)),
          (this.cached = []),
          this.registerEventListeners(),
          (this.initialized = !0));
      }),
      Fr(this, "has", (r) => {
        try {
          const i = this.formatTarget(r);
          return typeof this.getExpiration(i) < "u";
        } catch {
          return !1;
        }
      }),
      Fr(this, "set", (r, i) => {
        this.isInitialized();
        const s = this.formatTarget(r),
          o = { target: s, expiry: i };
        this.expirations.set(s, o),
          this.checkExpiry(s, o),
          this.events.emit(as.created, { target: s, expiration: o });
      }),
      Fr(this, "get", (r) => {
        this.isInitialized();
        const i = this.formatTarget(r);
        return this.getExpiration(i);
      }),
      Fr(this, "del", (r) => {
        if ((this.isInitialized(), this.has(r))) {
          const i = this.formatTarget(r),
            s = this.getExpiration(i);
          this.expirations.delete(i),
            this.events.emit(as.deleted, { target: i, expiration: s });
        }
      }),
      Fr(this, "on", (r, i) => {
        this.events.on(r, i);
      }),
      Fr(this, "once", (r, i) => {
        this.events.once(r, i);
      }),
      Fr(this, "off", (r, i) => {
        this.events.off(r, i);
      }),
      Fr(this, "removeListener", (r, i) => {
        this.events.removeListener(r, i);
      }),
      (this.logger = Gr(n, this.name));
  }
  get context() {
    return Ti(this.logger);
  }
  get storageKey() {
    return (
      this.storagePrefix +
      this.version +
      this.core.customStoragePrefix +
      "//" +
      this.name
    );
  }
  get length() {
    return this.expirations.size;
  }
  get keys() {
    return Array.from(this.expirations.keys());
  }
  get values() {
    return Array.from(this.expirations.values());
  }
  formatTarget(e) {
    if (typeof e == "string") return Cee(e);
    if (typeof e == "number") return xee(e);
    const { message: n } = xe("UNKNOWN_TYPE", `Target type: ${typeof e}`);
    throw new Error(n);
  }
  async setExpirations(e) {
    await this.core.storage.setItem(this.storageKey, e);
  }
  async getExpirations() {
    return await this.core.storage.getItem(this.storageKey);
  }
  async persist() {
    await this.setExpirations(this.values), this.events.emit(as.sync);
  }
  async restore() {
    try {
      const e = await this.getExpirations();
      if (typeof e > "u" || !e.length) return;
      if (this.expirations.size) {
        const { message: n } = xe("RESTORE_WILL_OVERRIDE", this.name);
        throw (this.logger.error(n), new Error(n));
      }
      (this.cached = e),
        this.logger.debug(`Successfully Restored expirations for ${this.name}`),
        this.logger.trace({
          type: "method",
          method: "restore",
          expirations: this.values,
        });
    } catch (e) {
      this.logger.debug(`Failed to Restore expirations for ${this.name}`),
        this.logger.error(e);
    }
  }
  getExpiration(e) {
    const n = this.expirations.get(e);
    if (!n) {
      const { message: r } = xe("NO_MATCHING_KEY", `${this.name}: ${e}`);
      throw (this.logger.warn(r), new Error(r));
    }
    return n;
  }
  checkExpiry(e, n) {
    const { expiry: r } = n;
    Ee.toMiliseconds(r) - Date.now() <= 0 && this.expire(e, n);
  }
  expire(e, n) {
    this.expirations.delete(e),
      this.events.emit(as.expired, { target: e, expiration: n });
  }
  checkExpirations() {
    this.core.relayer.connected &&
      this.expirations.forEach((e, n) => this.checkExpiry(n, e));
  }
  registerEventListeners() {
    this.core.heartbeat.on(Ap.pulse, () => this.checkExpirations()),
      this.events.on(as.created, (e) => {
        const n = as.created;
        this.logger.info(`Emitting ${n}`),
          this.logger.debug({ type: "event", event: n, data: e }),
          this.persist();
      }),
      this.events.on(as.expired, (e) => {
        const n = as.expired;
        this.logger.info(`Emitting ${n}`),
          this.logger.debug({ type: "event", event: n, data: e }),
          this.persist();
      }),
      this.events.on(as.deleted, (e) => {
        const n = as.deleted;
        this.logger.info(`Emitting ${n}`),
          this.logger.debug({ type: "event", event: n, data: e }),
          this.persist();
      });
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = xe("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
}
var Rae = Object.defineProperty,
  Nae = (t, e, n) =>
    e in t
      ? Rae(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n })
      : (t[e] = n),
  Wn = (t, e, n) => Nae(t, typeof e != "symbol" ? e + "" : e, n);
class Oae extends hK {
  constructor(e, n, r) {
    super(e, n, r),
      (this.core = e),
      (this.logger = n),
      (this.store = r),
      Wn(this, "name", Nie),
      Wn(this, "abortController"),
      Wn(this, "isDevEnv"),
      Wn(this, "verifyUrlV3", kie),
      Wn(this, "storagePrefix", Oo),
      Wn(this, "version", tM),
      Wn(this, "publicKey"),
      Wn(this, "fetchPromise"),
      Wn(this, "init", async () => {
        var i;
        this.isDevEnv ||
          ((this.publicKey = await this.store.getItem(this.storeKey)),
          this.publicKey &&
            Ee.toMiliseconds(
              (i = this.publicKey) == null ? void 0 : i.expiresAt
            ) < Date.now() &&
            (this.logger.debug("verify v2 public key expired"),
            await this.removePublicKey()));
      }),
      Wn(this, "register", async (i) => {
        if (!Jm() || this.isDevEnv) return;
        const s = window.location.origin,
          { id: o, decryptedId: a } = i,
          l = `${this.verifyUrlV3}/attestation?projectId=${this.core.projectId}&origin=${s}&id=${o}&decryptedId=${a}`;
        try {
          const d = Ql.getDocument(),
            p = this.startAbortTimer(Ee.ONE_SECOND * 5),
            f = await new Promise((m, y) => {
              const g = () => {
                window.removeEventListener("message", b),
                  d.body.removeChild(v),
                  y("attestation aborted");
              };
              this.abortController.signal.addEventListener("abort", g);
              const v = d.createElement("iframe");
              (v.src = l),
                (v.style.display = "none"),
                v.addEventListener("error", g, {
                  signal: this.abortController.signal,
                });
              const b = (E) => {
                if (E.data && typeof E.data == "string")
                  try {
                    const S = JSON.parse(E.data);
                    if (S.type === "verify_attestation") {
                      if (vx(S.attestation).payload.id !== o) return;
                      clearInterval(p),
                        d.body.removeChild(v),
                        this.abortController.signal.removeEventListener(
                          "abort",
                          g
                        ),
                        window.removeEventListener("message", b),
                        m(S.attestation === null ? "" : S.attestation);
                    }
                  } catch (S) {
                    this.logger.warn(S);
                  }
              };
              d.body.appendChild(v),
                window.addEventListener("message", b, {
                  signal: this.abortController.signal,
                });
            });
          return this.logger.debug("jwt attestation", f), f;
        } catch (d) {
          this.logger.warn(d);
        }
        return "";
      }),
      Wn(this, "resolve", async (i) => {
        if (this.isDevEnv) return "";
        const { attestationId: s, hash: o, encryptedId: a } = i;
        if (s === "") {
          this.logger.debug("resolve: attestationId is empty, skipping");
          return;
        }
        if (s) {
          if (vx(s).payload.id !== a) return;
          const d = await this.isValidJwtAttestation(s);
          if (d) {
            if (!d.isVerified) {
              this.logger.warn(
                "resolve: jwt attestation: origin url not verified"
              );
              return;
            }
            return d;
          }
        }
        if (!o) return;
        const l = this.getVerifyUrl(i == null ? void 0 : i.verifyUrl);
        return this.fetchAttestation(o, l);
      }),
      Wn(this, "fetchAttestation", async (i, s) => {
        this.logger.debug(`resolving attestation: ${i} from url: ${s}`);
        const o = this.startAbortTimer(Ee.ONE_SECOND * 5),
          a = await fetch(`${s}/attestation/${i}?v2Supported=true`, {
            signal: this.abortController.signal,
          });
        return clearTimeout(o), a.status === 200 ? await a.json() : void 0;
      }),
      Wn(this, "getVerifyUrl", (i) => {
        let s = i || bh;
        return (
          Die.includes(s) ||
            (this.logger.info(
              `verify url: ${s}, not included in trusted list, assigning default: ${bh}`
            ),
            (s = bh)),
          s
        );
      }),
      Wn(this, "fetchPublicKey", async () => {
        try {
          this.logger.debug(`fetching public key from: ${this.verifyUrlV3}`);
          const i = this.startAbortTimer(Ee.FIVE_SECONDS),
            s = await fetch(`${this.verifyUrlV3}/public-key`, {
              signal: this.abortController.signal,
            });
          return clearTimeout(i), await s.json();
        } catch (i) {
          this.logger.warn(i);
        }
      }),
      Wn(this, "persistPublicKey", async (i) => {
        this.logger.debug("persisting public key to local storage", i),
          await this.store.setItem(this.storeKey, i),
          (this.publicKey = i);
      }),
      Wn(this, "removePublicKey", async () => {
        this.logger.debug("removing verify v2 public key from storage"),
          await this.store.removeItem(this.storeKey),
          (this.publicKey = void 0);
      }),
      Wn(this, "isValidJwtAttestation", async (i) => {
        const s = await this.getPublicKey();
        try {
          if (s) return this.validateAttestation(i, s);
        } catch (a) {
          this.logger.error(a),
            this.logger.warn("error validating attestation");
        }
        const o = await this.fetchAndPersistPublicKey();
        try {
          if (o) return this.validateAttestation(i, o);
        } catch (a) {
          this.logger.error(a),
            this.logger.warn("error validating attestation");
        }
      }),
      Wn(this, "getPublicKey", async () =>
        this.publicKey ? this.publicKey : await this.fetchAndPersistPublicKey()
      ),
      Wn(this, "fetchAndPersistPublicKey", async () => {
        if (this.fetchPromise) return await this.fetchPromise, this.publicKey;
        this.fetchPromise = new Promise(async (s) => {
          const o = await this.fetchPublicKey();
          o && (await this.persistPublicKey(o), s(o));
        });
        const i = await this.fetchPromise;
        return (this.fetchPromise = void 0), i;
      }),
      Wn(this, "validateAttestation", (i, s) => {
        const o = Xne(i, s.publicKey),
          a = { hasExpired: Ee.toMiliseconds(o.exp) < Date.now(), payload: o };
        if (a.hasExpired)
          throw (
            (this.logger.warn("resolve: jwt attestation expired"),
            new Error("JWT attestation expired"))
          );
        return {
          origin: a.payload.origin,
          isScam: a.payload.isScam,
          isVerified: a.payload.isVerified,
        };
      }),
      (this.logger = Gr(n, this.name)),
      (this.abortController = new AbortController()),
      (this.isDevEnv = AA()),
      this.init();
  }
  get storeKey() {
    return (
      this.storagePrefix +
      this.version +
      this.core.customStoragePrefix +
      "//verify:public:key"
    );
  }
  get context() {
    return Ti(this.logger);
  }
  startAbortTimer(e) {
    return (
      (this.abortController = new AbortController()),
      setTimeout(() => this.abortController.abort(), Ee.toMiliseconds(e))
    );
  }
}
var kae = Object.defineProperty,
  Dae = (t, e, n) =>
    e in t
      ? kae(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n })
      : (t[e] = n),
  rO = (t, e, n) => Dae(t, typeof e != "symbol" ? e + "" : e, n);
class $ae extends mK {
  constructor(e, n) {
    super(e, n),
      (this.projectId = e),
      (this.logger = n),
      rO(this, "context", $ie),
      rO(this, "registerDeviceToken", async (r) => {
        const {
            clientId: i,
            token: s,
            notificationType: o,
            enableEncrypted: a = !1,
          } = r,
          l = `${Mie}/${this.projectId}/clients`;
        await fetch(l, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            client_id: i,
            type: o,
            token: s,
            always_raw: a,
          }),
        });
      }),
      (this.logger = Gr(n, this.context));
  }
}
var Mae = Object.defineProperty,
  iO = Object.getOwnPropertySymbols,
  Lae = Object.prototype.hasOwnProperty,
  Uae = Object.prototype.propertyIsEnumerable,
  Vx = (t, e, n) =>
    e in t
      ? Mae(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n })
      : (t[e] = n),
  Vf = (t, e) => {
    for (var n in e || (e = {})) Lae.call(e, n) && Vx(t, n, e[n]);
    if (iO) for (var n of iO(e)) Uae.call(e, n) && Vx(t, n, e[n]);
    return t;
  },
  cr = (t, e, n) => Vx(t, typeof e != "symbol" ? e + "" : e, n);
class Bae extends gK {
  constructor(e, n, r = !0) {
    super(e, n, r),
      (this.core = e),
      (this.logger = n),
      cr(this, "context", Uie),
      cr(this, "storagePrefix", Oo),
      cr(this, "storageVersion", Lie),
      cr(this, "events", new Map()),
      cr(this, "shouldPersist", !1),
      cr(this, "init", async () => {
        if (!AA())
          try {
            const i = {
              eventId: qR(),
              timestamp: Date.now(),
              domain: this.getAppDomain(),
              props: {
                event: "INIT",
                type: "",
                properties: {
                  client_id: await this.core.crypto.getClientId(),
                  user_agent: d$(
                    this.core.relayer.protocol,
                    this.core.relayer.version,
                    Ux
                  ),
                },
              },
            };
            await this.sendEvent([i]);
          } catch (i) {
            this.logger.warn(i);
          }
      }),
      cr(this, "createEvent", (i) => {
        const {
            event: s = "ERROR",
            type: o = "",
            properties: { topic: a, trace: l },
          } = i,
          d = qR(),
          p = this.core.projectId || "",
          f = Date.now(),
          m = Vf(
            {
              eventId: d,
              timestamp: f,
              props: { event: s, type: o, properties: { topic: a, trace: l } },
              bundleId: p,
              domain: this.getAppDomain(),
            },
            this.setMethods(d)
          );
        return (
          this.telemetryEnabled &&
            (this.events.set(d, m), (this.shouldPersist = !0)),
          m
        );
      }),
      cr(this, "getEvent", (i) => {
        const { eventId: s, topic: o } = i;
        if (s) return this.events.get(s);
        const a = Array.from(this.events.values()).find(
          (l) => l.props.properties.topic === o
        );
        if (a) return Vf(Vf({}, a), this.setMethods(a.eventId));
      }),
      cr(this, "deleteEvent", (i) => {
        const { eventId: s } = i;
        this.events.delete(s), (this.shouldPersist = !0);
      }),
      cr(this, "setEventListeners", () => {
        this.core.heartbeat.on(Ap.pulse, async () => {
          this.shouldPersist && (await this.persist()),
            this.events.forEach((i) => {
              Ee.fromMiliseconds(Date.now()) - Ee.fromMiliseconds(i.timestamp) >
                Bie &&
                (this.events.delete(i.eventId), (this.shouldPersist = !0));
            });
        });
      }),
      cr(this, "setMethods", (i) => ({
        addTrace: (s) => this.addTrace(i, s),
        setError: (s) => this.setError(i, s),
      })),
      cr(this, "addTrace", (i, s) => {
        const o = this.events.get(i);
        o &&
          (o.props.properties.trace.push(s),
          this.events.set(i, o),
          (this.shouldPersist = !0));
      }),
      cr(this, "setError", (i, s) => {
        const o = this.events.get(i);
        o &&
          ((o.props.type = s),
          (o.timestamp = Date.now()),
          this.events.set(i, o),
          (this.shouldPersist = !0));
      }),
      cr(this, "persist", async () => {
        await this.core.storage.setItem(
          this.storageKey,
          Array.from(this.events.values())
        ),
          (this.shouldPersist = !1);
      }),
      cr(this, "restore", async () => {
        try {
          const i = (await this.core.storage.getItem(this.storageKey)) || [];
          if (!i.length) return;
          i.forEach((s) => {
            this.events.set(
              s.eventId,
              Vf(Vf({}, s), this.setMethods(s.eventId))
            );
          });
        } catch (i) {
          this.logger.warn(i);
        }
      }),
      cr(this, "submit", async () => {
        if (!this.telemetryEnabled || this.events.size === 0) return;
        const i = [];
        for (const [s, o] of this.events) o.props.type && i.push(o);
        if (i.length !== 0)
          try {
            if ((await this.sendEvent(i)).ok)
              for (const s of i)
                this.events.delete(s.eventId), (this.shouldPersist = !0);
          } catch (s) {
            this.logger.warn(s);
          }
      }),
      cr(this, "sendEvent", async (i) => {
        const s = this.getAppDomain() ? "" : "&sp=desktop";
        return await fetch(
          `${jie}?projectId=${this.core.projectId}&st=events_sdk&sv=js-${Ux}${s}`,
          { method: "POST", body: JSON.stringify(i) }
        );
      }),
      cr(this, "getAppDomain", () => u$().url),
      (this.logger = Gr(n, this.context)),
      (this.telemetryEnabled = r),
      r
        ? this.restore().then(async () => {
            await this.submit(), this.setEventListeners();
          })
        : this.persist();
  }
  get storageKey() {
    return (
      this.storagePrefix +
      this.storageVersion +
      this.core.customStoragePrefix +
      "//" +
      this.context
    );
  }
}
var jae = Object.defineProperty,
  sO = Object.getOwnPropertySymbols,
  Fae = Object.prototype.hasOwnProperty,
  zae = Object.prototype.propertyIsEnumerable,
  Gx = (t, e, n) =>
    e in t
      ? jae(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n })
      : (t[e] = n),
  oO = (t, e) => {
    for (var n in e || (e = {})) Fae.call(e, n) && Gx(t, n, e[n]);
    if (sO) for (var n of sO(e)) zae.call(e, n) && Gx(t, n, e[n]);
    return t;
  },
  rn = (t, e, n) => Gx(t, typeof e != "symbol" ? e + "" : e, n);
let Wae = class mM extends rK {
  constructor(e) {
    var n;
    super(e),
      rn(this, "protocol", eM),
      rn(this, "version", tM),
      rn(this, "name", ww),
      rn(this, "relayUrl"),
      rn(this, "projectId"),
      rn(this, "customStoragePrefix"),
      rn(this, "events", new Ss.EventEmitter()),
      rn(this, "logger"),
      rn(this, "heartbeat"),
      rn(this, "relayer"),
      rn(this, "crypto"),
      rn(this, "storage"),
      rn(this, "history"),
      rn(this, "expirer"),
      rn(this, "pairing"),
      rn(this, "verify"),
      rn(this, "echoClient"),
      rn(this, "linkModeSupportedApps"),
      rn(this, "eventClient"),
      rn(this, "initialized", !1),
      rn(this, "logChunkController"),
      rn(this, "on", (a, l) => this.events.on(a, l)),
      rn(this, "once", (a, l) => this.events.once(a, l)),
      rn(this, "off", (a, l) => this.events.off(a, l)),
      rn(this, "removeListener", (a, l) => this.events.removeListener(a, l)),
      rn(
        this,
        "dispatchEnvelope",
        ({ topic: a, message: l, sessionExists: d }) => {
          if (!a || !l) return;
          const p = {
            topic: a,
            message: l,
            publishedAt: Date.now(),
            transportType: dn.link_mode,
          };
          this.relayer.onLinkMessageEvent(p, { sessionExists: d });
        }
      );
    const r = this.getGlobalCore(e == null ? void 0 : e.customStoragePrefix);
    if (r)
      try {
        return (
          (this.customStoragePrefix = r.customStoragePrefix),
          (this.logger = r.logger),
          (this.heartbeat = r.heartbeat),
          (this.crypto = r.crypto),
          (this.history = r.history),
          (this.expirer = r.expirer),
          (this.storage = r.storage),
          (this.relayer = r.relayer),
          (this.pairing = r.pairing),
          (this.verify = r.verify),
          (this.echoClient = r.echoClient),
          (this.linkModeSupportedApps = r.linkModeSupportedApps),
          (this.eventClient = r.eventClient),
          (this.initialized = r.initialized),
          (this.logChunkController = r.logChunkController),
          r
        );
      } catch (a) {
        console.warn("Failed to copy global core", a);
      }
    (this.projectId = e == null ? void 0 : e.projectId),
      (this.relayUrl = (e == null ? void 0 : e.relayUrl) || rM),
      (this.customStoragePrefix =
        e != null && e.customStoragePrefix ? `:${e.customStoragePrefix}` : "");
    const i = _p({
        level:
          typeof (e == null ? void 0 : e.logger) == "string" && e.logger
            ? e.logger
            : cie.logger,
        name: ww,
      }),
      { logger: s, chunkLoggerController: o } = yA({
        opts: i,
        maxSizeInBytes: e == null ? void 0 : e.maxLogBlobSizeInBytes,
        loggerOverride: e == null ? void 0 : e.logger,
      });
    (this.logChunkController = o),
      (n = this.logChunkController) != null &&
        n.downloadLogsBlobInBrowser &&
        (window.downloadLogsBlobInBrowser = async () => {
          var a, l;
          (a = this.logChunkController) != null &&
            a.downloadLogsBlobInBrowser &&
            ((l = this.logChunkController) == null ||
              l.downloadLogsBlobInBrowser({
                clientId: await this.crypto.getClientId(),
              }));
        }),
      (this.logger = Gr(s, this.name)),
      (this.heartbeat = new iG()),
      (this.crypto = new goe(
        this,
        this.logger,
        e == null ? void 0 : e.keychain
      )),
      (this.history = new _ae(this, this.logger)),
      (this.expirer = new Pae(this, this.logger)),
      (this.storage =
        e != null && e.storage
          ? e.storage
          : new UG(oO(oO({}, lie), e == null ? void 0 : e.storageOptions))),
      (this.relayer = new Woe({
        core: this,
        logger: this.logger,
        relayUrl: this.relayUrl,
        projectId: this.projectId,
      })),
      (this.pairing = new xae(this, this.logger)),
      (this.verify = new Oae(this, this.logger, this.storage)),
      (this.echoClient = new $ae(this.projectId || "", this.logger)),
      (this.linkModeSupportedApps = []),
      (this.eventClient = new Bae(
        this,
        this.logger,
        e == null ? void 0 : e.telemetryEnabled
      )),
      this.setGlobalCore(this);
  }
  static async init(e) {
    const n = new mM(e);
    await n.initialize();
    const r = await n.crypto.getClientId();
    return await n.storage.setItem(Cie, r), n;
  }
  get context() {
    return Ti(this.logger);
  }
  async start() {
    this.initialized || (await this.initialize());
  }
  async getLogsBlob() {
    var e;
    return (e = this.logChunkController) == null
      ? void 0
      : e.logsToBlob({ clientId: await this.crypto.getClientId() });
  }
  async addLinkModeSupportedApp(e) {
    this.linkModeSupportedApps.includes(e) ||
      (this.linkModeSupportedApps.push(e),
      await this.storage.setItem(BN, this.linkModeSupportedApps));
  }
  async initialize() {
    this.logger.trace("Initialized");
    try {
      await this.crypto.init(),
        await this.history.init(),
        await this.expirer.init(),
        await this.relayer.init(),
        await this.heartbeat.init(),
        await this.pairing.init(),
        (this.linkModeSupportedApps = (await this.storage.getItem(BN)) || []),
        (this.initialized = !0),
        this.logger.info("Core Initialization Success");
    } catch (e) {
      throw (
        (this.logger.warn(
          `Core Initialization Failure at epoch ${Date.now()}`,
          e
        ),
        this.logger.error(e.message),
        e)
      );
    }
  }
  getGlobalCore(e = "") {
    try {
      if (this.isGlobalCoreDisabled()) return;
      const n = `_walletConnectCore_${e}`,
        r = `${n}_count`;
      return (
        (globalThis[r] = (globalThis[r] || 0) + 1),
        globalThis[r] > 1 &&
          console.warn(
            `WalletConnect Core is already initialized. This is probably a mistake and can lead to unexpected behavior. Init() was called ${globalThis[r]} times.`
          ),
        globalThis[n]
      );
    } catch (n) {
      console.warn("Failed to get global WalletConnect core", n);
      return;
    }
  }
  setGlobalCore(e) {
    var n;
    try {
      if (this.isGlobalCoreDisabled()) return;
      const r = `_walletConnectCore_${
        ((n = e.opts) == null ? void 0 : n.customStoragePrefix) || ""
      }`;
      globalThis[r] = e;
    } catch (r) {
      console.warn("Failed to set global WalletConnect core", r);
    }
  }
  isGlobalCoreDisabled() {
    try {
      return typeof process < "u" && aie.DISABLE_GLOBAL_CORE === "true";
    } catch {
      return !0;
    }
  }
};
const Hae = Wae,
  gM = "wc",
  yM = 2,
  wM = "client",
  MA = `${gM}@${yM}:${wM}:`,
  ZE = {
    name: wM,
    logger: "error",
    controller: !1,
    relayUrl: "wss://relay.walletconnect.org",
  },
  aO = "WALLETCONNECT_DEEPLINK_CHOICE",
  qae = "proposal",
  cO = "Proposal expired",
  Vae = "session",
  Ju = Ee.SEVEN_DAYS,
  Gae = "engine",
  lr = {
    wc_sessionPropose: {
      req: { ttl: Ee.FIVE_MINUTES, prompt: !0, tag: 1100 },
      res: { ttl: Ee.FIVE_MINUTES, prompt: !1, tag: 1101 },
      reject: { ttl: Ee.FIVE_MINUTES, prompt: !1, tag: 1120 },
      autoReject: { ttl: Ee.FIVE_MINUTES, prompt: !1, tag: 1121 },
    },
    wc_sessionSettle: {
      req: { ttl: Ee.FIVE_MINUTES, prompt: !1, tag: 1102 },
      res: { ttl: Ee.FIVE_MINUTES, prompt: !1, tag: 1103 },
    },
    wc_sessionUpdate: {
      req: { ttl: Ee.ONE_DAY, prompt: !1, tag: 1104 },
      res: { ttl: Ee.ONE_DAY, prompt: !1, tag: 1105 },
    },
    wc_sessionExtend: {
      req: { ttl: Ee.ONE_DAY, prompt: !1, tag: 1106 },
      res: { ttl: Ee.ONE_DAY, prompt: !1, tag: 1107 },
    },
    wc_sessionRequest: {
      req: { ttl: Ee.FIVE_MINUTES, prompt: !0, tag: 1108 },
      res: { ttl: Ee.FIVE_MINUTES, prompt: !1, tag: 1109 },
    },
    wc_sessionEvent: {
      req: { ttl: Ee.FIVE_MINUTES, prompt: !0, tag: 1110 },
      res: { ttl: Ee.FIVE_MINUTES, prompt: !1, tag: 1111 },
    },
    wc_sessionDelete: {
      req: { ttl: Ee.ONE_DAY, prompt: !1, tag: 1112 },
      res: { ttl: Ee.ONE_DAY, prompt: !1, tag: 1113 },
    },
    wc_sessionPing: {
      req: { ttl: Ee.ONE_DAY, prompt: !1, tag: 1114 },
      res: { ttl: Ee.ONE_DAY, prompt: !1, tag: 1115 },
    },
    wc_sessionAuthenticate: {
      req: { ttl: Ee.ONE_HOUR, prompt: !0, tag: 1116 },
      res: { ttl: Ee.ONE_HOUR, prompt: !1, tag: 1117 },
      reject: { ttl: Ee.FIVE_MINUTES, prompt: !1, tag: 1118 },
      autoReject: { ttl: Ee.FIVE_MINUTES, prompt: !1, tag: 1119 },
    },
  },
  QE = { min: Ee.FIVE_MINUTES, max: Ee.SEVEN_DAYS },
  fo = { idle: "IDLE", active: "ACTIVE" },
  lO = {
    eth_sendTransaction: { key: "" },
    eth_sendRawTransaction: { key: "" },
    wallet_sendCalls: { key: "" },
    solana_signTransaction: { key: "signature" },
    solana_signAllTransactions: { key: "transactions" },
    solana_signAndSendTransaction: { key: "signature" },
  },
  Kae = "request",
  Yae = [
    "wc_sessionPropose",
    "wc_sessionRequest",
    "wc_authRequest",
    "wc_sessionAuthenticate",
  ],
  Zae = "wc",
  Qae = "auth",
  Xae = "authKeys",
  Jae = "pairingTopics",
  ece = "requests",
  Ov = `${Zae}@${1.5}:${Qae}:`,
  B0 = `${Ov}:PUB_KEY`;
var tce = Object.defineProperty,
  nce = Object.defineProperties,
  rce = Object.getOwnPropertyDescriptors,
  uO = Object.getOwnPropertySymbols,
  ice = Object.prototype.hasOwnProperty,
  sce = Object.prototype.propertyIsEnumerable,
  Kx = (t, e, n) =>
    e in t
      ? tce(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n })
      : (t[e] = n),
  en = (t, e) => {
    for (var n in e || (e = {})) ice.call(e, n) && Kx(t, n, e[n]);
    if (uO) for (var n of uO(e)) sce.call(e, n) && Kx(t, n, e[n]);
    return t;
  },
  Xr = (t, e) => nce(t, rce(e)),
  pe = (t, e, n) => Kx(t, typeof e != "symbol" ? e + "" : e, n);
class oce extends bK {
  constructor(e) {
    super(e),
      pe(this, "name", Gae),
      pe(this, "events", new mA()),
      pe(this, "initialized", !1),
      pe(this, "requestQueue", { state: fo.idle, queue: [] }),
      pe(this, "sessionRequestQueue", { state: fo.idle, queue: [] }),
      pe(this, "requestQueueDelay", Ee.ONE_SECOND),
      pe(this, "expectedPairingMethodMap", new Map()),
      pe(this, "recentlyDeletedMap", new Map()),
      pe(this, "recentlyDeletedLimit", 200),
      pe(this, "relayMessageCache", []),
      pe(this, "pendingSessions", new Map()),
      pe(this, "init", async () => {
        this.initialized ||
          (await this.cleanup(),
          this.registerRelayerEvents(),
          this.registerExpirerEvents(),
          this.registerPairingEvents(),
          await this.registerLinkModeListeners(),
          this.client.core.pairing.register({ methods: Object.keys(lr) }),
          (this.initialized = !0),
          setTimeout(async () => {
            await this.processPendingMessageEvents(),
              (this.sessionRequestQueue.queue =
                this.getPendingSessionRequests()),
              this.processSessionRequestQueue();
          }, Ee.toMiliseconds(this.requestQueueDelay)));
      }),
      pe(this, "connect", async (n) => {
        this.isInitialized(), await this.confirmOnlineStateOrThrow();
        const r = Xr(en({}, n), {
          requiredNamespaces: n.requiredNamespaces || {},
          optionalNamespaces: n.optionalNamespaces || {},
        });
        await this.isValidConnect(r);
        const {
          pairingTopic: i,
          requiredNamespaces: s,
          optionalNamespaces: o,
          sessionProperties: a,
          scopedProperties: l,
          relays: d,
        } = r;
        let p = i,
          f,
          m = !1;
        try {
          if (p) {
            const I = this.client.core.pairing.pairings.get(p);
            this.client.logger.warn(
              "connect() with existing pairing topic is deprecated and will be removed in the next major release."
            ),
              (m = I.active);
          }
        } catch (I) {
          throw (
            (this.client.logger.error(`connect() -> pairing.get(${p}) failed`),
            I)
          );
        }
        if (!p || !m) {
          const { topic: I, uri: R } = await this.client.core.pairing.create();
          (p = I), (f = R);
        }
        if (!p) {
          const { message: I } = xe(
            "NO_MATCHING_KEY",
            `connect() pairing topic: ${p}`
          );
          throw new Error(I);
        }
        const y = await this.client.core.crypto.generateKeyPair(),
          g = lr.wc_sessionPropose.req.ttl || Ee.FIVE_MINUTES,
          v = Zn(g),
          b = Xr(
            en(
              en(
                {
                  requiredNamespaces: s,
                  optionalNamespaces: o,
                  relays: d ?? [{ protocol: nM }],
                  proposer: { publicKey: y, metadata: this.client.metadata },
                  expiryTimestamp: v,
                  pairingTopic: p,
                },
                a && { sessionProperties: a }
              ),
              l && { scopedProperties: l }
            ),
            { id: go() }
          ),
          E = jt("session_connect", b.id),
          { reject: S, resolve: C, done: _ } = vl(g, cO),
          A = ({ id: I }) => {
            I === b.id &&
              (this.client.events.off("proposal_expire", A),
              this.pendingSessions.delete(b.id),
              this.events.emit(E, { error: { message: cO, code: 0 } }));
          };
        return (
          this.client.events.on("proposal_expire", A),
          this.events.once(E, ({ error: I, session: R }) => {
            this.client.events.off("proposal_expire", A), I ? S(I) : R && C(R);
          }),
          await this.sendRequest({
            topic: p,
            method: "wc_sessionPropose",
            params: b,
            throwOnFailedPublish: !0,
            clientRpcId: b.id,
          }),
          await this.setProposal(b.id, b),
          { uri: f, approval: _ }
        );
      }),
      pe(this, "pair", async (n) => {
        this.isInitialized(), await this.confirmOnlineStateOrThrow();
        try {
          return await this.client.core.pairing.pair(n);
        } catch (r) {
          throw (this.client.logger.error("pair() failed"), r);
        }
      }),
      pe(this, "approve", async (n) => {
        var r, i, s;
        const o = this.client.core.eventClient.createEvent({
          properties: {
            topic:
              (r = n == null ? void 0 : n.id) == null ? void 0 : r.toString(),
            trace: [Ls.session_approve_started],
          },
        });
        try {
          this.isInitialized(), await this.confirmOnlineStateOrThrow();
        } catch (k) {
          throw (o.setError(pl.no_internet_connection), k);
        }
        try {
          await this.isValidProposalId(n == null ? void 0 : n.id);
        } catch (k) {
          throw (
            (this.client.logger.error(
              `approve() -> proposal.get(${n == null ? void 0 : n.id}) failed`
            ),
            o.setError(pl.proposal_not_found),
            k)
          );
        }
        try {
          await this.isValidApprove(n);
        } catch (k) {
          throw (
            (this.client.logger.error("approve() -> isValidApprove() failed"),
            o.setError(pl.session_approve_namespace_validation_failure),
            k)
          );
        }
        const {
            id: a,
            relayProtocol: l,
            namespaces: d,
            sessionProperties: p,
            scopedProperties: f,
            sessionConfig: m,
          } = n,
          y = this.client.proposal.get(a);
        this.client.core.eventClient.deleteEvent({ eventId: o.eventId });
        const {
          pairingTopic: g,
          proposer: v,
          requiredNamespaces: b,
          optionalNamespaces: E,
        } = y;
        let S =
          (i = this.client.core.eventClient) == null
            ? void 0
            : i.getEvent({ topic: g });
        S ||
          (S =
            (s = this.client.core.eventClient) == null
              ? void 0
              : s.createEvent({
                  type: Ls.session_approve_started,
                  properties: {
                    topic: g,
                    trace: [
                      Ls.session_approve_started,
                      Ls.session_namespaces_validation_success,
                    ],
                  },
                }));
        const C = await this.client.core.crypto.generateKeyPair(),
          _ = v.publicKey,
          A = await this.client.core.crypto.generateSharedKey(C, _),
          I = en(
            en(
              en(
                {
                  relay: { protocol: l ?? "irn" },
                  namespaces: d,
                  controller: { publicKey: C, metadata: this.client.metadata },
                  expiry: Zn(Ju),
                },
                p && { sessionProperties: p }
              ),
              f && { scopedProperties: f }
            ),
            m && { sessionConfig: m }
          ),
          R = dn.relay;
        S.addTrace(Ls.subscribing_session_topic);
        try {
          await this.client.core.relayer.subscribe(A, { transportType: R });
        } catch (k) {
          throw (S.setError(pl.subscribe_session_topic_failure), k);
        }
        S.addTrace(Ls.subscribe_session_topic_success);
        const D = Xr(en({}, I), {
          topic: A,
          requiredNamespaces: b,
          optionalNamespaces: E,
          pairingTopic: g,
          acknowledged: !1,
          self: I.controller,
          peer: { publicKey: v.publicKey, metadata: v.metadata },
          controller: C,
          transportType: dn.relay,
        });
        await this.client.session.set(A, D), S.addTrace(Ls.store_session);
        try {
          S.addTrace(Ls.publishing_session_settle),
            await this.sendRequest({
              topic: A,
              method: "wc_sessionSettle",
              params: I,
              throwOnFailedPublish: !0,
            }).catch((k) => {
              throw (
                (S == null || S.setError(pl.session_settle_publish_failure), k)
              );
            }),
            S.addTrace(Ls.session_settle_publish_success),
            S.addTrace(Ls.publishing_session_approve),
            await this.sendResult({
              id: a,
              topic: g,
              result: {
                relay: { protocol: l ?? "irn" },
                responderPublicKey: C,
              },
              throwOnFailedPublish: !0,
            }).catch((k) => {
              throw (
                (S == null || S.setError(pl.session_approve_publish_failure), k)
              );
            }),
            S.addTrace(Ls.session_approve_publish_success);
        } catch (k) {
          throw (
            (this.client.logger.error(k),
            this.client.session.delete(A, Kt("USER_DISCONNECTED")),
            await this.client.core.relayer.unsubscribe(A),
            k)
          );
        }
        return (
          this.client.core.eventClient.deleteEvent({ eventId: S.eventId }),
          await this.client.core.pairing.updateMetadata({
            topic: g,
            metadata: v.metadata,
          }),
          await this.client.proposal.delete(a, Kt("USER_DISCONNECTED")),
          await this.client.core.pairing.activate({ topic: g }),
          await this.setExpiry(A, Zn(Ju)),
          {
            topic: A,
            acknowledged: () => Promise.resolve(this.client.session.get(A)),
          }
        );
      }),
      pe(this, "reject", async (n) => {
        this.isInitialized(), await this.confirmOnlineStateOrThrow();
        try {
          await this.isValidReject(n);
        } catch (o) {
          throw (
            (this.client.logger.error("reject() -> isValidReject() failed"), o)
          );
        }
        const { id: r, reason: i } = n;
        let s;
        try {
          s = this.client.proposal.get(r).pairingTopic;
        } catch (o) {
          throw (
            (this.client.logger.error(`reject() -> proposal.get(${r}) failed`),
            o)
          );
        }
        s &&
          (await this.sendError({
            id: r,
            topic: s,
            error: i,
            rpcOpts: lr.wc_sessionPropose.reject,
          }),
          await this.client.proposal.delete(r, Kt("USER_DISCONNECTED")));
      }),
      pe(this, "update", async (n) => {
        this.isInitialized(), await this.confirmOnlineStateOrThrow();
        try {
          await this.isValidUpdate(n);
        } catch (f) {
          throw (
            (this.client.logger.error("update() -> isValidUpdate() failed"), f)
          );
        }
        const { topic: r, namespaces: i } = n,
          { done: s, resolve: o, reject: a } = vl(),
          l = go(),
          d = Rl().toString(),
          p = this.client.session.get(r).namespaces;
        return (
          this.events.once(jt("session_update", l), ({ error: f }) => {
            f ? a(f) : o();
          }),
          await this.client.session.update(r, { namespaces: i }),
          await this.sendRequest({
            topic: r,
            method: "wc_sessionUpdate",
            params: { namespaces: i },
            throwOnFailedPublish: !0,
            clientRpcId: l,
            relayRpcId: d,
          }).catch((f) => {
            this.client.logger.error(f),
              this.client.session.update(r, { namespaces: p }),
              a(f);
          }),
          { acknowledged: s }
        );
      }),
      pe(this, "extend", async (n) => {
        this.isInitialized(), await this.confirmOnlineStateOrThrow();
        try {
          await this.isValidExtend(n);
        } catch (l) {
          throw (
            (this.client.logger.error("extend() -> isValidExtend() failed"), l)
          );
        }
        const { topic: r } = n,
          i = go(),
          { done: s, resolve: o, reject: a } = vl();
        return (
          this.events.once(jt("session_extend", i), ({ error: l }) => {
            l ? a(l) : o();
          }),
          await this.setExpiry(r, Zn(Ju)),
          this.sendRequest({
            topic: r,
            method: "wc_sessionExtend",
            params: {},
            clientRpcId: i,
            throwOnFailedPublish: !0,
          }).catch((l) => {
            a(l);
          }),
          { acknowledged: s }
        );
      }),
      pe(this, "request", async (n) => {
        this.isInitialized();
        try {
          await this.isValidRequest(n);
        } catch (E) {
          throw (
            (this.client.logger.error("request() -> isValidRequest() failed"),
            E)
          );
        }
        const {
            chainId: r,
            request: i,
            topic: s,
            expiry: o = lr.wc_sessionRequest.req.ttl,
          } = n,
          a = this.client.session.get(s);
        (a == null ? void 0 : a.transportType) === dn.relay &&
          (await this.confirmOnlineStateOrThrow());
        const l = go(),
          d = Rl().toString(),
          {
            done: p,
            resolve: f,
            reject: m,
          } = vl(o, "Request expired. Please try again.");
        this.events.once(
          jt("session_request", l),
          ({ error: E, result: S }) => {
            E ? m(E) : f(S);
          }
        );
        const y = "wc_sessionRequest",
          g = this.getAppLinkIfEnabled(a.peer.metadata, a.transportType);
        if (g)
          return (
            await this.sendRequest({
              clientRpcId: l,
              relayRpcId: d,
              topic: s,
              method: y,
              params: {
                request: Xr(en({}, i), { expiryTimestamp: Zn(o) }),
                chainId: r,
              },
              expiry: o,
              throwOnFailedPublish: !0,
              appLink: g,
            }).catch((E) => m(E)),
            this.client.events.emit("session_request_sent", {
              topic: s,
              request: i,
              chainId: r,
              id: l,
            }),
            await p()
          );
        const v = {
            request: Xr(en({}, i), { expiryTimestamp: Zn(o) }),
            chainId: r,
          },
          b = this.shouldSetTVF(y, v);
        return await Promise.all([
          new Promise(async (E) => {
            await this.sendRequest(
              en(
                {
                  clientRpcId: l,
                  relayRpcId: d,
                  topic: s,
                  method: y,
                  params: v,
                  expiry: o,
                  throwOnFailedPublish: !0,
                },
                b && { tvf: this.getTVFParams(l, v) }
              )
            ).catch((S) => m(S)),
              this.client.events.emit("session_request_sent", {
                topic: s,
                request: i,
                chainId: r,
                id: l,
              }),
              E();
          }),
          new Promise(async (E) => {
            var S;
            if (!((S = a.sessionConfig) != null && S.disableDeepLink)) {
              const C = await Iee(this.client.core.storage, aO);
              await See({ id: l, topic: s, wcDeepLink: C });
            }
            E();
          }),
          p(),
        ]).then((E) => E[2]);
      }),
      pe(this, "respond", async (n) => {
        this.isInitialized(), await this.isValidRespond(n);
        const { topic: r, response: i } = n,
          { id: s } = i,
          o = this.client.session.get(r);
        o.transportType === dn.relay &&
          (await this.confirmOnlineStateOrThrow());
        const a = this.getAppLinkIfEnabled(o.peer.metadata, o.transportType);
        yo(i)
          ? await this.sendResult({
              id: s,
              topic: r,
              result: i.result,
              throwOnFailedPublish: !0,
              appLink: a,
            })
          : ls(i) &&
            (await this.sendError({
              id: s,
              topic: r,
              error: i.error,
              appLink: a,
            })),
          this.cleanupAfterResponse(n);
      }),
      pe(this, "ping", async (n) => {
        this.isInitialized(), await this.confirmOnlineStateOrThrow();
        try {
          await this.isValidPing(n);
        } catch (i) {
          throw (this.client.logger.error("ping() -> isValidPing() failed"), i);
        }
        const { topic: r } = n;
        if (this.client.session.keys.includes(r)) {
          const i = go(),
            s = Rl().toString(),
            { done: o, resolve: a, reject: l } = vl();
          this.events.once(jt("session_ping", i), ({ error: d }) => {
            d ? l(d) : a();
          }),
            await Promise.all([
              this.sendRequest({
                topic: r,
                method: "wc_sessionPing",
                params: {},
                throwOnFailedPublish: !0,
                clientRpcId: i,
                relayRpcId: s,
              }),
              o(),
            ]);
        } else
          this.client.core.pairing.pairings.keys.includes(r) &&
            (this.client.logger.warn(
              "ping() on pairing topic is deprecated and will be removed in the next major release."
            ),
            await this.client.core.pairing.ping({ topic: r }));
      }),
      pe(this, "emit", async (n) => {
        this.isInitialized(),
          await this.confirmOnlineStateOrThrow(),
          await this.isValidEmit(n);
        const { topic: r, event: i, chainId: s } = n,
          o = Rl().toString(),
          a = go();
        await this.sendRequest({
          topic: r,
          method: "wc_sessionEvent",
          params: { event: i, chainId: s },
          throwOnFailedPublish: !0,
          relayRpcId: o,
          clientRpcId: a,
        });
      }),
      pe(this, "disconnect", async (n) => {
        this.isInitialized(),
          await this.confirmOnlineStateOrThrow(),
          await this.isValidDisconnect(n);
        const { topic: r } = n;
        if (this.client.session.keys.includes(r))
          await this.sendRequest({
            topic: r,
            method: "wc_sessionDelete",
            params: Kt("USER_DISCONNECTED"),
            throwOnFailedPublish: !0,
          }),
            await this.deleteSession({ topic: r, emitEvent: !1 });
        else if (this.client.core.pairing.pairings.keys.includes(r))
          await this.client.core.pairing.disconnect({ topic: r });
        else {
          const { message: i } = xe(
            "MISMATCHED_TOPIC",
            `Session or pairing topic not found: ${r}`
          );
          throw new Error(i);
        }
      }),
      pe(
        this,
        "find",
        (n) => (
          this.isInitialized(),
          this.client.session.getAll().filter((r) => lre(r, n))
        )
      ),
      pe(this, "getPendingSessionRequests", () =>
        this.client.pendingRequest.getAll()
      ),
      pe(this, "authenticate", async (n, r) => {
        var i;
        this.isInitialized(), this.isValidAuthenticate(n);
        const s =
            r &&
            this.client.core.linkModeSupportedApps.includes(r) &&
            ((i = this.client.metadata.redirect) == null ? void 0 : i.linkMode),
          o = s ? dn.link_mode : dn.relay;
        o === dn.relay && (await this.confirmOnlineStateOrThrow());
        const {
            chains: a,
            statement: l = "",
            uri: d,
            domain: p,
            nonce: f,
            type: m,
            exp: y,
            nbf: g,
            methods: v = [],
            expiry: b,
          } = n,
          E = [...(n.resources || [])],
          { topic: S, uri: C } = await this.client.core.pairing.create({
            methods: ["wc_sessionAuthenticate"],
            transportType: o,
          });
        this.client.logger.info({
          message: "Generated new pairing",
          pairing: { topic: S, uri: C },
        });
        const _ = await this.client.core.crypto.generateKeyPair(),
          A = L0(_);
        if (
          (await Promise.all([
            this.client.auth.authKeys.set(B0, {
              responseTopic: A,
              publicKey: _,
            }),
            this.client.auth.pairingTopics.set(A, {
              topic: A,
              pairingTopic: S,
            }),
          ]),
          await this.client.core.relayer.subscribe(A, { transportType: o }),
          this.client.logger.info(`sending request to new pairing topic: ${S}`),
          v.length > 0)
        ) {
          const { namespace: j } = Nd(a[0]);
          let V = vte(j, "request", v);
          M0(E) && (V = Ete(V, E.pop())), E.push(V);
        }
        const I =
            b && b > lr.wc_sessionAuthenticate.req.ttl
              ? b
              : lr.wc_sessionAuthenticate.req.ttl,
          R = {
            authPayload: {
              type: m ?? "caip122",
              chains: a,
              statement: l,
              aud: d,
              domain: p,
              version: "1",
              nonce: f,
              iat: new Date().toISOString(),
              exp: y,
              nbf: g,
              resources: E,
            },
            requester: { publicKey: _, metadata: this.client.metadata },
            expiryTimestamp: Zn(I),
          },
          D = {
            eip155: {
              chains: a,
              methods: [...new Set(["personal_sign", ...v])],
              events: ["chainChanged", "accountsChanged"],
            },
          },
          k = {
            requiredNamespaces: {},
            optionalNamespaces: D,
            relays: [{ protocol: "irn" }],
            pairingTopic: S,
            proposer: { publicKey: _, metadata: this.client.metadata },
            expiryTimestamp: Zn(lr.wc_sessionPropose.req.ttl),
            id: go(),
          },
          { done: T, resolve: U, reject: q } = vl(I, "Request expired"),
          K = go(),
          H = jt("session_connect", k.id),
          $ = jt("session_request", K),
          M = async ({ error: j, session: V }) => {
            this.events.off($, z), j ? q(j) : V && U({ session: V });
          },
          z = async (j) => {
            var V, W, Z;
            if (
              (await this.deletePendingAuthRequest(K, {
                message: "fulfilled",
                code: 0,
              }),
              j.error)
            ) {
              const le = Kt("WC_METHOD_UNSUPPORTED", "wc_sessionAuthenticate");
              return j.error.code === le.code
                ? void 0
                : (this.events.off(H, M), q(j.error.message));
            }
            await this.deleteProposal(k.id), this.events.off(H, M);
            const { cacaos: ee, responder: J } = j.result,
              se = [],
              re = [];
            for (const le of ee) {
              (await JR({
                cacao: le,
                projectId: this.client.core.projectId,
              })) ||
                (this.client.logger.error(le, "Signature verification failed"),
                q(
                  Kt(
                    "SESSION_SETTLEMENT_FAILED",
                    "Signature verification failed"
                  )
                ));
              const { p: Se } = le,
                je = M0(Se.resources),
                Pe = [Tx(Se.iss)],
                We = mw(Se.iss);
              if (je) {
                const Ne = eN(je),
                  pt = tN(je);
                se.push(...Ne), Pe.push(...pt);
              }
              for (const Ne of Pe) re.push(`${Ne}:${We}`);
            }
            const fe = await this.client.core.crypto.generateSharedKey(
              _,
              J.publicKey
            );
            let ce;
            se.length > 0 &&
              ((ce = {
                topic: fe,
                acknowledged: !0,
                self: { publicKey: _, metadata: this.client.metadata },
                peer: J,
                controller: J.publicKey,
                expiry: Zn(Ju),
                requiredNamespaces: {},
                optionalNamespaces: {},
                relay: { protocol: "irn" },
                pairingTopic: S,
                namespaces: xN([...new Set(se)], [...new Set(re)]),
                transportType: o,
              }),
              await this.client.core.relayer.subscribe(fe, {
                transportType: o,
              }),
              await this.client.session.set(fe, ce),
              S &&
                (await this.client.core.pairing.updateMetadata({
                  topic: S,
                  metadata: J.metadata,
                })),
              (ce = this.client.session.get(fe))),
              (V = this.client.metadata.redirect) != null &&
                V.linkMode &&
                (W = J.metadata.redirect) != null &&
                W.linkMode &&
                (Z = J.metadata.redirect) != null &&
                Z.universal &&
                r &&
                (this.client.core.addLinkModeSupportedApp(
                  J.metadata.redirect.universal
                ),
                this.client.session.update(fe, {
                  transportType: dn.link_mode,
                })),
              U({ auths: ee, session: ce });
          };
        this.events.once(H, M), this.events.once($, z);
        let B;
        try {
          if (s) {
            const j = Tc("wc_sessionAuthenticate", R, K);
            this.client.core.history.set(S, j);
            const V = await this.client.core.crypto.encode("", j, {
              type: sg,
              encoding: mc,
            });
            B = e0(r, S, V);
          } else
            await Promise.all([
              this.sendRequest({
                topic: S,
                method: "wc_sessionAuthenticate",
                params: R,
                expiry: n.expiry,
                throwOnFailedPublish: !0,
                clientRpcId: K,
              }),
              this.sendRequest({
                topic: S,
                method: "wc_sessionPropose",
                params: k,
                expiry: lr.wc_sessionPropose.req.ttl,
                throwOnFailedPublish: !0,
                clientRpcId: k.id,
              }),
            ]);
        } catch (j) {
          throw (this.events.off(H, M), this.events.off($, z), j);
        }
        return (
          await this.setProposal(k.id, k),
          await this.setAuthRequest(K, {
            request: Xr(en({}, R), { verifyContext: {} }),
            pairingTopic: S,
            transportType: o,
          }),
          { uri: B ?? C, response: T }
        );
      }),
      pe(this, "approveSessionAuthenticate", async (n) => {
        const { id: r, auths: i } = n,
          s = this.client.core.eventClient.createEvent({
            properties: {
              topic: r.toString(),
              trace: [fl.authenticated_session_approve_started],
            },
          });
        try {
          this.isInitialized();
        } catch (b) {
          throw (s.setError(Hf.no_internet_connection), b);
        }
        const o = this.getPendingAuthRequest(r);
        if (!o)
          throw (
            (s.setError(Hf.authenticated_session_pending_request_not_found),
            new Error(`Could not find pending auth request with id ${r}`))
          );
        const a = o.transportType || dn.relay;
        a === dn.relay && (await this.confirmOnlineStateOrThrow());
        const l = o.requester.publicKey,
          d = await this.client.core.crypto.generateKeyPair(),
          p = L0(l),
          f = { type: wa, receiverPublicKey: l, senderPublicKey: d },
          m = [],
          y = [];
        for (const b of i) {
          if (
            !(await JR({ cacao: b, projectId: this.client.core.projectId }))
          ) {
            s.setError(Hf.invalid_cacao);
            const A = Kt(
              "SESSION_SETTLEMENT_FAILED",
              "Signature verification failed"
            );
            throw (
              (await this.sendError({
                id: r,
                topic: p,
                error: A,
                encodeOpts: f,
              }),
              new Error(A.message))
            );
          }
          s.addTrace(fl.cacaos_verified);
          const { p: E } = b,
            S = M0(E.resources),
            C = [Tx(E.iss)],
            _ = mw(E.iss);
          if (S) {
            const A = eN(S),
              I = tN(S);
            m.push(...A), C.push(...I);
          }
          for (const A of C) y.push(`${A}:${_}`);
        }
        const g = await this.client.core.crypto.generateSharedKey(d, l);
        s.addTrace(fl.create_authenticated_session_topic);
        let v;
        if ((m == null ? void 0 : m.length) > 0) {
          (v = {
            topic: g,
            acknowledged: !0,
            self: { publicKey: d, metadata: this.client.metadata },
            peer: { publicKey: l, metadata: o.requester.metadata },
            controller: l,
            expiry: Zn(Ju),
            authentication: i,
            requiredNamespaces: {},
            optionalNamespaces: {},
            relay: { protocol: "irn" },
            pairingTopic: o.pairingTopic,
            namespaces: xN([...new Set(m)], [...new Set(y)]),
            transportType: a,
          }),
            s.addTrace(fl.subscribing_authenticated_session_topic);
          try {
            await this.client.core.relayer.subscribe(g, { transportType: a });
          } catch (b) {
            throw (
              (s.setError(Hf.subscribe_authenticated_session_topic_failure), b)
            );
          }
          s.addTrace(fl.subscribe_authenticated_session_topic_success),
            await this.client.session.set(g, v),
            s.addTrace(fl.store_authenticated_session),
            await this.client.core.pairing.updateMetadata({
              topic: o.pairingTopic,
              metadata: o.requester.metadata,
            });
        }
        s.addTrace(fl.publishing_authenticated_session_approve);
        try {
          await this.sendResult({
            topic: p,
            id: r,
            result: {
              cacaos: i,
              responder: { publicKey: d, metadata: this.client.metadata },
            },
            encodeOpts: f,
            throwOnFailedPublish: !0,
            appLink: this.getAppLinkIfEnabled(o.requester.metadata, a),
          });
        } catch (b) {
          throw (
            (s.setError(Hf.authenticated_session_approve_publish_failure), b)
          );
        }
        return (
          await this.client.auth.requests.delete(r, {
            message: "fulfilled",
            code: 0,
          }),
          await this.client.core.pairing.activate({ topic: o.pairingTopic }),
          this.client.core.eventClient.deleteEvent({ eventId: s.eventId }),
          { session: v }
        );
      }),
      pe(this, "rejectSessionAuthenticate", async (n) => {
        this.isInitialized();
        const { id: r, reason: i } = n,
          s = this.getPendingAuthRequest(r);
        if (!s)
          throw new Error(`Could not find pending auth request with id ${r}`);
        s.transportType === dn.relay &&
          (await this.confirmOnlineStateOrThrow());
        const o = s.requester.publicKey,
          a = await this.client.core.crypto.generateKeyPair(),
          l = L0(o),
          d = { type: wa, receiverPublicKey: o, senderPublicKey: a };
        await this.sendError({
          id: r,
          topic: l,
          error: i,
          encodeOpts: d,
          rpcOpts: lr.wc_sessionAuthenticate.reject,
          appLink: this.getAppLinkIfEnabled(
            s.requester.metadata,
            s.transportType
          ),
        }),
          await this.client.auth.requests.delete(r, {
            message: "rejected",
            code: 0,
          }),
          await this.client.proposal.delete(r, Kt("USER_DISCONNECTED"));
      }),
      pe(this, "formatAuthMessage", (n) => {
        this.isInitialized();
        const { request: r, iss: i } = n;
        return C$(r, i);
      }),
      pe(this, "processRelayMessageCache", () => {
        setTimeout(async () => {
          if (this.relayMessageCache.length !== 0)
            for (; this.relayMessageCache.length > 0; )
              try {
                const n = this.relayMessageCache.shift();
                n && (await this.onRelayMessage(n));
              } catch (n) {
                this.client.logger.error(n);
              }
        }, 50);
      }),
      pe(this, "cleanupDuplicatePairings", async (n) => {
        if (n.pairingTopic)
          try {
            const r = this.client.core.pairing.pairings.get(n.pairingTopic),
              i = this.client.core.pairing.pairings.getAll().filter((s) => {
                var o, a;
                return (
                  ((o = s.peerMetadata) == null ? void 0 : o.url) &&
                  ((a = s.peerMetadata) == null ? void 0 : a.url) ===
                    n.peer.metadata.url &&
                  s.topic &&
                  s.topic !== r.topic
                );
              });
            if (i.length === 0) return;
            this.client.logger.info(
              `Cleaning up ${i.length} duplicate pairing(s)`
            ),
              await Promise.all(
                i.map((s) =>
                  this.client.core.pairing.disconnect({ topic: s.topic })
                )
              ),
              this.client.logger.info("Duplicate pairings clean up finished");
          } catch (r) {
            this.client.logger.error(r);
          }
      }),
      pe(this, "deleteSession", async (n) => {
        var r;
        const {
            topic: i,
            expirerHasDeleted: s = !1,
            emitEvent: o = !0,
            id: a = 0,
          } = n,
          { self: l } = this.client.session.get(i);
        await this.client.core.relayer.unsubscribe(i),
          await this.client.session.delete(i, Kt("USER_DISCONNECTED")),
          this.addToRecentlyDeleted(i, "session"),
          this.client.core.crypto.keychain.has(l.publicKey) &&
            (await this.client.core.crypto.deleteKeyPair(l.publicKey)),
          this.client.core.crypto.keychain.has(i) &&
            (await this.client.core.crypto.deleteSymKey(i)),
          s || this.client.core.expirer.del(i),
          this.client.core.storage
            .removeItem(aO)
            .catch((d) => this.client.logger.warn(d)),
          this.getPendingSessionRequests().forEach((d) => {
            d.topic === i &&
              this.deletePendingSessionRequest(d.id, Kt("USER_DISCONNECTED"));
          }),
          i ===
            ((r = this.sessionRequestQueue.queue[0]) == null
              ? void 0
              : r.topic) && (this.sessionRequestQueue.state = fo.idle),
          o && this.client.events.emit("session_delete", { id: a, topic: i });
      }),
      pe(this, "deleteProposal", async (n, r) => {
        if (r)
          try {
            const i = this.client.proposal.get(n),
              s = this.client.core.eventClient.getEvent({
                topic: i.pairingTopic,
              });
            s == null || s.setError(pl.proposal_expired);
          } catch {}
        await Promise.all([
          this.client.proposal.delete(n, Kt("USER_DISCONNECTED")),
          r ? Promise.resolve() : this.client.core.expirer.del(n),
        ]),
          this.addToRecentlyDeleted(n, "proposal");
      }),
      pe(this, "deletePendingSessionRequest", async (n, r, i = !1) => {
        await Promise.all([
          this.client.pendingRequest.delete(n, r),
          i ? Promise.resolve() : this.client.core.expirer.del(n),
        ]),
          this.addToRecentlyDeleted(n, "request"),
          (this.sessionRequestQueue.queue =
            this.sessionRequestQueue.queue.filter((s) => s.id !== n)),
          i &&
            ((this.sessionRequestQueue.state = fo.idle),
            this.client.events.emit("session_request_expire", { id: n }));
      }),
      pe(this, "deletePendingAuthRequest", async (n, r, i = !1) => {
        await Promise.all([
          this.client.auth.requests.delete(n, r),
          i ? Promise.resolve() : this.client.core.expirer.del(n),
        ]);
      }),
      pe(this, "setExpiry", async (n, r) => {
        this.client.session.keys.includes(n) &&
          (this.client.core.expirer.set(n, r),
          await this.client.session.update(n, { expiry: r }));
      }),
      pe(this, "setProposal", async (n, r) => {
        this.client.core.expirer.set(n, Zn(lr.wc_sessionPropose.req.ttl)),
          await this.client.proposal.set(n, r);
      }),
      pe(this, "setAuthRequest", async (n, r) => {
        const { request: i, pairingTopic: s, transportType: o = dn.relay } = r;
        this.client.core.expirer.set(n, i.expiryTimestamp),
          await this.client.auth.requests.set(n, {
            authPayload: i.authPayload,
            requester: i.requester,
            expiryTimestamp: i.expiryTimestamp,
            id: n,
            pairingTopic: s,
            verifyContext: i.verifyContext,
            transportType: o,
          });
      }),
      pe(this, "setPendingSessionRequest", async (n) => {
        const { id: r, topic: i, params: s, verifyContext: o } = n,
          a = s.request.expiryTimestamp || Zn(lr.wc_sessionRequest.req.ttl);
        this.client.core.expirer.set(r, a),
          await this.client.pendingRequest.set(r, {
            id: r,
            topic: i,
            params: s,
            verifyContext: o,
          });
      }),
      pe(this, "sendRequest", async (n) => {
        const {
            topic: r,
            method: i,
            params: s,
            expiry: o,
            relayRpcId: a,
            clientRpcId: l,
            throwOnFailedPublish: d,
            appLink: p,
            tvf: f,
          } = n,
          m = Tc(i, s, l);
        let y;
        const g = !!p;
        try {
          const E = g ? mc : Vs;
          y = await this.client.core.crypto.encode(r, m, { encoding: E });
        } catch (E) {
          throw (
            (await this.cleanup(),
            this.client.logger.error(
              `sendRequest() -> core.crypto.encode() for topic ${r} failed`
            ),
            E)
          );
        }
        let v;
        if (Yae.includes(i)) {
          const E = So(JSON.stringify(m)),
            S = So(y);
          v = await this.client.core.verify.register({ id: S, decryptedId: E });
        }
        const b = lr[i].req;
        if (
          ((b.attestation = v),
          o && (b.ttl = o),
          a && (b.id = a),
          this.client.core.history.set(r, m),
          g)
        ) {
          const E = e0(p, r, y);
          await global.Linking.openURL(E, this.client.name);
        } else {
          const E = lr[i].req;
          o && (E.ttl = o),
            a && (E.id = a),
            (E.tvf = Xr(en({}, f), { correlationId: m.id })),
            d
              ? ((E.internal = Xr(en({}, E.internal), {
                  throwOnFailedPublish: !0,
                })),
                await this.client.core.relayer.publish(r, y, E))
              : this.client.core.relayer
                  .publish(r, y, E)
                  .catch((S) => this.client.logger.error(S));
        }
        return m.id;
      }),
      pe(this, "sendResult", async (n) => {
        const {
            id: r,
            topic: i,
            result: s,
            throwOnFailedPublish: o,
            encodeOpts: a,
            appLink: l,
          } = n,
          d = Tv(r, s);
        let p;
        const f = l && typeof (global == null ? void 0 : global.Linking) < "u";
        try {
          const g = f ? mc : Vs;
          p = await this.client.core.crypto.encode(
            i,
            d,
            Xr(en({}, a || {}), { encoding: g })
          );
        } catch (g) {
          throw (
            (await this.cleanup(),
            this.client.logger.error(
              `sendResult() -> core.crypto.encode() for topic ${i} failed`
            ),
            g)
          );
        }
        let m, y;
        try {
          m = await this.client.core.history.get(i, r);
          const g = m.request;
          try {
            this.shouldSetTVF(g.method, g.params) &&
              (y = this.getTVFParams(r, g.params, s));
          } catch (v) {
            this.client.logger.warn("sendResult() -> getTVFParams() failed", v);
          }
        } catch (g) {
          throw (
            (this.client.logger.error(
              `sendResult() -> history.get(${i}, ${r}) failed`
            ),
            g)
          );
        }
        if (f) {
          const g = e0(l, i, p);
          await global.Linking.openURL(g, this.client.name);
        } else {
          const g = m.request.method,
            v = lr[g].res;
          (v.tvf = Xr(en({}, y), { correlationId: r })),
            o
              ? ((v.internal = Xr(en({}, v.internal), {
                  throwOnFailedPublish: !0,
                })),
                await this.client.core.relayer.publish(i, p, v))
              : this.client.core.relayer
                  .publish(i, p, v)
                  .catch((b) => this.client.logger.error(b));
        }
        await this.client.core.history.resolve(d);
      }),
      pe(this, "sendError", async (n) => {
        const {
            id: r,
            topic: i,
            error: s,
            encodeOpts: o,
            rpcOpts: a,
            appLink: l,
          } = n,
          d = Pv(r, s);
        let p;
        const f = l && typeof (global == null ? void 0 : global.Linking) < "u";
        try {
          const y = f ? mc : Vs;
          p = await this.client.core.crypto.encode(
            i,
            d,
            Xr(en({}, o || {}), { encoding: y })
          );
        } catch (y) {
          throw (
            (await this.cleanup(),
            this.client.logger.error(
              `sendError() -> core.crypto.encode() for topic ${i} failed`
            ),
            y)
          );
        }
        let m;
        try {
          m = await this.client.core.history.get(i, r);
        } catch (y) {
          throw (
            (this.client.logger.error(
              `sendError() -> history.get(${i}, ${r}) failed`
            ),
            y)
          );
        }
        if (f) {
          const y = e0(l, i, p);
          await global.Linking.openURL(y, this.client.name);
        } else {
          const y = m.request.method,
            g = a || lr[y].res;
          this.client.core.relayer.publish(i, p, g);
        }
        await this.client.core.history.resolve(d);
      }),
      pe(this, "cleanup", async () => {
        const n = [],
          r = [];
        this.client.session.getAll().forEach((i) => {
          let s = !1;
          fc(i.expiry) && (s = !0),
            this.client.core.crypto.keychain.has(i.topic) || (s = !0),
            s && n.push(i.topic);
        }),
          this.client.proposal.getAll().forEach((i) => {
            fc(i.expiryTimestamp) && r.push(i.id);
          }),
          await Promise.all([
            ...n.map((i) => this.deleteSession({ topic: i })),
            ...r.map((i) => this.deleteProposal(i)),
          ]);
      }),
      pe(this, "onProviderMessageEvent", async (n) => {
        !this.initialized || this.relayMessageCache.length > 0
          ? this.relayMessageCache.push(n)
          : await this.onRelayMessage(n);
      }),
      pe(this, "onRelayEventRequest", async (n) => {
        this.requestQueue.queue.push(n), await this.processRequestsQueue();
      }),
      pe(this, "processRequestsQueue", async () => {
        if (this.requestQueue.state === fo.active) {
          this.client.logger.info("Request queue already active, skipping...");
          return;
        }
        for (
          this.client.logger.info(
            `Request queue starting with ${this.requestQueue.queue.length} requests`
          );
          this.requestQueue.queue.length > 0;

        ) {
          this.requestQueue.state = fo.active;
          const n = this.requestQueue.queue.shift();
          if (n)
            try {
              await this.processRequest(n);
            } catch (r) {
              this.client.logger.warn(r);
            }
        }
        this.requestQueue.state = fo.idle;
      }),
      pe(this, "processRequest", async (n) => {
        const {
            topic: r,
            payload: i,
            attestation: s,
            transportType: o,
            encryptedId: a,
          } = n,
          l = i.method;
        if (!this.shouldIgnorePairingRequest({ topic: r, requestMethod: l }))
          switch (l) {
            case "wc_sessionPropose":
              return await this.onSessionProposeRequest({
                topic: r,
                payload: i,
                attestation: s,
                encryptedId: a,
              });
            case "wc_sessionSettle":
              return await this.onSessionSettleRequest(r, i);
            case "wc_sessionUpdate":
              return await this.onSessionUpdateRequest(r, i);
            case "wc_sessionExtend":
              return await this.onSessionExtendRequest(r, i);
            case "wc_sessionPing":
              return await this.onSessionPingRequest(r, i);
            case "wc_sessionDelete":
              return await this.onSessionDeleteRequest(r, i);
            case "wc_sessionRequest":
              return await this.onSessionRequest({
                topic: r,
                payload: i,
                attestation: s,
                encryptedId: a,
                transportType: o,
              });
            case "wc_sessionEvent":
              return await this.onSessionEventRequest(r, i);
            case "wc_sessionAuthenticate":
              return await this.onSessionAuthenticateRequest({
                topic: r,
                payload: i,
                attestation: s,
                encryptedId: a,
                transportType: o,
              });
            default:
              return this.client.logger.info(`Unsupported request method ${l}`);
          }
      }),
      pe(this, "onRelayEventResponse", async (n) => {
        const { topic: r, payload: i, transportType: s } = n,
          o = (await this.client.core.history.get(r, i.id)).request.method;
        switch (o) {
          case "wc_sessionPropose":
            return this.onSessionProposeResponse(r, i, s);
          case "wc_sessionSettle":
            return this.onSessionSettleResponse(r, i);
          case "wc_sessionUpdate":
            return this.onSessionUpdateResponse(r, i);
          case "wc_sessionExtend":
            return this.onSessionExtendResponse(r, i);
          case "wc_sessionPing":
            return this.onSessionPingResponse(r, i);
          case "wc_sessionRequest":
            return this.onSessionRequestResponse(r, i);
          case "wc_sessionAuthenticate":
            return this.onSessionAuthenticateResponse(r, i);
          default:
            return this.client.logger.info(`Unsupported response method ${o}`);
        }
      }),
      pe(this, "onRelayEventUnknownPayload", (n) => {
        const { topic: r } = n,
          { message: i } = xe(
            "MISSING_OR_INVALID",
            `Decoded payload on topic ${r} is not identifiable as a JSON-RPC request or a response.`
          );
        throw new Error(i);
      }),
      pe(this, "shouldIgnorePairingRequest", (n) => {
        const { topic: r, requestMethod: i } = n,
          s = this.expectedPairingMethodMap.get(r);
        return !s || s.includes(i)
          ? !1
          : !!(
              s.includes("wc_sessionAuthenticate") &&
              this.client.events.listenerCount("session_authenticate") > 0
            );
      }),
      pe(this, "onSessionProposeRequest", async (n) => {
        const { topic: r, payload: i, attestation: s, encryptedId: o } = n,
          { params: a, id: l } = i;
        try {
          const d = this.client.core.eventClient.getEvent({ topic: r });
          this.client.events.listenerCount("session_proposal") === 0 &&
            (console.warn("No listener for session_proposal event"),
            d == null || d.setError(ca.proposal_listener_not_found)),
            this.isValidConnect(en({}, i.params));
          const p = a.expiryTimestamp || Zn(lr.wc_sessionPropose.req.ttl),
            f = en({ id: l, pairingTopic: r, expiryTimestamp: p }, a);
          await this.setProposal(l, f);
          const m = await this.getVerifyContext({
            attestationId: s,
            hash: So(JSON.stringify(i)),
            encryptedId: o,
            metadata: f.proposer.metadata,
          });
          d == null || d.addTrace(mo.emit_session_proposal),
            this.client.events.emit("session_proposal", {
              id: l,
              params: f,
              verifyContext: m,
            });
        } catch (d) {
          await this.sendError({
            id: l,
            topic: r,
            error: d,
            rpcOpts: lr.wc_sessionPropose.autoReject,
          }),
            this.client.logger.error(d);
        }
      }),
      pe(this, "onSessionProposeResponse", async (n, r, i) => {
        const { id: s } = r;
        if (yo(r)) {
          const { result: o } = r;
          this.client.logger.trace({
            type: "method",
            method: "onSessionProposeResponse",
            result: o,
          });
          const a = this.client.proposal.get(s);
          this.client.logger.trace({
            type: "method",
            method: "onSessionProposeResponse",
            proposal: a,
          });
          const l = a.proposer.publicKey;
          this.client.logger.trace({
            type: "method",
            method: "onSessionProposeResponse",
            selfPublicKey: l,
          });
          const d = o.responderPublicKey;
          this.client.logger.trace({
            type: "method",
            method: "onSessionProposeResponse",
            peerPublicKey: d,
          });
          const p = await this.client.core.crypto.generateSharedKey(l, d);
          this.pendingSessions.set(s, {
            sessionTopic: p,
            pairingTopic: n,
            proposalId: s,
            publicKey: l,
          });
          const f = await this.client.core.relayer.subscribe(p, {
            transportType: i,
          });
          this.client.logger.trace({
            type: "method",
            method: "onSessionProposeResponse",
            subscriptionId: f,
          }),
            await this.client.core.pairing.activate({ topic: n });
        } else if (ls(r)) {
          await this.client.proposal.delete(s, Kt("USER_DISCONNECTED"));
          const o = jt("session_connect", s);
          if (this.events.listenerCount(o) === 0)
            throw new Error(`emitting ${o} without any listeners, 954`);
          this.events.emit(o, { error: r.error });
        }
      }),
      pe(this, "onSessionSettleRequest", async (n, r) => {
        const { id: i, params: s } = r;
        try {
          this.isValidSessionSettleRequest(s);
          const {
              relay: o,
              controller: a,
              expiry: l,
              namespaces: d,
              sessionProperties: p,
              scopedProperties: f,
              sessionConfig: m,
            } = r.params,
            y = [...this.pendingSessions.values()].find(
              (b) => b.sessionTopic === n
            );
          if (!y)
            return this.client.logger.error(
              `Pending session not found for topic ${n}`
            );
          const g = this.client.proposal.get(y.proposalId),
            v = Xr(
              en(
                en(
                  en(
                    {
                      topic: n,
                      relay: o,
                      expiry: l,
                      namespaces: d,
                      acknowledged: !0,
                      pairingTopic: y.pairingTopic,
                      requiredNamespaces: g.requiredNamespaces,
                      optionalNamespaces: g.optionalNamespaces,
                      controller: a.publicKey,
                      self: {
                        publicKey: y.publicKey,
                        metadata: this.client.metadata,
                      },
                      peer: { publicKey: a.publicKey, metadata: a.metadata },
                    },
                    p && { sessionProperties: p }
                  ),
                  f && { scopedProperties: f }
                ),
                m && { sessionConfig: m }
              ),
              { transportType: dn.relay }
            );
          await this.client.session.set(v.topic, v),
            await this.setExpiry(v.topic, v.expiry),
            await this.client.core.pairing.updateMetadata({
              topic: y.pairingTopic,
              metadata: v.peer.metadata,
            }),
            this.client.events.emit("session_connect", { session: v }),
            this.events.emit(jt("session_connect", y.proposalId), {
              session: v,
            }),
            this.pendingSessions.delete(y.proposalId),
            this.deleteProposal(y.proposalId, !1),
            this.cleanupDuplicatePairings(v),
            await this.sendResult({
              id: r.id,
              topic: n,
              result: !0,
              throwOnFailedPublish: !0,
            });
        } catch (o) {
          await this.sendError({ id: i, topic: n, error: o }),
            this.client.logger.error(o);
        }
      }),
      pe(this, "onSessionSettleResponse", async (n, r) => {
        const { id: i } = r;
        yo(r)
          ? (await this.client.session.update(n, { acknowledged: !0 }),
            this.events.emit(jt("session_approve", i), {}))
          : ls(r) &&
            (await this.client.session.delete(n, Kt("USER_DISCONNECTED")),
            this.events.emit(jt("session_approve", i), { error: r.error }));
      }),
      pe(this, "onSessionUpdateRequest", async (n, r) => {
        const { params: i, id: s } = r;
        try {
          const o = `${n}_session_update`,
            a = zf.get(o);
          if (a && this.isRequestOutOfSync(a, s)) {
            this.client.logger.warn(`Discarding out of sync request - ${s}`),
              this.sendError({
                id: s,
                topic: n,
                error: Kt("INVALID_UPDATE_REQUEST"),
              });
            return;
          }
          this.isValidUpdate(en({ topic: n }, i));
          try {
            zf.set(o, s),
              await this.client.session.update(n, { namespaces: i.namespaces }),
              await this.sendResult({
                id: s,
                topic: n,
                result: !0,
                throwOnFailedPublish: !0,
              });
          } catch (l) {
            throw (zf.delete(o), l);
          }
          this.client.events.emit("session_update", {
            id: s,
            topic: n,
            params: i,
          });
        } catch (o) {
          await this.sendError({ id: s, topic: n, error: o }),
            this.client.logger.error(o);
        }
      }),
      pe(
        this,
        "isRequestOutOfSync",
        (n, r) => r.toString().slice(0, -3) < n.toString().slice(0, -3)
      ),
      pe(this, "onSessionUpdateResponse", (n, r) => {
        const { id: i } = r,
          s = jt("session_update", i);
        if (this.events.listenerCount(s) === 0)
          throw new Error(`emitting ${s} without any listeners`);
        yo(r)
          ? this.events.emit(jt("session_update", i), {})
          : ls(r) &&
            this.events.emit(jt("session_update", i), { error: r.error });
      }),
      pe(this, "onSessionExtendRequest", async (n, r) => {
        const { id: i } = r;
        try {
          this.isValidExtend({ topic: n }),
            await this.setExpiry(n, Zn(Ju)),
            await this.sendResult({
              id: i,
              topic: n,
              result: !0,
              throwOnFailedPublish: !0,
            }),
            this.client.events.emit("session_extend", { id: i, topic: n });
        } catch (s) {
          await this.sendError({ id: i, topic: n, error: s }),
            this.client.logger.error(s);
        }
      }),
      pe(this, "onSessionExtendResponse", (n, r) => {
        const { id: i } = r,
          s = jt("session_extend", i);
        if (this.events.listenerCount(s) === 0)
          throw new Error(`emitting ${s} without any listeners`);
        yo(r)
          ? this.events.emit(jt("session_extend", i), {})
          : ls(r) &&
            this.events.emit(jt("session_extend", i), { error: r.error });
      }),
      pe(this, "onSessionPingRequest", async (n, r) => {
        const { id: i } = r;
        try {
          this.isValidPing({ topic: n }),
            await this.sendResult({
              id: i,
              topic: n,
              result: !0,
              throwOnFailedPublish: !0,
            }),
            this.client.events.emit("session_ping", { id: i, topic: n });
        } catch (s) {
          await this.sendError({ id: i, topic: n, error: s }),
            this.client.logger.error(s);
        }
      }),
      pe(this, "onSessionPingResponse", (n, r) => {
        const { id: i } = r,
          s = jt("session_ping", i);
        setTimeout(() => {
          if (this.events.listenerCount(s) === 0)
            throw new Error(`emitting ${s} without any listeners 2176`);
          yo(r)
            ? this.events.emit(jt("session_ping", i), {})
            : ls(r) &&
              this.events.emit(jt("session_ping", i), { error: r.error });
        }, 500);
      }),
      pe(this, "onSessionDeleteRequest", async (n, r) => {
        const { id: i } = r;
        try {
          this.isValidDisconnect({ topic: n, reason: r.params }),
            Promise.all([
              new Promise((s) => {
                this.client.core.relayer.once(fr.publish, async () => {
                  s(await this.deleteSession({ topic: n, id: i }));
                });
              }),
              this.sendResult({
                id: i,
                topic: n,
                result: !0,
                throwOnFailedPublish: !0,
              }),
              this.cleanupPendingSentRequestsForTopic({
                topic: n,
                error: Kt("USER_DISCONNECTED"),
              }),
            ]).catch((s) => this.client.logger.error(s));
        } catch (s) {
          this.client.logger.error(s);
        }
      }),
      pe(this, "onSessionRequest", async (n) => {
        var r, i, s;
        const {
            topic: o,
            payload: a,
            attestation: l,
            encryptedId: d,
            transportType: p,
          } = n,
          { id: f, params: m } = a;
        try {
          await this.isValidRequest(en({ topic: o }, m));
          const y = this.client.session.get(o),
            g = await this.getVerifyContext({
              attestationId: l,
              hash: So(JSON.stringify(Tc("wc_sessionRequest", m, f))),
              encryptedId: d,
              metadata: y.peer.metadata,
              transportType: p,
            }),
            v = { id: f, topic: o, params: m, verifyContext: g };
          await this.setPendingSessionRequest(v),
            p === dn.link_mode &&
              (r = y.peer.metadata.redirect) != null &&
              r.universal &&
              this.client.core.addLinkModeSupportedApp(
                (i = y.peer.metadata.redirect) == null ? void 0 : i.universal
              ),
            (s = this.client.signConfig) != null && s.disableRequestQueue
              ? this.emitSessionRequest(v)
              : (this.addSessionRequestToSessionRequestQueue(v),
                this.processSessionRequestQueue());
        } catch (y) {
          await this.sendError({ id: f, topic: o, error: y }),
            this.client.logger.error(y);
        }
      }),
      pe(this, "onSessionRequestResponse", (n, r) => {
        const { id: i } = r,
          s = jt("session_request", i);
        if (this.events.listenerCount(s) === 0)
          throw new Error(`emitting ${s} without any listeners`);
        yo(r)
          ? this.events.emit(jt("session_request", i), { result: r.result })
          : ls(r) &&
            this.events.emit(jt("session_request", i), { error: r.error });
      }),
      pe(this, "onSessionEventRequest", async (n, r) => {
        const { id: i, params: s } = r;
        try {
          const o = `${n}_session_event_${s.event.name}`,
            a = zf.get(o);
          if (a && this.isRequestOutOfSync(a, i)) {
            this.client.logger.info(`Discarding out of sync request - ${i}`);
            return;
          }
          this.isValidEmit(en({ topic: n }, s)),
            this.client.events.emit("session_event", {
              id: i,
              topic: n,
              params: s,
            }),
            zf.set(o, i);
        } catch (o) {
          await this.sendError({ id: i, topic: n, error: o }),
            this.client.logger.error(o);
        }
      }),
      pe(this, "onSessionAuthenticateResponse", (n, r) => {
        const { id: i } = r;
        this.client.logger.trace({
          type: "method",
          method: "onSessionAuthenticateResponse",
          topic: n,
          payload: r,
        }),
          yo(r)
            ? this.events.emit(jt("session_request", i), { result: r.result })
            : ls(r) &&
              this.events.emit(jt("session_request", i), { error: r.error });
      }),
      pe(this, "onSessionAuthenticateRequest", async (n) => {
        var r;
        const {
          topic: i,
          payload: s,
          attestation: o,
          encryptedId: a,
          transportType: l,
        } = n;
        try {
          const { requester: d, authPayload: p, expiryTimestamp: f } = s.params,
            m = await this.getVerifyContext({
              attestationId: o,
              hash: So(JSON.stringify(s)),
              encryptedId: a,
              metadata: d.metadata,
              transportType: l,
            }),
            y = {
              requester: d,
              pairingTopic: i,
              id: s.id,
              authPayload: p,
              verifyContext: m,
              expiryTimestamp: f,
            };
          await this.setAuthRequest(s.id, {
            request: y,
            pairingTopic: i,
            transportType: l,
          }),
            l === dn.link_mode &&
              (r = d.metadata.redirect) != null &&
              r.universal &&
              this.client.core.addLinkModeSupportedApp(
                d.metadata.redirect.universal
              ),
            this.client.events.emit("session_authenticate", {
              topic: i,
              params: s.params,
              id: s.id,
              verifyContext: m,
            });
        } catch (d) {
          this.client.logger.error(d);
          const p = s.params.requester.publicKey,
            f = await this.client.core.crypto.generateKeyPair(),
            m = this.getAppLinkIfEnabled(s.params.requester.metadata, l),
            y = { type: wa, receiverPublicKey: p, senderPublicKey: f };
          await this.sendError({
            id: s.id,
            topic: i,
            error: d,
            encodeOpts: y,
            rpcOpts: lr.wc_sessionAuthenticate.autoReject,
            appLink: m,
          });
        }
      }),
      pe(this, "addSessionRequestToSessionRequestQueue", (n) => {
        this.sessionRequestQueue.queue.push(n);
      }),
      pe(this, "cleanupAfterResponse", (n) => {
        this.deletePendingSessionRequest(n.response.id, {
          message: "fulfilled",
          code: 0,
        }),
          setTimeout(() => {
            (this.sessionRequestQueue.state = fo.idle),
              this.processSessionRequestQueue();
          }, Ee.toMiliseconds(this.requestQueueDelay));
      }),
      pe(
        this,
        "cleanupPendingSentRequestsForTopic",
        ({ topic: n, error: r }) => {
          const i = this.client.core.history.pending;
          i.length > 0 &&
            i
              .filter(
                (s) => s.topic === n && s.request.method === "wc_sessionRequest"
              )
              .forEach((s) => {
                const o = s.request.id,
                  a = jt("session_request", o);
                if (this.events.listenerCount(a) === 0)
                  throw new Error(`emitting ${a} without any listeners`);
                this.events.emit(jt("session_request", s.request.id), {
                  error: r,
                });
              });
        }
      ),
      pe(this, "processSessionRequestQueue", () => {
        if (this.sessionRequestQueue.state === fo.active) {
          this.client.logger.info("session request queue is already active.");
          return;
        }
        const n = this.sessionRequestQueue.queue[0];
        if (!n) {
          this.client.logger.info("session request queue is empty.");
          return;
        }
        try {
          (this.sessionRequestQueue.state = fo.active),
            this.emitSessionRequest(n);
        } catch (r) {
          this.client.logger.error(r);
        }
      }),
      pe(this, "emitSessionRequest", (n) => {
        this.client.events.emit("session_request", n);
      }),
      pe(this, "onPairingCreated", (n) => {
        if (
          (n.methods && this.expectedPairingMethodMap.set(n.topic, n.methods),
          n.active)
        )
          return;
        const r = this.client.proposal
          .getAll()
          .find((i) => i.pairingTopic === n.topic);
        r &&
          this.onSessionProposeRequest({
            topic: n.topic,
            payload: Tc(
              "wc_sessionPropose",
              Xr(en({}, r), {
                requiredNamespaces: r.requiredNamespaces,
                optionalNamespaces: r.optionalNamespaces,
                relays: r.relays,
                proposer: r.proposer,
                sessionProperties: r.sessionProperties,
                scopedProperties: r.scopedProperties,
              }),
              r.id
            ),
          });
      }),
      pe(this, "isValidConnect", async (n) => {
        if (!wi(n)) {
          const { message: d } = xe(
            "MISSING_OR_INVALID",
            `connect() params: ${JSON.stringify(n)}`
          );
          throw new Error(d);
        }
        const {
          pairingTopic: r,
          requiredNamespaces: i,
          optionalNamespaces: s,
          sessionProperties: o,
          scopedProperties: a,
          relays: l,
        } = n;
        if ((Tr(r) || (await this.isValidPairingTopic(r)), !Ere(l))) {
          const { message: d } = xe(
            "MISSING_OR_INVALID",
            `connect() relays: ${l}`
          );
          throw new Error(d);
        }
        if (
          (!Tr(i) &&
            Kh(i) !== 0 &&
            this.validateNamespaces(i, "requiredNamespaces"),
          !Tr(s) &&
            Kh(s) !== 0 &&
            this.validateNamespaces(s, "optionalNamespaces"),
          Tr(o) || this.validateSessionProps(o, "sessionProperties"),
          !Tr(a))
        ) {
          this.validateSessionProps(a, "scopedProperties");
          const d = Object.keys(i || {}).concat(Object.keys(s || {}));
          if (!Object.keys(a).every((p) => d.includes(p)))
            throw new Error(
              `Scoped properties must be a subset of required/optional namespaces, received: ${JSON.stringify(
                a
              )}, required/optional namespaces: ${JSON.stringify(d)}`
            );
        }
      }),
      pe(this, "validateNamespaces", (n, r) => {
        const i = bre(n, "connect()", r);
        if (i) throw new Error(i.message);
      }),
      pe(this, "isValidApprove", async (n) => {
        if (!wi(n))
          throw new Error(
            xe("MISSING_OR_INVALID", `approve() params: ${n}`).message
          );
        const {
          id: r,
          namespaces: i,
          relayProtocol: s,
          sessionProperties: o,
          scopedProperties: a,
        } = n;
        this.checkRecentlyDeleted(r), await this.isValidProposalId(r);
        const l = this.client.proposal.get(r),
          d = WE(i, "approve()");
        if (d) throw new Error(d.message);
        const p = _N(l.requiredNamespaces, i, "approve()");
        if (p) throw new Error(p.message);
        if (!Hn(s, !0)) {
          const { message: f } = xe(
            "MISSING_OR_INVALID",
            `approve() relayProtocol: ${s}`
          );
          throw new Error(f);
        }
        if (
          (Tr(o) || this.validateSessionProps(o, "sessionProperties"), !Tr(a))
        ) {
          this.validateSessionProps(a, "scopedProperties");
          const f = new Set(Object.keys(i));
          if (!Object.keys(a).every((m) => f.has(m)))
            throw new Error(
              `Scoped properties must be a subset of approved namespaces, received: ${JSON.stringify(
                a
              )}, approved namespaces: ${Array.from(f).join(", ")}`
            );
        }
      }),
      pe(this, "isValidReject", async (n) => {
        if (!wi(n)) {
          const { message: s } = xe(
            "MISSING_OR_INVALID",
            `reject() params: ${n}`
          );
          throw new Error(s);
        }
        const { id: r, reason: i } = n;
        if (
          (this.checkRecentlyDeleted(r),
          await this.isValidProposalId(r),
          !xre(i))
        ) {
          const { message: s } = xe(
            "MISSING_OR_INVALID",
            `reject() reason: ${JSON.stringify(i)}`
          );
          throw new Error(s);
        }
      }),
      pe(this, "isValidSessionSettleRequest", (n) => {
        if (!wi(n)) {
          const { message: d } = xe(
            "MISSING_OR_INVALID",
            `onSessionSettleRequest() params: ${n}`
          );
          throw new Error(d);
        }
        const { relay: r, controller: i, namespaces: s, expiry: o } = n;
        if (!K$(r)) {
          const { message: d } = xe(
            "MISSING_OR_INVALID",
            "onSessionSettleRequest() relay protocol should be a string"
          );
          throw new Error(d);
        }
        const a = hre(i, "onSessionSettleRequest()");
        if (a) throw new Error(a.message);
        const l = WE(s, "onSessionSettleRequest()");
        if (l) throw new Error(l.message);
        if (fc(o)) {
          const { message: d } = xe("EXPIRED", "onSessionSettleRequest()");
          throw new Error(d);
        }
      }),
      pe(this, "isValidUpdate", async (n) => {
        if (!wi(n)) {
          const { message: l } = xe(
            "MISSING_OR_INVALID",
            `update() params: ${n}`
          );
          throw new Error(l);
        }
        const { topic: r, namespaces: i } = n;
        this.checkRecentlyDeleted(r), await this.isValidSessionTopic(r);
        const s = this.client.session.get(r),
          o = WE(i, "update()");
        if (o) throw new Error(o.message);
        const a = _N(s.requiredNamespaces, i, "update()");
        if (a) throw new Error(a.message);
      }),
      pe(this, "isValidExtend", async (n) => {
        if (!wi(n)) {
          const { message: i } = xe(
            "MISSING_OR_INVALID",
            `extend() params: ${n}`
          );
          throw new Error(i);
        }
        const { topic: r } = n;
        this.checkRecentlyDeleted(r), await this.isValidSessionTopic(r);
      }),
      pe(this, "isValidRequest", async (n) => {
        if (!wi(n)) {
          const { message: l } = xe(
            "MISSING_OR_INVALID",
            `request() params: ${n}`
          );
          throw new Error(l);
        }
        const { topic: r, request: i, chainId: s, expiry: o } = n;
        this.checkRecentlyDeleted(r), await this.isValidSessionTopic(r);
        const { namespaces: a } = this.client.session.get(r);
        if (!AN(a, s)) {
          const { message: l } = xe(
            "MISSING_OR_INVALID",
            `request() chainId: ${s}`
          );
          throw new Error(l);
        }
        if (!Sre(i)) {
          const { message: l } = xe(
            "MISSING_OR_INVALID",
            `request() ${JSON.stringify(i)}`
          );
          throw new Error(l);
        }
        if (!Ire(a, s, i.method)) {
          const { message: l } = xe(
            "MISSING_OR_INVALID",
            `request() method: ${i.method}`
          );
          throw new Error(l);
        }
        if (o && !Nre(o, QE)) {
          const { message: l } = xe(
            "MISSING_OR_INVALID",
            `request() expiry: ${o}. Expiry must be a number (in seconds) between ${QE.min} and ${QE.max}`
          );
          throw new Error(l);
        }
      }),
      pe(this, "isValidRespond", async (n) => {
        var r;
        if (!wi(n)) {
          const { message: o } = xe(
            "MISSING_OR_INVALID",
            `respond() params: ${n}`
          );
          throw new Error(o);
        }
        const { topic: i, response: s } = n;
        try {
          await this.isValidSessionTopic(i);
        } catch (o) {
          throw (
            ((r = n == null ? void 0 : n.response) != null &&
              r.id &&
              this.cleanupAfterResponse(n),
            o)
          );
        }
        if (!Are(s)) {
          const { message: o } = xe(
            "MISSING_OR_INVALID",
            `respond() response: ${JSON.stringify(s)}`
          );
          throw new Error(o);
        }
      }),
      pe(this, "isValidPing", async (n) => {
        if (!wi(n)) {
          const { message: i } = xe(
            "MISSING_OR_INVALID",
            `ping() params: ${n}`
          );
          throw new Error(i);
        }
        const { topic: r } = n;
        await this.isValidSessionOrPairingTopic(r);
      }),
      pe(this, "isValidEmit", async (n) => {
        if (!wi(n)) {
          const { message: a } = xe(
            "MISSING_OR_INVALID",
            `emit() params: ${n}`
          );
          throw new Error(a);
        }
        const { topic: r, event: i, chainId: s } = n;
        await this.isValidSessionTopic(r);
        const { namespaces: o } = this.client.session.get(r);
        if (!AN(o, s)) {
          const { message: a } = xe(
            "MISSING_OR_INVALID",
            `emit() chainId: ${s}`
          );
          throw new Error(a);
        }
        if (!_re(i)) {
          const { message: a } = xe(
            "MISSING_OR_INVALID",
            `emit() event: ${JSON.stringify(i)}`
          );
          throw new Error(a);
        }
        if (!Tre(o, s, i.name)) {
          const { message: a } = xe(
            "MISSING_OR_INVALID",
            `emit() event: ${JSON.stringify(i)}`
          );
          throw new Error(a);
        }
      }),
      pe(this, "isValidDisconnect", async (n) => {
        if (!wi(n)) {
          const { message: i } = xe(
            "MISSING_OR_INVALID",
            `disconnect() params: ${n}`
          );
          throw new Error(i);
        }
        const { topic: r } = n;
        await this.isValidSessionOrPairingTopic(r);
      }),
      pe(this, "isValidAuthenticate", (n) => {
        const { chains: r, uri: i, domain: s, nonce: o } = n;
        if (!Array.isArray(r) || r.length === 0)
          throw new Error("chains is required and must be a non-empty array");
        if (!Hn(i, !1)) throw new Error("uri is required parameter");
        if (!Hn(s, !1)) throw new Error("domain is required parameter");
        if (!Hn(o, !1)) throw new Error("nonce is required parameter");
        if ([...new Set(r.map((l) => Nd(l).namespace))].length > 1)
          throw new Error(
            "Multi-namespace requests are not supported. Please request single namespace only."
          );
        const { namespace: a } = Nd(r[0]);
        if (a !== "eip155")
          throw new Error(
            "Only eip155 namespace is supported for authenticated sessions. Please use .connect() for non-eip155 chains."
          );
      }),
      pe(this, "getVerifyContext", async (n) => {
        const {
            attestationId: r,
            hash: i,
            encryptedId: s,
            metadata: o,
            transportType: a,
          } = n,
          l = {
            verified: {
              verifyUrl: o.verifyUrl || bh,
              validation: "UNKNOWN",
              origin: o.url || "",
            },
          };
        try {
          if (a === dn.link_mode) {
            const p = this.getAppLinkIfEnabled(o, a);
            return (
              (l.verified.validation =
                p && new URL(p).origin === new URL(o.url).origin
                  ? "VALID"
                  : "INVALID"),
              l
            );
          }
          const d = await this.client.core.verify.resolve({
            attestationId: r,
            hash: i,
            encryptedId: s,
            verifyUrl: o.verifyUrl,
          });
          d &&
            ((l.verified.origin = d.origin),
            (l.verified.isScam = d.isScam),
            (l.verified.validation =
              d.origin === new URL(o.url).origin ? "VALID" : "INVALID"));
        } catch (d) {
          this.client.logger.warn(d);
        }
        return (
          this.client.logger.debug(`Verify context: ${JSON.stringify(l)}`), l
        );
      }),
      pe(this, "validateSessionProps", (n, r) => {
        Object.values(n).forEach((i, s) => {
          if (i == null) {
            const { message: o } = xe(
              "MISSING_OR_INVALID",
              `${r} must contain an existing value for each key. Received: ${i} for key ${
                Object.keys(n)[s]
              }`
            );
            throw new Error(o);
          }
        });
      }),
      pe(this, "getPendingAuthRequest", (n) => {
        const r = this.client.auth.requests.get(n);
        return typeof r == "object" ? r : void 0;
      }),
      pe(this, "addToRecentlyDeleted", (n, r) => {
        if (
          (this.recentlyDeletedMap.set(n, r),
          this.recentlyDeletedMap.size >= this.recentlyDeletedLimit)
        ) {
          let i = 0;
          const s = this.recentlyDeletedLimit / 2;
          for (const o of this.recentlyDeletedMap.keys()) {
            if (i++ >= s) break;
            this.recentlyDeletedMap.delete(o);
          }
        }
      }),
      pe(this, "checkRecentlyDeleted", (n) => {
        const r = this.recentlyDeletedMap.get(n);
        if (r) {
          const { message: i } = xe(
            "MISSING_OR_INVALID",
            `Record was recently deleted - ${r}: ${n}`
          );
          throw new Error(i);
        }
      }),
      pe(this, "isLinkModeEnabled", (n, r) => {
        var i, s, o, a, l, d, p, f, m;
        return !n || r !== dn.link_mode
          ? !1
          : ((s = (i = this.client.metadata) == null ? void 0 : i.redirect) ==
            null
              ? void 0
              : s.linkMode) === !0 &&
              ((a = (o = this.client.metadata) == null ? void 0 : o.redirect) ==
              null
                ? void 0
                : a.universal) !== void 0 &&
              ((d = (l = this.client.metadata) == null ? void 0 : l.redirect) ==
              null
                ? void 0
                : d.universal) !== "" &&
              ((p = n == null ? void 0 : n.redirect) == null
                ? void 0
                : p.universal) !== void 0 &&
              ((f = n == null ? void 0 : n.redirect) == null
                ? void 0
                : f.universal) !== "" &&
              ((m = n == null ? void 0 : n.redirect) == null
                ? void 0
                : m.linkMode) === !0 &&
              this.client.core.linkModeSupportedApps.includes(
                n.redirect.universal
              ) &&
              typeof (global == null ? void 0 : global.Linking) < "u";
      }),
      pe(this, "getAppLinkIfEnabled", (n, r) => {
        var i;
        return this.isLinkModeEnabled(n, r)
          ? (i = n == null ? void 0 : n.redirect) == null
            ? void 0
            : i.universal
          : void 0;
      }),
      pe(this, "handleLinkModeMessage", ({ url: n }) => {
        if (!n || !n.includes("wc_ev") || !n.includes("topic")) return;
        const r = HR(n, "topic") || "",
          i = decodeURIComponent(HR(n, "wc_ev") || ""),
          s = this.client.session.keys.includes(r);
        s && this.client.session.update(r, { transportType: dn.link_mode }),
          this.client.core.dispatchEnvelope({
            topic: r,
            message: i,
            sessionExists: s,
          });
      }),
      pe(this, "registerLinkModeListeners", async () => {
        var n;
        if (
          AA() ||
          (Yc() && (n = this.client.metadata.redirect) != null && n.linkMode)
        ) {
          const r = global == null ? void 0 : global.Linking;
          if (typeof r < "u") {
            r.addEventListener(
              "url",
              this.handleLinkModeMessage,
              this.client.name
            );
            const i = await r.getInitialURL();
            i &&
              setTimeout(() => {
                this.handleLinkModeMessage({ url: i });
              }, 50);
          }
        }
      }),
      pe(this, "shouldSetTVF", (n, r) => {
        if (!r || n !== "wc_sessionRequest") return !1;
        const { request: i } = r;
        return Object.keys(lO).includes(i.method);
      }),
      pe(this, "getTVFParams", (n, r, i) => {
        var s, o;
        try {
          const a = r.request.method,
            l = this.extractTxHashesFromResult(a, i);
          return Xr(
            en(
              { correlationId: n, rpcMethods: [a], chainId: r.chainId },
              this.isValidContractData(r.request.params) && {
                contractAddresses: [
                  (o = (s = r.request.params) == null ? void 0 : s[0]) == null
                    ? void 0
                    : o.to,
                ],
              }
            ),
            { txHashes: l }
          );
        } catch (a) {
          this.client.logger.warn("Error getting TVF params", a);
        }
        return {};
      }),
      pe(this, "isValidContractData", (n) => {
        var r;
        if (!n) return !1;
        try {
          const i =
            (n == null ? void 0 : n.data) ||
            ((r = n == null ? void 0 : n[0]) == null ? void 0 : r.data);
          if (!i.startsWith("0x")) return !1;
          const s = i.slice(2);
          return /^[0-9a-fA-F]*$/.test(s) ? s.length % 2 === 0 : !1;
        } catch {}
        return !1;
      }),
      pe(this, "extractTxHashesFromResult", (n, r) => {
        try {
          const i = lO[n];
          if (typeof r == "string") return [r];
          const s = r[i.key];
          if (Nc(s))
            return n === "solana_signAllTransactions"
              ? s.map((o) => ste(o))
              : s;
          if (typeof s == "string") return [s];
        } catch (i) {
          this.client.logger.warn("Error extracting tx hashes from result", i);
        }
        return [];
      });
  }
  async processPendingMessageEvents() {
    try {
      const e = this.client.session.keys,
        n = this.client.core.relayer.messages.getWithoutAck(e);
      for (const [r, i] of Object.entries(n))
        for (const s of i)
          try {
            await this.onProviderMessageEvent({
              topic: r,
              message: s,
              publishedAt: Date.now(),
            });
          } catch {
            this.client.logger.warn(
              `Error processing pending message event for topic: ${r}, message: ${s}`
            );
          }
    } catch (e) {
      this.client.logger.warn("processPendingMessageEvents failed", e);
    }
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = xe("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
  async confirmOnlineStateOrThrow() {
    await this.client.core.relayer.confirmOnlineStateOrThrow();
  }
  registerRelayerEvents() {
    this.client.core.relayer.on(fr.message, (e) => {
      this.onProviderMessageEvent(e);
    });
  }
  async onRelayMessage(e) {
    const { topic: n, message: r, attestation: i, transportType: s } = e,
      { publicKey: o } = this.client.auth.authKeys.keys.includes(B0)
        ? this.client.auth.authKeys.get(B0)
        : { responseTopic: void 0, publicKey: void 0 };
    try {
      const a = await this.client.core.crypto.decode(n, r, {
        receiverPublicKey: o,
        encoding: s === dn.link_mode ? mc : Vs,
      });
      $A(a)
        ? (this.client.core.history.set(n, a),
          await this.onRelayEventRequest({
            topic: n,
            payload: a,
            attestation: i,
            transportType: s,
            encryptedId: So(r),
          }))
        : Rv(a)
        ? (await this.client.core.history.resolve(a),
          await this.onRelayEventResponse({
            topic: n,
            payload: a,
            transportType: s,
          }),
          this.client.core.history.delete(n, a.id))
        : await this.onRelayEventUnknownPayload({
            topic: n,
            payload: a,
            transportType: s,
          }),
        await this.client.core.relayer.messages.ack(n, r);
    } catch (a) {
      this.client.logger.error(a);
    }
  }
  registerExpirerEvents() {
    this.client.core.expirer.on(as.expired, async (e) => {
      const { topic: n, id: r } = f$(e.target);
      if (r && this.client.pendingRequest.keys.includes(r))
        return await this.deletePendingSessionRequest(r, xe("EXPIRED"), !0);
      if (r && this.client.auth.requests.keys.includes(r))
        return await this.deletePendingAuthRequest(r, xe("EXPIRED"), !0);
      n
        ? this.client.session.keys.includes(n) &&
          (await this.deleteSession({ topic: n, expirerHasDeleted: !0 }),
          this.client.events.emit("session_expire", { topic: n }))
        : r &&
          (await this.deleteProposal(r, !0),
          this.client.events.emit("proposal_expire", { id: r }));
    });
  }
  registerPairingEvents() {
    this.client.core.pairing.events.on(Sl.create, (e) =>
      this.onPairingCreated(e)
    ),
      this.client.core.pairing.events.on(Sl.delete, (e) => {
        this.addToRecentlyDeleted(e.topic, "pairing");
      });
  }
  isValidPairingTopic(e) {
    if (!Hn(e, !1)) {
      const { message: n } = xe(
        "MISSING_OR_INVALID",
        `pairing topic should be a string: ${e}`
      );
      throw new Error(n);
    }
    if (!this.client.core.pairing.pairings.keys.includes(e)) {
      const { message: n } = xe(
        "NO_MATCHING_KEY",
        `pairing topic doesn't exist: ${e}`
      );
      throw new Error(n);
    }
    if (fc(this.client.core.pairing.pairings.get(e).expiry)) {
      const { message: n } = xe("EXPIRED", `pairing topic: ${e}`);
      throw new Error(n);
    }
  }
  async isValidSessionTopic(e) {
    if (!Hn(e, !1)) {
      const { message: n } = xe(
        "MISSING_OR_INVALID",
        `session topic should be a string: ${e}`
      );
      throw new Error(n);
    }
    if ((this.checkRecentlyDeleted(e), !this.client.session.keys.includes(e))) {
      const { message: n } = xe(
        "NO_MATCHING_KEY",
        `session topic doesn't exist: ${e}`
      );
      throw new Error(n);
    }
    if (fc(this.client.session.get(e).expiry)) {
      await this.deleteSession({ topic: e });
      const { message: n } = xe("EXPIRED", `session topic: ${e}`);
      throw new Error(n);
    }
    if (!this.client.core.crypto.keychain.has(e)) {
      const { message: n } = xe(
        "MISSING_OR_INVALID",
        `session topic does not exist in keychain: ${e}`
      );
      throw (await this.deleteSession({ topic: e }), new Error(n));
    }
  }
  async isValidSessionOrPairingTopic(e) {
    if ((this.checkRecentlyDeleted(e), this.client.session.keys.includes(e)))
      await this.isValidSessionTopic(e);
    else if (this.client.core.pairing.pairings.keys.includes(e))
      this.isValidPairingTopic(e);
    else if (Hn(e, !1)) {
      const { message: n } = xe(
        "NO_MATCHING_KEY",
        `session or pairing topic doesn't exist: ${e}`
      );
      throw new Error(n);
    } else {
      const { message: n } = xe(
        "MISSING_OR_INVALID",
        `session or pairing topic should be a string: ${e}`
      );
      throw new Error(n);
    }
  }
  async isValidProposalId(e) {
    if (!Cre(e)) {
      const { message: n } = xe(
        "MISSING_OR_INVALID",
        `proposal id should be a number: ${e}`
      );
      throw new Error(n);
    }
    if (!this.client.proposal.keys.includes(e)) {
      const { message: n } = xe(
        "NO_MATCHING_KEY",
        `proposal id doesn't exist: ${e}`
      );
      throw new Error(n);
    }
    if (fc(this.client.proposal.get(e).expiryTimestamp)) {
      await this.deleteProposal(e);
      const { message: n } = xe("EXPIRED", `proposal id: ${e}`);
      throw new Error(n);
    }
  }
}
class ace extends mu {
  constructor(e, n) {
    super(e, n, qae, MA), (this.core = e), (this.logger = n);
  }
}
let cce = class extends mu {
  constructor(e, n) {
    super(e, n, Vae, MA), (this.core = e), (this.logger = n);
  }
};
class lce extends mu {
  constructor(e, n) {
    super(e, n, Kae, MA, (r) => r.id), (this.core = e), (this.logger = n);
  }
}
class uce extends mu {
  constructor(e, n) {
    super(e, n, Xae, Ov, () => B0), (this.core = e), (this.logger = n);
  }
}
class dce extends mu {
  constructor(e, n) {
    super(e, n, Jae, Ov), (this.core = e), (this.logger = n);
  }
}
class pce extends mu {
  constructor(e, n) {
    super(e, n, ece, Ov, (r) => r.id), (this.core = e), (this.logger = n);
  }
}
var fce = Object.defineProperty,
  hce = (t, e, n) =>
    e in t
      ? fce(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n })
      : (t[e] = n),
  XE = (t, e, n) => hce(t, typeof e != "symbol" ? e + "" : e, n);
class mce {
  constructor(e, n) {
    (this.core = e),
      (this.logger = n),
      XE(this, "authKeys"),
      XE(this, "pairingTopics"),
      XE(this, "requests"),
      (this.authKeys = new uce(this.core, this.logger)),
      (this.pairingTopics = new dce(this.core, this.logger)),
      (this.requests = new pce(this.core, this.logger));
  }
  async init() {
    await this.authKeys.init(),
      await this.pairingTopics.init(),
      await this.requests.init();
  }
}
var gce = Object.defineProperty,
  yce = (t, e, n) =>
    e in t
      ? gce(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n })
      : (t[e] = n),
  St = (t, e, n) => yce(t, typeof e != "symbol" ? e + "" : e, n);
let wce = class vM extends vK {
  constructor(e) {
    super(e),
      St(this, "protocol", gM),
      St(this, "version", yM),
      St(this, "name", ZE.name),
      St(this, "metadata"),
      St(this, "core"),
      St(this, "logger"),
      St(this, "events", new Ss.EventEmitter()),
      St(this, "engine"),
      St(this, "session"),
      St(this, "proposal"),
      St(this, "pendingRequest"),
      St(this, "auth"),
      St(this, "signConfig"),
      St(this, "on", (r, i) => this.events.on(r, i)),
      St(this, "once", (r, i) => this.events.once(r, i)),
      St(this, "off", (r, i) => this.events.off(r, i)),
      St(this, "removeListener", (r, i) => this.events.removeListener(r, i)),
      St(this, "removeAllListeners", (r) => this.events.removeAllListeners(r)),
      St(this, "connect", async (r) => {
        try {
          return await this.engine.connect(r);
        } catch (i) {
          throw (this.logger.error(i.message), i);
        }
      }),
      St(this, "pair", async (r) => {
        try {
          return await this.engine.pair(r);
        } catch (i) {
          throw (this.logger.error(i.message), i);
        }
      }),
      St(this, "approve", async (r) => {
        try {
          return await this.engine.approve(r);
        } catch (i) {
          throw (this.logger.error(i.message), i);
        }
      }),
      St(this, "reject", async (r) => {
        try {
          return await this.engine.reject(r);
        } catch (i) {
          throw (this.logger.error(i.message), i);
        }
      }),
      St(this, "update", async (r) => {
        try {
          return await this.engine.update(r);
        } catch (i) {
          throw (this.logger.error(i.message), i);
        }
      }),
      St(this, "extend", async (r) => {
        try {
          return await this.engine.extend(r);
        } catch (i) {
          throw (this.logger.error(i.message), i);
        }
      }),
      St(this, "request", async (r) => {
        try {
          return await this.engine.request(r);
        } catch (i) {
          throw (this.logger.error(i.message), i);
        }
      }),
      St(this, "respond", async (r) => {
        try {
          return await this.engine.respond(r);
        } catch (i) {
          throw (this.logger.error(i.message), i);
        }
      }),
      St(this, "ping", async (r) => {
        try {
          return await this.engine.ping(r);
        } catch (i) {
          throw (this.logger.error(i.message), i);
        }
      }),
      St(this, "emit", async (r) => {
        try {
          return await this.engine.emit(r);
        } catch (i) {
          throw (this.logger.error(i.message), i);
        }
      }),
      St(this, "disconnect", async (r) => {
        try {
          return await this.engine.disconnect(r);
        } catch (i) {
          throw (this.logger.error(i.message), i);
        }
      }),
      St(this, "find", (r) => {
        try {
          return this.engine.find(r);
        } catch (i) {
          throw (this.logger.error(i.message), i);
        }
      }),
      St(this, "getPendingSessionRequests", () => {
        try {
          return this.engine.getPendingSessionRequests();
        } catch (r) {
          throw (this.logger.error(r.message), r);
        }
      }),
      St(this, "authenticate", async (r, i) => {
        try {
          return await this.engine.authenticate(r, i);
        } catch (s) {
          throw (this.logger.error(s.message), s);
        }
      }),
      St(this, "formatAuthMessage", (r) => {
        try {
          return this.engine.formatAuthMessage(r);
        } catch (i) {
          throw (this.logger.error(i.message), i);
        }
      }),
      St(this, "approveSessionAuthenticate", async (r) => {
        try {
          return await this.engine.approveSessionAuthenticate(r);
        } catch (i) {
          throw (this.logger.error(i.message), i);
        }
      }),
      St(this, "rejectSessionAuthenticate", async (r) => {
        try {
          return await this.engine.rejectSessionAuthenticate(r);
        } catch (i) {
          throw (this.logger.error(i.message), i);
        }
      }),
      (this.name = (e == null ? void 0 : e.name) || ZE.name),
      (this.metadata = wee(e == null ? void 0 : e.metadata)),
      (this.signConfig = e == null ? void 0 : e.signConfig);
    const n =
      typeof (e == null ? void 0 : e.logger) < "u" &&
      typeof (e == null ? void 0 : e.logger) != "string"
        ? e.logger
        : Ym(_p({ level: (e == null ? void 0 : e.logger) || ZE.logger }));
    (this.core = (e == null ? void 0 : e.core) || new Hae(e)),
      (this.logger = Gr(n, this.name)),
      (this.session = new cce(this.core, this.logger)),
      (this.proposal = new ace(this.core, this.logger)),
      (this.pendingRequest = new lce(this.core, this.logger)),
      (this.engine = new oce(this)),
      (this.auth = new mce(this.core, this.logger));
  }
  static async init(e) {
    const n = new vM(e);
    return await n.initialize(), n;
  }
  get context() {
    return Ti(this.logger);
  }
  get pairing() {
    return this.core.pairing.pairings;
  }
  async initialize() {
    this.logger.trace("Initialized");
    try {
      await this.core.start(),
        await this.session.init(),
        await this.proposal.init(),
        await this.pendingRequest.init(),
        await this.auth.init(),
        await this.engine.init(),
        this.logger.info("SignClient Initialization Success"),
        setTimeout(() => {
          this.engine.processRelayMessageCache();
        }, Ee.toMiliseconds(Ee.ONE_SECOND));
    } catch (e) {
      throw (
        (this.logger.info("SignClient Initialization Failure"),
        this.logger.error(e.message),
        e)
      );
    }
  }
};
var n0 = { exports: {} },
  dO;
function vce() {
  return (
    dO ||
      ((dO = 1),
      (function (t, e) {
        var n =
            (typeof globalThis < "u" && globalThis) ||
            (typeof self < "u" && self) ||
            (typeof Eo < "u" && Eo),
          r = (function () {
            function s() {
              (this.fetch = !1), (this.DOMException = n.DOMException);
            }
            return (s.prototype = n), new s();
          })();
        (function (s) {
          (function (o) {
            var a =
                (typeof s < "u" && s) ||
                (typeof self < "u" && self) ||
                (typeof Eo < "u" && Eo) ||
                {},
              l = {
                searchParams: "URLSearchParams" in a,
                iterable: "Symbol" in a && "iterator" in Symbol,
                blob:
                  "FileReader" in a &&
                  "Blob" in a &&
                  (function () {
                    try {
                      return new Blob(), !0;
                    } catch {
                      return !1;
                    }
                  })(),
                formData: "FormData" in a,
                arrayBuffer: "ArrayBuffer" in a,
              };
            function d($) {
              return $ && DataView.prototype.isPrototypeOf($);
            }
            if (l.arrayBuffer)
              var p = [
                  "[object Int8Array]",
                  "[object Uint8Array]",
                  "[object Uint8ClampedArray]",
                  "[object Int16Array]",
                  "[object Uint16Array]",
                  "[object Int32Array]",
                  "[object Uint32Array]",
                  "[object Float32Array]",
                  "[object Float64Array]",
                ],
                f =
                  ArrayBuffer.isView ||
                  function ($) {
                    return (
                      $ && p.indexOf(Object.prototype.toString.call($)) > -1
                    );
                  };
            function m($) {
              if (
                (typeof $ != "string" && ($ = String($)),
                /[^a-z0-9\-#$%&'*+.^_`|~!]/i.test($) || $ === "")
              )
                throw new TypeError(
                  'Invalid character in header field name: "' + $ + '"'
                );
              return $.toLowerCase();
            }
            function y($) {
              return typeof $ != "string" && ($ = String($)), $;
            }
            function g($) {
              var M = {
                next: function () {
                  var z = $.shift();
                  return { done: z === void 0, value: z };
                },
              };
              return (
                l.iterable &&
                  (M[Symbol.iterator] = function () {
                    return M;
                  }),
                M
              );
            }
            function v($) {
              (this.map = {}),
                $ instanceof v
                  ? $.forEach(function (M, z) {
                      this.append(z, M);
                    }, this)
                  : Array.isArray($)
                  ? $.forEach(function (M) {
                      if (M.length != 2)
                        throw new TypeError(
                          "Headers constructor: expected name/value pair to be length 2, found" +
                            M.length
                        );
                      this.append(M[0], M[1]);
                    }, this)
                  : $ &&
                    Object.getOwnPropertyNames($).forEach(function (M) {
                      this.append(M, $[M]);
                    }, this);
            }
            (v.prototype.append = function ($, M) {
              ($ = m($)), (M = y(M));
              var z = this.map[$];
              this.map[$] = z ? z + ", " + M : M;
            }),
              (v.prototype.delete = function ($) {
                delete this.map[m($)];
              }),
              (v.prototype.get = function ($) {
                return ($ = m($)), this.has($) ? this.map[$] : null;
              }),
              (v.prototype.has = function ($) {
                return this.map.hasOwnProperty(m($));
              }),
              (v.prototype.set = function ($, M) {
                this.map[m($)] = y(M);
              }),
              (v.prototype.forEach = function ($, M) {
                for (var z in this.map)
                  this.map.hasOwnProperty(z) && $.call(M, this.map[z], z, this);
              }),
              (v.prototype.keys = function () {
                var $ = [];
                return (
                  this.forEach(function (M, z) {
                    $.push(z);
                  }),
                  g($)
                );
              }),
              (v.prototype.values = function () {
                var $ = [];
                return (
                  this.forEach(function (M) {
                    $.push(M);
                  }),
                  g($)
                );
              }),
              (v.prototype.entries = function () {
                var $ = [];
                return (
                  this.forEach(function (M, z) {
                    $.push([z, M]);
                  }),
                  g($)
                );
              }),
              l.iterable &&
                (v.prototype[Symbol.iterator] = v.prototype.entries);
            function b($) {
              if (!$._noBody) {
                if ($.bodyUsed)
                  return Promise.reject(new TypeError("Already read"));
                $.bodyUsed = !0;
              }
            }
            function E($) {
              return new Promise(function (M, z) {
                ($.onload = function () {
                  M($.result);
                }),
                  ($.onerror = function () {
                    z($.error);
                  });
              });
            }
            function S($) {
              var M = new FileReader(),
                z = E(M);
              return M.readAsArrayBuffer($), z;
            }
            function C($) {
              var M = new FileReader(),
                z = E(M),
                B = /charset=([A-Za-z0-9_-]+)/.exec($.type),
                j = B ? B[1] : "utf-8";
              return M.readAsText($, j), z;
            }
            function _($) {
              for (
                var M = new Uint8Array($), z = new Array(M.length), B = 0;
                B < M.length;
                B++
              )
                z[B] = String.fromCharCode(M[B]);
              return z.join("");
            }
            function A($) {
              if ($.slice) return $.slice(0);
              var M = new Uint8Array($.byteLength);
              return M.set(new Uint8Array($)), M.buffer;
            }
            function I() {
              return (
                (this.bodyUsed = !1),
                (this._initBody = function ($) {
                  (this.bodyUsed = this.bodyUsed),
                    (this._bodyInit = $),
                    $
                      ? typeof $ == "string"
                        ? (this._bodyText = $)
                        : l.blob && Blob.prototype.isPrototypeOf($)
                        ? (this._bodyBlob = $)
                        : l.formData && FormData.prototype.isPrototypeOf($)
                        ? (this._bodyFormData = $)
                        : l.searchParams &&
                          URLSearchParams.prototype.isPrototypeOf($)
                        ? (this._bodyText = $.toString())
                        : l.arrayBuffer && l.blob && d($)
                        ? ((this._bodyArrayBuffer = A($.buffer)),
                          (this._bodyInit = new Blob([this._bodyArrayBuffer])))
                        : l.arrayBuffer &&
                          (ArrayBuffer.prototype.isPrototypeOf($) || f($))
                        ? (this._bodyArrayBuffer = A($))
                        : (this._bodyText = $ =
                            Object.prototype.toString.call($))
                      : ((this._noBody = !0), (this._bodyText = "")),
                    this.headers.get("content-type") ||
                      (typeof $ == "string"
                        ? this.headers.set(
                            "content-type",
                            "text/plain;charset=UTF-8"
                          )
                        : this._bodyBlob && this._bodyBlob.type
                        ? this.headers.set("content-type", this._bodyBlob.type)
                        : l.searchParams &&
                          URLSearchParams.prototype.isPrototypeOf($) &&
                          this.headers.set(
                            "content-type",
                            "application/x-www-form-urlencoded;charset=UTF-8"
                          ));
                }),
                l.blob &&
                  (this.blob = function () {
                    var $ = b(this);
                    if ($) return $;
                    if (this._bodyBlob) return Promise.resolve(this._bodyBlob);
                    if (this._bodyArrayBuffer)
                      return Promise.resolve(new Blob([this._bodyArrayBuffer]));
                    if (this._bodyFormData)
                      throw new Error("could not read FormData body as blob");
                    return Promise.resolve(new Blob([this._bodyText]));
                  }),
                (this.arrayBuffer = function () {
                  if (this._bodyArrayBuffer) {
                    var $ = b(this);
                    return (
                      $ ||
                      (ArrayBuffer.isView(this._bodyArrayBuffer)
                        ? Promise.resolve(
                            this._bodyArrayBuffer.buffer.slice(
                              this._bodyArrayBuffer.byteOffset,
                              this._bodyArrayBuffer.byteOffset +
                                this._bodyArrayBuffer.byteLength
                            )
                          )
                        : Promise.resolve(this._bodyArrayBuffer))
                    );
                  } else {
                    if (l.blob) return this.blob().then(S);
                    throw new Error("could not read as ArrayBuffer");
                  }
                }),
                (this.text = function () {
                  var $ = b(this);
                  if ($) return $;
                  if (this._bodyBlob) return C(this._bodyBlob);
                  if (this._bodyArrayBuffer)
                    return Promise.resolve(_(this._bodyArrayBuffer));
                  if (this._bodyFormData)
                    throw new Error("could not read FormData body as text");
                  return Promise.resolve(this._bodyText);
                }),
                l.formData &&
                  (this.formData = function () {
                    return this.text().then(T);
                  }),
                (this.json = function () {
                  return this.text().then(JSON.parse);
                }),
                this
              );
            }
            var R = [
              "CONNECT",
              "DELETE",
              "GET",
              "HEAD",
              "OPTIONS",
              "PATCH",
              "POST",
              "PUT",
              "TRACE",
            ];
            function D($) {
              var M = $.toUpperCase();
              return R.indexOf(M) > -1 ? M : $;
            }
            function k($, M) {
              if (!(this instanceof k))
                throw new TypeError(
                  'Please use the "new" operator, this DOM object constructor cannot be called as a function.'
                );
              M = M || {};
              var z = M.body;
              if ($ instanceof k) {
                if ($.bodyUsed) throw new TypeError("Already read");
                (this.url = $.url),
                  (this.credentials = $.credentials),
                  M.headers || (this.headers = new v($.headers)),
                  (this.method = $.method),
                  (this.mode = $.mode),
                  (this.signal = $.signal),
                  !z &&
                    $._bodyInit != null &&
                    ((z = $._bodyInit), ($.bodyUsed = !0));
              } else this.url = String($);
              if (
                ((this.credentials =
                  M.credentials || this.credentials || "same-origin"),
                (M.headers || !this.headers) &&
                  (this.headers = new v(M.headers)),
                (this.method = D(M.method || this.method || "GET")),
                (this.mode = M.mode || this.mode || null),
                (this.signal =
                  M.signal ||
                  this.signal ||
                  (function () {
                    if ("AbortController" in a) {
                      var V = new AbortController();
                      return V.signal;
                    }
                  })()),
                (this.referrer = null),
                (this.method === "GET" || this.method === "HEAD") && z)
              )
                throw new TypeError(
                  "Body not allowed for GET or HEAD requests"
                );
              if (
                (this._initBody(z),
                (this.method === "GET" || this.method === "HEAD") &&
                  (M.cache === "no-store" || M.cache === "no-cache"))
              ) {
                var B = /([?&])_=[^&]*/;
                if (B.test(this.url))
                  this.url = this.url.replace(B, "$1_=" + new Date().getTime());
                else {
                  var j = /\?/;
                  this.url +=
                    (j.test(this.url) ? "&" : "?") +
                    "_=" +
                    new Date().getTime();
                }
              }
            }
            k.prototype.clone = function () {
              return new k(this, { body: this._bodyInit });
            };
            function T($) {
              var M = new FormData();
              return (
                $.trim()
                  .split("&")
                  .forEach(function (z) {
                    if (z) {
                      var B = z.split("="),
                        j = B.shift().replace(/\+/g, " "),
                        V = B.join("=").replace(/\+/g, " ");
                      M.append(decodeURIComponent(j), decodeURIComponent(V));
                    }
                  }),
                M
              );
            }
            function U($) {
              var M = new v(),
                z = $.replace(/\r?\n[\t ]+/g, " ");
              return (
                z
                  .split("\r")
                  .map(function (B) {
                    return B.indexOf(`
`) === 0
                      ? B.substr(1, B.length)
                      : B;
                  })
                  .forEach(function (B) {
                    var j = B.split(":"),
                      V = j.shift().trim();
                    if (V) {
                      var W = j.join(":").trim();
                      try {
                        M.append(V, W);
                      } catch (Z) {
                        console.warn("Response " + Z.message);
                      }
                    }
                  }),
                M
              );
            }
            I.call(k.prototype);
            function q($, M) {
              if (!(this instanceof q))
                throw new TypeError(
                  'Please use the "new" operator, this DOM object constructor cannot be called as a function.'
                );
              if (
                (M || (M = {}),
                (this.type = "default"),
                (this.status = M.status === void 0 ? 200 : M.status),
                this.status < 200 || this.status > 599)
              )
                throw new RangeError(
                  "Failed to construct 'Response': The status provided (0) is outside the range [200, 599]."
                );
              (this.ok = this.status >= 200 && this.status < 300),
                (this.statusText =
                  M.statusText === void 0 ? "" : "" + M.statusText),
                (this.headers = new v(M.headers)),
                (this.url = M.url || ""),
                this._initBody($);
            }
            I.call(q.prototype),
              (q.prototype.clone = function () {
                return new q(this._bodyInit, {
                  status: this.status,
                  statusText: this.statusText,
                  headers: new v(this.headers),
                  url: this.url,
                });
              }),
              (q.error = function () {
                var $ = new q(null, { status: 200, statusText: "" });
                return ($.ok = !1), ($.status = 0), ($.type = "error"), $;
              });
            var K = [301, 302, 303, 307, 308];
            (q.redirect = function ($, M) {
              if (K.indexOf(M) === -1)
                throw new RangeError("Invalid status code");
              return new q(null, { status: M, headers: { location: $ } });
            }),
              (o.DOMException = a.DOMException);
            try {
              new o.DOMException();
            } catch {
              (o.DOMException = function (M, z) {
                (this.message = M), (this.name = z);
                var B = Error(M);
                this.stack = B.stack;
              }),
                (o.DOMException.prototype = Object.create(Error.prototype)),
                (o.DOMException.prototype.constructor = o.DOMException);
            }
            function H($, M) {
              return new Promise(function (z, B) {
                var j = new k($, M);
                if (j.signal && j.signal.aborted)
                  return B(new o.DOMException("Aborted", "AbortError"));
                var V = new XMLHttpRequest();
                function W() {
                  V.abort();
                }
                (V.onload = function () {
                  var J = {
                    statusText: V.statusText,
                    headers: U(V.getAllResponseHeaders() || ""),
                  };
                  j.url.indexOf("file://") === 0 &&
                  (V.status < 200 || V.status > 599)
                    ? (J.status = 200)
                    : (J.status = V.status),
                    (J.url =
                      "responseURL" in V
                        ? V.responseURL
                        : J.headers.get("X-Request-URL"));
                  var se = "response" in V ? V.response : V.responseText;
                  setTimeout(function () {
                    z(new q(se, J));
                  }, 0);
                }),
                  (V.onerror = function () {
                    setTimeout(function () {
                      B(new TypeError("Network request failed"));
                    }, 0);
                  }),
                  (V.ontimeout = function () {
                    setTimeout(function () {
                      B(new TypeError("Network request timed out"));
                    }, 0);
                  }),
                  (V.onabort = function () {
                    setTimeout(function () {
                      B(new o.DOMException("Aborted", "AbortError"));
                    }, 0);
                  });
                function Z(J) {
                  try {
                    return J === "" && a.location.href ? a.location.href : J;
                  } catch {
                    return J;
                  }
                }
                if (
                  (V.open(j.method, Z(j.url), !0),
                  j.credentials === "include"
                    ? (V.withCredentials = !0)
                    : j.credentials === "omit" && (V.withCredentials = !1),
                  "responseType" in V &&
                    (l.blob
                      ? (V.responseType = "blob")
                      : l.arrayBuffer && (V.responseType = "arraybuffer")),
                  M &&
                    typeof M.headers == "object" &&
                    !(
                      M.headers instanceof v ||
                      (a.Headers && M.headers instanceof a.Headers)
                    ))
                ) {
                  var ee = [];
                  Object.getOwnPropertyNames(M.headers).forEach(function (J) {
                    ee.push(m(J)), V.setRequestHeader(J, y(M.headers[J]));
                  }),
                    j.headers.forEach(function (J, se) {
                      ee.indexOf(se) === -1 && V.setRequestHeader(se, J);
                    });
                } else
                  j.headers.forEach(function (J, se) {
                    V.setRequestHeader(se, J);
                  });
                j.signal &&
                  (j.signal.addEventListener("abort", W),
                  (V.onreadystatechange = function () {
                    V.readyState === 4 &&
                      j.signal.removeEventListener("abort", W);
                  })),
                  V.send(typeof j._bodyInit > "u" ? null : j._bodyInit);
              });
            }
            return (
              (H.polyfill = !0),
              a.fetch ||
                ((a.fetch = H),
                (a.Headers = v),
                (a.Request = k),
                (a.Response = q)),
              (o.Headers = v),
              (o.Request = k),
              (o.Response = q),
              (o.fetch = H),
              Object.defineProperty(o, "__esModule", { value: !0 }),
              o
            );
          })({});
        })(r),
          (r.fetch.ponyfill = !0),
          delete r.fetch.polyfill;
        var i = n.fetch ? n : r;
        (e = i.fetch),
          (e.default = i.fetch),
          (e.fetch = i.fetch),
          (e.Headers = i.Headers),
          (e.Request = i.Request),
          (e.Response = i.Response),
          (t.exports = e);
      })(n0, n0.exports)),
    n0.exports
  );
}
var bce = vce();
const pO = Hc(bce);
var Ece = Object.defineProperty,
  Cce = Object.defineProperties,
  xce = Object.getOwnPropertyDescriptors,
  fO = Object.getOwnPropertySymbols,
  Sce = Object.prototype.hasOwnProperty,
  Ace = Object.prototype.propertyIsEnumerable,
  hO = (t, e, n) =>
    e in t
      ? Ece(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n })
      : (t[e] = n),
  mO = (t, e) => {
    for (var n in e) Sce.call(e, n) && hO(t, n, e[n]);
    if (fO) for (var n of fO(e)) Ace.call(e, n) && hO(t, n, e[n]);
    return t;
  },
  gO = (t, e) => Cce(t, xce(e));
const _ce = { Accept: "application/json", "Content-Type": "application/json" },
  Ice = "POST",
  yO = { headers: _ce, method: Ice },
  wO = 10;
let eo = class {
  constructor(e, n = !1) {
    if (
      ((this.url = e),
      (this.disableProviderPing = n),
      (this.events = new Ss.EventEmitter()),
      (this.isAvailable = !1),
      (this.registering = !1),
      !kN(e))
    )
      throw new Error(
        `Provided URL is not compatible with HTTP connection: ${e}`
      );
    (this.url = e), (this.disableProviderPing = n);
  }
  get connected() {
    return this.isAvailable;
  }
  get connecting() {
    return this.registering;
  }
  on(e, n) {
    this.events.on(e, n);
  }
  once(e, n) {
    this.events.once(e, n);
  }
  off(e, n) {
    this.events.off(e, n);
  }
  removeListener(e, n) {
    this.events.removeListener(e, n);
  }
  async open(e = this.url) {
    await this.register(e);
  }
  async close() {
    if (!this.isAvailable) throw new Error("Connection already closed");
    this.onClose();
  }
  async send(e) {
    this.isAvailable || (await this.register());
    try {
      const n = Aa(e),
        r = await (await pO(this.url, gO(mO({}, yO), { body: n }))).json();
      this.onPayload({ data: r });
    } catch (n) {
      this.onError(e.id, n);
    }
  }
  async register(e = this.url) {
    if (!kN(e))
      throw new Error(
        `Provided URL is not compatible with HTTP connection: ${e}`
      );
    if (this.registering) {
      const n = this.events.getMaxListeners();
      return (
        (this.events.listenerCount("register_error") >= n ||
          this.events.listenerCount("open") >= n) &&
          this.events.setMaxListeners(n + 1),
        new Promise((r, i) => {
          this.events.once("register_error", (s) => {
            this.resetMaxListeners(), i(s);
          }),
            this.events.once("open", () => {
              if ((this.resetMaxListeners(), typeof this.isAvailable > "u"))
                return i(new Error("HTTP connection is missing or invalid"));
              r();
            });
        })
      );
    }
    (this.url = e), (this.registering = !0);
    try {
      if (!this.disableProviderPing) {
        const n = Aa({ id: 1, jsonrpc: "2.0", method: "test", params: [] });
        await pO(e, gO(mO({}, yO), { body: n }));
      }
      this.onOpen();
    } catch (n) {
      const r = this.parseError(n);
      throw (this.events.emit("register_error", r), this.onClose(), r);
    }
  }
  onOpen() {
    (this.isAvailable = !0), (this.registering = !1), this.events.emit("open");
  }
  onClose() {
    (this.isAvailable = !1), (this.registering = !1), this.events.emit("close");
  }
  onPayload(e) {
    if (typeof e.data > "u") return;
    const n = typeof e.data == "string" ? Zl(e.data) : e.data;
    this.events.emit("payload", n);
  }
  onError(e, n) {
    const r = this.parseError(n),
      i = r.message || r.toString(),
      s = Pv(e, i);
    this.events.emit("payload", s);
  }
  parseError(e, n = this.url) {
    return Q$(e, n, "HTTP");
  }
  resetMaxListeners() {
    this.events.getMaxListeners() > wO && this.events.setMaxListeners(wO);
  }
};
const vO = "error",
  Tce = "wss://relay.walletconnect.org",
  Pce = "wc",
  Rce = "universal_provider",
  r0 = `${Pce}@2:${Rce}:`,
  bM = "https://rpc.walletconnect.org/v1/",
  vd = "generic",
  Nce = `${bM}bundler`,
  Is = { DEFAULT_CHAIN_CHANGED: "default_chain_changed" };
function Oce() {}
function LA(t) {
  return t == null || (typeof t != "object" && typeof t != "function");
}
function UA(t) {
  return ArrayBuffer.isView(t) && !(t instanceof DataView);
}
function kce(t) {
  if (LA(t)) return t;
  if (
    Array.isArray(t) ||
    UA(t) ||
    t instanceof ArrayBuffer ||
    (typeof SharedArrayBuffer < "u" && t instanceof SharedArrayBuffer)
  )
    return t.slice(0);
  const e = Object.getPrototypeOf(t),
    n = e.constructor;
  if (t instanceof Date || t instanceof Map || t instanceof Set)
    return new n(t);
  if (t instanceof RegExp) {
    const r = new n(t);
    return (r.lastIndex = t.lastIndex), r;
  }
  if (t instanceof DataView) return new n(t.buffer.slice(0));
  if (t instanceof Error) {
    const r = new n(t.message);
    return (r.stack = t.stack), (r.name = t.name), (r.cause = t.cause), r;
  }
  if (typeof File < "u" && t instanceof File)
    return new n([t], t.name, { type: t.type, lastModified: t.lastModified });
  if (typeof t == "object") {
    const r = Object.create(e);
    return Object.assign(r, t);
  }
  return t;
}
function bO(t) {
  return typeof t == "object" && t !== null;
}
function EM(t) {
  return Object.getOwnPropertySymbols(t).filter((e) =>
    Object.prototype.propertyIsEnumerable.call(t, e)
  );
}
function CM(t) {
  return t == null
    ? t === void 0
      ? "[object Undefined]"
      : "[object Null]"
    : Object.prototype.toString.call(t);
}
const Dce = "[object RegExp]",
  xM = "[object String]",
  SM = "[object Number]",
  AM = "[object Boolean]",
  _M = "[object Arguments]",
  $ce = "[object Symbol]",
  Mce = "[object Date]",
  Lce = "[object Map]",
  Uce = "[object Set]",
  Bce = "[object Array]",
  jce = "[object ArrayBuffer]",
  Fce = "[object Object]",
  zce = "[object DataView]",
  Wce = "[object Uint8Array]",
  Hce = "[object Uint8ClampedArray]",
  qce = "[object Uint16Array]",
  Vce = "[object Uint32Array]",
  Gce = "[object Int8Array]",
  Kce = "[object Int16Array]",
  Yce = "[object Int32Array]",
  Zce = "[object Float32Array]",
  Qce = "[object Float64Array]";
function Xce(t, e) {
  return Ad(t, void 0, t, new Map(), e);
}
function Ad(t, e, n, r = new Map(), i = void 0) {
  const s = i == null ? void 0 : i(t, e, n, r);
  if (s != null) return s;
  if (LA(t)) return t;
  if (r.has(t)) return r.get(t);
  if (Array.isArray(t)) {
    const o = new Array(t.length);
    r.set(t, o);
    for (let a = 0; a < t.length; a++) o[a] = Ad(t[a], a, n, r, i);
    return (
      Object.hasOwn(t, "index") && (o.index = t.index),
      Object.hasOwn(t, "input") && (o.input = t.input),
      o
    );
  }
  if (t instanceof Date) return new Date(t.getTime());
  if (t instanceof RegExp) {
    const o = new RegExp(t.source, t.flags);
    return (o.lastIndex = t.lastIndex), o;
  }
  if (t instanceof Map) {
    const o = new Map();
    r.set(t, o);
    for (const [a, l] of t) o.set(a, Ad(l, a, n, r, i));
    return o;
  }
  if (t instanceof Set) {
    const o = new Set();
    r.set(t, o);
    for (const a of t) o.add(Ad(a, void 0, n, r, i));
    return o;
  }
  if (typeof Buffer < "u" && Buffer.isBuffer(t)) return t.subarray();
  if (UA(t)) {
    const o = new (Object.getPrototypeOf(t).constructor)(t.length);
    r.set(t, o);
    for (let a = 0; a < t.length; a++) o[a] = Ad(t[a], a, n, r, i);
    return o;
  }
  if (
    t instanceof ArrayBuffer ||
    (typeof SharedArrayBuffer < "u" && t instanceof SharedArrayBuffer)
  )
    return t.slice(0);
  if (t instanceof DataView) {
    const o = new DataView(t.buffer.slice(0), t.byteOffset, t.byteLength);
    return r.set(t, o), Al(o, t, n, r, i), o;
  }
  if (typeof File < "u" && t instanceof File) {
    const o = new File([t], t.name, { type: t.type });
    return r.set(t, o), Al(o, t, n, r, i), o;
  }
  if (t instanceof Blob) {
    const o = new Blob([t], { type: t.type });
    return r.set(t, o), Al(o, t, n, r, i), o;
  }
  if (t instanceof Error) {
    const o = new t.constructor();
    return (
      r.set(t, o),
      (o.message = t.message),
      (o.name = t.name),
      (o.stack = t.stack),
      (o.cause = t.cause),
      Al(o, t, n, r, i),
      o
    );
  }
  if (typeof t == "object" && Jce(t)) {
    const o = Object.create(Object.getPrototypeOf(t));
    return r.set(t, o), Al(o, t, n, r, i), o;
  }
  return t;
}
function Al(t, e, n = t, r, i) {
  const s = [...Object.keys(e), ...EM(e)];
  for (let o = 0; o < s.length; o++) {
    const a = s[o],
      l = Object.getOwnPropertyDescriptor(t, a);
    (l == null || l.writable) && (t[a] = Ad(e[a], a, n, r, i));
  }
}
function Jce(t) {
  switch (CM(t)) {
    case _M:
    case Bce:
    case jce:
    case zce:
    case AM:
    case Mce:
    case Zce:
    case Qce:
    case Gce:
    case Kce:
    case Yce:
    case Lce:
    case SM:
    case Fce:
    case Dce:
    case Uce:
    case xM:
    case $ce:
    case Wce:
    case Hce:
    case qce:
    case Vce:
      return !0;
    default:
      return !1;
  }
}
function ele(t, e) {
  return Xce(t, (n, r, i, s) => {
    if (typeof t == "object")
      switch (Object.prototype.toString.call(t)) {
        case SM:
        case xM:
        case AM: {
          const o = new t.constructor(t == null ? void 0 : t.valueOf());
          return Al(o, t), o;
        }
        case _M: {
          const o = {};
          return (
            Al(o, t),
            (o.length = t.length),
            (o[Symbol.iterator] = t[Symbol.iterator]),
            o
          );
        }
        default:
          return;
      }
  });
}
function EO(t) {
  return ele(t);
}
function CO(t) {
  return t !== null && typeof t == "object" && CM(t) === "[object Arguments]";
}
function tle(t) {
  return UA(t);
}
function nle(t) {
  var n;
  if (typeof t != "object" || t == null) return !1;
  if (Object.getPrototypeOf(t) === null) return !0;
  if (Object.prototype.toString.call(t) !== "[object Object]") {
    const r = t[Symbol.toStringTag];
    return r == null ||
      !(
        (n = Object.getOwnPropertyDescriptor(t, Symbol.toStringTag)) != null &&
        n.writable
      )
      ? !1
      : t.toString() === `[object ${r}]`;
  }
  let e = t;
  for (; Object.getPrototypeOf(e) !== null; ) e = Object.getPrototypeOf(e);
  return Object.getPrototypeOf(t) === e;
}
function rle(t, ...e) {
  const n = e.slice(0, -1),
    r = e[e.length - 1];
  let i = t;
  for (let s = 0; s < n.length; s++) {
    const o = n[s];
    i = Yx(i, o, r, new Map());
  }
  return i;
}
function Yx(t, e, n, r) {
  if ((LA(t) && (t = Object(t)), e == null || typeof e != "object")) return t;
  if (r.has(e)) return kce(r.get(e));
  if ((r.set(e, t), Array.isArray(e))) {
    e = e.slice();
    for (let s = 0; s < e.length; s++) e[s] = e[s] ?? void 0;
  }
  const i = [...Object.keys(e), ...EM(e)];
  for (let s = 0; s < i.length; s++) {
    const o = i[s];
    let a = e[o],
      l = t[o];
    if (
      (CO(a) && (a = { ...a }),
      CO(l) && (l = { ...l }),
      typeof Buffer < "u" && Buffer.isBuffer(a) && (a = EO(a)),
      Array.isArray(a))
    )
      if (typeof l == "object" && l != null) {
        const p = [],
          f = Reflect.ownKeys(l);
        for (let m = 0; m < f.length; m++) {
          const y = f[m];
          p[y] = l[y];
        }
        l = p;
      } else l = [];
    const d = n(l, a, o, t, e, r);
    d != null
      ? (t[o] = d)
      : Array.isArray(a) || (bO(l) && bO(a))
      ? (t[o] = Yx(l, a, n, r))
      : l == null && nle(a)
      ? (t[o] = Yx({}, a, n, r))
      : l == null && tle(a)
      ? (t[o] = EO(a))
      : (l === void 0 || a !== void 0) && (t[o] = a);
  }
  return t;
}
function ile(t, ...e) {
  return rle(t, ...e, Oce);
}
var sle = Object.defineProperty,
  ole = Object.defineProperties,
  ale = Object.getOwnPropertyDescriptors,
  xO = Object.getOwnPropertySymbols,
  cle = Object.prototype.hasOwnProperty,
  lle = Object.prototype.propertyIsEnumerable,
  SO = (t, e, n) =>
    e in t
      ? sle(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n })
      : (t[e] = n),
  i0 = (t, e) => {
    for (var n in e || (e = {})) cle.call(e, n) && SO(t, n, e[n]);
    if (xO) for (var n of xO(e)) lle.call(e, n) && SO(t, n, e[n]);
    return t;
  },
  ule = (t, e) => ole(t, ale(e));
function Vi(t, e, n) {
  var r;
  const i = Nd(t);
  return (
    ((r = e.rpcMap) == null ? void 0 : r[i.reference]) ||
    `${bM}?chainId=${i.namespace}:${i.reference}&projectId=${n}`
  );
}
function gu(t) {
  return t.includes(":") ? t.split(":")[1] : t;
}
function IM(t) {
  return t.map((e) => `${e.split(":")[0]}:${e.split(":")[1]}`);
}
function dle(t, e) {
  const n = Object.keys(e.namespaces).filter((i) => i.includes(t));
  if (!n.length) return [];
  const r = [];
  return (
    n.forEach((i) => {
      const s = e.namespaces[i].accounts;
      r.push(...s);
    }),
    r
  );
}
function JE(t = {}, e = {}) {
  const n = AO(t),
    r = AO(e);
  return ile(n, r);
}
function AO(t) {
  var e, n, r, i;
  const s = {};
  if (!Kh(t)) return s;
  for (const [o, a] of Object.entries(t)) {
    const l = OA(o) ? [o] : a.chains,
      d = a.methods || [],
      p = a.events || [],
      f = a.rpcMap || {},
      m = lh(o);
    s[m] = ule(i0(i0({}, s[m]), a), {
      chains: $0(l, (e = s[m]) == null ? void 0 : e.chains),
      methods: $0(d, (n = s[m]) == null ? void 0 : n.methods),
      events: $0(p, (r = s[m]) == null ? void 0 : r.events),
      rpcMap: i0(i0({}, f), (i = s[m]) == null ? void 0 : i.rpcMap),
    });
  }
  return s;
}
function _O(t) {
  return t.includes(":") ? t.split(":")[2] : t;
}
function IO(t) {
  const e = {};
  for (const [n, r] of Object.entries(t)) {
    const i = r.methods || [],
      s = r.events || [],
      o = r.accounts || [],
      a = OA(n) ? [n] : r.chains ? r.chains : IM(r.accounts);
    e[n] = { chains: a, methods: i, events: s, accounts: o };
  }
  return e;
}
function eC(t) {
  return typeof t == "number"
    ? t
    : t.includes("0x")
    ? parseInt(t, 16)
    : ((t = t.includes(":") ? t.split(":")[1] : t),
      isNaN(Number(t)) ? t : Number(t));
}
const TM = {},
  Dt = (t) => TM[t],
  tC = (t, e) => {
    TM[t] = e;
  };
var ple = Object.defineProperty,
  fle = (t, e, n) =>
    e in t
      ? ple(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n })
      : (t[e] = n),
  ed = (t, e, n) => fle(t, typeof e != "symbol" ? e + "" : e, n);
class hle {
  constructor(e) {
    ed(this, "name", "polkadot"),
      ed(this, "client"),
      ed(this, "httpProviders"),
      ed(this, "events"),
      ed(this, "namespace"),
      ed(this, "chainId"),
      (this.namespace = e.namespace),
      (this.events = Dt("events")),
      (this.client = Dt("client")),
      (this.chainId = this.getDefaultChain()),
      (this.httpProviders = this.createHttpProviders());
  }
  updateNamespace(e) {
    this.namespace = Object.assign(this.namespace, e);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const e = this.namespace.chains[0];
    if (!e) throw new Error("ChainId not found");
    return e.split(":")[1];
  }
  request(e) {
    return this.namespace.methods.includes(e.request.method)
      ? this.client.request(e)
      : this.getHttpProvider().request(e.request);
  }
  setDefaultChain(e, n) {
    this.httpProviders[e] || this.setHttpProvider(e, n),
      (this.chainId = e),
      this.events.emit(Is.DEFAULT_CHAIN_CHANGED, `${this.name}:${e}`);
  }
  getAccounts() {
    const e = this.namespace.accounts;
    return e
      ? e
          .filter((n) => n.split(":")[1] === this.chainId.toString())
          .map((n) => n.split(":")[2]) || []
      : [];
  }
  createHttpProviders() {
    const e = {};
    return (
      this.namespace.chains.forEach((n) => {
        var r;
        const i = gu(n);
        e[i] = this.createHttpProvider(
          i,
          (r = this.namespace.rpcMap) == null ? void 0 : r[n]
        );
      }),
      e
    );
  }
  getHttpProvider() {
    const e = `${this.name}:${this.chainId}`,
      n = this.httpProviders[e];
    if (typeof n > "u") throw new Error(`JSON-RPC provider for ${e} not found`);
    return n;
  }
  setHttpProvider(e, n) {
    const r = this.createHttpProvider(e, n);
    r && (this.httpProviders[e] = r);
  }
  createHttpProvider(e, n) {
    const r = n || Vi(e, this.namespace, this.client.core.projectId);
    if (!r) throw new Error(`No RPC url provided for chainId: ${e}`);
    return new _s(new eo(r, Dt("disableProviderPing")));
  }
}
var mle = Object.defineProperty,
  gle = Object.defineProperties,
  yle = Object.getOwnPropertyDescriptors,
  TO = Object.getOwnPropertySymbols,
  wle = Object.prototype.hasOwnProperty,
  vle = Object.prototype.propertyIsEnumerable,
  Zx = (t, e, n) =>
    e in t
      ? mle(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n })
      : (t[e] = n),
  PO = (t, e) => {
    for (var n in e || (e = {})) wle.call(e, n) && Zx(t, n, e[n]);
    if (TO) for (var n of TO(e)) vle.call(e, n) && Zx(t, n, e[n]);
    return t;
  },
  RO = (t, e) => gle(t, yle(e)),
  td = (t, e, n) => Zx(t, typeof e != "symbol" ? e + "" : e, n);
class ble {
  constructor(e) {
    td(this, "name", "eip155"),
      td(this, "client"),
      td(this, "chainId"),
      td(this, "namespace"),
      td(this, "httpProviders"),
      td(this, "events"),
      (this.namespace = e.namespace),
      (this.events = Dt("events")),
      (this.client = Dt("client")),
      (this.httpProviders = this.createHttpProviders()),
      (this.chainId = parseInt(this.getDefaultChain()));
  }
  async request(e) {
    switch (e.request.method) {
      case "eth_requestAccounts":
        return this.getAccounts();
      case "eth_accounts":
        return this.getAccounts();
      case "wallet_switchEthereumChain":
        return await this.handleSwitchChain(e);
      case "eth_chainId":
        return parseInt(this.getDefaultChain());
      case "wallet_getCapabilities":
        return await this.getCapabilities(e);
      case "wallet_getCallsStatus":
        return await this.getCallStatus(e);
    }
    return this.namespace.methods.includes(e.request.method)
      ? await this.client.request(e)
      : this.getHttpProvider().request(e.request);
  }
  updateNamespace(e) {
    this.namespace = Object.assign(this.namespace, e);
  }
  setDefaultChain(e, n) {
    this.httpProviders[e] || this.setHttpProvider(parseInt(e), n),
      (this.chainId = parseInt(e)),
      this.events.emit(Is.DEFAULT_CHAIN_CHANGED, `${this.name}:${e}`);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId.toString();
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const e = this.namespace.chains[0];
    if (!e) throw new Error("ChainId not found");
    return e.split(":")[1];
  }
  createHttpProvider(e, n) {
    const r =
      n || Vi(`${this.name}:${e}`, this.namespace, this.client.core.projectId);
    if (!r) throw new Error(`No RPC url provided for chainId: ${e}`);
    return new _s(new eo(r, Dt("disableProviderPing")));
  }
  setHttpProvider(e, n) {
    const r = this.createHttpProvider(e, n);
    r && (this.httpProviders[e] = r);
  }
  createHttpProviders() {
    const e = {};
    return (
      this.namespace.chains.forEach((n) => {
        var r;
        const i = parseInt(gu(n));
        e[i] = this.createHttpProvider(
          i,
          (r = this.namespace.rpcMap) == null ? void 0 : r[n]
        );
      }),
      e
    );
  }
  getAccounts() {
    const e = this.namespace.accounts;
    return e
      ? [
          ...new Set(
            e
              .filter((n) => n.split(":")[1] === this.chainId.toString())
              .map((n) => n.split(":")[2])
          ),
        ]
      : [];
  }
  getHttpProvider() {
    const e = this.chainId,
      n = this.httpProviders[e];
    if (typeof n > "u") throw new Error(`JSON-RPC provider for ${e} not found`);
    return n;
  }
  async handleSwitchChain(e) {
    var n, r;
    let i = e.request.params
      ? (n = e.request.params[0]) == null
        ? void 0
        : n.chainId
      : "0x0";
    i = i.startsWith("0x") ? i : `0x${i}`;
    const s = parseInt(i, 16);
    if (this.isChainApproved(s)) this.setDefaultChain(`${s}`);
    else if (this.namespace.methods.includes("wallet_switchEthereumChain"))
      await this.client.request({
        topic: e.topic,
        request: { method: e.request.method, params: [{ chainId: i }] },
        chainId: (r = this.namespace.chains) == null ? void 0 : r[0],
      }),
        this.setDefaultChain(`${s}`);
    else
      throw new Error(
        `Failed to switch to chain 'eip155:${s}'. The chain is not approved or the wallet does not support 'wallet_switchEthereumChain' method.`
      );
    return null;
  }
  isChainApproved(e) {
    return this.namespace.chains.includes(`${this.name}:${e}`);
  }
  async getCapabilities(e) {
    var n, r, i;
    const s =
      (r = (n = e.request) == null ? void 0 : n.params) == null ? void 0 : r[0];
    if (!s)
      throw new Error(
        "Missing address parameter in `wallet_getCapabilities` request"
      );
    const o = this.client.session.get(e.topic),
      a =
        ((i = o == null ? void 0 : o.sessionProperties) == null
          ? void 0
          : i.capabilities) || {};
    if (a != null && a[s]) return a == null ? void 0 : a[s];
    const l = await this.client.request(e);
    try {
      await this.client.session.update(e.topic, {
        sessionProperties: RO(PO({}, o.sessionProperties || {}), {
          capabilities: RO(PO({}, a || {}), { [s]: l }),
        }),
      });
    } catch (d) {
      console.warn("Failed to update session with capabilities", d);
    }
    return l;
  }
  async getCallStatus(e) {
    var n, r;
    const i = this.client.session.get(e.topic),
      s = (n = i.sessionProperties) == null ? void 0 : n.bundler_name;
    if (s) {
      const a = this.getBundlerUrl(e.chainId, s);
      try {
        return await this.getUserOperationReceipt(a, e);
      } catch (l) {
        console.warn("Failed to fetch call status from bundler", l, a);
      }
    }
    const o = (r = i.sessionProperties) == null ? void 0 : r.bundler_url;
    if (o)
      try {
        return await this.getUserOperationReceipt(o, e);
      } catch (a) {
        console.warn("Failed to fetch call status from custom bundler", a, o);
      }
    if (this.namespace.methods.includes(e.request.method))
      return await this.client.request(e);
    throw new Error("Fetching call status not approved by the wallet.");
  }
  async getUserOperationReceipt(e, n) {
    var r;
    const i = new URL(e),
      s = await fetch(i, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(
          Tc("eth_getUserOperationReceipt", [
            (r = n.request.params) == null ? void 0 : r[0],
          ])
        ),
      });
    if (!s.ok)
      throw new Error(`Failed to fetch user operation receipt - ${s.status}`);
    return await s.json();
  }
  getBundlerUrl(e, n) {
    return `${Nce}?projectId=${this.client.core.projectId}&chainId=${e}&bundler=${n}`;
  }
}
var Ele = Object.defineProperty,
  Cle = (t, e, n) =>
    e in t
      ? Ele(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n })
      : (t[e] = n),
  nd = (t, e, n) => Cle(t, typeof e != "symbol" ? e + "" : e, n);
class xle {
  constructor(e) {
    nd(this, "name", "solana"),
      nd(this, "client"),
      nd(this, "httpProviders"),
      nd(this, "events"),
      nd(this, "namespace"),
      nd(this, "chainId"),
      (this.namespace = e.namespace),
      (this.events = Dt("events")),
      (this.client = Dt("client")),
      (this.chainId = this.getDefaultChain()),
      (this.httpProviders = this.createHttpProviders());
  }
  updateNamespace(e) {
    this.namespace = Object.assign(this.namespace, e);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  request(e) {
    return this.namespace.methods.includes(e.request.method)
      ? this.client.request(e)
      : this.getHttpProvider().request(e.request);
  }
  setDefaultChain(e, n) {
    this.httpProviders[e] || this.setHttpProvider(e, n),
      (this.chainId = e),
      this.events.emit(Is.DEFAULT_CHAIN_CHANGED, `${this.name}:${e}`);
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const e = this.namespace.chains[0];
    if (!e) throw new Error("ChainId not found");
    return e.split(":")[1];
  }
  getAccounts() {
    const e = this.namespace.accounts;
    return e
      ? [
          ...new Set(
            e
              .filter((n) => n.split(":")[1] === this.chainId.toString())
              .map((n) => n.split(":")[2])
          ),
        ]
      : [];
  }
  createHttpProviders() {
    const e = {};
    return (
      this.namespace.chains.forEach((n) => {
        var r;
        const i = gu(n);
        e[i] = this.createHttpProvider(
          i,
          (r = this.namespace.rpcMap) == null ? void 0 : r[n]
        );
      }),
      e
    );
  }
  getHttpProvider() {
    const e = `${this.name}:${this.chainId}`,
      n = this.httpProviders[e];
    if (typeof n > "u") throw new Error(`JSON-RPC provider for ${e} not found`);
    return n;
  }
  setHttpProvider(e, n) {
    const r = this.createHttpProvider(e, n);
    r && (this.httpProviders[e] = r);
  }
  createHttpProvider(e, n) {
    const r = n || Vi(e, this.namespace, this.client.core.projectId);
    if (!r) throw new Error(`No RPC url provided for chainId: ${e}`);
    return new _s(new eo(r, Dt("disableProviderPing")));
  }
}
var Sle = Object.defineProperty,
  Ale = (t, e, n) =>
    e in t
      ? Sle(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n })
      : (t[e] = n),
  rd = (t, e, n) => Ale(t, typeof e != "symbol" ? e + "" : e, n);
class _le {
  constructor(e) {
    rd(this, "name", "cosmos"),
      rd(this, "client"),
      rd(this, "httpProviders"),
      rd(this, "events"),
      rd(this, "namespace"),
      rd(this, "chainId"),
      (this.namespace = e.namespace),
      (this.events = Dt("events")),
      (this.client = Dt("client")),
      (this.chainId = this.getDefaultChain()),
      (this.httpProviders = this.createHttpProviders());
  }
  updateNamespace(e) {
    this.namespace = Object.assign(this.namespace, e);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const e = this.namespace.chains[0];
    if (!e) throw new Error("ChainId not found");
    return e.split(":")[1];
  }
  request(e) {
    return this.namespace.methods.includes(e.request.method)
      ? this.client.request(e)
      : this.getHttpProvider().request(e.request);
  }
  setDefaultChain(e, n) {
    this.httpProviders[e] || this.setHttpProvider(e, n),
      (this.chainId = e),
      this.events.emit(
        Is.DEFAULT_CHAIN_CHANGED,
        `${this.name}:${this.chainId}`
      );
  }
  getAccounts() {
    const e = this.namespace.accounts;
    return e
      ? [
          ...new Set(
            e
              .filter((n) => n.split(":")[1] === this.chainId.toString())
              .map((n) => n.split(":")[2])
          ),
        ]
      : [];
  }
  createHttpProviders() {
    const e = {};
    return (
      this.namespace.chains.forEach((n) => {
        var r;
        const i = gu(n);
        e[i] = this.createHttpProvider(
          i,
          (r = this.namespace.rpcMap) == null ? void 0 : r[n]
        );
      }),
      e
    );
  }
  getHttpProvider() {
    const e = `${this.name}:${this.chainId}`,
      n = this.httpProviders[e];
    if (typeof n > "u") throw new Error(`JSON-RPC provider for ${e} not found`);
    return n;
  }
  setHttpProvider(e, n) {
    const r = this.createHttpProvider(e, n);
    r && (this.httpProviders[e] = r);
  }
  createHttpProvider(e, n) {
    const r = n || Vi(e, this.namespace, this.client.core.projectId);
    if (!r) throw new Error(`No RPC url provided for chainId: ${e}`);
    return new _s(new eo(r, Dt("disableProviderPing")));
  }
}
var Ile = Object.defineProperty,
  Tle = (t, e, n) =>
    e in t
      ? Ile(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n })
      : (t[e] = n),
  id = (t, e, n) => Tle(t, typeof e != "symbol" ? e + "" : e, n);
class Ple {
  constructor(e) {
    id(this, "name", "algorand"),
      id(this, "client"),
      id(this, "httpProviders"),
      id(this, "events"),
      id(this, "namespace"),
      id(this, "chainId"),
      (this.namespace = e.namespace),
      (this.events = Dt("events")),
      (this.client = Dt("client")),
      (this.chainId = this.getDefaultChain()),
      (this.httpProviders = this.createHttpProviders());
  }
  updateNamespace(e) {
    this.namespace = Object.assign(this.namespace, e);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  request(e) {
    return this.namespace.methods.includes(e.request.method)
      ? this.client.request(e)
      : this.getHttpProvider().request(e.request);
  }
  setDefaultChain(e, n) {
    if (!this.httpProviders[e]) {
      const r =
        n ||
        Vi(`${this.name}:${e}`, this.namespace, this.client.core.projectId);
      if (!r) throw new Error(`No RPC url provided for chainId: ${e}`);
      this.setHttpProvider(e, r);
    }
    (this.chainId = e),
      this.events.emit(
        Is.DEFAULT_CHAIN_CHANGED,
        `${this.name}:${this.chainId}`
      );
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const e = this.namespace.chains[0];
    if (!e) throw new Error("ChainId not found");
    return e.split(":")[1];
  }
  getAccounts() {
    const e = this.namespace.accounts;
    return e
      ? [
          ...new Set(
            e
              .filter((n) => n.split(":")[1] === this.chainId.toString())
              .map((n) => n.split(":")[2])
          ),
        ]
      : [];
  }
  createHttpProviders() {
    const e = {};
    return (
      this.namespace.chains.forEach((n) => {
        var r;
        e[n] = this.createHttpProvider(
          n,
          (r = this.namespace.rpcMap) == null ? void 0 : r[n]
        );
      }),
      e
    );
  }
  getHttpProvider() {
    const e = `${this.name}:${this.chainId}`,
      n = this.httpProviders[e];
    if (typeof n > "u") throw new Error(`JSON-RPC provider for ${e} not found`);
    return n;
  }
  setHttpProvider(e, n) {
    const r = this.createHttpProvider(e, n);
    r && (this.httpProviders[e] = r);
  }
  createHttpProvider(e, n) {
    const r = n || Vi(e, this.namespace, this.client.core.projectId);
    return typeof r > "u"
      ? void 0
      : new _s(new eo(r, Dt("disableProviderPing")));
  }
}
var Rle = Object.defineProperty,
  Nle = (t, e, n) =>
    e in t
      ? Rle(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n })
      : (t[e] = n),
  sd = (t, e, n) => Nle(t, typeof e != "symbol" ? e + "" : e, n);
class Ole {
  constructor(e) {
    sd(this, "name", "cip34"),
      sd(this, "client"),
      sd(this, "httpProviders"),
      sd(this, "events"),
      sd(this, "namespace"),
      sd(this, "chainId"),
      (this.namespace = e.namespace),
      (this.events = Dt("events")),
      (this.client = Dt("client")),
      (this.chainId = this.getDefaultChain()),
      (this.httpProviders = this.createHttpProviders());
  }
  updateNamespace(e) {
    this.namespace = Object.assign(this.namespace, e);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const e = this.namespace.chains[0];
    if (!e) throw new Error("ChainId not found");
    return e.split(":")[1];
  }
  request(e) {
    return this.namespace.methods.includes(e.request.method)
      ? this.client.request(e)
      : this.getHttpProvider().request(e.request);
  }
  setDefaultChain(e, n) {
    this.httpProviders[e] || this.setHttpProvider(e, n),
      (this.chainId = e),
      this.events.emit(
        Is.DEFAULT_CHAIN_CHANGED,
        `${this.name}:${this.chainId}`
      );
  }
  getAccounts() {
    const e = this.namespace.accounts;
    return e
      ? [
          ...new Set(
            e
              .filter((n) => n.split(":")[1] === this.chainId.toString())
              .map((n) => n.split(":")[2])
          ),
        ]
      : [];
  }
  createHttpProviders() {
    const e = {};
    return (
      this.namespace.chains.forEach((n) => {
        const r = this.getCardanoRPCUrl(n),
          i = gu(n);
        e[i] = this.createHttpProvider(i, r);
      }),
      e
    );
  }
  getHttpProvider() {
    const e = `${this.name}:${this.chainId}`,
      n = this.httpProviders[e];
    if (typeof n > "u") throw new Error(`JSON-RPC provider for ${e} not found`);
    return n;
  }
  getCardanoRPCUrl(e) {
    const n = this.namespace.rpcMap;
    if (n) return n[e];
  }
  setHttpProvider(e, n) {
    const r = this.createHttpProvider(e, n);
    r && (this.httpProviders[e] = r);
  }
  createHttpProvider(e, n) {
    const r = n || this.getCardanoRPCUrl(e);
    if (!r) throw new Error(`No RPC url provided for chainId: ${e}`);
    return new _s(new eo(r, Dt("disableProviderPing")));
  }
}
var kle = Object.defineProperty,
  Dle = (t, e, n) =>
    e in t
      ? kle(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n })
      : (t[e] = n),
  od = (t, e, n) => Dle(t, typeof e != "symbol" ? e + "" : e, n);
class $le {
  constructor(e) {
    od(this, "name", "elrond"),
      od(this, "client"),
      od(this, "httpProviders"),
      od(this, "events"),
      od(this, "namespace"),
      od(this, "chainId"),
      (this.namespace = e.namespace),
      (this.events = Dt("events")),
      (this.client = Dt("client")),
      (this.chainId = this.getDefaultChain()),
      (this.httpProviders = this.createHttpProviders());
  }
  updateNamespace(e) {
    this.namespace = Object.assign(this.namespace, e);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  request(e) {
    return this.namespace.methods.includes(e.request.method)
      ? this.client.request(e)
      : this.getHttpProvider().request(e.request);
  }
  setDefaultChain(e, n) {
    this.httpProviders[e] || this.setHttpProvider(e, n),
      (this.chainId = e),
      this.events.emit(Is.DEFAULT_CHAIN_CHANGED, `${this.name}:${e}`);
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const e = this.namespace.chains[0];
    if (!e) throw new Error("ChainId not found");
    return e.split(":")[1];
  }
  getAccounts() {
    const e = this.namespace.accounts;
    return e
      ? [
          ...new Set(
            e
              .filter((n) => n.split(":")[1] === this.chainId.toString())
              .map((n) => n.split(":")[2])
          ),
        ]
      : [];
  }
  createHttpProviders() {
    const e = {};
    return (
      this.namespace.chains.forEach((n) => {
        var r;
        const i = gu(n);
        e[i] = this.createHttpProvider(
          i,
          (r = this.namespace.rpcMap) == null ? void 0 : r[n]
        );
      }),
      e
    );
  }
  getHttpProvider() {
    const e = `${this.name}:${this.chainId}`,
      n = this.httpProviders[e];
    if (typeof n > "u") throw new Error(`JSON-RPC provider for ${e} not found`);
    return n;
  }
  setHttpProvider(e, n) {
    const r = this.createHttpProvider(e, n);
    r && (this.httpProviders[e] = r);
  }
  createHttpProvider(e, n) {
    const r = n || Vi(e, this.namespace, this.client.core.projectId);
    if (!r) throw new Error(`No RPC url provided for chainId: ${e}`);
    return new _s(new eo(r, Dt("disableProviderPing")));
  }
}
var Mle = Object.defineProperty,
  Lle = (t, e, n) =>
    e in t
      ? Mle(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n })
      : (t[e] = n),
  ad = (t, e, n) => Lle(t, typeof e != "symbol" ? e + "" : e, n);
class Ule {
  constructor(e) {
    ad(this, "name", "multiversx"),
      ad(this, "client"),
      ad(this, "httpProviders"),
      ad(this, "events"),
      ad(this, "namespace"),
      ad(this, "chainId"),
      (this.namespace = e.namespace),
      (this.events = Dt("events")),
      (this.client = Dt("client")),
      (this.chainId = this.getDefaultChain()),
      (this.httpProviders = this.createHttpProviders());
  }
  updateNamespace(e) {
    this.namespace = Object.assign(this.namespace, e);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  request(e) {
    return this.namespace.methods.includes(e.request.method)
      ? this.client.request(e)
      : this.getHttpProvider().request(e.request);
  }
  setDefaultChain(e, n) {
    this.httpProviders[e] || this.setHttpProvider(e, n),
      (this.chainId = e),
      this.events.emit(Is.DEFAULT_CHAIN_CHANGED, `${this.name}:${e}`);
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const e = this.namespace.chains[0];
    if (!e) throw new Error("ChainId not found");
    return e.split(":")[1];
  }
  getAccounts() {
    const e = this.namespace.accounts;
    return e
      ? [
          ...new Set(
            e
              .filter((n) => n.split(":")[1] === this.chainId.toString())
              .map((n) => n.split(":")[2])
          ),
        ]
      : [];
  }
  createHttpProviders() {
    const e = {};
    return (
      this.namespace.chains.forEach((n) => {
        var r;
        const i = gu(n);
        e[i] = this.createHttpProvider(
          i,
          (r = this.namespace.rpcMap) == null ? void 0 : r[n]
        );
      }),
      e
    );
  }
  getHttpProvider() {
    const e = `${this.name}:${this.chainId}`,
      n = this.httpProviders[e];
    if (typeof n > "u") throw new Error(`JSON-RPC provider for ${e} not found`);
    return n;
  }
  setHttpProvider(e, n) {
    const r = this.createHttpProvider(e, n);
    r && (this.httpProviders[e] = r);
  }
  createHttpProvider(e, n) {
    const r = n || Vi(e, this.namespace, this.client.core.projectId);
    if (!r) throw new Error(`No RPC url provided for chainId: ${e}`);
    return new _s(new eo(r, Dt("disableProviderPing")));
  }
}
var Ble = Object.defineProperty,
  jle = (t, e, n) =>
    e in t
      ? Ble(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n })
      : (t[e] = n),
  cd = (t, e, n) => jle(t, typeof e != "symbol" ? e + "" : e, n);
class Fle {
  constructor(e) {
    cd(this, "name", "near"),
      cd(this, "client"),
      cd(this, "httpProviders"),
      cd(this, "events"),
      cd(this, "namespace"),
      cd(this, "chainId"),
      (this.namespace = e.namespace),
      (this.events = Dt("events")),
      (this.client = Dt("client")),
      (this.chainId = this.getDefaultChain()),
      (this.httpProviders = this.createHttpProviders());
  }
  updateNamespace(e) {
    this.namespace = Object.assign(this.namespace, e);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const e = this.namespace.chains[0];
    if (!e) throw new Error("ChainId not found");
    return e.split(":")[1];
  }
  request(e) {
    return this.namespace.methods.includes(e.request.method)
      ? this.client.request(e)
      : this.getHttpProvider().request(e.request);
  }
  setDefaultChain(e, n) {
    if (((this.chainId = e), !this.httpProviders[e])) {
      const r = n || Vi(`${this.name}:${e}`, this.namespace);
      if (!r) throw new Error(`No RPC url provided for chainId: ${e}`);
      this.setHttpProvider(e, r);
    }
    this.events.emit(Is.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);
  }
  getAccounts() {
    const e = this.namespace.accounts;
    return e
      ? e
          .filter((n) => n.split(":")[1] === this.chainId.toString())
          .map((n) => n.split(":")[2]) || []
      : [];
  }
  createHttpProviders() {
    const e = {};
    return (
      this.namespace.chains.forEach((n) => {
        var r;
        e[n] = this.createHttpProvider(
          n,
          (r = this.namespace.rpcMap) == null ? void 0 : r[n]
        );
      }),
      e
    );
  }
  getHttpProvider() {
    const e = `${this.name}:${this.chainId}`,
      n = this.httpProviders[e];
    if (typeof n > "u") throw new Error(`JSON-RPC provider for ${e} not found`);
    return n;
  }
  setHttpProvider(e, n) {
    const r = this.createHttpProvider(e, n);
    r && (this.httpProviders[e] = r);
  }
  createHttpProvider(e, n) {
    const r = n || Vi(e, this.namespace);
    return typeof r > "u"
      ? void 0
      : new _s(new eo(r, Dt("disableProviderPing")));
  }
}
var zle = Object.defineProperty,
  Wle = (t, e, n) =>
    e in t
      ? zle(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n })
      : (t[e] = n),
  ld = (t, e, n) => Wle(t, typeof e != "symbol" ? e + "" : e, n);
class Hle {
  constructor(e) {
    ld(this, "name", "tezos"),
      ld(this, "client"),
      ld(this, "httpProviders"),
      ld(this, "events"),
      ld(this, "namespace"),
      ld(this, "chainId"),
      (this.namespace = e.namespace),
      (this.events = Dt("events")),
      (this.client = Dt("client")),
      (this.chainId = this.getDefaultChain()),
      (this.httpProviders = this.createHttpProviders());
  }
  updateNamespace(e) {
    this.namespace = Object.assign(this.namespace, e);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const e = this.namespace.chains[0];
    if (!e) throw new Error("ChainId not found");
    return e.split(":")[1];
  }
  request(e) {
    return this.namespace.methods.includes(e.request.method)
      ? this.client.request(e)
      : this.getHttpProvider().request(e.request);
  }
  setDefaultChain(e, n) {
    if (((this.chainId = e), !this.httpProviders[e])) {
      const r = n || Vi(`${this.name}:${e}`, this.namespace);
      if (!r) throw new Error(`No RPC url provided for chainId: ${e}`);
      this.setHttpProvider(e, r);
    }
    this.events.emit(Is.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);
  }
  getAccounts() {
    const e = this.namespace.accounts;
    return e
      ? e
          .filter((n) => n.split(":")[1] === this.chainId.toString())
          .map((n) => n.split(":")[2]) || []
      : [];
  }
  createHttpProviders() {
    const e = {};
    return (
      this.namespace.chains.forEach((n) => {
        e[n] = this.createHttpProvider(n);
      }),
      e
    );
  }
  getHttpProvider() {
    const e = `${this.name}:${this.chainId}`,
      n = this.httpProviders[e];
    if (typeof n > "u") throw new Error(`JSON-RPC provider for ${e} not found`);
    return n;
  }
  setHttpProvider(e, n) {
    const r = this.createHttpProvider(e, n);
    r && (this.httpProviders[e] = r);
  }
  createHttpProvider(e, n) {
    const r = n || Vi(e, this.namespace);
    return typeof r > "u" ? void 0 : new _s(new eo(r));
  }
}
var qle = Object.defineProperty,
  Vle = (t, e, n) =>
    e in t
      ? qle(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n })
      : (t[e] = n),
  ud = (t, e, n) => Vle(t, typeof e != "symbol" ? e + "" : e, n);
class Gle {
  constructor(e) {
    ud(this, "name", vd),
      ud(this, "client"),
      ud(this, "httpProviders"),
      ud(this, "events"),
      ud(this, "namespace"),
      ud(this, "chainId"),
      (this.namespace = e.namespace),
      (this.events = Dt("events")),
      (this.client = Dt("client")),
      (this.chainId = this.getDefaultChain()),
      (this.httpProviders = this.createHttpProviders());
  }
  updateNamespace(e) {
    (this.namespace.chains = [
      ...new Set((this.namespace.chains || []).concat(e.chains || [])),
    ]),
      (this.namespace.accounts = [
        ...new Set((this.namespace.accounts || []).concat(e.accounts || [])),
      ]),
      (this.namespace.methods = [
        ...new Set((this.namespace.methods || []).concat(e.methods || [])),
      ]),
      (this.namespace.events = [
        ...new Set((this.namespace.events || []).concat(e.events || [])),
      ]),
      (this.httpProviders = this.createHttpProviders());
  }
  requestAccounts() {
    return this.getAccounts();
  }
  request(e) {
    return this.namespace.methods.includes(e.request.method)
      ? this.client.request(e)
      : this.getHttpProvider(e.chainId).request(e.request);
  }
  setDefaultChain(e, n) {
    this.httpProviders[e] || this.setHttpProvider(e, n),
      (this.chainId = e),
      this.events.emit(Is.DEFAULT_CHAIN_CHANGED, `${this.name}:${e}`);
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const e = this.namespace.chains[0];
    if (!e) throw new Error("ChainId not found");
    return e.split(":")[1];
  }
  getAccounts() {
    const e = this.namespace.accounts;
    return e
      ? [
          ...new Set(
            e
              .filter((n) => n.split(":")[1] === this.chainId.toString())
              .map((n) => n.split(":")[2])
          ),
        ]
      : [];
  }
  createHttpProviders() {
    var e, n;
    const r = {};
    return (
      (n = (e = this.namespace) == null ? void 0 : e.accounts) == null ||
        n.forEach((i) => {
          const s = Nd(i);
          r[`${s.namespace}:${s.reference}`] = this.createHttpProvider(i);
        }),
      r
    );
  }
  getHttpProvider(e) {
    const n = this.httpProviders[e];
    if (typeof n > "u") throw new Error(`JSON-RPC provider for ${e} not found`);
    return n;
  }
  setHttpProvider(e, n) {
    const r = this.createHttpProvider(e, n);
    r && (this.httpProviders[e] = r);
  }
  createHttpProvider(e, n) {
    const r = n || Vi(e, this.namespace, this.client.core.projectId);
    if (!r) throw new Error(`No RPC url provided for chainId: ${e}`);
    return new _s(new eo(r, Dt("disableProviderPing")));
  }
}
var Kle = Object.defineProperty,
  Yle = Object.defineProperties,
  Zle = Object.getOwnPropertyDescriptors,
  NO = Object.getOwnPropertySymbols,
  Qle = Object.prototype.hasOwnProperty,
  Xle = Object.prototype.propertyIsEnumerable,
  Qx = (t, e, n) =>
    e in t
      ? Kle(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n })
      : (t[e] = n),
  s0 = (t, e) => {
    for (var n in e || (e = {})) Qle.call(e, n) && Qx(t, n, e[n]);
    if (NO) for (var n of NO(e)) Xle.call(e, n) && Qx(t, n, e[n]);
    return t;
  },
  nC = (t, e) => Yle(t, Zle(e)),
  rs = (t, e, n) => Qx(t, typeof e != "symbol" ? e + "" : e, n);
let Jle = class PM {
  constructor(e) {
    rs(this, "client"),
      rs(this, "namespaces"),
      rs(this, "optionalNamespaces"),
      rs(this, "sessionProperties"),
      rs(this, "scopedProperties"),
      rs(this, "events", new mA()),
      rs(this, "rpcProviders", {}),
      rs(this, "session"),
      rs(this, "providerOpts"),
      rs(this, "logger"),
      rs(this, "uri"),
      rs(this, "disableProviderPing", !1),
      (this.providerOpts = e),
      (this.logger =
        typeof (e == null ? void 0 : e.logger) < "u" &&
        typeof (e == null ? void 0 : e.logger) != "string"
          ? e.logger
          : Ym(_p({ level: (e == null ? void 0 : e.logger) || vO }))),
      (this.disableProviderPing =
        (e == null ? void 0 : e.disableProviderPing) || !1);
  }
  static async init(e) {
    const n = new PM(e);
    return await n.initialize(), n;
  }
  async request(e, n, r) {
    const [i, s] = this.validateChain(n);
    if (!this.session)
      throw new Error("Please call connect() before request()");
    return await this.getProvider(i).request({
      request: s0({}, e),
      chainId: `${i}:${s}`,
      topic: this.session.topic,
      expiry: r,
    });
  }
  sendAsync(e, n, r, i) {
    const s = new Date().getTime();
    this.request(e, r, i)
      .then((o) => n(null, Tv(s, o)))
      .catch((o) => n(o, void 0));
  }
  async enable() {
    if (!this.client) throw new Error("Sign Client not initialized");
    return (
      this.session ||
        (await this.connect({
          namespaces: this.namespaces,
          optionalNamespaces: this.optionalNamespaces,
          sessionProperties: this.sessionProperties,
          scopedProperties: this.scopedProperties,
        })),
      await this.requestAccounts()
    );
  }
  async disconnect() {
    var e;
    if (!this.session) throw new Error("Please call connect() before enable()");
    await this.client.disconnect({
      topic: (e = this.session) == null ? void 0 : e.topic,
      reason: Kt("USER_DISCONNECTED"),
    }),
      await this.cleanup();
  }
  async connect(e) {
    if (!this.client) throw new Error("Sign Client not initialized");
    if (
      (this.setNamespaces(e),
      await this.cleanupPendingPairings(),
      !e.skipPairing)
    )
      return await this.pair(e.pairingTopic);
  }
  async authenticate(e, n) {
    if (!this.client) throw new Error("Sign Client not initialized");
    this.setNamespaces(e), await this.cleanupPendingPairings();
    const { uri: r, response: i } = await this.client.authenticate(e, n);
    r && ((this.uri = r), this.events.emit("display_uri", r));
    const s = await i();
    if (((this.session = s.session), this.session)) {
      const o = IO(this.session.namespaces);
      (this.namespaces = JE(this.namespaces, o)),
        await this.persist("namespaces", this.namespaces),
        this.onConnect();
    }
    return s;
  }
  on(e, n) {
    this.events.on(e, n);
  }
  once(e, n) {
    this.events.once(e, n);
  }
  removeListener(e, n) {
    this.events.removeListener(e, n);
  }
  off(e, n) {
    this.events.off(e, n);
  }
  get isWalletConnect() {
    return !0;
  }
  async pair(e) {
    const { uri: n, approval: r } = await this.client.connect({
      pairingTopic: e,
      requiredNamespaces: this.namespaces,
      optionalNamespaces: this.optionalNamespaces,
      sessionProperties: this.sessionProperties,
      scopedProperties: this.scopedProperties,
    });
    n && ((this.uri = n), this.events.emit("display_uri", n));
    const i = await r();
    this.session = i;
    const s = IO(i.namespaces);
    return (
      (this.namespaces = JE(this.namespaces, s)),
      await this.persist("namespaces", this.namespaces),
      await this.persist("optionalNamespaces", this.optionalNamespaces),
      this.onConnect(),
      this.session
    );
  }
  setDefaultChain(e, n) {
    try {
      if (!this.session) return;
      const [r, i] = this.validateChain(e),
        s = this.getProvider(r);
      s.name === vd
        ? s.setDefaultChain(`${r}:${i}`, n)
        : s.setDefaultChain(i, n);
    } catch (r) {
      if (!/Please call connect/.test(r.message)) throw r;
    }
  }
  async cleanupPendingPairings(e = {}) {
    this.logger.info("Cleaning up inactive pairings...");
    const n = this.client.pairing.getAll();
    if (Nc(n)) {
      for (const r of n)
        e.deletePairings
          ? this.client.core.expirer.set(r.topic, 0)
          : await this.client.core.relayer.subscriber.unsubscribe(r.topic);
      this.logger.info(`Inactive pairings cleared: ${n.length}`);
    }
  }
  abortPairingAttempt() {
    this.logger.warn("abortPairingAttempt is deprecated. This is now a no-op.");
  }
  async checkStorage() {
    (this.namespaces = (await this.getFromStore("namespaces")) || {}),
      (this.optionalNamespaces =
        (await this.getFromStore("optionalNamespaces")) || {}),
      this.session && this.createProviders();
  }
  async initialize() {
    this.logger.trace("Initialized"),
      await this.createClient(),
      await this.checkStorage(),
      this.registerEventListeners();
  }
  async createClient() {
    var e, n;
    if (
      ((this.client =
        this.providerOpts.client ||
        (await wce.init({
          core: this.providerOpts.core,
          logger: this.providerOpts.logger || vO,
          relayUrl: this.providerOpts.relayUrl || Tce,
          projectId: this.providerOpts.projectId,
          metadata: this.providerOpts.metadata,
          storageOptions: this.providerOpts.storageOptions,
          storage: this.providerOpts.storage,
          name: this.providerOpts.name,
          customStoragePrefix: this.providerOpts.customStoragePrefix,
          telemetryEnabled: this.providerOpts.telemetryEnabled,
        }))),
      this.providerOpts.session)
    )
      try {
        this.session = this.client.session.get(this.providerOpts.session.topic);
      } catch (r) {
        throw (
          (this.logger.error("Failed to get session", r),
          new Error(
            `The provided session: ${
              (n = (e = this.providerOpts) == null ? void 0 : e.session) == null
                ? void 0
                : n.topic
            } doesn't exist in the Sign client`
          ))
        );
      }
    else {
      const r = this.client.session.getAll();
      this.session = r[0];
    }
    this.logger.trace("SignClient Initialized");
  }
  createProviders() {
    if (!this.client) throw new Error("Sign Client not initialized");
    if (!this.session)
      throw new Error(
        "Session not initialized. Please call connect() before enable()"
      );
    const e = [
      ...new Set(Object.keys(this.session.namespaces).map((n) => lh(n))),
    ];
    tC("client", this.client),
      tC("events", this.events),
      tC("disableProviderPing", this.disableProviderPing),
      e.forEach((n) => {
        if (!this.session) return;
        const r = dle(n, this.session),
          i = IM(r),
          s = JE(this.namespaces, this.optionalNamespaces),
          o = nC(s0({}, s[n]), { accounts: r, chains: i });
        switch (n) {
          case "eip155":
            this.rpcProviders[n] = new ble({ namespace: o });
            break;
          case "algorand":
            this.rpcProviders[n] = new Ple({ namespace: o });
            break;
          case "solana":
            this.rpcProviders[n] = new xle({ namespace: o });
            break;
          case "cosmos":
            this.rpcProviders[n] = new _le({ namespace: o });
            break;
          case "polkadot":
            this.rpcProviders[n] = new hle({ namespace: o });
            break;
          case "cip34":
            this.rpcProviders[n] = new Ole({ namespace: o });
            break;
          case "elrond":
            this.rpcProviders[n] = new $le({ namespace: o });
            break;
          case "multiversx":
            this.rpcProviders[n] = new Ule({ namespace: o });
            break;
          case "near":
            this.rpcProviders[n] = new Fle({ namespace: o });
            break;
          case "tezos":
            this.rpcProviders[n] = new Hle({ namespace: o });
            break;
          default:
            this.rpcProviders[vd]
              ? this.rpcProviders[vd].updateNamespace(o)
              : (this.rpcProviders[vd] = new Gle({ namespace: o }));
        }
      });
  }
  registerEventListeners() {
    if (typeof this.client > "u")
      throw new Error("Sign Client is not initialized");
    this.client.on("session_ping", (e) => {
      var n;
      const { topic: r } = e;
      r === ((n = this.session) == null ? void 0 : n.topic) &&
        this.events.emit("session_ping", e);
    }),
      this.client.on("session_event", (e) => {
        var n;
        const { params: r, topic: i } = e;
        if (i !== ((n = this.session) == null ? void 0 : n.topic)) return;
        const { event: s } = r;
        if (s.name === "accountsChanged") {
          const o = s.data;
          o && Nc(o) && this.events.emit("accountsChanged", o.map(_O));
        } else if (s.name === "chainChanged") {
          const o = r.chainId,
            a = r.event.data,
            l = lh(o),
            d = eC(o) !== eC(a) ? `${l}:${eC(a)}` : o;
          this.onChainChanged(d);
        } else this.events.emit(s.name, s.data);
        this.events.emit("session_event", e);
      }),
      this.client.on("session_update", ({ topic: e, params: n }) => {
        var r, i;
        if (e !== ((r = this.session) == null ? void 0 : r.topic)) return;
        const { namespaces: s } = n,
          o = (i = this.client) == null ? void 0 : i.session.get(e);
        (this.session = nC(s0({}, o), { namespaces: s })),
          this.onSessionUpdate(),
          this.events.emit("session_update", { topic: e, params: n });
      }),
      this.client.on("session_delete", async (e) => {
        var n;
        e.topic === ((n = this.session) == null ? void 0 : n.topic) &&
          (await this.cleanup(),
          this.events.emit("session_delete", e),
          this.events.emit(
            "disconnect",
            nC(s0({}, Kt("USER_DISCONNECTED")), { data: e.topic })
          ));
      }),
      this.on(Is.DEFAULT_CHAIN_CHANGED, (e) => {
        this.onChainChanged(e, !0);
      });
  }
  getProvider(e) {
    return this.rpcProviders[e] || this.rpcProviders[vd];
  }
  onSessionUpdate() {
    Object.keys(this.rpcProviders).forEach((e) => {
      var n;
      this.getProvider(e).updateNamespace(
        (n = this.session) == null ? void 0 : n.namespaces[e]
      );
    });
  }
  setNamespaces(e) {
    const {
      namespaces: n,
      optionalNamespaces: r,
      sessionProperties: i,
      scopedProperties: s,
    } = e;
    n && Object.keys(n).length && (this.namespaces = n),
      r && Object.keys(r).length && (this.optionalNamespaces = r),
      (this.sessionProperties = i),
      (this.scopedProperties = s);
  }
  validateChain(e) {
    const [n, r] = (e == null ? void 0 : e.split(":")) || ["", ""];
    if (!this.namespaces || !Object.keys(this.namespaces).length) return [n, r];
    if (
      n &&
      !Object.keys(this.namespaces || {})
        .map((o) => lh(o))
        .includes(n)
    )
      throw new Error(
        `Namespace '${n}' is not configured. Please call connect() first with namespace config.`
      );
    if (n && r) return [n, r];
    const i = lh(Object.keys(this.namespaces)[0]),
      s = this.rpcProviders[i].getDefaultChain();
    return [i, s];
  }
  async requestAccounts() {
    const [e] = this.validateChain();
    return await this.getProvider(e).requestAccounts();
  }
  async onChainChanged(e, n = !1) {
    if (!this.namespaces) return;
    const [r, i] = this.validateChain(e);
    if (!i) return;
    this.updateNamespaceChain(r, i), this.events.emit("chainChanged", i);
    const s = this.getProvider(r).getDefaultChain();
    n || this.getProvider(r).setDefaultChain(i),
      this.emitAccountsChangedOnChainChange({
        namespace: r,
        previousChainId: s,
        newChainId: e,
      }),
      await this.persist("namespaces", this.namespaces);
  }
  emitAccountsChangedOnChainChange({
    namespace: e,
    previousChainId: n,
    newChainId: r,
  }) {
    var i, s;
    try {
      if (n === r) return;
      const o =
        (s = (i = this.session) == null ? void 0 : i.namespaces[e]) == null
          ? void 0
          : s.accounts;
      if (!o) return;
      const a = o.filter((l) => l.includes(`${r}:`)).map(_O);
      if (!Nc(a)) return;
      this.events.emit("accountsChanged", a);
    } catch (o) {
      this.logger.warn("Failed to emit accountsChanged on chain change", o);
    }
  }
  updateNamespaceChain(e, n) {
    if (!this.namespaces) return;
    const r = this.namespaces[e] ? e : `${e}:${n}`,
      i = { chains: [], methods: [], events: [], defaultChain: n };
    this.namespaces[r]
      ? this.namespaces[r] && (this.namespaces[r].defaultChain = n)
      : (this.namespaces[r] = i);
  }
  onConnect() {
    this.createProviders(),
      this.events.emit("connect", { session: this.session });
  }
  async cleanup() {
    (this.namespaces = void 0),
      (this.optionalNamespaces = void 0),
      (this.sessionProperties = void 0),
      await this.deleteFromStore("namespaces"),
      await this.deleteFromStore("optionalNamespaces"),
      await this.deleteFromStore("sessionProperties"),
      (this.session = void 0),
      await this.cleanupPendingPairings({ deletePairings: !0 }),
      await this.cleanupStorage();
  }
  async persist(e, n) {
    var r;
    const i = ((r = this.session) == null ? void 0 : r.topic) || "";
    await this.client.core.storage.setItem(`${r0}/${e}${i}`, n);
  }
  async getFromStore(e) {
    var n;
    const r = ((n = this.session) == null ? void 0 : n.topic) || "";
    return await this.client.core.storage.getItem(`${r0}/${e}${r}`);
  }
  async deleteFromStore(e) {
    var n;
    const r = ((n = this.session) == null ? void 0 : n.topic) || "";
    await this.client.core.storage.removeItem(`${r0}/${e}${r}`);
  }
  async cleanupStorage() {
    var e;
    try {
      if (((e = this.client) == null ? void 0 : e.session.length) > 0) return;
      const n = await this.client.core.storage.getKeys();
      for (const r of n)
        r.startsWith(r0) && (await this.client.core.storage.removeItem(r));
    } catch (n) {
      this.logger.warn("Failed to cleanup storage", n);
    }
  }
};
var op = {};
const eue = "https://secure.walletconnect.org/sdk",
  tue =
    (typeof process < "u" && typeof op < "u"
      ? op.NEXT_PUBLIC_SECURE_SITE_SDK_URL
      : void 0) || eue,
  nue =
    (typeof process < "u" && typeof op < "u"
      ? op.NEXT_PUBLIC_DEFAULT_LOG_LEVEL
      : void 0) || "error",
  rue =
    (typeof process < "u" && typeof op < "u"
      ? op.NEXT_PUBLIC_SECURE_SITE_SDK_VERSION
      : void 0) || "4",
  Me = {
    APP_EVENT_KEY: "@w3m-app/",
    FRAME_EVENT_KEY: "@w3m-frame/",
    RPC_METHOD_KEY: "RPC_",
    STORAGE_KEY: "@appkit-wallet/",
    SESSION_TOKEN_KEY: "SESSION_TOKEN_KEY",
    EMAIL_LOGIN_USED_KEY: "EMAIL_LOGIN_USED_KEY",
    LAST_USED_CHAIN_KEY: "LAST_USED_CHAIN_KEY",
    LAST_EMAIL_LOGIN_TIME: "LAST_EMAIL_LOGIN_TIME",
    EMAIL: "EMAIL",
    PREFERRED_ACCOUNT_TYPE: "PREFERRED_ACCOUNT_TYPE",
    SMART_ACCOUNT_ENABLED: "SMART_ACCOUNT_ENABLED",
    SMART_ACCOUNT_ENABLED_NETWORKS: "SMART_ACCOUNT_ENABLED_NETWORKS",
    SOCIAL_USERNAME: "SOCIAL_USERNAME",
    APP_SWITCH_NETWORK: "@w3m-app/SWITCH_NETWORK",
    APP_CONNECT_EMAIL: "@w3m-app/CONNECT_EMAIL",
    APP_CONNECT_DEVICE: "@w3m-app/CONNECT_DEVICE",
    APP_CONNECT_OTP: "@w3m-app/CONNECT_OTP",
    APP_CONNECT_SOCIAL: "@w3m-app/CONNECT_SOCIAL",
    APP_GET_SOCIAL_REDIRECT_URI: "@w3m-app/GET_SOCIAL_REDIRECT_URI",
    APP_GET_USER: "@w3m-app/GET_USER",
    APP_SIGN_OUT: "@w3m-app/SIGN_OUT",
    APP_IS_CONNECTED: "@w3m-app/IS_CONNECTED",
    APP_GET_CHAIN_ID: "@w3m-app/GET_CHAIN_ID",
    APP_RPC_REQUEST: "@w3m-app/RPC_REQUEST",
    APP_UPDATE_EMAIL: "@w3m-app/UPDATE_EMAIL",
    APP_UPDATE_EMAIL_PRIMARY_OTP: "@w3m-app/UPDATE_EMAIL_PRIMARY_OTP",
    APP_UPDATE_EMAIL_SECONDARY_OTP: "@w3m-app/UPDATE_EMAIL_SECONDARY_OTP",
    APP_AWAIT_UPDATE_EMAIL: "@w3m-app/AWAIT_UPDATE_EMAIL",
    APP_SYNC_THEME: "@w3m-app/SYNC_THEME",
    APP_SYNC_DAPP_DATA: "@w3m-app/SYNC_DAPP_DATA",
    APP_GET_SMART_ACCOUNT_ENABLED_NETWORKS:
      "@w3m-app/GET_SMART_ACCOUNT_ENABLED_NETWORKS",
    APP_INIT_SMART_ACCOUNT: "@w3m-app/INIT_SMART_ACCOUNT",
    APP_SET_PREFERRED_ACCOUNT: "@w3m-app/SET_PREFERRED_ACCOUNT",
    APP_CONNECT_FARCASTER: "@w3m-app/CONNECT_FARCASTER",
    APP_GET_FARCASTER_URI: "@w3m-app/GET_FARCASTER_URI",
    APP_RELOAD: "@w3m-app/RELOAD",
    FRAME_SWITCH_NETWORK_ERROR: "@w3m-frame/SWITCH_NETWORK_ERROR",
    FRAME_SWITCH_NETWORK_SUCCESS: "@w3m-frame/SWITCH_NETWORK_SUCCESS",
    FRAME_CONNECT_EMAIL_ERROR: "@w3m-frame/CONNECT_EMAIL_ERROR",
    FRAME_CONNECT_EMAIL_SUCCESS: "@w3m-frame/CONNECT_EMAIL_SUCCESS",
    FRAME_CONNECT_DEVICE_ERROR: "@w3m-frame/CONNECT_DEVICE_ERROR",
    FRAME_CONNECT_DEVICE_SUCCESS: "@w3m-frame/CONNECT_DEVICE_SUCCESS",
    FRAME_CONNECT_OTP_SUCCESS: "@w3m-frame/CONNECT_OTP_SUCCESS",
    FRAME_CONNECT_OTP_ERROR: "@w3m-frame/CONNECT_OTP_ERROR",
    FRAME_CONNECT_SOCIAL_SUCCESS: "@w3m-frame/CONNECT_SOCIAL_SUCCESS",
    FRAME_CONNECT_SOCIAL_ERROR: "@w3m-frame/CONNECT_SOCIAL_ERROR",
    FRAME_CONNECT_FARCASTER_SUCCESS: "@w3m-frame/CONNECT_FARCASTER_SUCCESS",
    FRAME_CONNECT_FARCASTER_ERROR: "@w3m-frame/CONNECT_FARCASTER_ERROR",
    FRAME_GET_FARCASTER_URI_SUCCESS: "@w3m-frame/GET_FARCASTER_URI_SUCCESS",
    FRAME_GET_FARCASTER_URI_ERROR: "@w3m-frame/GET_FARCASTER_URI_ERROR",
    FRAME_GET_SOCIAL_REDIRECT_URI_SUCCESS:
      "@w3m-frame/GET_SOCIAL_REDIRECT_URI_SUCCESS",
    FRAME_GET_SOCIAL_REDIRECT_URI_ERROR:
      "@w3m-frame/GET_SOCIAL_REDIRECT_URI_ERROR",
    FRAME_GET_USER_SUCCESS: "@w3m-frame/GET_USER_SUCCESS",
    FRAME_GET_USER_ERROR: "@w3m-frame/GET_USER_ERROR",
    FRAME_SIGN_OUT_SUCCESS: "@w3m-frame/SIGN_OUT_SUCCESS",
    FRAME_SIGN_OUT_ERROR: "@w3m-frame/SIGN_OUT_ERROR",
    FRAME_IS_CONNECTED_SUCCESS: "@w3m-frame/IS_CONNECTED_SUCCESS",
    FRAME_IS_CONNECTED_ERROR: "@w3m-frame/IS_CONNECTED_ERROR",
    FRAME_GET_CHAIN_ID_SUCCESS: "@w3m-frame/GET_CHAIN_ID_SUCCESS",
    FRAME_GET_CHAIN_ID_ERROR: "@w3m-frame/GET_CHAIN_ID_ERROR",
    FRAME_RPC_REQUEST_SUCCESS: "@w3m-frame/RPC_REQUEST_SUCCESS",
    FRAME_RPC_REQUEST_ERROR: "@w3m-frame/RPC_REQUEST_ERROR",
    FRAME_SESSION_UPDATE: "@w3m-frame/SESSION_UPDATE",
    FRAME_UPDATE_EMAIL_SUCCESS: "@w3m-frame/UPDATE_EMAIL_SUCCESS",
    FRAME_UPDATE_EMAIL_ERROR: "@w3m-frame/UPDATE_EMAIL_ERROR",
    FRAME_UPDATE_EMAIL_PRIMARY_OTP_SUCCESS:
      "@w3m-frame/UPDATE_EMAIL_PRIMARY_OTP_SUCCESS",
    FRAME_UPDATE_EMAIL_PRIMARY_OTP_ERROR:
      "@w3m-frame/UPDATE_EMAIL_PRIMARY_OTP_ERROR",
    FRAME_UPDATE_EMAIL_SECONDARY_OTP_SUCCESS:
      "@w3m-frame/UPDATE_EMAIL_SECONDARY_OTP_SUCCESS",
    FRAME_UPDATE_EMAIL_SECONDARY_OTP_ERROR:
      "@w3m-frame/UPDATE_EMAIL_SECONDARY_OTP_ERROR",
    FRAME_SYNC_THEME_SUCCESS: "@w3m-frame/SYNC_THEME_SUCCESS",
    FRAME_SYNC_THEME_ERROR: "@w3m-frame/SYNC_THEME_ERROR",
    FRAME_SYNC_DAPP_DATA_SUCCESS: "@w3m-frame/SYNC_DAPP_DATA_SUCCESS",
    FRAME_SYNC_DAPP_DATA_ERROR: "@w3m-frame/SYNC_DAPP_DATA_ERROR",
    FRAME_GET_SMART_ACCOUNT_ENABLED_NETWORKS_SUCCESS:
      "@w3m-frame/GET_SMART_ACCOUNT_ENABLED_NETWORKS_SUCCESS",
    FRAME_GET_SMART_ACCOUNT_ENABLED_NETWORKS_ERROR:
      "@w3m-frame/GET_SMART_ACCOUNT_ENABLED_NETWORKS_ERROR",
    FRAME_INIT_SMART_ACCOUNT_SUCCESS: "@w3m-frame/INIT_SMART_ACCOUNT_SUCCESS",
    FRAME_INIT_SMART_ACCOUNT_ERROR: "@w3m-frame/INIT_SMART_ACCOUNT_ERROR",
    FRAME_SET_PREFERRED_ACCOUNT_SUCCESS:
      "@w3m-frame/SET_PREFERRED_ACCOUNT_SUCCESS",
    FRAME_SET_PREFERRED_ACCOUNT_ERROR: "@w3m-frame/SET_PREFERRED_ACCOUNT_ERROR",
    FRAME_READY: "@w3m-frame/READY",
    FRAME_RELOAD_SUCCESS: "@w3m-frame/RELOAD_SUCCESS",
    FRAME_RELOAD_ERROR: "@w3m-frame/RELOAD_ERROR",
    RPC_RESPONSE_TYPE_ERROR: "RPC_RESPONSE_ERROR",
    RPC_RESPONSE_TYPE_TX: "RPC_RESPONSE_TRANSACTION_HASH",
    RPC_RESPONSE_TYPE_OBJECT: "RPC_RESPONSE_OBJECT",
  },
  Rr = {
    SAFE_RPC_METHODS: [
      "eth_accounts",
      "eth_blockNumber",
      "eth_call",
      "eth_chainId",
      "eth_estimateGas",
      "eth_feeHistory",
      "eth_gasPrice",
      "eth_getAccount",
      "eth_getBalance",
      "eth_getBlockByHash",
      "eth_getBlockByNumber",
      "eth_getBlockReceipts",
      "eth_getBlockTransactionCountByHash",
      "eth_getBlockTransactionCountByNumber",
      "eth_getCode",
      "eth_getFilterChanges",
      "eth_getFilterLogs",
      "eth_getLogs",
      "eth_getProof",
      "eth_getStorageAt",
      "eth_getTransactionByBlockHashAndIndex",
      "eth_getTransactionByBlockNumberAndIndex",
      "eth_getTransactionByHash",
      "eth_getTransactionCount",
      "eth_getTransactionReceipt",
      "eth_getUncleCountByBlockHash",
      "eth_getUncleCountByBlockNumber",
      "eth_maxPriorityFeePerGas",
      "eth_newBlockFilter",
      "eth_newFilter",
      "eth_newPendingTransactionFilter",
      "eth_sendRawTransaction",
      "eth_syncing",
      "eth_uninstallFilter",
      "wallet_getCapabilities",
      "wallet_getCallsStatus",
      "eth_getUserOperationReceipt",
      "eth_estimateUserOperationGas",
      "eth_getUserOperationByHash",
      "eth_supportedEntryPoints",
      "wallet_getAssets",
    ],
    NOT_SAFE_RPC_METHODS: [
      "personal_sign",
      "eth_signTypedData_v4",
      "eth_sendTransaction",
      "solana_signMessage",
      "solana_signTransaction",
      "solana_signAllTransactions",
      "solana_signAndSendTransaction",
      "wallet_sendCalls",
      "wallet_grantPermissions",
      "wallet_revokePermissions",
      "eth_sendUserOperation",
    ],
    GET_CHAIN_ID: "eth_chainId",
    RPC_METHOD_NOT_ALLOWED_MESSAGE: "Requested RPC call is not allowed",
    RPC_METHOD_NOT_ALLOWED_UI_MESSAGE: "Action not allowed",
    ACCOUNT_TYPES: { EOA: "eoa", SMART_ACCOUNT: "smartAccount" },
  },
  bl = Object.freeze({
    message: "",
    variant: "success",
    svg: void 0,
    open: !1,
    autoClose: !0,
  }),
  Yn = wn({ ...bl }),
  qs = {
    state: Yn,
    subscribeKey(t, e) {
      return si(Yn, t, e);
    },
    showLoading(t, e = {}) {
      this._showMessage({ message: t, variant: "loading", ...e });
    },
    showSuccess(t) {
      this._showMessage({ message: t, variant: "success" });
    },
    showSvg(t, e) {
      this._showMessage({ message: t, svg: e });
    },
    showError(t) {
      const e = Je.parseError(t);
      this._showMessage({ message: e, variant: "error" });
    },
    hide() {
      (Yn.message = bl.message),
        (Yn.variant = bl.variant),
        (Yn.svg = bl.svg),
        (Yn.open = bl.open),
        (Yn.autoClose = bl.autoClose);
    },
    _showMessage({
      message: t,
      svg: e,
      variant: n = "success",
      autoClose: r = bl.autoClose,
    }) {
      Yn.open
        ? ((Yn.open = !1),
          setTimeout(() => {
            (Yn.message = t),
              (Yn.variant = n),
              (Yn.svg = e),
              (Yn.open = !0),
              (Yn.autoClose = r);
          }, 150))
        : ((Yn.message = t),
          (Yn.variant = n),
          (Yn.svg = e),
          (Yn.open = !0),
          (Yn.autoClose = r));
    },
  },
  Ch = {
    getSIWX() {
      return me.state.siwx;
    },
    async initializeIfEnabled() {
      var s;
      const t = me.state.siwx,
        e = Y.getActiveCaipAddress();
      if (!(t && e)) return;
      const [n, r, i] = e.split(":");
      if (Y.checkIfSupportedNetwork(n))
        try {
          if ((await t.getSessions(`${n}:${r}`, i)).length) return;
          await jn.open({ view: "SIWXSignMessage" });
        } catch (o) {
          console.error("SIWXUtil:initializeIfEnabled", o),
            fn.sendEvent({
              type: "track",
              event: "SIWX_AUTH_ERROR",
              properties: this.getSIWXEventProperties(),
            }),
            await ((s = an._getClient()) == null
              ? void 0
              : s.disconnect().catch(console.error)),
            zt.reset("Connect"),
            qs.showError(
              "A problem occurred while trying initialize authentication"
            );
        }
    },
    async requestSignMessage() {
      const t = me.state.siwx,
        e = Je.getPlainAddress(Y.getActiveCaipAddress()),
        n = Y.getActiveCaipNetwork(),
        r = an._getClient();
      if (!t) throw new Error("SIWX is not enabled");
      if (!e) throw new Error("No ActiveCaipAddress found");
      if (!n) throw new Error("No ActiveCaipNetwork or client found");
      if (!r) throw new Error("No ConnectionController client found");
      try {
        const i = await t.createMessage({
            chainId: n.caipNetworkId,
            accountAddress: e,
          }),
          s = i.toString();
        nt.getConnectorId(n.chainNamespace) === ye.CONNECTOR_ID.AUTH &&
          zt.pushTransactionStack({ view: null, goBack: !1, replace: !0 });
        const a = await r.signMessage(s);
        await t.addSession({ data: i, message: s, signature: a }),
          jn.close(),
          fn.sendEvent({
            type: "track",
            event: "SIWX_AUTH_SUCCESS",
            properties: this.getSIWXEventProperties(),
          });
      } catch (i) {
        const s = this.getSIWXEventProperties();
        (!jn.state.open || zt.state.view === "ApproveTransaction") &&
          (await jn.open({ view: "SIWXSignMessage" })),
          s.isSmartAccount
            ? qs.showError("This application might not support Smart Accounts")
            : qs.showError("Signature declined"),
          fn.sendEvent({
            type: "track",
            event: "SIWX_AUTH_ERROR",
            properties: s,
          }),
          console.error("SWIXUtil:requestSignMessage", i);
      }
    },
    async cancelSignMessage() {
      var t;
      try {
        const e = this.getSIWX();
        ((t = e == null ? void 0 : e.getRequired) == null ? void 0 : t.call(e))
          ? await an.disconnect()
          : jn.close(),
          zt.reset("Connect"),
          fn.sendEvent({
            event: "CLICK_CANCEL_SIWX",
            type: "track",
            properties: this.getSIWXEventProperties(),
          });
      } catch (e) {
        console.error("SIWXUtil:cancelSignMessage", e);
      }
    },
    async getSessions() {
      const t = me.state.siwx,
        e = Je.getPlainAddress(Y.getActiveCaipAddress()),
        n = Y.getActiveCaipNetwork();
      return t && e && n ? t.getSessions(n.caipNetworkId, e) : [];
    },
    async isSIWXCloseDisabled() {
      var e;
      const t = this.getSIWX();
      if (t) {
        const n = zt.state.view === "ApproveTransaction",
          r = zt.state.view === "SIWXSignMessage";
        if (n || r)
          return (
            ((e = t.getRequired) == null ? void 0 : e.call(t)) &&
            (await this.getSessions()).length === 0
          );
      }
      return !1;
    },
    async universalProviderAuthenticate({
      universalProvider: t,
      chains: e,
      methods: n,
    }) {
      var a, l, d;
      const r = Ch.getSIWX(),
        i = new Set(e.map((p) => p.split(":")[0]));
      if (!r || i.size !== 1 || !i.has("eip155")) return !1;
      const s = await r.createMessage({
          chainId:
            ((a = Y.getActiveCaipNetwork()) == null
              ? void 0
              : a.caipNetworkId) || "",
          accountAddress: "",
        }),
        o = await t.authenticate({
          nonce: s.nonce,
          domain: s.domain,
          uri: s.uri,
          exp: s.expirationTime,
          iat: s.issuedAt,
          nbf: s.notBefore,
          requestId: s.requestId,
          version: s.version,
          resources: s.resources,
          statement: s.statement,
          chainId: s.chainId,
          methods: n,
          chains: [s.chainId, ...e.filter((p) => p !== s.chainId)],
        });
      if (
        (qs.showLoading("Authenticating...", { autoClose: !1 }),
        Be.setConnectedWalletInfo(
          {
            ...o.session.peer.metadata,
            name: o.session.peer.metadata.name,
            icon: (l = o.session.peer.metadata.icons) == null ? void 0 : l[0],
            type: "WALLET_CONNECT",
          },
          Array.from(i)[0]
        ),
        (d = o == null ? void 0 : o.auths) != null && d.length)
      ) {
        const p = o.auths.map((f) => {
          const m = t.client.formatAuthMessage({ request: f.p, iss: f.p.iss });
          return {
            data: {
              ...f.p,
              accountAddress: f.p.iss.split(":").slice(-1).join(""),
              chainId: f.p.iss.split(":").slice(2, 4).join(":"),
              uri: f.p.aud,
              version: f.p.version || s.version,
              expirationTime: f.p.exp,
              issuedAt: f.p.iat,
              notBefore: f.p.nbf,
            },
            message: m,
            signature: f.s.s,
            cacao: f,
          };
        });
        try {
          await r.setSessions(p),
            fn.sendEvent({
              type: "track",
              event: "SIWX_AUTH_SUCCESS",
              properties: Ch.getSIWXEventProperties(),
            });
        } catch (f) {
          throw (
            (console.error(
              "SIWX:universalProviderAuth - failed to set sessions",
              f
            ),
            fn.sendEvent({
              type: "track",
              event: "SIWX_AUTH_ERROR",
              properties: Ch.getSIWXEventProperties(),
            }),
            await t.disconnect().catch(console.error),
            f)
          );
        } finally {
          qs.hide();
        }
      }
      return !0;
    },
    getSIWXEventProperties() {
      var e, n;
      const t = Y.state.activeChain;
      return {
        network:
          ((e = Y.state.activeCaipNetwork) == null
            ? void 0
            : e.caipNetworkId) || "",
        isSmartAccount:
          ((n = Be.state.preferredAccountTypes) == null ? void 0 : n[t]) ===
          Rr.ACCOUNT_TYPES.SMART_ACCOUNT,
      };
    },
    async clearSessions() {
      const t = this.getSIWX();
      t && (await t.setSessions([]));
    },
  },
  sn = wn({
    transactions: [],
    coinbaseTransactions: {},
    transactionsByYear: {},
    lastNetworkInView: void 0,
    loading: !1,
    empty: !1,
    next: void 0,
  }),
  iue = {
    state: sn,
    subscribe(t) {
      return ri(sn, () => t(sn));
    },
    setLastNetworkInView(t) {
      sn.lastNetworkInView = t;
    },
    async fetchTransactions(t, e) {
      var n, r;
      if (!t)
        throw new Error(
          "Transactions can't be fetched without an accountAddress"
        );
      sn.loading = !0;
      try {
        const i = await Xe.fetchTransactions({
            account: t,
            cursor: sn.next,
            onramp: e,
            cache: e === "coinbase" ? "no-cache" : void 0,
            chainId:
              (n = Y.state.activeCaipNetwork) == null
                ? void 0
                : n.caipNetworkId,
          }),
          s = this.filterSpamTransactions(i.data),
          o = this.filterByConnectedChain(s),
          a = [...sn.transactions, ...o];
        (sn.loading = !1),
          e === "coinbase"
            ? (sn.coinbaseTransactions = this.groupTransactionsByYearAndMonth(
                sn.coinbaseTransactions,
                i.data
              ))
            : ((sn.transactions = a),
              (sn.transactionsByYear = this.groupTransactionsByYearAndMonth(
                sn.transactionsByYear,
                o
              ))),
          (sn.empty = a.length === 0),
          (sn.next = i.next ? i.next : void 0);
      } catch {
        const s = Y.state.activeChain;
        fn.sendEvent({
          type: "track",
          event: "ERROR_FETCH_TRANSACTIONS",
          properties: {
            address: t,
            projectId: me.state.projectId,
            cursor: sn.next,
            isSmartAccount:
              ((r = Be.state.preferredAccountTypes) == null ? void 0 : r[s]) ===
              Rr.ACCOUNT_TYPES.SMART_ACCOUNT,
          },
        }),
          qs.showError("Failed to fetch transactions"),
          (sn.loading = !1),
          (sn.empty = !0),
          (sn.next = void 0);
      }
    },
    groupTransactionsByYearAndMonth(t = {}, e = []) {
      const n = t;
      return (
        e.forEach((r) => {
          const i = new Date(r.metadata.minedAt).getFullYear(),
            s = new Date(r.metadata.minedAt).getMonth(),
            o = n[i] ?? {},
            l = (o[s] ?? []).filter((d) => d.id !== r.id);
          n[i] = {
            ...o,
            [s]: [...l, r].sort(
              (d, p) =>
                new Date(p.metadata.minedAt).getTime() -
                new Date(d.metadata.minedAt).getTime()
            ),
          };
        }),
        n
      );
    },
    filterSpamTransactions(t) {
      return t.filter(
        (e) =>
          !e.transfers.every((r) => {
            var i;
            return ((i = r.nft_info) == null ? void 0 : i.flags.is_spam) === !0;
          })
      );
    },
    filterByConnectedChain(t) {
      var r;
      const e =
        (r = Y.state.activeCaipNetwork) == null ? void 0 : r.caipNetworkId;
      return t.filter((i) => i.metadata.chain === e);
    },
    clearCursor() {
      sn.next = void 0;
    },
    resetTransactions() {
      (sn.transactions = []),
        (sn.transactionsByYear = {}),
        (sn.lastNetworkInView = void 0),
        (sn.loading = !1),
        (sn.empty = !1),
        (sn.next = void 0);
    },
  },
  on = wn({ wcError: !1, buffering: !1, status: "disconnected" });
let hl;
const an = {
    state: on,
    subscribeKey(t, e) {
      return si(on, t, e);
    },
    _getClient() {
      return on._client;
    },
    setClient(t) {
      on._client = Kl(t);
    },
    async connectWalletConnect() {
      var t, e, n, r;
      if (Je.isTelegram() || (Je.isSafari() && Je.isIos())) {
        if (hl) {
          await hl, (hl = void 0);
          return;
        }
        if (!Je.isPairingExpired(on == null ? void 0 : on.wcPairingExpiry)) {
          const i = on.wcUri;
          on.wcUri = i;
          return;
        }
        (hl =
          (e =
            (t = this._getClient()) == null
              ? void 0
              : t.connectWalletConnect) == null
            ? void 0
            : e.call(t).catch(() => {})),
          (this.state.status = "connecting"),
          await hl,
          (hl = void 0),
          (on.wcPairingExpiry = void 0),
          (this.state.status = "connected");
      } else
        await ((r =
          (n = this._getClient()) == null ? void 0 : n.connectWalletConnect) ==
        null
          ? void 0
          : r.call(n));
    },
    async connectExternal(t, e, n = !0) {
      var r, i;
      await ((i =
        (r = this._getClient()) == null ? void 0 : r.connectExternal) == null
        ? void 0
        : i.call(r, t)),
        n && Y.setActiveNamespace(e);
    },
    async reconnectExternal(t) {
      var n, r;
      await ((r =
        (n = this._getClient()) == null ? void 0 : n.reconnectExternal) == null
        ? void 0
        : r.call(n, t));
      const e = t.chain || Y.state.activeChain;
      e && nt.setConnectorId(t.id, e);
    },
    async setPreferredAccountType(t, e) {
      var r;
      jn.setLoading(!0, Y.state.activeChain);
      const n = nt.getAuthConnector();
      n &&
        (Be.setPreferredAccountType(t, e),
        await n.provider.setPreferredAccount(t),
        Ie.setPreferredAccountTypes(
          Be.state.preferredAccountTypes ?? { [e]: t }
        ),
        await this.reconnectExternal(n),
        jn.setLoading(!1, Y.state.activeChain),
        fn.sendEvent({
          type: "track",
          event: "SET_PREFERRED_ACCOUNT_TYPE",
          properties: {
            accountType: t,
            network:
              ((r = Y.state.activeCaipNetwork) == null
                ? void 0
                : r.caipNetworkId) || "",
          },
        }));
    },
    async signMessage(t) {
      var e;
      return (e = this._getClient()) == null ? void 0 : e.signMessage(t);
    },
    parseUnits(t, e) {
      var n;
      return (n = this._getClient()) == null ? void 0 : n.parseUnits(t, e);
    },
    formatUnits(t, e) {
      var n;
      return (n = this._getClient()) == null ? void 0 : n.formatUnits(t, e);
    },
    async sendTransaction(t) {
      var e;
      return (e = this._getClient()) == null ? void 0 : e.sendTransaction(t);
    },
    async getCapabilities(t) {
      var e;
      return (e = this._getClient()) == null ? void 0 : e.getCapabilities(t);
    },
    async grantPermissions(t) {
      var e;
      return (e = this._getClient()) == null ? void 0 : e.grantPermissions(t);
    },
    async walletGetAssets(t) {
      var e;
      return (
        ((e = this._getClient()) == null ? void 0 : e.walletGetAssets(t)) ?? {}
      );
    },
    async estimateGas(t) {
      var e;
      return (e = this._getClient()) == null ? void 0 : e.estimateGas(t);
    },
    async writeContract(t) {
      var e;
      return (e = this._getClient()) == null ? void 0 : e.writeContract(t);
    },
    async getEnsAddress(t) {
      var e;
      return (e = this._getClient()) == null ? void 0 : e.getEnsAddress(t);
    },
    async getEnsAvatar(t) {
      var e;
      return (e = this._getClient()) == null ? void 0 : e.getEnsAvatar(t);
    },
    checkInstalled(t) {
      var e, n;
      return (
        ((n = (e = this._getClient()) == null ? void 0 : e.checkInstalled) ==
        null
          ? void 0
          : n.call(e, t)) || !1
      );
    },
    resetWcConnection() {
      (on.wcUri = void 0),
        (on.wcPairingExpiry = void 0),
        (on.wcLinking = void 0),
        (on.recentWallet = void 0),
        (on.status = "disconnected"),
        iue.resetTransactions(),
        Ie.deleteWalletConnectDeepLink();
    },
    resetUri() {
      (on.wcUri = void 0), (on.wcPairingExpiry = void 0), (hl = void 0);
    },
    finalizeWcConnection() {
      var n, r;
      const { wcLinking: t, recentWallet: e } = an.state;
      t && Ie.setWalletConnectDeepLink(t),
        e && Ie.setAppKitRecent(e),
        fn.sendEvent({
          type: "track",
          event: "CONNECT_SUCCESS",
          properties: {
            method: t ? "mobile" : "qrcode",
            name:
              ((r = (n = zt.state.data) == null ? void 0 : n.wallet) == null
                ? void 0
                : r.name) || "Unknown",
          },
        });
    },
    setWcBasic(t) {
      on.wcBasic = t;
    },
    setUri(t) {
      (on.wcUri = t), (on.wcPairingExpiry = Je.getPairingExpiry());
    },
    setWcLinking(t) {
      on.wcLinking = t;
    },
    setWcError(t) {
      (on.wcError = t), (on.buffering = !1);
    },
    setRecentWallet(t) {
      on.recentWallet = t;
    },
    setBuffering(t) {
      on.buffering = t;
    },
    setStatus(t) {
      on.status = t;
    },
    async disconnect(t) {
      try {
        jn.setLoading(!0, t),
          await Ch.clearSessions(),
          await Y.disconnect(t),
          jn.setLoading(!1, t),
          nt.setFilterByNamespace(void 0);
      } catch {
        throw new Error("Failed to disconnect");
      }
    },
  },
  dd = wn({
    loading: !1,
    open: !1,
    selectedNetworkId: void 0,
    activeChain: void 0,
    initialized: !1,
  }),
  Ro = {
    state: dd,
    subscribe(t) {
      return ri(dd, () => t(dd));
    },
    subscribeOpen(t) {
      return si(dd, "open", t);
    },
    set(t) {
      Object.assign(dd, { ...dd, ...t });
    },
  };
function yn(t, e, n) {
  const r = t[e.name];
  if (typeof r == "function") return r;
  const i = t[n];
  return typeof i == "function" ? i : (s) => e(t, s);
}
function Bc(t, { includeName: e = !1 } = {}) {
  if (t.type !== "function" && t.type !== "event" && t.type !== "error")
    throw new gue(t.type);
  return `${t.name}(${kv(t.inputs, { includeName: e })})`;
}
function kv(t, { includeName: e = !1 } = {}) {
  return t ? t.map((n) => sue(n, { includeName: e })).join(e ? ", " : ",") : "";
}
function sue(t, { includeName: e }) {
  return t.type.startsWith("tuple")
    ? `(${kv(t.components, { includeName: e })})${t.type.slice(5)}`
    : t.type + (e && t.name ? ` ${t.name}` : "");
}
function jc(t, { strict: e = !0 } = {}) {
  return !t || typeof t != "string"
    ? !1
    : e
    ? /^0x[0-9a-fA-F]*$/.test(t)
    : t.startsWith("0x");
}
function tr(t) {
  return jc(t, { strict: !1 }) ? Math.ceil((t.length - 2) / 2) : t.length;
}
const RM = "2.29.1";
let Gf = {
    getDocsUrl: ({ docsBaseUrl: t, docsPath: e = "", docsSlug: n }) =>
      e ? `${t ?? "https://viem.sh"}${e}${n ? `#${n}` : ""}` : void 0,
    version: `viem@${RM}`,
  },
  ge = class Xx extends Error {
    constructor(e, n = {}) {
      var a;
      const r = (() => {
          var l;
          return n.cause instanceof Xx
            ? n.cause.details
            : (l = n.cause) != null && l.message
            ? n.cause.message
            : n.details;
        })(),
        i = (n.cause instanceof Xx && n.cause.docsPath) || n.docsPath,
        s =
          (a = Gf.getDocsUrl) == null
            ? void 0
            : a.call(Gf, { ...n, docsPath: i }),
        o = [
          e || "An error occurred.",
          "",
          ...(n.metaMessages ? [...n.metaMessages, ""] : []),
          ...(s ? [`Docs: ${s}`] : []),
          ...(r ? [`Details: ${r}`] : []),
          ...(Gf.version ? [`Version: ${Gf.version}`] : []),
        ].join(`
`);
      super(o, n.cause ? { cause: n.cause } : void 0),
        Object.defineProperty(this, "details", {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: void 0,
        }),
        Object.defineProperty(this, "docsPath", {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: void 0,
        }),
        Object.defineProperty(this, "metaMessages", {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: void 0,
        }),
        Object.defineProperty(this, "shortMessage", {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: void 0,
        }),
        Object.defineProperty(this, "version", {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: void 0,
        }),
        Object.defineProperty(this, "name", {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: "BaseError",
        }),
        (this.details = r),
        (this.docsPath = i),
        (this.metaMessages = n.metaMessages),
        (this.name = n.name ?? this.name),
        (this.shortMessage = e),
        (this.version = RM);
    }
    walk(e) {
      return NM(this, e);
    }
  };
function NM(t, e) {
  return e != null && e(t)
    ? t
    : t && typeof t == "object" && "cause" in t && t.cause !== void 0
    ? NM(t.cause, e)
    : e
    ? null
    : t;
}
class oue extends ge {
  constructor({ docsPath: e }) {
    super(
      [
        "A constructor was not found on the ABI.",
        "Make sure you are using the correct ABI and that the constructor exists on it.",
      ].join(`
`),
      { docsPath: e, name: "AbiConstructorNotFoundError" }
    );
  }
}
class OO extends ge {
  constructor({ docsPath: e }) {
    super(
      [
        "Constructor arguments were provided (`args`), but a constructor parameters (`inputs`) were not found on the ABI.",
        "Make sure you are using the correct ABI, and that the `inputs` attribute on the constructor exists.",
      ].join(`
`),
      { docsPath: e, name: "AbiConstructorParamsNotFoundError" }
    );
  }
}
class OM extends ge {
  constructor({ data: e, params: n, size: r }) {
    super(
      [`Data size of ${r} bytes is too small for given parameters.`].join(`
`),
      {
        metaMessages: [
          `Params: (${kv(n, { includeName: !0 })})`,
          `Data:   ${e} (${r} bytes)`,
        ],
        name: "AbiDecodingDataSizeTooSmallError",
      }
    ),
      Object.defineProperty(this, "data", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0,
      }),
      Object.defineProperty(this, "params", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0,
      }),
      Object.defineProperty(this, "size", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0,
      }),
      (this.data = e),
      (this.params = n),
      (this.size = r);
  }
}
class Dv extends ge {
  constructor() {
    super('Cannot decode zero data ("0x") with ABI parameters.', {
      name: "AbiDecodingZeroDataError",
    });
  }
}
class aue extends ge {
  constructor({ expectedLength: e, givenLength: n, type: r }) {
    super(
      [
        `ABI encoding array length mismatch for type ${r}.`,
        `Expected length: ${e}`,
        `Given length: ${n}`,
      ].join(`
`),
      { name: "AbiEncodingArrayLengthMismatchError" }
    );
  }
}
class cue extends ge {
  constructor({ expectedSize: e, value: n }) {
    super(
      `Size of bytes "${n}" (bytes${tr(
        n
      )}) does not match expected size (bytes${e}).`,
      { name: "AbiEncodingBytesSizeMismatchError" }
    );
  }
}
class lue extends ge {
  constructor({ expectedLength: e, givenLength: n }) {
    super(
      [
        "ABI encoding params/values length mismatch.",
        `Expected length (params): ${e}`,
        `Given length (values): ${n}`,
      ].join(`
`),
      { name: "AbiEncodingLengthMismatchError" }
    );
  }
}
class I1e extends ge {
  constructor(e, { docsPath: n }) {
    super(
      [
        `Arguments (\`args\`) were provided to "${e}", but "${e}" on the ABI does not contain any parameters (\`inputs\`).`,
        "Cannot encode error result without knowing what the parameter types are.",
        "Make sure you are using the correct ABI and that the inputs exist on it.",
      ].join(`
`),
      { docsPath: n, name: "AbiErrorInputsNotFoundError" }
    );
  }
}
class T1e extends ge {
  constructor(e, { docsPath: n } = {}) {
    super(
      [
        `Error ${e ? `"${e}" ` : ""}not found on ABI.`,
        "Make sure you are using the correct ABI and that the error exists on it.",
      ].join(`
`),
      { docsPath: n, name: "AbiErrorNotFoundError" }
    );
  }
}
class kM extends ge {
  constructor(e, { docsPath: n }) {
    super(
      [
        `Encoded error signature "${e}" not found on ABI.`,
        "Make sure you are using the correct ABI and that the error exists on it.",
        `You can look up the decoded signature here: https://openchain.xyz/signatures?query=${e}.`,
      ].join(`
`),
      { docsPath: n, name: "AbiErrorSignatureNotFoundError" }
    ),
      Object.defineProperty(this, "signature", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0,
      }),
      (this.signature = e);
  }
}
class uue extends ge {
  constructor({ docsPath: e }) {
    super("Cannot extract event signature from empty topics.", {
      docsPath: e,
      name: "AbiEventSignatureEmptyTopicsError",
    });
  }
}
class DM extends ge {
  constructor(e, { docsPath: n }) {
    super(
      [
        `Encoded event signature "${e}" not found on ABI.`,
        "Make sure you are using the correct ABI and that the event exists on it.",
        `You can look up the signature here: https://openchain.xyz/signatures?query=${e}.`,
      ].join(`
`),
      { docsPath: n, name: "AbiEventSignatureNotFoundError" }
    );
  }
}
class vw extends ge {
  constructor(e, { docsPath: n } = {}) {
    super(
      [
        `Function ${e ? `"${e}" ` : ""}not found on ABI.`,
        "Make sure you are using the correct ABI and that the function exists on it.",
      ].join(`
`),
      { docsPath: n, name: "AbiFunctionNotFoundError" }
    );
  }
}
class due extends ge {
  constructor(e, { docsPath: n }) {
    super(
      [
        `Function "${e}" does not contain any \`outputs\` on ABI.`,
        "Cannot decode function result without knowing what the parameter types are.",
        "Make sure you are using the correct ABI and that the function exists on it.",
      ].join(`
`),
      { docsPath: n, name: "AbiFunctionOutputsNotFoundError" }
    );
  }
}
class P1e extends ge {
  constructor(e, { docsPath: n }) {
    super(
      [
        `Encoded function signature "${e}" not found on ABI.`,
        "Make sure you are using the correct ABI and that the function exists on it.",
        `You can look up the signature here: https://openchain.xyz/signatures?query=${e}.`,
      ].join(`
`),
      { docsPath: n, name: "AbiFunctionSignatureNotFoundError" }
    );
  }
}
class pue extends ge {
  constructor(e, n) {
    super("Found ambiguous types in overloaded ABI items.", {
      metaMessages: [
        `\`${e.type}\` in \`${Bc(e.abiItem)}\`, and`,
        `\`${n.type}\` in \`${Bc(n.abiItem)}\``,
        "",
        "These types encode differently and cannot be distinguished at runtime.",
        "Remove one of the ambiguous items in the ABI.",
      ],
      name: "AbiItemAmbiguityError",
    });
  }
}
class Jx extends ge {
  constructor({ abiItem: e, data: n, params: r, size: i }) {
    super(
      [`Data size of ${i} bytes is too small for non-indexed event parameters.`]
        .join(`
`),
      {
        metaMessages: [
          `Params: (${kv(r, { includeName: !0 })})`,
          `Data:   ${n} (${i} bytes)`,
        ],
        name: "DecodeLogDataMismatch",
      }
    ),
      Object.defineProperty(this, "abiItem", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0,
      }),
      Object.defineProperty(this, "data", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0,
      }),
      Object.defineProperty(this, "params", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0,
      }),
      Object.defineProperty(this, "size", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0,
      }),
      (this.abiItem = e),
      (this.data = n),
      (this.params = r),
      (this.size = i);
  }
}
class $M extends ge {
  constructor({ abiItem: e, param: n }) {
    super(
      [
        `Expected a topic for indexed event parameter${
          n.name ? ` "${n.name}"` : ""
        } on event "${Bc(e, { includeName: !0 })}".`,
      ].join(`
`),
      { name: "DecodeLogTopicsMismatch" }
    ),
      Object.defineProperty(this, "abiItem", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0,
      }),
      (this.abiItem = e);
  }
}
class fue extends ge {
  constructor(e, { docsPath: n }) {
    super(
      [
        `Type "${e}" is not a valid encoding type.`,
        "Please provide a valid ABI type.",
      ].join(`
`),
      { docsPath: n, name: "InvalidAbiEncodingType" }
    );
  }
}
class hue extends ge {
  constructor(e, { docsPath: n }) {
    super(
      [
        `Type "${e}" is not a valid decoding type.`,
        "Please provide a valid ABI type.",
      ].join(`
`),
      { docsPath: n, name: "InvalidAbiDecodingType" }
    );
  }
}
class mue extends ge {
  constructor(e) {
    super(
      [`Value "${e}" is not a valid array.`].join(`
`),
      { name: "InvalidArrayError" }
    );
  }
}
class gue extends ge {
  constructor(e) {
    super(
      [
        `"${e}" is not a valid definition type.`,
        'Valid types: "function", "event", "error"',
      ].join(`
`),
      { name: "InvalidDefinitionTypeError" }
    );
  }
}
class MM extends ge {
  constructor({ offset: e, position: n, size: r }) {
    super(
      `Slice ${
        n === "start" ? "starting" : "ending"
      } at offset "${e}" is out-of-bounds (size: ${r}).`,
      { name: "SliceOffsetOutOfBoundsError" }
    );
  }
}
let LM = class extends ge {
  constructor({ size: e, targetSize: n, type: r }) {
    super(
      `${r.charAt(0).toUpperCase()}${r
        .slice(1)
        .toLowerCase()} size (${e}) exceeds padding size (${n}).`,
      { name: "SizeExceedsPaddingSizeError" }
    );
  }
};
class kO extends ge {
  constructor({ size: e, targetSize: n, type: r }) {
    super(
      `${r.charAt(0).toUpperCase()}${r
        .slice(1)
        .toLowerCase()} is expected to be ${n} ${r} long, but is ${e} ${r} long.`,
      { name: "InvalidBytesLengthError" }
    );
  }
}
function Dp(t, { dir: e, size: n = 32 } = {}) {
  return typeof t == "string"
    ? Oc(t, { dir: e, size: n })
    : yue(t, { dir: e, size: n });
}
function Oc(t, { dir: e, size: n = 32 } = {}) {
  if (n === null) return t;
  const r = t.replace("0x", "");
  if (r.length > n * 2)
    throw new LM({ size: Math.ceil(r.length / 2), targetSize: n, type: "hex" });
  return `0x${r[e === "right" ? "padEnd" : "padStart"](n * 2, "0")}`;
}
function yue(t, { dir: e, size: n = 32 } = {}) {
  if (n === null) return t;
  if (t.length > n)
    throw new LM({ size: t.length, targetSize: n, type: "bytes" });
  const r = new Uint8Array(n);
  for (let i = 0; i < n; i++) {
    const s = e === "right";
    r[s ? i : n - i - 1] = t[s ? i : t.length - i - 1];
  }
  return r;
}
let UM = class extends ge {
  constructor({ max: e, min: n, signed: r, size: i, value: s }) {
    super(
      `Number "${s}" is not in safe ${
        i ? `${i * 8}-bit ${r ? "signed" : "unsigned"} ` : ""
      }integer range ${e ? `(${n} to ${e})` : `(above ${n})`}`,
      { name: "IntegerOutOfRangeError" }
    );
  }
};
class wue extends ge {
  constructor(e) {
    super(
      `Bytes value "${e}" is not a valid boolean. The bytes array must contain a single byte of either a 0 or 1 value.`,
      { name: "InvalidBytesBooleanError" }
    );
  }
}
class vue extends ge {
  constructor({ givenSize: e, maxSize: n }) {
    super(`Size cannot exceed ${n} bytes. Given size: ${e} bytes.`, {
      name: "SizeOverflowError",
    });
  }
}
function ag(t, { dir: e = "left" } = {}) {
  let n = typeof t == "string" ? t.replace("0x", "") : t,
    r = 0;
  for (
    let i = 0;
    i < n.length - 1 &&
    n[e === "left" ? i : n.length - i - 1].toString() === "0";
    i++
  )
    r++;
  return (
    (n = e === "left" ? n.slice(r) : n.slice(0, n.length - r)),
    typeof t == "string"
      ? (n.length === 1 && e === "right" && (n = `${n}0`),
        `0x${n.length % 2 === 1 ? `0${n}` : n}`)
      : n
  );
}
function to(t, { size: e }) {
  if (tr(t) > e) throw new vue({ givenSize: tr(t), maxSize: e });
}
function ap(t, e = {}) {
  const { signed: n } = e;
  e.size && to(t, { size: e.size });
  const r = BigInt(t);
  if (!n) return r;
  const i = (t.length - 2) / 2,
    s = (1n << (BigInt(i) * 8n - 1n)) - 1n;
  return r <= s ? r : r - BigInt(`0x${"f".padStart(i * 2, "f")}`) - 1n;
}
function nu(t, e = {}) {
  return Number(ap(t, e));
}
function BM(t, e = {}) {
  let n = ko(t);
  return (
    e.size && (to(n, { size: e.size }), (n = ag(n, { dir: "right" }))),
    new TextDecoder().decode(n)
  );
}
const bue = Array.from({ length: 256 }, (t, e) =>
  e.toString(16).padStart(2, "0")
);
function cp(t, e = {}) {
  return typeof t == "number" || typeof t == "bigint"
    ? Et(t, e)
    : typeof t == "string"
    ? $v(t, e)
    : typeof t == "boolean"
    ? jM(t, e)
    : _i(t, e);
}
function jM(t, e = {}) {
  const n = `0x${Number(t)}`;
  return typeof e.size == "number"
    ? (to(n, { size: e.size }), Dp(n, { size: e.size }))
    : n;
}
function _i(t, e = {}) {
  let n = "";
  for (let i = 0; i < t.length; i++) n += bue[t[i]];
  const r = `0x${n}`;
  return typeof e.size == "number"
    ? (to(r, { size: e.size }), Dp(r, { dir: "right", size: e.size }))
    : r;
}
function Et(t, e = {}) {
  const { signed: n, size: r } = e,
    i = BigInt(t);
  let s;
  r
    ? n
      ? (s = (1n << (BigInt(r) * 8n - 1n)) - 1n)
      : (s = 2n ** (BigInt(r) * 8n) - 1n)
    : typeof t == "number" && (s = BigInt(Number.MAX_SAFE_INTEGER));
  const o = typeof s == "bigint" && n ? -s - 1n : 0;
  if ((s && i > s) || i < o) {
    const l = typeof t == "bigint" ? "n" : "";
    throw new UM({
      max: s ? `${s}${l}` : void 0,
      min: `${o}${l}`,
      signed: n,
      size: r,
      value: `${t}${l}`,
    });
  }
  const a = `0x${(n && i < 0 ? (1n << BigInt(r * 8)) + BigInt(i) : i).toString(
    16
  )}`;
  return r ? Dp(a, { size: r }) : a;
}
const Eue = new TextEncoder();
function $v(t, e = {}) {
  const n = Eue.encode(t);
  return _i(n, e);
}
const Cue = new TextEncoder();
function Mv(t, e = {}) {
  return typeof t == "number" || typeof t == "bigint"
    ? Sue(t, e)
    : typeof t == "boolean"
    ? xue(t, e)
    : jc(t)
    ? ko(t, e)
    : FM(t, e);
}
function xue(t, e = {}) {
  const n = new Uint8Array(1);
  return (
    (n[0] = Number(t)),
    typeof e.size == "number"
      ? (to(n, { size: e.size }), Dp(n, { size: e.size }))
      : n
  );
}
const sa = { zero: 48, nine: 57, A: 65, F: 70, a: 97, f: 102 };
function DO(t) {
  if (t >= sa.zero && t <= sa.nine) return t - sa.zero;
  if (t >= sa.A && t <= sa.F) return t - (sa.A - 10);
  if (t >= sa.a && t <= sa.f) return t - (sa.a - 10);
}
function ko(t, e = {}) {
  let n = t;
  e.size &&
    (to(n, { size: e.size }), (n = Dp(n, { dir: "right", size: e.size })));
  let r = n.slice(2);
  r.length % 2 && (r = `0${r}`);
  const i = r.length / 2,
    s = new Uint8Array(i);
  for (let o = 0, a = 0; o < i; o++) {
    const l = DO(r.charCodeAt(a++)),
      d = DO(r.charCodeAt(a++));
    if (l === void 0 || d === void 0)
      throw new ge(
        `Invalid byte sequence ("${r[a - 2]}${r[a - 1]}" in "${r}").`
      );
    s[o] = l * 16 + d;
  }
  return s;
}
function Sue(t, e) {
  const n = Et(t, e);
  return ko(n);
}
function FM(t, e = {}) {
  const n = Cue.encode(t);
  return typeof e.size == "number"
    ? (to(n, { size: e.size }), Dp(n, { dir: "right", size: e.size }))
    : n;
}
function bw(t) {
  if (!Number.isSafeInteger(t) || t < 0)
    throw new Error("positive integer expected, got " + t);
}
function Aue(t) {
  return (
    t instanceof Uint8Array ||
    (ArrayBuffer.isView(t) && t.constructor.name === "Uint8Array")
  );
}
function Lv(t, ...e) {
  if (!Aue(t)) throw new Error("Uint8Array expected");
  if (e.length > 0 && !e.includes(t.length))
    throw new Error(
      "Uint8Array expected of length " + e + ", got length=" + t.length
    );
}
function O1e(t) {
  if (typeof t != "function" || typeof t.create != "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  bw(t.outputLen), bw(t.blockLen);
}
function Ew(t, e = !0) {
  if (t.destroyed) throw new Error("Hash instance has been destroyed");
  if (e && t.finished) throw new Error("Hash#digest() has already been called");
}
function zM(t, e) {
  Lv(t);
  const n = e.outputLen;
  if (t.length < n)
    throw new Error(
      "digestInto() expects output buffer of length at least " + n
    );
}
const o0 = BigInt(2 ** 32 - 1),
  $O = BigInt(32);
function _ue(t, e = !1) {
  return e
    ? { h: Number(t & o0), l: Number((t >> $O) & o0) }
    : { h: Number((t >> $O) & o0) | 0, l: Number(t & o0) | 0 };
}
function Iue(t, e = !1) {
  let n = new Uint32Array(t.length),
    r = new Uint32Array(t.length);
  for (let i = 0; i < t.length; i++) {
    const { h: s, l: o } = _ue(t[i], e);
    [n[i], r[i]] = [s, o];
  }
  return [n, r];
}
const Tue = (t, e, n) => (t << n) | (e >>> (32 - n)),
  Pue = (t, e, n) => (e << n) | (t >>> (32 - n)),
  Rue = (t, e, n) => (e << (n - 32)) | (t >>> (64 - n)),
  Nue = (t, e, n) => (t << (n - 32)) | (e >>> (64 - n)),
  pd =
    typeof globalThis == "object" && "crypto" in globalThis
      ? globalThis.crypto
      : void 0;
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */ function Oue(
  t
) {
  return new Uint32Array(t.buffer, t.byteOffset, Math.floor(t.byteLength / 4));
}
function rC(t) {
  return new DataView(t.buffer, t.byteOffset, t.byteLength);
}
function ho(t, e) {
  return (t << (32 - e)) | (t >>> e);
}
const MO = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
function kue(t) {
  return (
    ((t << 24) & 4278190080) |
    ((t << 8) & 16711680) |
    ((t >>> 8) & 65280) |
    ((t >>> 24) & 255)
  );
}
function LO(t) {
  for (let e = 0; e < t.length; e++) t[e] = kue(t[e]);
}
typeof Uint8Array.from([]).toHex == "function" && Uint8Array.fromHex;
function Due(t) {
  if (typeof t != "string")
    throw new Error("utf8ToBytes expected string, got " + typeof t);
  return new Uint8Array(new TextEncoder().encode(t));
}
function BA(t) {
  return typeof t == "string" && (t = Due(t)), Lv(t), t;
}
function k1e(...t) {
  let e = 0;
  for (let r = 0; r < t.length; r++) {
    const i = t[r];
    Lv(i), (e += i.length);
  }
  const n = new Uint8Array(e);
  for (let r = 0, i = 0; r < t.length; r++) {
    const s = t[r];
    n.set(s, i), (i += s.length);
  }
  return n;
}
class WM {
  clone() {
    return this._cloneInto();
  }
}
function HM(t) {
  const e = (r) => t().update(BA(r)).digest(),
    n = t();
  return (
    (e.outputLen = n.outputLen),
    (e.blockLen = n.blockLen),
    (e.create = () => t()),
    e
  );
}
function D1e(t = 32) {
  if (pd && typeof pd.getRandomValues == "function")
    return pd.getRandomValues(new Uint8Array(t));
  if (pd && typeof pd.randomBytes == "function")
    return Uint8Array.from(pd.randomBytes(t));
  throw new Error("crypto.getRandomValues must be defined");
}
const qM = [],
  VM = [],
  GM = [],
  $ue = BigInt(0),
  Kf = BigInt(1),
  Mue = BigInt(2),
  Lue = BigInt(7),
  Uue = BigInt(256),
  Bue = BigInt(113);
for (let t = 0, e = Kf, n = 1, r = 0; t < 24; t++) {
  ([n, r] = [r, (2 * n + 3 * r) % 5]),
    qM.push(2 * (5 * r + n)),
    VM.push((((t + 1) * (t + 2)) / 2) % 64);
  let i = $ue;
  for (let s = 0; s < 7; s++)
    (e = ((e << Kf) ^ ((e >> Lue) * Bue)) % Uue),
      e & Mue && (i ^= Kf << ((Kf << BigInt(s)) - Kf));
  GM.push(i);
}
const [jue, Fue] = Iue(GM, !0),
  UO = (t, e, n) => (n > 32 ? Rue(t, e, n) : Tue(t, e, n)),
  BO = (t, e, n) => (n > 32 ? Nue(t, e, n) : Pue(t, e, n));
function zue(t, e = 24) {
  const n = new Uint32Array(10);
  for (let r = 24 - e; r < 24; r++) {
    for (let o = 0; o < 10; o++)
      n[o] = t[o] ^ t[o + 10] ^ t[o + 20] ^ t[o + 30] ^ t[o + 40];
    for (let o = 0; o < 10; o += 2) {
      const a = (o + 8) % 10,
        l = (o + 2) % 10,
        d = n[l],
        p = n[l + 1],
        f = UO(d, p, 1) ^ n[a],
        m = BO(d, p, 1) ^ n[a + 1];
      for (let y = 0; y < 50; y += 10) (t[o + y] ^= f), (t[o + y + 1] ^= m);
    }
    let i = t[2],
      s = t[3];
    for (let o = 0; o < 24; o++) {
      const a = VM[o],
        l = UO(i, s, a),
        d = BO(i, s, a),
        p = qM[o];
      (i = t[p]), (s = t[p + 1]), (t[p] = l), (t[p + 1] = d);
    }
    for (let o = 0; o < 50; o += 10) {
      for (let a = 0; a < 10; a++) n[a] = t[o + a];
      for (let a = 0; a < 10; a++)
        t[o + a] ^= ~n[(a + 2) % 10] & n[(a + 4) % 10];
    }
    (t[0] ^= jue[r]), (t[1] ^= Fue[r]);
  }
  n.fill(0);
}
class jA extends WM {
  constructor(e, n, r, i = !1, s = 24) {
    if (
      (super(),
      (this.pos = 0),
      (this.posOut = 0),
      (this.finished = !1),
      (this.destroyed = !1),
      (this.enableXOF = !1),
      (this.blockLen = e),
      (this.suffix = n),
      (this.outputLen = r),
      (this.enableXOF = i),
      (this.rounds = s),
      bw(r),
      0 >= this.blockLen || this.blockLen >= 200)
    )
      throw new Error("Sha3 supports only keccak-f1600 function");
    (this.state = new Uint8Array(200)), (this.state32 = Oue(this.state));
  }
  keccak() {
    MO || LO(this.state32),
      zue(this.state32, this.rounds),
      MO || LO(this.state32),
      (this.posOut = 0),
      (this.pos = 0);
  }
  update(e) {
    Ew(this);
    const { blockLen: n, state: r } = this;
    e = BA(e);
    const i = e.length;
    for (let s = 0; s < i; ) {
      const o = Math.min(n - this.pos, i - s);
      for (let a = 0; a < o; a++) r[this.pos++] ^= e[s++];
      this.pos === n && this.keccak();
    }
    return this;
  }
  finish() {
    if (this.finished) return;
    this.finished = !0;
    const { state: e, suffix: n, pos: r, blockLen: i } = this;
    (e[r] ^= n),
      n & 128 && r === i - 1 && this.keccak(),
      (e[i - 1] ^= 128),
      this.keccak();
  }
  writeInto(e) {
    Ew(this, !1), Lv(e), this.finish();
    const n = this.state,
      { blockLen: r } = this;
    for (let i = 0, s = e.length; i < s; ) {
      this.posOut >= r && this.keccak();
      const o = Math.min(r - this.posOut, s - i);
      e.set(n.subarray(this.posOut, this.posOut + o), i),
        (this.posOut += o),
        (i += o);
    }
    return e;
  }
  xofInto(e) {
    if (!this.enableXOF)
      throw new Error("XOF is not possible for this instance");
    return this.writeInto(e);
  }
  xof(e) {
    return bw(e), this.xofInto(new Uint8Array(e));
  }
  digestInto(e) {
    if ((zM(e, this), this.finished))
      throw new Error("digest() was already called");
    return this.writeInto(e), this.destroy(), e;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
  destroy() {
    (this.destroyed = !0), this.state.fill(0);
  }
  _cloneInto(e) {
    const {
      blockLen: n,
      suffix: r,
      outputLen: i,
      rounds: s,
      enableXOF: o,
    } = this;
    return (
      e || (e = new jA(n, r, i, o, s)),
      e.state32.set(this.state32),
      (e.pos = this.pos),
      (e.posOut = this.posOut),
      (e.finished = this.finished),
      (e.rounds = s),
      (e.suffix = r),
      (e.outputLen = i),
      (e.enableXOF = o),
      (e.destroyed = this.destroyed),
      e
    );
  }
}
const Wue = (t, e, n) => HM(() => new jA(e, t, n)),
  Hue = Wue(1, 136, 256 / 8);
function cg(t, e) {
  const n = e || "hex",
    r = Hue(jc(t, { strict: !1 }) ? Mv(t) : t);
  return n === "bytes" ? r : cp(r);
}
const que = (t) => cg(Mv(t));
function Vue(t) {
  return que(t);
}
function Gue(t) {
  let e = !0,
    n = "",
    r = 0,
    i = "",
    s = !1;
  for (let o = 0; o < t.length; o++) {
    const a = t[o];
    if (
      (["(", ")", ","].includes(a) && (e = !0),
      a === "(" && r++,
      a === ")" && r--,
      !!e)
    ) {
      if (r === 0) {
        if (a === " " && ["event", "function", ""].includes(i)) i = "";
        else if (((i += a), a === ")")) {
          s = !0;
          break;
        }
        continue;
      }
      if (a === " ") {
        t[o - 1] !== "," && n !== "," && n !== ",(" && ((n = ""), (e = !1));
        continue;
      }
      (i += a), (n += a);
    }
  }
  if (!s) throw new ge("Unable to normalize signature.");
  return i;
}
const Kue = (t) => {
  const e = typeof t == "string" ? t : PQ(t);
  return Gue(e);
};
function KM(t) {
  return Vue(Kue(t));
}
const FA = KM;
class ru extends ge {
  constructor({ address: e }) {
    super(`Address "${e}" is invalid.`, {
      metaMessages: [
        "- Address must be a hex value of 20 bytes (40 hex characters).",
        "- Address must match its checksum counterpart.",
      ],
      name: "InvalidAddressError",
    });
  }
}
class Uv extends Map {
  constructor(e) {
    super(),
      Object.defineProperty(this, "maxSize", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0,
      }),
      (this.maxSize = e);
  }
  get(e) {
    const n = super.get(e);
    return super.has(e) && n !== void 0 && (this.delete(e), super.set(e, n)), n;
  }
  set(e, n) {
    if ((super.set(e, n), this.maxSize && this.size > this.maxSize)) {
      const r = this.keys().next().value;
      r && this.delete(r);
    }
    return this;
  }
}
const iC = new Uv(8192);
function Bv(t, e) {
  if (iC.has(`${t}.${e}`)) return iC.get(`${t}.${e}`);
  const n = e ? `${e}${t.toLowerCase()}` : t.substring(2).toLowerCase(),
    r = cg(FM(n), "bytes"),
    i = (e ? n.substring(`${e}0x`.length) : n).split("");
  for (let o = 0; o < 40; o += 2)
    r[o >> 1] >> 4 >= 8 && i[o] && (i[o] = i[o].toUpperCase()),
      (r[o >> 1] & 15) >= 8 && i[o + 1] && (i[o + 1] = i[o + 1].toUpperCase());
  const s = `0x${i.join("")}`;
  return iC.set(`${t}.${e}`, s), s;
}
function Nl(t, e) {
  if (!Do(t, { strict: !1 })) throw new ru({ address: t });
  return Bv(t, e);
}
const Yue = /^0x[a-fA-F0-9]{40}$/,
  sC = new Uv(8192);
function Do(t, e) {
  const { strict: n = !0 } = e ?? {},
    r = `${t}.${n}`;
  if (sC.has(r)) return sC.get(r);
  const i = Yue.test(t)
    ? t.toLowerCase() === t
      ? !0
      : n
      ? Bv(t) === t
      : !0
    : !1;
  return sC.set(r, i), i;
}
function lp(t) {
  return typeof t[0] == "string" ? jv(t) : Zue(t);
}
function Zue(t) {
  let e = 0;
  for (const i of t) e += i.length;
  const n = new Uint8Array(e);
  let r = 0;
  for (const i of t) n.set(i, r), (r += i.length);
  return n;
}
function jv(t) {
  return `0x${t.reduce((e, n) => e + n.replace("0x", ""), "")}`;
}
function Cw(t, e, n, { strict: r } = {}) {
  return jc(t, { strict: !1 })
    ? Que(t, e, n, { strict: r })
    : QM(t, e, n, { strict: r });
}
function YM(t, e) {
  if (typeof e == "number" && e > 0 && e > tr(t) - 1)
    throw new MM({ offset: e, position: "start", size: tr(t) });
}
function ZM(t, e, n) {
  if (typeof e == "number" && typeof n == "number" && tr(t) !== n - e)
    throw new MM({ offset: n, position: "end", size: tr(t) });
}
function QM(t, e, n, { strict: r } = {}) {
  YM(t, e);
  const i = t.slice(e, n);
  return r && ZM(i, e, n), i;
}
function Que(t, e, n, { strict: r } = {}) {
  YM(t, e);
  const i = `0x${t.replace("0x", "").slice((e ?? 0) * 2, (n ?? t.length) * 2)}`;
  return r && ZM(i, e, n), i;
}
const Xue =
  /^(u?int)(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/;
function XM(t, e) {
  if (t.length !== e.length)
    throw new lue({ expectedLength: t.length, givenLength: e.length });
  const n = Jue({ params: t, values: e }),
    r = WA(n);
  return r.length === 0 ? "0x" : r;
}
function Jue({ params: t, values: e }) {
  const n = [];
  for (let r = 0; r < t.length; r++) n.push(zA({ param: t[r], value: e[r] }));
  return n;
}
function zA({ param: t, value: e }) {
  const n = HA(t.type);
  if (n) {
    const [r, i] = n;
    return tde(e, { length: r, param: { ...t, type: i } });
  }
  if (t.type === "tuple") return ode(e, { param: t });
  if (t.type === "address") return ede(e);
  if (t.type === "bool") return rde(e);
  if (t.type.startsWith("uint") || t.type.startsWith("int")) {
    const r = t.type.startsWith("int"),
      [, , i = "256"] = Xue.exec(t.type) ?? [];
    return ide(e, { signed: r, size: Number(i) });
  }
  if (t.type.startsWith("bytes")) return nde(e, { param: t });
  if (t.type === "string") return sde(e);
  throw new fue(t.type, { docsPath: "/docs/contract/encodeAbiParameters" });
}
function WA(t) {
  let e = 0;
  for (let s = 0; s < t.length; s++) {
    const { dynamic: o, encoded: a } = t[s];
    o ? (e += 32) : (e += tr(a));
  }
  const n = [],
    r = [];
  let i = 0;
  for (let s = 0; s < t.length; s++) {
    const { dynamic: o, encoded: a } = t[s];
    o ? (n.push(Et(e + i, { size: 32 })), r.push(a), (i += tr(a))) : n.push(a);
  }
  return lp([...n, ...r]);
}
function ede(t) {
  if (!Do(t)) throw new ru({ address: t });
  return { dynamic: !1, encoded: Oc(t.toLowerCase()) };
}
function tde(t, { length: e, param: n }) {
  const r = e === null;
  if (!Array.isArray(t)) throw new mue(t);
  if (!r && t.length !== e)
    throw new aue({
      expectedLength: e,
      givenLength: t.length,
      type: `${n.type}[${e}]`,
    });
  let i = !1;
  const s = [];
  for (let o = 0; o < t.length; o++) {
    const a = zA({ param: n, value: t[o] });
    a.dynamic && (i = !0), s.push(a);
  }
  if (r || i) {
    const o = WA(s);
    if (r) {
      const a = Et(s.length, { size: 32 });
      return { dynamic: !0, encoded: s.length > 0 ? lp([a, o]) : a };
    }
    if (i) return { dynamic: !0, encoded: o };
  }
  return { dynamic: !1, encoded: lp(s.map(({ encoded: o }) => o)) };
}
function nde(t, { param: e }) {
  const [, n] = e.type.split("bytes"),
    r = tr(t);
  if (!n) {
    let i = t;
    return (
      r % 32 !== 0 &&
        (i = Oc(i, {
          dir: "right",
          size: Math.ceil((t.length - 2) / 2 / 32) * 32,
        })),
      { dynamic: !0, encoded: lp([Oc(Et(r, { size: 32 })), i]) }
    );
  }
  if (r !== Number.parseInt(n))
    throw new cue({ expectedSize: Number.parseInt(n), value: t });
  return { dynamic: !1, encoded: Oc(t, { dir: "right" }) };
}
function rde(t) {
  if (typeof t != "boolean")
    throw new ge(
      `Invalid boolean value: "${t}" (type: ${typeof t}). Expected: \`true\` or \`false\`.`
    );
  return { dynamic: !1, encoded: Oc(jM(t)) };
}
function ide(t, { signed: e, size: n = 256 }) {
  if (typeof n == "number") {
    const r = 2n ** (BigInt(n) - (e ? 1n : 0n)) - 1n,
      i = e ? -r - 1n : 0n;
    if (t > r || t < i)
      throw new UM({
        max: r.toString(),
        min: i.toString(),
        signed: e,
        size: n / 8,
        value: t.toString(),
      });
  }
  return { dynamic: !1, encoded: Et(t, { size: 32, signed: e }) };
}
function sde(t) {
  const e = $v(t),
    n = Math.ceil(tr(e) / 32),
    r = [];
  for (let i = 0; i < n; i++)
    r.push(Oc(Cw(e, i * 32, (i + 1) * 32), { dir: "right" }));
  return { dynamic: !0, encoded: lp([Oc(Et(tr(e), { size: 32 })), ...r]) };
}
function ode(t, { param: e }) {
  let n = !1;
  const r = [];
  for (let i = 0; i < e.components.length; i++) {
    const s = e.components[i],
      o = Array.isArray(t) ? i : s.name,
      a = zA({ param: s, value: t[o] });
    r.push(a), a.dynamic && (n = !0);
  }
  return { dynamic: n, encoded: n ? WA(r) : lp(r.map(({ encoded: i }) => i)) };
}
function HA(t) {
  const e = t.match(/^(.*)\[(\d+)?\]$/);
  return e ? [e[2] ? Number(e[2]) : null, e[1]] : void 0;
}
const qA = (t) => Cw(KM(t), 0, 4);
function VA(t) {
  const { abi: e, args: n = [], name: r } = t,
    i = jc(r, { strict: !1 }),
    s = e.filter((a) =>
      i
        ? a.type === "function"
          ? qA(a) === r
          : a.type === "event"
          ? FA(a) === r
          : !1
        : "name" in a && a.name === r
    );
  if (s.length === 0) return;
  if (s.length === 1) return s[0];
  let o;
  for (const a of s) {
    if (!("inputs" in a)) continue;
    if (!n || n.length === 0) {
      if (!a.inputs || a.inputs.length === 0) return a;
      continue;
    }
    if (!a.inputs || a.inputs.length === 0 || a.inputs.length !== n.length)
      continue;
    if (
      n.every((d, p) => {
        const f = "inputs" in a && a.inputs[p];
        return f ? eS(d, f) : !1;
      })
    ) {
      if (o && "inputs" in o && o.inputs) {
        const d = JM(a.inputs, o.inputs, n);
        if (d)
          throw new pue({ abiItem: a, type: d[0] }, { abiItem: o, type: d[1] });
      }
      o = a;
    }
  }
  return o || s[0];
}
function eS(t, e) {
  const n = typeof t,
    r = e.type;
  switch (r) {
    case "address":
      return Do(t, { strict: !1 });
    case "bool":
      return n === "boolean";
    case "function":
      return n === "string";
    case "string":
      return n === "string";
    default:
      return r === "tuple" && "components" in e
        ? Object.values(e.components).every((i, s) =>
            eS(Object.values(t)[s], i)
          )
        : /^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/.test(
            r
          )
        ? n === "number" || n === "bigint"
        : /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/.test(r)
        ? n === "string" || t instanceof Uint8Array
        : /[a-z]+[1-9]{0,3}(\[[0-9]{0,}\])+$/.test(r)
        ? Array.isArray(t) &&
          t.every((i) =>
            eS(i, { ...e, type: r.replace(/(\[[0-9]{0,}\])$/, "") })
          )
        : !1;
  }
}
function JM(t, e, n) {
  for (const r in t) {
    const i = t[r],
      s = e[r];
    if (
      i.type === "tuple" &&
      s.type === "tuple" &&
      "components" in i &&
      "components" in s
    )
      return JM(i.components, s.components, n[r]);
    const o = [i.type, s.type];
    if (
      o.includes("address") && o.includes("bytes20")
        ? !0
        : o.includes("address") && o.includes("string")
        ? Do(n[r], { strict: !1 })
        : o.includes("address") && o.includes("bytes")
        ? Do(n[r], { strict: !1 })
        : !1
    )
      return o;
  }
}
function ade(t, { method: e }) {
  var r, i;
  const n = {};
  return (
    t.transport.type === "fallback" &&
      ((i = (r = t.transport).onResponse) == null ||
        i.call(r, ({ method: s, response: o, status: a, transport: l }) => {
          a === "success" && e === s && (n[o] = l.request);
        })),
    (s) => n[s] || t.request
  );
}
function Bo(t) {
  return typeof t == "string" ? { address: t, type: "json-rpc" } : t;
}
const jO = "/docs/contract/encodeFunctionData";
function cde(t) {
  const { abi: e, args: n, functionName: r } = t;
  let i = e[0];
  if (r) {
    const s = VA({ abi: e, args: n, name: r });
    if (!s) throw new vw(r, { docsPath: jO });
    i = s;
  }
  if (i.type !== "function") throw new vw(void 0, { docsPath: jO });
  return { abi: [i], functionName: qA(Bc(i)) };
}
function Fv(t) {
  const { args: e } = t,
    { abi: n, functionName: r } = (() => {
      var a;
      return t.abi.length === 1 &&
        (a = t.functionName) != null &&
        a.startsWith("0x")
        ? t
        : cde(t);
    })(),
    i = n[0],
    s = r,
    o = "inputs" in i && i.inputs ? XM(i.inputs, e ?? []) : void 0;
  return jv([s, o ?? "0x"]);
}
const lde = {
    1: "An `assert` condition failed.",
    17: "Arithmetic operation resulted in underflow or overflow.",
    18: "Division or modulo by zero (e.g. `5 / 0` or `23 % 0`).",
    33: "Attempted to convert to an invalid type.",
    34: "Attempted to access a storage byte array that is incorrectly encoded.",
    49: "Performed `.pop()` on an empty array",
    50: "Array index is out of bounds.",
    65: "Allocated too much memory or created an array which is too large.",
    81: "Attempted to call a zero-initialized variable of internal function type.",
  },
  ude = {
    inputs: [{ name: "message", type: "string" }],
    name: "Error",
    type: "error",
  },
  dde = {
    inputs: [{ name: "reason", type: "uint256" }],
    name: "Panic",
    type: "error",
  };
class FO extends ge {
  constructor({ offset: e }) {
    super(`Offset \`${e}\` cannot be negative.`, {
      name: "NegativeOffsetError",
    });
  }
}
class e6 extends ge {
  constructor({ length: e, position: n }) {
    super(`Position \`${n}\` is out of bounds (\`0 < position < ${e}\`).`, {
      name: "PositionOutOfBoundsError",
    });
  }
}
class pde extends ge {
  constructor({ count: e, limit: n }) {
    super(
      `Recursive read limit of \`${n}\` exceeded (recursive read count: \`${e}\`).`,
      { name: "RecursiveReadLimitExceededError" }
    );
  }
}
const fde = {
  bytes: new Uint8Array(),
  dataView: new DataView(new ArrayBuffer(0)),
  position: 0,
  positionReadCount: new Map(),
  recursiveReadCount: 0,
  recursiveReadLimit: Number.POSITIVE_INFINITY,
  assertReadLimit() {
    if (this.recursiveReadCount >= this.recursiveReadLimit)
      throw new pde({
        count: this.recursiveReadCount + 1,
        limit: this.recursiveReadLimit,
      });
  },
  assertPosition(t) {
    if (t < 0 || t > this.bytes.length - 1)
      throw new e6({ length: this.bytes.length, position: t });
  },
  decrementPosition(t) {
    if (t < 0) throw new FO({ offset: t });
    const e = this.position - t;
    this.assertPosition(e), (this.position = e);
  },
  getReadCount(t) {
    return this.positionReadCount.get(t || this.position) || 0;
  },
  incrementPosition(t) {
    if (t < 0) throw new FO({ offset: t });
    const e = this.position + t;
    this.assertPosition(e), (this.position = e);
  },
  inspectByte(t) {
    const e = t ?? this.position;
    return this.assertPosition(e), this.bytes[e];
  },
  inspectBytes(t, e) {
    const n = e ?? this.position;
    return this.assertPosition(n + t - 1), this.bytes.subarray(n, n + t);
  },
  inspectUint8(t) {
    const e = t ?? this.position;
    return this.assertPosition(e), this.bytes[e];
  },
  inspectUint16(t) {
    const e = t ?? this.position;
    return this.assertPosition(e + 1), this.dataView.getUint16(e);
  },
  inspectUint24(t) {
    const e = t ?? this.position;
    return (
      this.assertPosition(e + 2),
      (this.dataView.getUint16(e) << 8) + this.dataView.getUint8(e + 2)
    );
  },
  inspectUint32(t) {
    const e = t ?? this.position;
    return this.assertPosition(e + 3), this.dataView.getUint32(e);
  },
  pushByte(t) {
    this.assertPosition(this.position),
      (this.bytes[this.position] = t),
      this.position++;
  },
  pushBytes(t) {
    this.assertPosition(this.position + t.length - 1),
      this.bytes.set(t, this.position),
      (this.position += t.length);
  },
  pushUint8(t) {
    this.assertPosition(this.position),
      (this.bytes[this.position] = t),
      this.position++;
  },
  pushUint16(t) {
    this.assertPosition(this.position + 1),
      this.dataView.setUint16(this.position, t),
      (this.position += 2);
  },
  pushUint24(t) {
    this.assertPosition(this.position + 2),
      this.dataView.setUint16(this.position, t >> 8),
      this.dataView.setUint8(this.position + 2, t & 255),
      (this.position += 3);
  },
  pushUint32(t) {
    this.assertPosition(this.position + 3),
      this.dataView.setUint32(this.position, t),
      (this.position += 4);
  },
  readByte() {
    this.assertReadLimit(), this._touch();
    const t = this.inspectByte();
    return this.position++, t;
  },
  readBytes(t, e) {
    this.assertReadLimit(), this._touch();
    const n = this.inspectBytes(t);
    return (this.position += e ?? t), n;
  },
  readUint8() {
    this.assertReadLimit(), this._touch();
    const t = this.inspectUint8();
    return (this.position += 1), t;
  },
  readUint16() {
    this.assertReadLimit(), this._touch();
    const t = this.inspectUint16();
    return (this.position += 2), t;
  },
  readUint24() {
    this.assertReadLimit(), this._touch();
    const t = this.inspectUint24();
    return (this.position += 3), t;
  },
  readUint32() {
    this.assertReadLimit(), this._touch();
    const t = this.inspectUint32();
    return (this.position += 4), t;
  },
  get remaining() {
    return this.bytes.length - this.position;
  },
  setPosition(t) {
    const e = this.position;
    return (
      this.assertPosition(t), (this.position = t), () => (this.position = e)
    );
  },
  _touch() {
    if (this.recursiveReadLimit === Number.POSITIVE_INFINITY) return;
    const t = this.getReadCount();
    this.positionReadCount.set(this.position, t + 1),
      t > 0 && this.recursiveReadCount++;
  },
};
function GA(t, { recursiveReadLimit: e = 8192 } = {}) {
  const n = Object.create(fde);
  return (
    (n.bytes = t),
    (n.dataView = new DataView(t.buffer, t.byteOffset, t.byteLength)),
    (n.positionReadCount = new Map()),
    (n.recursiveReadLimit = e),
    n
  );
}
function hde(t, e = {}) {
  typeof e.size < "u" && to(t, { size: e.size });
  const n = _i(t, e);
  return ap(n, e);
}
function mde(t, e = {}) {
  let n = t;
  if (
    (typeof e.size < "u" && (to(n, { size: e.size }), (n = ag(n))),
    n.length > 1 || n[0] > 1)
  )
    throw new wue(n);
  return !!n[0];
}
function va(t, e = {}) {
  typeof e.size < "u" && to(t, { size: e.size });
  const n = _i(t, e);
  return nu(n, e);
}
function gde(t, e = {}) {
  let n = t;
  return (
    typeof e.size < "u" &&
      (to(n, { size: e.size }), (n = ag(n, { dir: "right" }))),
    new TextDecoder().decode(n)
  );
}
function zv(t, e) {
  const n = typeof e == "string" ? ko(e) : e,
    r = GA(n);
  if (tr(n) === 0 && t.length > 0) throw new Dv();
  if (tr(e) && tr(e) < 32)
    throw new OM({
      data: typeof e == "string" ? e : _i(e),
      params: t,
      size: tr(e),
    });
  let i = 0;
  const s = [];
  for (let o = 0; o < t.length; ++o) {
    const a = t[o];
    r.setPosition(i);
    const [l, d] = Od(r, a, { staticPosition: 0 });
    (i += d), s.push(l);
  }
  return s;
}
function Od(t, e, { staticPosition: n }) {
  const r = HA(e.type);
  if (r) {
    const [i, s] = r;
    return wde(t, { ...e, type: s }, { length: i, staticPosition: n });
  }
  if (e.type === "tuple") return Cde(t, e, { staticPosition: n });
  if (e.type === "address") return yde(t);
  if (e.type === "bool") return vde(t);
  if (e.type.startsWith("bytes")) return bde(t, e, { staticPosition: n });
  if (e.type.startsWith("uint") || e.type.startsWith("int")) return Ede(t, e);
  if (e.type === "string") return xde(t, { staticPosition: n });
  throw new hue(e.type, { docsPath: "/docs/contract/decodeAbiParameters" });
}
const zO = 32,
  tS = 32;
function yde(t) {
  const e = t.readBytes(32);
  return [Bv(_i(QM(e, -20))), 32];
}
function wde(t, e, { length: n, staticPosition: r }) {
  if (!n) {
    const o = va(t.readBytes(tS)),
      a = r + o,
      l = a + zO;
    t.setPosition(a);
    const d = va(t.readBytes(zO)),
      p = Yh(e);
    let f = 0;
    const m = [];
    for (let y = 0; y < d; ++y) {
      t.setPosition(l + (p ? y * 32 : f));
      const [g, v] = Od(t, e, { staticPosition: l });
      (f += v), m.push(g);
    }
    return t.setPosition(r + 32), [m, 32];
  }
  if (Yh(e)) {
    const o = va(t.readBytes(tS)),
      a = r + o,
      l = [];
    for (let d = 0; d < n; ++d) {
      t.setPosition(a + d * 32);
      const [p] = Od(t, e, { staticPosition: a });
      l.push(p);
    }
    return t.setPosition(r + 32), [l, 32];
  }
  let i = 0;
  const s = [];
  for (let o = 0; o < n; ++o) {
    const [a, l] = Od(t, e, { staticPosition: r + i });
    (i += l), s.push(a);
  }
  return [s, i];
}
function vde(t) {
  return [mde(t.readBytes(32), { size: 32 }), 32];
}
function bde(t, e, { staticPosition: n }) {
  const [r, i] = e.type.split("bytes");
  if (!i) {
    const o = va(t.readBytes(32));
    t.setPosition(n + o);
    const a = va(t.readBytes(32));
    if (a === 0) return t.setPosition(n + 32), ["0x", 32];
    const l = t.readBytes(a);
    return t.setPosition(n + 32), [_i(l), 32];
  }
  return [_i(t.readBytes(Number.parseInt(i), 32)), 32];
}
function Ede(t, e) {
  const n = e.type.startsWith("int"),
    r = Number.parseInt(e.type.split("int")[1] || "256"),
    i = t.readBytes(32);
  return [r > 48 ? hde(i, { signed: n }) : va(i, { signed: n }), 32];
}
function Cde(t, e, { staticPosition: n }) {
  const r = e.components.length === 0 || e.components.some(({ name: o }) => !o),
    i = r ? [] : {};
  let s = 0;
  if (Yh(e)) {
    const o = va(t.readBytes(tS)),
      a = n + o;
    for (let l = 0; l < e.components.length; ++l) {
      const d = e.components[l];
      t.setPosition(a + s);
      const [p, f] = Od(t, d, { staticPosition: a });
      (s += f), (i[r ? l : d == null ? void 0 : d.name] = p);
    }
    return t.setPosition(n + 32), [i, 32];
  }
  for (let o = 0; o < e.components.length; ++o) {
    const a = e.components[o],
      [l, d] = Od(t, a, { staticPosition: n });
    (i[r ? o : a == null ? void 0 : a.name] = l), (s += d);
  }
  return [i, s];
}
function xde(t, { staticPosition: e }) {
  const n = va(t.readBytes(32)),
    r = e + n;
  t.setPosition(r);
  const i = va(t.readBytes(32));
  if (i === 0) return t.setPosition(e + 32), ["", 32];
  const s = t.readBytes(i, 32),
    o = gde(ag(s));
  return t.setPosition(e + 32), [o, 32];
}
function Yh(t) {
  var r;
  const { type: e } = t;
  if (e === "string" || e === "bytes" || e.endsWith("[]")) return !0;
  if (e === "tuple") return (r = t.components) == null ? void 0 : r.some(Yh);
  const n = HA(t.type);
  return !!(n && Yh({ ...t, type: n[1] }));
}
function Sde(t) {
  const { abi: e, data: n } = t,
    r = Cw(n, 0, 4);
  if (r === "0x") throw new Dv();
  const s = [...(e || []), ude, dde].find(
    (o) => o.type === "error" && r === qA(Bc(o))
  );
  if (!s) throw new kM(r, { docsPath: "/docs/contract/decodeErrorResult" });
  return {
    abiItem: s,
    args:
      "inputs" in s && s.inputs && s.inputs.length > 0
        ? zv(s.inputs, Cw(n, 4))
        : void 0,
    errorName: s.name,
  };
}
const gs = (t, e, n) =>
  JSON.stringify(t, (r, i) => (typeof i == "bigint" ? i.toString() : i), n);
function t6({
  abiItem: t,
  args: e,
  includeFunctionName: n = !0,
  includeName: r = !1,
}) {
  if ("name" in t && "inputs" in t && t.inputs)
    return `${n ? t.name : ""}(${t.inputs
      .map(
        (i, s) =>
          `${r && i.name ? `${i.name}: ` : ""}${
            typeof e[s] == "object" ? gs(e[s]) : e[s]
          }`
      )
      .join(", ")})`;
}
const Ade = { gwei: 9, wei: 18 },
  _de = { ether: -9, wei: 9 },
  Ide = { ether: -18, gwei: -9 };
function Ln(t, e) {
  let n = t.toString();
  const r = n.startsWith("-");
  r && (n = n.slice(1)), (n = n.padStart(e, "0"));
  let [i, s] = [n.slice(0, n.length - e), n.slice(n.length - e)];
  return (
    (s = s.replace(/(0+)$/, "")),
    `${r ? "-" : ""}${i || "0"}${s ? `.${s}` : ""}`
  );
}
function KA(t, e = "wei") {
  return Ln(t, Ade[e]);
}
function Si(t, e = "wei") {
  return Ln(t, _de[e]);
}
class Tde extends ge {
  constructor({ address: e }) {
    super(`State for account "${e}" is set multiple times.`, {
      name: "AccountStateConflictError",
    });
  }
}
class Pde extends ge {
  constructor() {
    super("state and stateDiff are set on the same account.", {
      name: "StateAssignmentConflictError",
    });
  }
}
function WO(t) {
  return t.reduce(
    (e, { slot: n, value: r }) => `${e}        ${n}: ${r}
`,
    ""
  );
}
function Rde(t) {
  return t
    .reduce(
      (e, { address: n, ...r }) => {
        let i = `${e}    ${n}:
`;
        return (
          r.nonce &&
            (i += `      nonce: ${r.nonce}
`),
          r.balance &&
            (i += `      balance: ${r.balance}
`),
          r.code &&
            (i += `      code: ${r.code}
`),
          r.state &&
            ((i += `      state:
`),
            (i += WO(r.state))),
          r.stateDiff &&
            ((i += `      stateDiff:
`),
            (i += WO(r.stateDiff))),
          i
        );
      },
      `  State Override:
`
    )
    .slice(0, -1);
}
function lg(t) {
  const e = Object.entries(t)
      .map(([r, i]) => (i === void 0 || i === !1 ? null : [r, i]))
      .filter(Boolean),
    n = e.reduce((r, [i]) => Math.max(r, i.length), 0);
  return e.map(([r, i]) => `  ${`${r}:`.padEnd(n + 1)}  ${i}`).join(`
`);
}
class Nde extends ge {
  constructor() {
    super(
      [
        "Cannot specify both a `gasPrice` and a `maxFeePerGas`/`maxPriorityFeePerGas`.",
        "Use `maxFeePerGas`/`maxPriorityFeePerGas` for EIP-1559 compatible networks, and `gasPrice` for others.",
      ].join(`
`),
      { name: "FeeConflictError" }
    );
  }
}
class Ode extends ge {
  constructor({ transaction: e }) {
    super("Cannot infer a transaction type from provided transaction.", {
      metaMessages: [
        "Provided Transaction:",
        "{",
        lg(e),
        "}",
        "",
        "To infer the type, either provide:",
        "- a `type` to the Transaction, or",
        "- an EIP-1559 Transaction with `maxFeePerGas`, or",
        "- an EIP-2930 Transaction with `gasPrice` & `accessList`, or",
        "- an EIP-4844 Transaction with `blobs`, `blobVersionedHashes`, `sidecars`, or",
        "- an EIP-7702 Transaction with `authorizationList`, or",
        "- a Legacy Transaction with `gasPrice`",
      ],
      name: "InvalidSerializableTransactionError",
    });
  }
}
class kde extends ge {
  constructor(
    e,
    {
      account: n,
      docsPath: r,
      chain: i,
      data: s,
      gas: o,
      gasPrice: a,
      maxFeePerGas: l,
      maxPriorityFeePerGas: d,
      nonce: p,
      to: f,
      value: m,
    }
  ) {
    var g;
    const y = lg({
      chain:
        i &&
        `${i == null ? void 0 : i.name} (id: ${i == null ? void 0 : i.id})`,
      from: n == null ? void 0 : n.address,
      to: f,
      value:
        typeof m < "u" &&
        `${KA(m)} ${
          ((g = i == null ? void 0 : i.nativeCurrency) == null
            ? void 0
            : g.symbol) || "ETH"
        }`,
      data: s,
      gas: o,
      gasPrice: typeof a < "u" && `${Si(a)} gwei`,
      maxFeePerGas: typeof l < "u" && `${Si(l)} gwei`,
      maxPriorityFeePerGas: typeof d < "u" && `${Si(d)} gwei`,
      nonce: p,
    });
    super(e.shortMessage, {
      cause: e,
      docsPath: r,
      metaMessages: [
        ...(e.metaMessages ? [...e.metaMessages, " "] : []),
        "Request Arguments:",
        y,
      ].filter(Boolean),
      name: "TransactionExecutionError",
    }),
      Object.defineProperty(this, "cause", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0,
      }),
      (this.cause = e);
  }
}
class n6 extends ge {
  constructor({
    blockHash: e,
    blockNumber: n,
    blockTag: r,
    hash: i,
    index: s,
  }) {
    let o = "Transaction";
    r &&
      s !== void 0 &&
      (o = `Transaction at block time "${r}" at index "${s}"`),
      e &&
        s !== void 0 &&
        (o = `Transaction at block hash "${e}" at index "${s}"`),
      n &&
        s !== void 0 &&
        (o = `Transaction at block number "${n}" at index "${s}"`),
      i && (o = `Transaction with hash "${i}"`),
      super(`${o} could not be found.`, { name: "TransactionNotFoundError" });
  }
}
class r6 extends ge {
  constructor({ hash: e }) {
    super(
      `Transaction receipt with hash "${e}" could not be found. The Transaction may not be processed on a block yet.`,
      { name: "TransactionReceiptNotFoundError" }
    );
  }
}
class Dde extends ge {
  constructor({ hash: e }) {
    super(
      `Timed out while waiting for transaction with hash "${e}" to be confirmed.`,
      { name: "WaitForTransactionReceiptTimeoutError" }
    );
  }
}
const $de = (t) => t,
  YA = (t) => t;
class Mde extends ge {
  constructor(
    e,
    {
      account: n,
      docsPath: r,
      chain: i,
      data: s,
      gas: o,
      gasPrice: a,
      maxFeePerGas: l,
      maxPriorityFeePerGas: d,
      nonce: p,
      to: f,
      value: m,
      stateOverride: y,
    }
  ) {
    var b;
    const g = n ? Bo(n) : void 0;
    let v = lg({
      from: g == null ? void 0 : g.address,
      to: f,
      value:
        typeof m < "u" &&
        `${KA(m)} ${
          ((b = i == null ? void 0 : i.nativeCurrency) == null
            ? void 0
            : b.symbol) || "ETH"
        }`,
      data: s,
      gas: o,
      gasPrice: typeof a < "u" && `${Si(a)} gwei`,
      maxFeePerGas: typeof l < "u" && `${Si(l)} gwei`,
      maxPriorityFeePerGas: typeof d < "u" && `${Si(d)} gwei`,
      nonce: p,
    });
    y &&
      (v += `
${Rde(y)}`),
      super(e.shortMessage, {
        cause: e,
        docsPath: r,
        metaMessages: [
          ...(e.metaMessages ? [...e.metaMessages, " "] : []),
          "Raw Call Arguments:",
          v,
        ].filter(Boolean),
        name: "CallExecutionError",
      }),
      Object.defineProperty(this, "cause", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0,
      }),
      (this.cause = e);
  }
}
class i6 extends ge {
  constructor(
    e,
    {
      abi: n,
      args: r,
      contractAddress: i,
      docsPath: s,
      functionName: o,
      sender: a,
    }
  ) {
    const l = VA({ abi: n, args: r, name: o }),
      d = l
        ? t6({ abiItem: l, args: r, includeFunctionName: !1, includeName: !1 })
        : void 0,
      p = l ? Bc(l, { includeName: !0 }) : void 0,
      f = lg({
        address: i && $de(i),
        function: p,
        args:
          d &&
          d !== "()" &&
          `${[...Array((o == null ? void 0 : o.length) ?? 0).keys()]
            .map(() => " ")
            .join("")}${d}`,
        sender: a,
      });
    super(
      e.shortMessage ||
        `An unknown error occurred while executing the contract function "${o}".`,
      {
        cause: e,
        docsPath: s,
        metaMessages: [
          ...(e.metaMessages ? [...e.metaMessages, " "] : []),
          f && "Contract Call:",
          f,
        ].filter(Boolean),
        name: "ContractFunctionExecutionError",
      }
    ),
      Object.defineProperty(this, "abi", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0,
      }),
      Object.defineProperty(this, "args", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0,
      }),
      Object.defineProperty(this, "cause", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0,
      }),
      Object.defineProperty(this, "contractAddress", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0,
      }),
      Object.defineProperty(this, "formattedArgs", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0,
      }),
      Object.defineProperty(this, "functionName", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0,
      }),
      Object.defineProperty(this, "sender", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0,
      }),
      (this.abi = n),
      (this.args = r),
      (this.cause = e),
      (this.contractAddress = i),
      (this.functionName = o),
      (this.sender = a);
  }
}
class Lde extends ge {
  constructor({ abi: e, data: n, functionName: r, message: i }) {
    let s, o, a, l;
    if (n && n !== "0x")
      try {
        o = Sde({ abi: e, data: n });
        const { abiItem: p, errorName: f, args: m } = o;
        if (f === "Error") l = m[0];
        else if (f === "Panic") {
          const [y] = m;
          l = lde[y];
        } else {
          const y = p ? Bc(p, { includeName: !0 }) : void 0,
            g =
              p && m
                ? t6({
                    abiItem: p,
                    args: m,
                    includeFunctionName: !1,
                    includeName: !1,
                  })
                : void 0;
          a = [
            y ? `Error: ${y}` : "",
            g && g !== "()"
              ? `       ${[
                  ...Array((f == null ? void 0 : f.length) ?? 0).keys(),
                ]
                  .map(() => " ")
                  .join("")}${g}`
              : "",
          ];
        }
      } catch (p) {
        s = p;
      }
    else i && (l = i);
    let d;
    s instanceof kM &&
      ((d = s.signature),
      (a = [
        `Unable to decode signature "${d}" as it was not found on the provided ABI.`,
        "Make sure you are using the correct ABI and that the error exists on it.",
        `You can look up the decoded signature here: https://openchain.xyz/signatures?query=${d}.`,
      ])),
      super(
        (l && l !== "execution reverted") || d
          ? [
              `The contract function "${r}" reverted with the following ${
                d ? "signature" : "reason"
              }:`,
              l || d,
            ].join(`
`)
          : `The contract function "${r}" reverted.`,
        { cause: s, metaMessages: a, name: "ContractFunctionRevertedError" }
      ),
      Object.defineProperty(this, "data", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0,
      }),
      Object.defineProperty(this, "raw", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0,
      }),
      Object.defineProperty(this, "reason", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0,
      }),
      Object.defineProperty(this, "signature", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0,
      }),
      (this.data = o),
      (this.raw = n),
      (this.reason = l),
      (this.signature = d);
  }
}
class Ude extends ge {
  constructor({ functionName: e }) {
    super(`The contract function "${e}" returned no data ("0x").`, {
      metaMessages: [
        "This could be due to any of the following:",
        `  - The contract does not have the function "${e}",`,
        "  - The parameters passed to the contract function may be invalid, or",
        "  - The address is not a contract.",
      ],
      name: "ContractFunctionZeroDataError",
    });
  }
}
class Bde extends ge {
  constructor({ factory: e }) {
    super(
      `Deployment for counterfactual contract call failed${
        e ? ` for factory "${e}".` : ""
      }`,
      {
        metaMessages: [
          "Please ensure:",
          "- The `factory` is a valid contract deployment factory (ie. Create2 Factory, ERC-4337 Factory, etc).",
          "- The `factoryData` is a valid encoded function call for contract deployment function on the factory.",
        ],
        name: "CounterfactualDeploymentFailedError",
      }
    );
  }
}
class ZA extends ge {
  constructor({ data: e, message: n }) {
    super(n || "", { name: "RawContractError" }),
      Object.defineProperty(this, "code", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: 3,
      }),
      Object.defineProperty(this, "data", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0,
      }),
      (this.data = e);
  }
}
class xh extends ge {
  constructor({
    body: e,
    cause: n,
    details: r,
    headers: i,
    status: s,
    url: o,
  }) {
    super("HTTP request failed.", {
      cause: n,
      details: r,
      metaMessages: [
        s && `Status: ${s}`,
        `URL: ${YA(o)}`,
        e && `Request body: ${gs(e)}`,
      ].filter(Boolean),
      name: "HttpRequestError",
    }),
      Object.defineProperty(this, "body", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0,
      }),
      Object.defineProperty(this, "headers", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0,
      }),
      Object.defineProperty(this, "status", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0,
      }),
      Object.defineProperty(this, "url", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0,
      }),
      (this.body = e),
      (this.headers = i),
      (this.status = s),
      (this.url = o);
  }
}
class QA extends ge {
  constructor({ body: e, error: n, url: r }) {
    super("RPC Request failed.", {
      cause: n,
      details: n.message,
      metaMessages: [`URL: ${YA(r)}`, `Request body: ${gs(e)}`],
      name: "RpcRequestError",
    }),
      Object.defineProperty(this, "code", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0,
      }),
      Object.defineProperty(this, "data", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0,
      }),
      (this.code = n.code),
      (this.data = n.data);
  }
}
class HO extends ge {
  constructor({ body: e, url: n }) {
    super("The request took too long to respond.", {
      details: "The request timed out.",
      metaMessages: [`URL: ${YA(n)}`, `Request body: ${gs(e)}`],
      name: "TimeoutError",
    });
  }
}
const jde = -1;
class Pi extends ge {
  constructor(
    e,
    { code: n, docsPath: r, metaMessages: i, name: s, shortMessage: o }
  ) {
    super(o, {
      cause: e,
      docsPath: r,
      metaMessages: i || (e == null ? void 0 : e.metaMessages),
      name: s || "RpcError",
    }),
      Object.defineProperty(this, "code", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0,
      }),
      (this.name = s || e.name),
      (this.code = e instanceof QA ? e.code : n ?? jde);
  }
}
class Yi extends Pi {
  constructor(e, n) {
    super(e, n),
      Object.defineProperty(this, "data", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0,
      }),
      (this.data = n.data);
  }
}
class Zh extends Pi {
  constructor(e) {
    super(e, {
      code: Zh.code,
      name: "ParseRpcError",
      shortMessage:
        "Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text.",
    });
  }
}
Object.defineProperty(Zh, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32700,
});
class Qh extends Pi {
  constructor(e) {
    super(e, {
      code: Qh.code,
      name: "InvalidRequestRpcError",
      shortMessage: "JSON is not a valid request object.",
    });
  }
}
Object.defineProperty(Qh, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32600,
});
class Xh extends Pi {
  constructor(e, { method: n } = {}) {
    super(e, {
      code: Xh.code,
      name: "MethodNotFoundRpcError",
      shortMessage: `The method${
        n ? ` "${n}"` : ""
      } does not exist / is not available.`,
    });
  }
}
Object.defineProperty(Xh, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32601,
});
class Jh extends Pi {
  constructor(e) {
    super(e, {
      code: Jh.code,
      name: "InvalidParamsRpcError",
      shortMessage: [
        "Invalid parameters were provided to the RPC method.",
        "Double check you have provided the correct parameters.",
      ].join(`
`),
    });
  }
}
Object.defineProperty(Jh, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32602,
});
class iu extends Pi {
  constructor(e) {
    super(e, {
      code: iu.code,
      name: "InternalRpcError",
      shortMessage: "An internal error was received.",
    });
  }
}
Object.defineProperty(iu, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32603,
});
class em extends Pi {
  constructor(e) {
    super(e, {
      code: em.code,
      name: "InvalidInputRpcError",
      shortMessage: [
        "Missing or invalid parameters.",
        "Double check you have provided the correct parameters.",
      ].join(`
`),
    });
  }
}
Object.defineProperty(em, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32e3,
});
class tm extends Pi {
  constructor(e) {
    super(e, {
      code: tm.code,
      name: "ResourceNotFoundRpcError",
      shortMessage: "Requested resource not found.",
    }),
      Object.defineProperty(this, "name", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: "ResourceNotFoundRpcError",
      });
  }
}
Object.defineProperty(tm, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32001,
});
class kc extends Pi {
  constructor(e) {
    super(e, {
      code: kc.code,
      name: "ResourceUnavailableRpcError",
      shortMessage: "Requested resource not available.",
    });
  }
}
Object.defineProperty(kc, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32002,
});
class up extends Pi {
  constructor(e) {
    super(e, {
      code: up.code,
      name: "TransactionRejectedRpcError",
      shortMessage: "Transaction creation failed.",
    });
  }
}
Object.defineProperty(up, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32003,
});
class Ol extends Pi {
  constructor(e, { method: n } = {}) {
    super(e, {
      code: Ol.code,
      name: "MethodNotSupportedRpcError",
      shortMessage: `Method${n ? ` "${n}"` : ""} is not supported.`,
    });
  }
}
Object.defineProperty(Ol, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32004,
});
class dp extends Pi {
  constructor(e) {
    super(e, {
      code: dp.code,
      name: "LimitExceededRpcError",
      shortMessage: "Request exceeds defined limit.",
    });
  }
}
Object.defineProperty(dp, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32005,
});
class nm extends Pi {
  constructor(e) {
    super(e, {
      code: nm.code,
      name: "JsonRpcVersionUnsupportedError",
      shortMessage: "Version of JSON-RPC protocol is not supported.",
    });
  }
}
Object.defineProperty(nm, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32006,
});
class Qn extends Yi {
  constructor(e) {
    super(e, {
      code: Qn.code,
      name: "UserRejectedRequestError",
      shortMessage: "User rejected the request.",
    });
  }
}
Object.defineProperty(Qn, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 4001,
});
class rm extends Yi {
  constructor(e) {
    super(e, {
      code: rm.code,
      name: "UnauthorizedProviderError",
      shortMessage:
        "The requested method and/or account has not been authorized by the user.",
    });
  }
}
Object.defineProperty(rm, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 4100,
});
class im extends Yi {
  constructor(e, { method: n } = {}) {
    super(e, {
      code: im.code,
      name: "UnsupportedProviderMethodError",
      shortMessage: `The Provider does not support the requested method${
        n ? ` " ${n}"` : ""
      }.`,
    });
  }
}
Object.defineProperty(im, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 4200,
});
class sm extends Yi {
  constructor(e) {
    super(e, {
      code: sm.code,
      name: "ProviderDisconnectedError",
      shortMessage: "The Provider is disconnected from all chains.",
    });
  }
}
Object.defineProperty(sm, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 4900,
});
class om extends Yi {
  constructor(e) {
    super(e, {
      code: om.code,
      name: "ChainDisconnectedError",
      shortMessage: "The Provider is not connected to the requested chain.",
    });
  }
}
Object.defineProperty(om, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 4901,
});
class $o extends Yi {
  constructor(e) {
    super(e, {
      code: $o.code,
      name: "SwitchChainError",
      shortMessage: "An error occurred when attempting to switch chain.",
    });
  }
}
Object.defineProperty($o, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 4902,
});
class am extends Yi {
  constructor(e) {
    super(e, {
      code: am.code,
      name: "UnsupportedNonOptionalCapabilityError",
      shortMessage:
        "This Wallet does not support a capability that was not marked as optional.",
    });
  }
}
Object.defineProperty(am, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 5700,
});
class cm extends Yi {
  constructor(e) {
    super(e, {
      code: cm.code,
      name: "UnsupportedChainIdError",
      shortMessage: "This Wallet does not support the requested chain ID.",
    });
  }
}
Object.defineProperty(cm, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 5710,
});
class lm extends Yi {
  constructor(e) {
    super(e, {
      code: lm.code,
      name: "DuplicateIdError",
      shortMessage: "There is already a bundle submitted with this ID.",
    });
  }
}
Object.defineProperty(lm, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 5720,
});
class um extends Yi {
  constructor(e) {
    super(e, {
      code: um.code,
      name: "UnknownBundleIdError",
      shortMessage: "This bundle id is unknown / has not been submitted",
    });
  }
}
Object.defineProperty(um, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 5730,
});
class dm extends Yi {
  constructor(e) {
    super(e, {
      code: dm.code,
      name: "BundleTooLargeError",
      shortMessage: "The call bundle is too large for the Wallet to process.",
    });
  }
}
Object.defineProperty(dm, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 5740,
});
class pm extends Yi {
  constructor(e) {
    super(e, {
      code: pm.code,
      name: "AtomicReadyWalletRejectedUpgradeError",
      shortMessage:
        "The Wallet can support atomicity after an upgrade, but the user rejected the upgrade.",
    });
  }
}
Object.defineProperty(pm, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 5750,
});
class fm extends Yi {
  constructor(e) {
    super(e, {
      code: fm.code,
      name: "AtomicityNotSupportedError",
      shortMessage:
        "The wallet does not support atomic execution but the request requires it.",
    });
  }
}
Object.defineProperty(fm, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 5760,
});
class Fde extends Pi {
  constructor(e) {
    super(e, {
      name: "UnknownRpcError",
      shortMessage: "An unknown RPC error occurred.",
    });
  }
}
const zde = 3;
function xw(
  t,
  { abi: e, address: n, args: r, docsPath: i, functionName: s, sender: o }
) {
  const a =
      t instanceof ZA
        ? t
        : t instanceof ge
        ? t.walk((g) => "data" in g) || t.walk()
        : {},
    { code: l, data: d, details: p, message: f, shortMessage: m } = a,
    y =
      t instanceof Dv
        ? new Ude({ functionName: s })
        : [zde, iu.code].includes(l) && (d || p || f || m)
        ? new Lde({
            abi: e,
            data: typeof d == "object" ? d.data : d,
            functionName: s,
            message: a instanceof QA ? p : m ?? f,
          })
        : t;
  return new i6(y, {
    abi: e,
    args: r,
    contractAddress: n,
    docsPath: i,
    functionName: s,
    sender: o,
  });
}
function Wde(t) {
  const e = cg(`0x${t.substring(4)}`).substring(26);
  return Bv(`0x${e}`);
}
async function Hde({ hash: t, signature: e }) {
  const n = jc(t) ? t : cp(t),
    { secp256k1: r } = await ei(async () => {
      const { secp256k1: o } = await import("./secp256k1-C4MgA7l2.js");
      return { secp256k1: o };
    }, []);
  return `0x${(() => {
    if (typeof e == "object" && "r" in e && "s" in e) {
      const { r: d, s: p, v: f, yParity: m } = e,
        y = Number(m ?? f),
        g = qO(y);
      return new r.Signature(ap(d), ap(p)).addRecoveryBit(g);
    }
    const o = jc(e) ? e : cp(e);
    if (tr(o) !== 65) throw new Error("invalid signature length");
    const a = nu(`0x${o.slice(130)}`),
      l = qO(a);
    return r.Signature.fromCompact(o.substring(2, 130)).addRecoveryBit(l);
  })()
    .recoverPublicKey(n.substring(2))
    .toHex(!1)}`;
}
function qO(t) {
  if (t === 0 || t === 1) return t;
  if (t === 27) return 0;
  if (t === 28) return 1;
  throw new Error("Invalid yParityOrV value");
}
async function qde({ hash: t, signature: e }) {
  return Wde(await Hde({ hash: t, signature: e }));
}
function Vde(t, e = "hex") {
  const n = s6(t),
    r = GA(new Uint8Array(n.length));
  return n.encode(r), e === "hex" ? _i(r.bytes) : r.bytes;
}
function s6(t) {
  return Array.isArray(t) ? Gde(t.map((e) => s6(e))) : Kde(t);
}
function Gde(t) {
  const e = t.reduce((i, s) => i + s.length, 0),
    n = o6(e);
  return {
    length: e <= 55 ? 1 + e : 1 + n + e,
    encode(i) {
      e <= 55
        ? i.pushByte(192 + e)
        : (i.pushByte(247 + n),
          n === 1
            ? i.pushUint8(e)
            : n === 2
            ? i.pushUint16(e)
            : n === 3
            ? i.pushUint24(e)
            : i.pushUint32(e));
      for (const { encode: s } of t) s(i);
    },
  };
}
function Kde(t) {
  const e = typeof t == "string" ? ko(t) : t,
    n = o6(e.length);
  return {
    length:
      e.length === 1 && e[0] < 128
        ? 1
        : e.length <= 55
        ? 1 + e.length
        : 1 + n + e.length,
    encode(i) {
      e.length === 1 && e[0] < 128
        ? i.pushBytes(e)
        : e.length <= 55
        ? (i.pushByte(128 + e.length), i.pushBytes(e))
        : (i.pushByte(183 + n),
          n === 1
            ? i.pushUint8(e.length)
            : n === 2
            ? i.pushUint16(e.length)
            : n === 3
            ? i.pushUint24(e.length)
            : i.pushUint32(e.length),
          i.pushBytes(e));
    },
  };
}
function o6(t) {
  if (t < 2 ** 8) return 1;
  if (t < 2 ** 16) return 2;
  if (t < 2 ** 24) return 3;
  if (t < 2 ** 32) return 4;
  throw new ge("Length is too large.");
}
function Yde(t) {
  const { chainId: e, nonce: n, to: r } = t,
    i = t.contractAddress ?? t.address,
    s = cg(jv(["0x05", Vde([e ? Et(e) : "0x", i, n ? Et(n) : "0x"])]));
  return r === "bytes" ? ko(s) : s;
}
async function a6(t) {
  const { authorization: e, signature: n } = t;
  return qde({ hash: Yde(e), signature: n ?? e });
}
class Zde extends ge {
  constructor(
    e,
    {
      account: n,
      docsPath: r,
      chain: i,
      data: s,
      gas: o,
      gasPrice: a,
      maxFeePerGas: l,
      maxPriorityFeePerGas: d,
      nonce: p,
      to: f,
      value: m,
    }
  ) {
    var g;
    const y = lg({
      from: n == null ? void 0 : n.address,
      to: f,
      value:
        typeof m < "u" &&
        `${KA(m)} ${
          ((g = i == null ? void 0 : i.nativeCurrency) == null
            ? void 0
            : g.symbol) || "ETH"
        }`,
      data: s,
      gas: o,
      gasPrice: typeof a < "u" && `${Si(a)} gwei`,
      maxFeePerGas: typeof l < "u" && `${Si(l)} gwei`,
      maxPriorityFeePerGas: typeof d < "u" && `${Si(d)} gwei`,
      nonce: p,
    });
    super(e.shortMessage, {
      cause: e,
      docsPath: r,
      metaMessages: [
        ...(e.metaMessages ? [...e.metaMessages, " "] : []),
        "Estimate Gas Arguments:",
        y,
      ].filter(Boolean),
      name: "EstimateGasExecutionError",
    }),
      Object.defineProperty(this, "cause", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0,
      }),
      (this.cause = e);
  }
}
class kl extends ge {
  constructor({ cause: e, message: n } = {}) {
    var i;
    const r =
      (i = n == null ? void 0 : n.replace("execution reverted: ", "")) == null
        ? void 0
        : i.replace("execution reverted", "");
    super(
      `Execution reverted ${
        r ? `with reason: ${r}` : "for an unknown reason"
      }.`,
      { cause: e, name: "ExecutionRevertedError" }
    );
  }
}
Object.defineProperty(kl, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 3,
});
Object.defineProperty(kl, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /execution reverted/,
});
class Sw extends ge {
  constructor({ cause: e, maxFeePerGas: n } = {}) {
    super(
      `The fee cap (\`maxFeePerGas\`${
        n ? ` = ${Si(n)} gwei` : ""
      }) cannot be higher than the maximum allowed value (2^256-1).`,
      { cause: e, name: "FeeCapTooHighError" }
    );
  }
}
Object.defineProperty(Sw, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /max fee per gas higher than 2\^256-1|fee cap higher than 2\^256-1/,
});
class nS extends ge {
  constructor({ cause: e, maxFeePerGas: n } = {}) {
    super(
      `The fee cap (\`maxFeePerGas\`${
        n ? ` = ${Si(n)}` : ""
      } gwei) cannot be lower than the block base fee.`,
      { cause: e, name: "FeeCapTooLowError" }
    );
  }
}
Object.defineProperty(nS, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value:
    /max fee per gas less than block base fee|fee cap less than block base fee|transaction is outdated/,
});
class rS extends ge {
  constructor({ cause: e, nonce: n } = {}) {
    super(
      `Nonce provided for the transaction ${
        n ? `(${n}) ` : ""
      }is higher than the next one expected.`,
      { cause: e, name: "NonceTooHighError" }
    );
  }
}
Object.defineProperty(rS, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /nonce too high/,
});
class iS extends ge {
  constructor({ cause: e, nonce: n } = {}) {
    super(
      [
        `Nonce provided for the transaction ${
          n ? `(${n}) ` : ""
        }is lower than the current nonce of the account.`,
        "Try increasing the nonce or find the latest nonce with `getTransactionCount`.",
      ].join(`
`),
      { cause: e, name: "NonceTooLowError" }
    );
  }
}
Object.defineProperty(iS, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /nonce too low|transaction already imported|already known/,
});
class sS extends ge {
  constructor({ cause: e, nonce: n } = {}) {
    super(
      `Nonce provided for the transaction ${
        n ? `(${n}) ` : ""
      }exceeds the maximum allowed nonce.`,
      { cause: e, name: "NonceMaxValueError" }
    );
  }
}
Object.defineProperty(sS, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /nonce has max value/,
});
class oS extends ge {
  constructor({ cause: e } = {}) {
    super(
      [
        "The total cost (gas * gas fee + value) of executing this transaction exceeds the balance of the account.",
      ].join(`
`),
      {
        cause: e,
        metaMessages: [
          "This error could arise when the account does not have enough funds to:",
          " - pay for the total gas fee,",
          " - pay for the value to send.",
          " ",
          "The cost of the transaction is calculated as `gas * gas fee + value`, where:",
          " - `gas` is the amount of gas needed for transaction to execute,",
          " - `gas fee` is the gas fee,",
          " - `value` is the amount of ether to send to the recipient.",
        ],
        name: "InsufficientFundsError",
      }
    );
  }
}
Object.defineProperty(oS, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /insufficient funds|exceeds transaction sender account balance/,
});
class aS extends ge {
  constructor({ cause: e, gas: n } = {}) {
    super(
      `The amount of gas ${
        n ? `(${n}) ` : ""
      }provided for the transaction exceeds the limit allowed for the block.`,
      { cause: e, name: "IntrinsicGasTooHighError" }
    );
  }
}
Object.defineProperty(aS, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /intrinsic gas too high|gas limit reached/,
});
class cS extends ge {
  constructor({ cause: e, gas: n } = {}) {
    super(
      `The amount of gas ${
        n ? `(${n}) ` : ""
      }provided for the transaction is too low.`,
      { cause: e, name: "IntrinsicGasTooLowError" }
    );
  }
}
Object.defineProperty(cS, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /intrinsic gas too low/,
});
class lS extends ge {
  constructor({ cause: e }) {
    super("The transaction type is not supported for this chain.", {
      cause: e,
      name: "TransactionTypeNotSupportedError",
    });
  }
}
Object.defineProperty(lS, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /transaction type not valid/,
});
class Aw extends ge {
  constructor({ cause: e, maxPriorityFeePerGas: n, maxFeePerGas: r } = {}) {
    super(
      [
        `The provided tip (\`maxPriorityFeePerGas\`${
          n ? ` = ${Si(n)} gwei` : ""
        }) cannot be higher than the fee cap (\`maxFeePerGas\`${
          r ? ` = ${Si(r)} gwei` : ""
        }).`,
      ].join(`
`),
      { cause: e, name: "TipAboveFeeCapError" }
    );
  }
}
Object.defineProperty(Aw, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value:
    /max priority fee per gas higher than max fee per gas|tip higher than fee cap/,
});
class Wv extends ge {
  constructor({ cause: e }) {
    super(
      `An error occurred while executing: ${
        e == null ? void 0 : e.shortMessage
      }`,
      { cause: e, name: "UnknownNodeError" }
    );
  }
}
function XA(t, e) {
  const n = (t.details || "").toLowerCase(),
    r =
      t instanceof ge
        ? t.walk((i) => (i == null ? void 0 : i.code) === kl.code)
        : t;
  return r instanceof ge
    ? new kl({ cause: t, message: r.details })
    : kl.nodeMessage.test(n)
    ? new kl({ cause: t, message: t.details })
    : Sw.nodeMessage.test(n)
    ? new Sw({ cause: t, maxFeePerGas: e == null ? void 0 : e.maxFeePerGas })
    : nS.nodeMessage.test(n)
    ? new nS({ cause: t, maxFeePerGas: e == null ? void 0 : e.maxFeePerGas })
    : rS.nodeMessage.test(n)
    ? new rS({ cause: t, nonce: e == null ? void 0 : e.nonce })
    : iS.nodeMessage.test(n)
    ? new iS({ cause: t, nonce: e == null ? void 0 : e.nonce })
    : sS.nodeMessage.test(n)
    ? new sS({ cause: t, nonce: e == null ? void 0 : e.nonce })
    : oS.nodeMessage.test(n)
    ? new oS({ cause: t })
    : aS.nodeMessage.test(n)
    ? new aS({ cause: t, gas: e == null ? void 0 : e.gas })
    : cS.nodeMessage.test(n)
    ? new cS({ cause: t, gas: e == null ? void 0 : e.gas })
    : lS.nodeMessage.test(n)
    ? new lS({ cause: t })
    : Aw.nodeMessage.test(n)
    ? new Aw({
        cause: t,
        maxFeePerGas: e == null ? void 0 : e.maxFeePerGas,
        maxPriorityFeePerGas: e == null ? void 0 : e.maxPriorityFeePerGas,
      })
    : new Wv({ cause: t });
}
function Qde(t, { docsPath: e, ...n }) {
  const r = (() => {
    const i = XA(t, n);
    return i instanceof Wv ? t : i;
  })();
  return new Zde(r, { docsPath: e, ...n });
}
function JA(t, { format: e }) {
  if (!e) return {};
  const n = {};
  function r(s) {
    const o = Object.keys(s);
    for (const a of o)
      a in t && (n[a] = t[a]),
        s[a] && typeof s[a] == "object" && !Array.isArray(s[a]) && r(s[a]);
  }
  const i = e(t || {});
  return r(i), n;
}
const Xde = {
  legacy: "0x0",
  eip2930: "0x1",
  eip1559: "0x2",
  eip4844: "0x3",
  eip7702: "0x4",
};
function e_(t) {
  const e = {};
  return (
    typeof t.authorizationList < "u" &&
      (e.authorizationList = Jde(t.authorizationList)),
    typeof t.accessList < "u" && (e.accessList = t.accessList),
    typeof t.blobVersionedHashes < "u" &&
      (e.blobVersionedHashes = t.blobVersionedHashes),
    typeof t.blobs < "u" &&
      (typeof t.blobs[0] != "string"
        ? (e.blobs = t.blobs.map((n) => _i(n)))
        : (e.blobs = t.blobs)),
    typeof t.data < "u" && (e.data = t.data),
    typeof t.from < "u" && (e.from = t.from),
    typeof t.gas < "u" && (e.gas = Et(t.gas)),
    typeof t.gasPrice < "u" && (e.gasPrice = Et(t.gasPrice)),
    typeof t.maxFeePerBlobGas < "u" &&
      (e.maxFeePerBlobGas = Et(t.maxFeePerBlobGas)),
    typeof t.maxFeePerGas < "u" && (e.maxFeePerGas = Et(t.maxFeePerGas)),
    typeof t.maxPriorityFeePerGas < "u" &&
      (e.maxPriorityFeePerGas = Et(t.maxPriorityFeePerGas)),
    typeof t.nonce < "u" && (e.nonce = Et(t.nonce)),
    typeof t.to < "u" && (e.to = t.to),
    typeof t.type < "u" && (e.type = Xde[t.type]),
    typeof t.value < "u" && (e.value = Et(t.value)),
    e
  );
}
function Jde(t) {
  return t.map((e) => ({
    address: e.address,
    r: e.r ? Et(BigInt(e.r)) : e.r,
    s: e.s ? Et(BigInt(e.s)) : e.s,
    chainId: Et(e.chainId),
    nonce: Et(e.nonce),
    ...(typeof e.yParity < "u" ? { yParity: Et(e.yParity) } : {}),
    ...(typeof e.v < "u" && typeof e.yParity > "u" ? { v: Et(e.v) } : {}),
  }));
}
function VO(t) {
  if (!(!t || t.length === 0))
    return t.reduce((e, { slot: n, value: r }) => {
      if (n.length !== 66)
        throw new kO({ size: n.length, targetSize: 66, type: "hex" });
      if (r.length !== 66)
        throw new kO({ size: r.length, targetSize: 66, type: "hex" });
      return (e[n] = r), e;
    }, {});
}
function epe(t) {
  const { balance: e, nonce: n, state: r, stateDiff: i, code: s } = t,
    o = {};
  if (
    (s !== void 0 && (o.code = s),
    e !== void 0 && (o.balance = Et(e)),
    n !== void 0 && (o.nonce = Et(n)),
    r !== void 0 && (o.state = VO(r)),
    i !== void 0)
  ) {
    if (o.state) throw new Pde();
    o.stateDiff = VO(i);
  }
  return o;
}
function c6(t) {
  if (!t) return;
  const e = {};
  for (const { address: n, ...r } of t) {
    if (!Do(n, { strict: !1 })) throw new ru({ address: n });
    if (e[n]) throw new Tde({ address: n });
    e[n] = epe(r);
  }
  return e;
}
const tpe = 2n ** 256n - 1n;
function Hv(t) {
  const {
      account: e,
      gasPrice: n,
      maxFeePerGas: r,
      maxPriorityFeePerGas: i,
      to: s,
    } = t,
    o = e ? Bo(e) : void 0;
  if (o && !Do(o.address)) throw new ru({ address: o.address });
  if (s && !Do(s)) throw new ru({ address: s });
  if (typeof n < "u" && (typeof r < "u" || typeof i < "u")) throw new Nde();
  if (r && r > tpe) throw new Sw({ maxFeePerGas: r });
  if (i && r && i > r)
    throw new Aw({ maxFeePerGas: r, maxPriorityFeePerGas: i });
}
class npe extends ge {
  constructor() {
    super("`baseFeeMultiplier` must be greater than 1.", {
      name: "BaseFeeScalarError",
    });
  }
}
class t_ extends ge {
  constructor() {
    super("Chain does not support EIP-1559 fees.", {
      name: "Eip1559FeesNotSupportedError",
    });
  }
}
class rpe extends ge {
  constructor({ maxPriorityFeePerGas: e }) {
    super(
      `\`maxFeePerGas\` cannot be less than the \`maxPriorityFeePerGas\` (${Si(
        e
      )} gwei).`,
      { name: "MaxFeePerGasTooLowError" }
    );
  }
}
class l6 extends ge {
  constructor({ blockHash: e, blockNumber: n }) {
    let r = "Block";
    e && (r = `Block at hash "${e}"`),
      n && (r = `Block at number "${n}"`),
      super(`${r} could not be found.`, { name: "BlockNotFoundError" });
  }
}
const u6 = {
  "0x0": "legacy",
  "0x1": "eip2930",
  "0x2": "eip1559",
  "0x3": "eip4844",
  "0x4": "eip7702",
};
function d6(t) {
  const e = {
    ...t,
    blockHash: t.blockHash ? t.blockHash : null,
    blockNumber: t.blockNumber ? BigInt(t.blockNumber) : null,
    chainId: t.chainId ? nu(t.chainId) : void 0,
    gas: t.gas ? BigInt(t.gas) : void 0,
    gasPrice: t.gasPrice ? BigInt(t.gasPrice) : void 0,
    maxFeePerBlobGas: t.maxFeePerBlobGas ? BigInt(t.maxFeePerBlobGas) : void 0,
    maxFeePerGas: t.maxFeePerGas ? BigInt(t.maxFeePerGas) : void 0,
    maxPriorityFeePerGas: t.maxPriorityFeePerGas
      ? BigInt(t.maxPriorityFeePerGas)
      : void 0,
    nonce: t.nonce ? nu(t.nonce) : void 0,
    to: t.to ? t.to : null,
    transactionIndex: t.transactionIndex ? Number(t.transactionIndex) : null,
    type: t.type ? u6[t.type] : void 0,
    typeHex: t.type ? t.type : void 0,
    value: t.value ? BigInt(t.value) : void 0,
    v: t.v ? BigInt(t.v) : void 0,
  };
  return (
    t.authorizationList && (e.authorizationList = ipe(t.authorizationList)),
    (e.yParity = (() => {
      if (t.yParity) return Number(t.yParity);
      if (typeof e.v == "bigint") {
        if (e.v === 0n || e.v === 27n) return 0;
        if (e.v === 1n || e.v === 28n) return 1;
        if (e.v >= 35n) return e.v % 2n === 0n ? 1 : 0;
      }
    })()),
    e.type === "legacy" &&
      (delete e.accessList,
      delete e.maxFeePerBlobGas,
      delete e.maxFeePerGas,
      delete e.maxPriorityFeePerGas,
      delete e.yParity),
    e.type === "eip2930" &&
      (delete e.maxFeePerBlobGas,
      delete e.maxFeePerGas,
      delete e.maxPriorityFeePerGas),
    e.type === "eip1559" && delete e.maxFeePerBlobGas,
    e
  );
}
function ipe(t) {
  return t.map((e) => ({
    address: e.address,
    chainId: Number(e.chainId),
    nonce: Number(e.nonce),
    r: e.r,
    s: e.s,
    yParity: Number(e.yParity),
  }));
}
function spe(t) {
  const e = (t.transactions ?? []).map((n) =>
    typeof n == "string" ? n : d6(n)
  );
  return {
    ...t,
    baseFeePerGas: t.baseFeePerGas ? BigInt(t.baseFeePerGas) : null,
    blobGasUsed: t.blobGasUsed ? BigInt(t.blobGasUsed) : void 0,
    difficulty: t.difficulty ? BigInt(t.difficulty) : void 0,
    excessBlobGas: t.excessBlobGas ? BigInt(t.excessBlobGas) : void 0,
    gasLimit: t.gasLimit ? BigInt(t.gasLimit) : void 0,
    gasUsed: t.gasUsed ? BigInt(t.gasUsed) : void 0,
    hash: t.hash ? t.hash : null,
    logsBloom: t.logsBloom ? t.logsBloom : null,
    nonce: t.nonce ? t.nonce : null,
    number: t.number ? BigInt(t.number) : null,
    size: t.size ? BigInt(t.size) : void 0,
    timestamp: t.timestamp ? BigInt(t.timestamp) : void 0,
    transactions: e,
    totalDifficulty: t.totalDifficulty ? BigInt(t.totalDifficulty) : null,
  };
}
async function hm(
  t,
  { blockHash: e, blockNumber: n, blockTag: r, includeTransactions: i } = {}
) {
  var p, f, m;
  const s = r ?? "latest",
    o = i ?? !1,
    a = n !== void 0 ? Et(n) : void 0;
  let l = null;
  if (
    (e
      ? (l = await t.request(
          { method: "eth_getBlockByHash", params: [e, o] },
          { dedupe: !0 }
        ))
      : (l = await t.request(
          { method: "eth_getBlockByNumber", params: [a || s, o] },
          { dedupe: !!a }
        )),
    !l)
  )
    throw new l6({ blockHash: e, blockNumber: n });
  return (
    ((m =
      (f = (p = t.chain) == null ? void 0 : p.formatters) == null
        ? void 0
        : f.block) == null
      ? void 0
      : m.format) || spe
  )(l);
}
async function p6(t) {
  const e = await t.request({ method: "eth_gasPrice" });
  return BigInt(e);
}
async function ope(t, e) {
  var s, o;
  const { block: n, chain: r = t.chain, request: i } = e;
  try {
    const a =
      ((s = r == null ? void 0 : r.fees) == null
        ? void 0
        : s.maxPriorityFeePerGas) ??
      ((o = r == null ? void 0 : r.fees) == null
        ? void 0
        : o.defaultPriorityFee);
    if (typeof a == "function") {
      const d = n || (await yn(t, hm, "getBlock")({})),
        p = await a({ block: d, client: t, request: i });
      if (p === null) throw new Error();
      return p;
    }
    if (typeof a < "u") return a;
    const l = await t.request({ method: "eth_maxPriorityFeePerGas" });
    return ap(l);
  } catch {
    const [a, l] = await Promise.all([
      n ? Promise.resolve(n) : yn(t, hm, "getBlock")({}),
      yn(t, p6, "getGasPrice")({}),
    ]);
    if (typeof a.baseFeePerGas != "bigint") throw new t_();
    const d = l - a.baseFeePerGas;
    return d < 0n ? 0n : d;
  }
}
async function GO(t, e) {
  var m, y;
  const {
      block: n,
      chain: r = t.chain,
      request: i,
      type: s = "eip1559",
    } = e || {},
    o = await (async () => {
      var g, v;
      return typeof ((g = r == null ? void 0 : r.fees) == null
        ? void 0
        : g.baseFeeMultiplier) == "function"
        ? r.fees.baseFeeMultiplier({ block: n, client: t, request: i })
        : ((v = r == null ? void 0 : r.fees) == null
            ? void 0
            : v.baseFeeMultiplier) ?? 1.2;
    })();
  if (o < 1) throw new npe();
  const l =
      10 **
      (((m = o.toString().split(".")[1]) == null ? void 0 : m.length) ?? 0),
    d = (g) => (g * BigInt(Math.ceil(o * l))) / BigInt(l),
    p = n || (await yn(t, hm, "getBlock")({}));
  if (
    typeof ((y = r == null ? void 0 : r.fees) == null
      ? void 0
      : y.estimateFeesPerGas) == "function"
  ) {
    const g = await r.fees.estimateFeesPerGas({
      block: n,
      client: t,
      multiply: d,
      request: i,
      type: s,
    });
    if (g !== null) return g;
  }
  if (s === "eip1559") {
    if (typeof p.baseFeePerGas != "bigint") throw new t_();
    const g =
        typeof (i == null ? void 0 : i.maxPriorityFeePerGas) == "bigint"
          ? i.maxPriorityFeePerGas
          : await ope(t, { block: p, chain: r, request: i }),
      v = d(p.baseFeePerGas);
    return {
      maxFeePerGas: (i == null ? void 0 : i.maxFeePerGas) ?? v + g,
      maxPriorityFeePerGas: g,
    };
  }
  return {
    gasPrice:
      (i == null ? void 0 : i.gasPrice) ??
      d(await yn(t, p6, "getGasPrice")({})),
  };
}
async function ape(t, { address: e, blockTag: n = "latest", blockNumber: r }) {
  const i = await t.request(
    {
      method: "eth_getTransactionCount",
      params: [e, typeof r == "bigint" ? Et(r) : n],
    },
    { dedupe: !!r }
  );
  return nu(i);
}
function f6(t) {
  const { kzg: e } = t,
    n = t.to ?? (typeof t.blobs[0] == "string" ? "hex" : "bytes"),
    r = typeof t.blobs[0] == "string" ? t.blobs.map((s) => ko(s)) : t.blobs,
    i = [];
  for (const s of r) i.push(Uint8Array.from(e.blobToKzgCommitment(s)));
  return n === "bytes" ? i : i.map((s) => _i(s));
}
function h6(t) {
  const { kzg: e } = t,
    n = t.to ?? (typeof t.blobs[0] == "string" ? "hex" : "bytes"),
    r = typeof t.blobs[0] == "string" ? t.blobs.map((o) => ko(o)) : t.blobs,
    i =
      typeof t.commitments[0] == "string"
        ? t.commitments.map((o) => ko(o))
        : t.commitments,
    s = [];
  for (let o = 0; o < r.length; o++) {
    const a = r[o],
      l = i[o];
    s.push(Uint8Array.from(e.computeBlobKzgProof(a, l)));
  }
  return n === "bytes" ? s : s.map((o) => _i(o));
}
function cpe(t, e, n, r) {
  if (typeof t.setBigUint64 == "function") return t.setBigUint64(e, n, r);
  const i = BigInt(32),
    s = BigInt(4294967295),
    o = Number((n >> i) & s),
    a = Number(n & s),
    l = r ? 4 : 0,
    d = r ? 0 : 4;
  t.setUint32(e + l, o, r), t.setUint32(e + d, a, r);
}
function lpe(t, e, n) {
  return (t & e) ^ (~t & n);
}
function upe(t, e, n) {
  return (t & e) ^ (t & n) ^ (e & n);
}
class dpe extends WM {
  constructor(e, n, r, i) {
    super(),
      (this.finished = !1),
      (this.length = 0),
      (this.pos = 0),
      (this.destroyed = !1),
      (this.blockLen = e),
      (this.outputLen = n),
      (this.padOffset = r),
      (this.isLE = i),
      (this.buffer = new Uint8Array(e)),
      (this.view = rC(this.buffer));
  }
  update(e) {
    Ew(this);
    const { view: n, buffer: r, blockLen: i } = this;
    e = BA(e);
    const s = e.length;
    for (let o = 0; o < s; ) {
      const a = Math.min(i - this.pos, s - o);
      if (a === i) {
        const l = rC(e);
        for (; i <= s - o; o += i) this.process(l, o);
        continue;
      }
      r.set(e.subarray(o, o + a), this.pos),
        (this.pos += a),
        (o += a),
        this.pos === i && (this.process(n, 0), (this.pos = 0));
    }
    return (this.length += e.length), this.roundClean(), this;
  }
  digestInto(e) {
    Ew(this), zM(e, this), (this.finished = !0);
    const { buffer: n, view: r, blockLen: i, isLE: s } = this;
    let { pos: o } = this;
    (n[o++] = 128),
      this.buffer.subarray(o).fill(0),
      this.padOffset > i - o && (this.process(r, 0), (o = 0));
    for (let f = o; f < i; f++) n[f] = 0;
    cpe(r, i - 8, BigInt(this.length * 8), s), this.process(r, 0);
    const a = rC(e),
      l = this.outputLen;
    if (l % 4) throw new Error("_sha2: outputLen should be aligned to 32bit");
    const d = l / 4,
      p = this.get();
    if (d > p.length) throw new Error("_sha2: outputLen bigger than state");
    for (let f = 0; f < d; f++) a.setUint32(4 * f, p[f], s);
  }
  digest() {
    const { buffer: e, outputLen: n } = this;
    this.digestInto(e);
    const r = e.slice(0, n);
    return this.destroy(), r;
  }
  _cloneInto(e) {
    e || (e = new this.constructor()), e.set(...this.get());
    const {
      blockLen: n,
      buffer: r,
      length: i,
      finished: s,
      destroyed: o,
      pos: a,
    } = this;
    return (
      (e.length = i),
      (e.pos = a),
      (e.finished = s),
      (e.destroyed = o),
      i % n && e.buffer.set(r),
      e
    );
  }
}
const ppe = new Uint32Array([
    1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993,
    2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987,
    1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774,
    264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986,
    2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711,
    113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291,
    1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411,
    3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344,
    430227734, 506948616, 659060556, 883997877, 958139571, 1322822218,
    1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424,
    2428436474, 2756734187, 3204031479, 3329325298,
  ]),
  ac = new Uint32Array([
    1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924,
    528734635, 1541459225,
  ]),
  cc = new Uint32Array(64);
class fpe extends dpe {
  constructor(e = 32) {
    super(64, e, 8, !1),
      (this.A = ac[0] | 0),
      (this.B = ac[1] | 0),
      (this.C = ac[2] | 0),
      (this.D = ac[3] | 0),
      (this.E = ac[4] | 0),
      (this.F = ac[5] | 0),
      (this.G = ac[6] | 0),
      (this.H = ac[7] | 0);
  }
  get() {
    const { A: e, B: n, C: r, D: i, E: s, F: o, G: a, H: l } = this;
    return [e, n, r, i, s, o, a, l];
  }
  set(e, n, r, i, s, o, a, l) {
    (this.A = e | 0),
      (this.B = n | 0),
      (this.C = r | 0),
      (this.D = i | 0),
      (this.E = s | 0),
      (this.F = o | 0),
      (this.G = a | 0),
      (this.H = l | 0);
  }
  process(e, n) {
    for (let f = 0; f < 16; f++, n += 4) cc[f] = e.getUint32(n, !1);
    for (let f = 16; f < 64; f++) {
      const m = cc[f - 15],
        y = cc[f - 2],
        g = ho(m, 7) ^ ho(m, 18) ^ (m >>> 3),
        v = ho(y, 17) ^ ho(y, 19) ^ (y >>> 10);
      cc[f] = (v + cc[f - 7] + g + cc[f - 16]) | 0;
    }
    let { A: r, B: i, C: s, D: o, E: a, F: l, G: d, H: p } = this;
    for (let f = 0; f < 64; f++) {
      const m = ho(a, 6) ^ ho(a, 11) ^ ho(a, 25),
        y = (p + m + lpe(a, l, d) + ppe[f] + cc[f]) | 0,
        v = ((ho(r, 2) ^ ho(r, 13) ^ ho(r, 22)) + upe(r, i, s)) | 0;
      (p = d),
        (d = l),
        (l = a),
        (a = (o + y) | 0),
        (o = s),
        (s = i),
        (i = r),
        (r = (y + v) | 0);
    }
    (r = (r + this.A) | 0),
      (i = (i + this.B) | 0),
      (s = (s + this.C) | 0),
      (o = (o + this.D) | 0),
      (a = (a + this.E) | 0),
      (l = (l + this.F) | 0),
      (d = (d + this.G) | 0),
      (p = (p + this.H) | 0),
      this.set(r, i, s, o, a, l, d, p);
  }
  roundClean() {
    cc.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
  }
}
const hpe = HM(() => new fpe());
function mpe(t, e) {
  return hpe(jc(t, { strict: !1 }) ? Mv(t) : t);
}
function gpe(t) {
  const { commitment: e, version: n = 1 } = t,
    r = t.to ?? (typeof e == "string" ? "hex" : "bytes"),
    i = mpe(e);
  return i.set([n], 0), r === "bytes" ? i : _i(i);
}
function ype(t) {
  const { commitments: e, version: n } = t,
    r = t.to ?? (typeof e[0] == "string" ? "hex" : "bytes"),
    i = [];
  for (const s of e) i.push(gpe({ commitment: s, to: r, version: n }));
  return i;
}
const KO = 6,
  m6 = 32,
  n_ = 4096,
  g6 = m6 * n_,
  YO = g6 * KO - 1 - 1 * n_ * KO;
class wpe extends ge {
  constructor({ maxSize: e, size: n }) {
    super("Blob size is too large.", {
      metaMessages: [`Max: ${e} bytes`, `Given: ${n} bytes`],
      name: "BlobSizeTooLargeError",
    });
  }
}
class vpe extends ge {
  constructor() {
    super("Blob data must not be empty.", { name: "EmptyBlobError" });
  }
}
function bpe(t) {
  const e = t.to ?? (typeof t.data == "string" ? "hex" : "bytes"),
    n = typeof t.data == "string" ? ko(t.data) : t.data,
    r = tr(n);
  if (!r) throw new vpe();
  if (r > YO) throw new wpe({ maxSize: YO, size: r });
  const i = [];
  let s = !0,
    o = 0;
  for (; s; ) {
    const a = GA(new Uint8Array(g6));
    let l = 0;
    for (; l < n_; ) {
      const d = n.slice(o, o + (m6 - 1));
      if ((a.pushByte(0), a.pushBytes(d), d.length < 31)) {
        a.pushByte(128), (s = !1);
        break;
      }
      l++, (o += 31);
    }
    i.push(a);
  }
  return e === "bytes" ? i.map((a) => a.bytes) : i.map((a) => _i(a.bytes));
}
function Epe(t) {
  const { data: e, kzg: n, to: r } = t,
    i = t.blobs ?? bpe({ data: e, to: r }),
    s = t.commitments ?? f6({ blobs: i, kzg: n, to: r }),
    o = t.proofs ?? h6({ blobs: i, commitments: s, kzg: n, to: r }),
    a = [];
  for (let l = 0; l < i.length; l++)
    a.push({ blob: i[l], commitment: s[l], proof: o[l] });
  return a;
}
function Cpe(t) {
  if (t.type) return t.type;
  if (typeof t.authorizationList < "u") return "eip7702";
  if (
    typeof t.blobs < "u" ||
    typeof t.blobVersionedHashes < "u" ||
    typeof t.maxFeePerBlobGas < "u" ||
    typeof t.sidecars < "u"
  )
    return "eip4844";
  if (typeof t.maxFeePerGas < "u" || typeof t.maxPriorityFeePerGas < "u")
    return "eip1559";
  if (typeof t.gasPrice < "u")
    return typeof t.accessList < "u" ? "eip2930" : "legacy";
  throw new Ode({ transaction: t });
}
async function y6(t) {
  const e = await t.request({ method: "eth_chainId" }, { dedupe: !0 });
  return nu(e);
}
const w6 = ["blobVersionedHashes", "chainId", "fees", "gas", "nonce", "type"],
  ZO = new Map();
async function r_(t, e) {
  const {
      account: n = t.account,
      blobs: r,
      chain: i,
      gas: s,
      kzg: o,
      nonce: a,
      nonceManager: l,
      parameters: d = w6,
      type: p,
    } = e,
    f = n && Bo(n),
    m = { ...e, ...(f ? { from: f == null ? void 0 : f.address } : {}) };
  let y;
  async function g() {
    return y || ((y = await yn(t, hm, "getBlock")({ blockTag: "latest" })), y);
  }
  let v;
  async function b() {
    return (
      v ||
      (i
        ? i.id
        : typeof e.chainId < "u"
        ? e.chainId
        : ((v = await yn(t, y6, "getChainId")({})), v))
    );
  }
  if (d.includes("nonce") && typeof a > "u" && f)
    if (l) {
      const E = await b();
      m.nonce = await l.consume({ address: f.address, chainId: E, client: t });
    } else
      m.nonce = await yn(
        t,
        ape,
        "getTransactionCount"
      )({ address: f.address, blockTag: "pending" });
  if ((d.includes("blobVersionedHashes") || d.includes("sidecars")) && r && o) {
    const E = f6({ blobs: r, kzg: o });
    if (d.includes("blobVersionedHashes")) {
      const S = ype({ commitments: E, to: "hex" });
      m.blobVersionedHashes = S;
    }
    if (d.includes("sidecars")) {
      const S = h6({ blobs: r, commitments: E, kzg: o }),
        C = Epe({ blobs: r, commitments: E, proofs: S, to: "hex" });
      m.sidecars = C;
    }
  }
  if (
    (d.includes("chainId") && (m.chainId = await b()),
    (d.includes("fees") || d.includes("type")) && typeof p > "u")
  )
    try {
      m.type = Cpe(m);
    } catch {
      let E = ZO.get(t.uid);
      if (typeof E > "u") {
        const S = await g();
        (E = typeof (S == null ? void 0 : S.baseFeePerGas) == "bigint"),
          ZO.set(t.uid, E);
      }
      m.type = E ? "eip1559" : "legacy";
    }
  if (d.includes("fees"))
    if (m.type !== "legacy" && m.type !== "eip2930") {
      if (typeof m.maxFeePerGas > "u" || typeof m.maxPriorityFeePerGas > "u") {
        const E = await g(),
          { maxFeePerGas: S, maxPriorityFeePerGas: C } = await GO(t, {
            block: E,
            chain: i,
            request: m,
          });
        if (
          typeof e.maxPriorityFeePerGas > "u" &&
          e.maxFeePerGas &&
          e.maxFeePerGas < C
        )
          throw new rpe({ maxPriorityFeePerGas: C });
        (m.maxPriorityFeePerGas = C), (m.maxFeePerGas = S);
      }
    } else {
      if (typeof e.maxFeePerGas < "u" || typeof e.maxPriorityFeePerGas < "u")
        throw new t_();
      if (typeof e.gasPrice > "u") {
        const E = await g(),
          { gasPrice: S } = await GO(t, {
            block: E,
            chain: i,
            request: m,
            type: "legacy",
          });
        m.gasPrice = S;
      }
    }
  return (
    d.includes("gas") &&
      typeof s > "u" &&
      (m.gas = await yn(
        t,
        b6,
        "estimateGas"
      )({ ...m, account: f && { address: f.address, type: "json-rpc" } })),
    Hv(m),
    delete m.parameters,
    m
  );
}
async function v6(t, { address: e, blockNumber: n, blockTag: r = "latest" }) {
  const i = typeof n == "bigint" ? Et(n) : void 0,
    s = await t.request({ method: "eth_getBalance", params: [e, i || r] });
  return BigInt(s);
}
async function b6(t, e) {
  var i, s, o;
  const { account: n = t.account } = e,
    r = n ? Bo(n) : void 0;
  try {
    let H = function (M) {
      const { block: z, request: B, rpcStateOverride: j } = M;
      return t.request({
        method: "eth_estimateGas",
        params: j ? [B, z ?? "latest", j] : z ? [B, z] : [B],
      });
    };
    const {
        accessList: a,
        authorizationList: l,
        blobs: d,
        blobVersionedHashes: p,
        blockNumber: f,
        blockTag: m,
        data: y,
        gas: g,
        gasPrice: v,
        maxFeePerBlobGas: b,
        maxFeePerGas: E,
        maxPriorityFeePerGas: S,
        nonce: C,
        value: _,
        stateOverride: A,
        ...I
      } = await r_(t, {
        ...e,
        parameters:
          (r == null ? void 0 : r.type) === "local"
            ? void 0
            : ["blobVersionedHashes"],
      }),
      D = (typeof f == "bigint" ? Et(f) : void 0) || m,
      k = c6(A),
      T = await (async () => {
        if (I.to) return I.to;
        if (l && l.length > 0)
          return await a6({ authorization: l[0] }).catch(() => {
            throw new ge(
              "`to` is required. Could not infer from `authorizationList`"
            );
          });
      })();
    Hv(e);
    const U =
        (o =
          (s = (i = t.chain) == null ? void 0 : i.formatters) == null
            ? void 0
            : s.transactionRequest) == null
          ? void 0
          : o.format,
      K = (U || e_)({
        ...JA(I, { format: U }),
        from: r == null ? void 0 : r.address,
        accessList: a,
        authorizationList: l,
        blobs: d,
        blobVersionedHashes: p,
        data: y,
        gas: g,
        gasPrice: v,
        maxFeePerBlobGas: b,
        maxFeePerGas: E,
        maxPriorityFeePerGas: S,
        nonce: C,
        to: T,
        value: _,
      });
    let $ = BigInt(await H({ block: D, request: K, rpcStateOverride: k }));
    if (l) {
      const M = await v6(t, { address: K.from }),
        z = await Promise.all(
          l.map(async (B) => {
            const { address: j } = B,
              V = await H({
                block: D,
                request: {
                  authorizationList: void 0,
                  data: y,
                  from: r == null ? void 0 : r.address,
                  to: j,
                  value: Et(M),
                },
                rpcStateOverride: k,
              }).catch(() => 100000n);
            return 2n * BigInt(V);
          })
        );
      $ += z.reduce((B, j) => B + j, 0n);
    }
    return $;
  } catch (a) {
    throw Qde(a, { ...e, account: r, chain: t.chain });
  }
}
function xpe(t, e) {
  if (!Do(t, { strict: !1 })) throw new ru({ address: t });
  if (!Do(e, { strict: !1 })) throw new ru({ address: e });
  return t.toLowerCase() === e.toLowerCase();
}
const QO = "/docs/contract/decodeEventLog";
function Spe(t) {
  const { abi: e, data: n, strict: r, topics: i } = t,
    s = r ?? !0,
    [o, ...a] = i;
  if (!o) throw new uue({ docsPath: QO });
  const l =
    e.length === 1
      ? e[0]
      : e.find((v) => v.type === "event" && o === FA(Bc(v)));
  if (!(l && "name" in l) || l.type !== "event")
    throw new DM(o, { docsPath: QO });
  const { name: d, inputs: p } = l,
    f = p == null ? void 0 : p.some((v) => !("name" in v && v.name));
  let m = f ? [] : {};
  const y = p.filter((v) => "indexed" in v && v.indexed);
  for (let v = 0; v < y.length; v++) {
    const b = y[v],
      E = a[v];
    if (!E) throw new $M({ abiItem: l, param: b });
    m[f ? v : b.name || v] = Ape({ param: b, value: E });
  }
  const g = p.filter((v) => !("indexed" in v && v.indexed));
  if (g.length > 0) {
    if (n && n !== "0x")
      try {
        const v = zv(g, n);
        if (v)
          if (f) m = [...m, ...v];
          else for (let b = 0; b < g.length; b++) m[g[b].name] = v[b];
      } catch (v) {
        if (s)
          throw v instanceof OM || v instanceof e6
            ? new Jx({ abiItem: l, data: n, params: g, size: tr(n) })
            : v;
      }
    else if (s) throw new Jx({ abiItem: l, data: "0x", params: g, size: 0 });
  }
  return { eventName: d, args: Object.values(m).length > 0 ? m : void 0 };
}
function Ape({ param: t, value: e }) {
  return t.type === "string" ||
    t.type === "bytes" ||
    t.type === "tuple" ||
    t.type.match(/^(.*)\[(\d+)?\]$/)
    ? e
    : zv([t], e)[0];
}
function _pe(t) {
  const { abi: e, args: n, logs: r, strict: i = !0 } = t,
    s = (() => {
      if (t.eventName)
        return Array.isArray(t.eventName) ? t.eventName : [t.eventName];
    })();
  return r
    .map((o) => {
      var a;
      try {
        const l = e.find((p) => p.type === "event" && o.topics[0] === FA(p));
        if (!l) return null;
        const d = Spe({ ...o, abi: [l], strict: i });
        return (s && !s.includes(d.eventName)) ||
          !Ipe({ args: d.args, inputs: l.inputs, matchArgs: n })
          ? null
          : { ...d, ...o };
      } catch (l) {
        let d, p;
        if (l instanceof DM) return null;
        if (l instanceof Jx || l instanceof $M) {
          if (i) return null;
          (d = l.abiItem.name),
            (p =
              (a = l.abiItem.inputs) == null
                ? void 0
                : a.some((f) => !("name" in f && f.name)));
        }
        return { ...o, args: p ? [] : {}, eventName: d };
      }
    })
    .filter(Boolean);
}
function Ipe(t) {
  const { args: e, inputs: n, matchArgs: r } = t;
  if (!r) return !0;
  if (!e) return !1;
  function i(s, o, a) {
    try {
      return s.type === "address"
        ? xpe(o, a)
        : s.type === "string" || s.type === "bytes"
        ? cg(Mv(o)) === a
        : o === a;
    } catch {
      return !1;
    }
  }
  return Array.isArray(e) && Array.isArray(r)
    ? r.every((s, o) => {
        if (s == null) return !0;
        const a = n[o];
        return a ? (Array.isArray(s) ? s : [s]).some((d) => i(a, d, e[o])) : !1;
      })
    : typeof e == "object" &&
      !Array.isArray(e) &&
      typeof r == "object" &&
      !Array.isArray(r)
    ? Object.entries(r).every(([s, o]) => {
        if (o == null) return !0;
        const a = n.find((d) => d.name === s);
        return a ? (Array.isArray(o) ? o : [o]).some((d) => i(a, d, e[s])) : !1;
      })
    : !1;
}
function E6(t, { args: e, eventName: n } = {}) {
  return {
    ...t,
    blockHash: t.blockHash ? t.blockHash : null,
    blockNumber: t.blockNumber ? BigInt(t.blockNumber) : null,
    logIndex: t.logIndex ? Number(t.logIndex) : null,
    transactionHash: t.transactionHash ? t.transactionHash : null,
    transactionIndex: t.transactionIndex ? Number(t.transactionIndex) : null,
    ...(n ? { args: e, eventName: n } : {}),
  };
}
const oC = "/docs/contract/decodeFunctionResult";
function i_(t) {
  const { abi: e, args: n, functionName: r, data: i } = t;
  let s = e[0];
  if (r) {
    const a = VA({ abi: e, args: n, name: r });
    if (!a) throw new vw(r, { docsPath: oC });
    s = a;
  }
  if (s.type !== "function") throw new vw(void 0, { docsPath: oC });
  if (!s.outputs) throw new due(s.name, { docsPath: oC });
  const o = zv(s.outputs, i);
  if (o.length > 1) return o;
  if (o.length === 1) return o[0];
}
const Tpe = "0.1.1";
function Ppe() {
  return Tpe;
}
let C6 = class uS extends Error {
  constructor(e, n = {}) {
    const r = (() => {
        var l;
        if (n.cause instanceof uS) {
          if (n.cause.details) return n.cause.details;
          if (n.cause.shortMessage) return n.cause.shortMessage;
        }
        return (l = n.cause) != null && l.message ? n.cause.message : n.details;
      })(),
      i = (n.cause instanceof uS && n.cause.docsPath) || n.docsPath,
      o = `https://oxlib.sh${i ?? ""}`,
      a = [
        e || "An error occurred.",
        ...(n.metaMessages ? ["", ...n.metaMessages] : []),
        ...(r || i
          ? ["", r ? `Details: ${r}` : void 0, i ? `See: ${o}` : void 0]
          : []),
      ].filter((l) => typeof l == "string").join(`
`);
    super(a, n.cause ? { cause: n.cause } : void 0),
      Object.defineProperty(this, "details", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0,
      }),
      Object.defineProperty(this, "docs", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0,
      }),
      Object.defineProperty(this, "docsPath", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0,
      }),
      Object.defineProperty(this, "shortMessage", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0,
      }),
      Object.defineProperty(this, "cause", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0,
      }),
      Object.defineProperty(this, "name", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: "BaseError",
      }),
      Object.defineProperty(this, "version", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: `ox@${Ppe()}`,
      }),
      (this.cause = n.cause),
      (this.details = r),
      (this.docs = o),
      (this.docsPath = i),
      (this.shortMessage = e);
  }
  walk(e) {
    return x6(this, e);
  }
};
function x6(t, e) {
  return e != null && e(t)
    ? t
    : t && typeof t == "object" && "cause" in t && t.cause
    ? x6(t.cause, e)
    : e
    ? null
    : t;
}
function Rpe(t, e = {}) {
  const { dir: n, size: r = 32 } = e;
  if (r === 0) return t;
  const i = t.replace("0x", "");
  if (i.length > r * 2)
    throw new kpe({
      size: Math.ceil(i.length / 2),
      targetSize: r,
      type: "Hex",
    });
  return `0x${i[n === "right" ? "padEnd" : "padStart"](r * 2, "0")}`;
}
function da(t, e = {}) {
  const { signed: n, size: r } = e,
    i = BigInt(t);
  let s;
  r
    ? n
      ? (s = (1n << (BigInt(r) * 8n - 1n)) - 1n)
      : (s = 2n ** (BigInt(r) * 8n) - 1n)
    : typeof t == "number" && (s = BigInt(Number.MAX_SAFE_INTEGER));
  const o = typeof s == "bigint" && n ? -s - 1n : 0;
  if ((s && i > s) || i < o) {
    const d = typeof t == "bigint" ? "n" : "";
    throw new Ope({
      max: s ? `${s}${d}` : void 0,
      min: `${o}${d}`,
      signed: n,
      size: r,
      value: `${t}${d}`,
    });
  }
  const l = `0x${(n && i < 0 ? (1n << BigInt(r * 8)) + BigInt(i) : i).toString(
    16
  )}`;
  return r ? Npe(l, r) : l;
}
function Npe(t, e) {
  return Rpe(t, { dir: "left", size: e });
}
class Ope extends C6 {
  constructor({ max: e, min: n, signed: r, size: i, value: s }) {
    super(
      `Number \`${s}\` is not in safe${i ? ` ${i * 8}-bit` : ""}${
        r ? " signed" : " unsigned"
      } integer range ${e ? `(\`${n}\` to \`${e}\`)` : `(above \`${n}\`)`}`
    ),
      Object.defineProperty(this, "name", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: "Hex.IntegerOutOfRangeError",
      });
  }
}
class kpe extends C6 {
  constructor({ size: e, targetSize: n, type: r }) {
    super(
      `${r.charAt(0).toUpperCase()}${r
        .slice(1)
        .toLowerCase()} size (\`${e}\`) exceeds padding size (\`${n}\`).`
    ),
      Object.defineProperty(this, "name", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: "Hex.SizeExceedsPaddingSizeError",
      });
  }
}
function Dpe(t) {
  return {
    address: t.address,
    amount: da(t.amount),
    index: da(t.index),
    validatorIndex: da(t.validatorIndex),
  };
}
function $pe(t) {
  return {
    ...(typeof t.baseFeePerGas == "bigint" && {
      baseFeePerGas: da(t.baseFeePerGas),
    }),
    ...(typeof t.blobBaseFee == "bigint" && { blobBaseFee: da(t.blobBaseFee) }),
    ...(typeof t.feeRecipient == "string" && { feeRecipient: t.feeRecipient }),
    ...(typeof t.gasLimit == "bigint" && { gasLimit: da(t.gasLimit) }),
    ...(typeof t.number == "bigint" && { number: da(t.number) }),
    ...(typeof t.prevRandao == "bigint" && { prevRandao: da(t.prevRandao) }),
    ...(typeof t.time == "bigint" && { time: da(t.time) }),
    ...(t.withdrawals && { withdrawals: t.withdrawals.map(Dpe) }),
  };
}
const dS = [
    {
      inputs: [
        {
          components: [
            { name: "target", type: "address" },
            { name: "allowFailure", type: "bool" },
            { name: "callData", type: "bytes" },
          ],
          name: "calls",
          type: "tuple[]",
        },
      ],
      name: "aggregate3",
      outputs: [
        {
          components: [
            { name: "success", type: "bool" },
            { name: "returnData", type: "bytes" },
          ],
          name: "returnData",
          type: "tuple[]",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
  ],
  $1e = [
    {
      name: "query",
      type: "function",
      stateMutability: "view",
      inputs: [
        {
          type: "tuple[]",
          name: "queries",
          components: [
            { type: "address", name: "sender" },
            { type: "string[]", name: "urls" },
            { type: "bytes", name: "data" },
          ],
        },
      ],
      outputs: [
        { type: "bool[]", name: "failures" },
        { type: "bytes[]", name: "responses" },
      ],
    },
    {
      name: "HttpError",
      type: "error",
      inputs: [
        { type: "uint16", name: "status" },
        { type: "string", name: "message" },
      ],
    },
  ],
  Mpe = "0x82ad56cb",
  Lpe =
    "0x608060405234801561001057600080fd5b5060405161018e38038061018e83398101604081905261002f91610124565b6000808351602085016000f59050803b61004857600080fd5b6000808351602085016000855af16040513d6000823e81610067573d81fd5b3d81f35b634e487b7160e01b600052604160045260246000fd5b600082601f83011261009257600080fd5b81516001600160401b038111156100ab576100ab61006b565b604051601f8201601f19908116603f011681016001600160401b03811182821017156100d9576100d961006b565b6040528181528382016020018510156100f157600080fd5b60005b82811015610110576020818601810151838301820152016100f4565b506000918101602001919091529392505050565b6000806040838503121561013757600080fd5b82516001600160401b0381111561014d57600080fd5b61015985828601610081565b602085015190935090506001600160401b0381111561017757600080fd5b61018385828601610081565b915050925092905056fe",
  Upe =
    "0x608060405234801561001057600080fd5b506040516102c03803806102c083398101604081905261002f916101e6565b836001600160a01b03163b6000036100e457600080836001600160a01b03168360405161005c9190610270565b6000604051808303816000865af19150503d8060008114610099576040519150601f19603f3d011682016040523d82523d6000602084013e61009e565b606091505b50915091508115806100b857506001600160a01b0386163b155b156100e1578060405163101bb98d60e01b81526004016100d8919061028c565b60405180910390fd5b50505b6000808451602086016000885af16040513d6000823e81610103573d81fd5b3d81f35b80516001600160a01b038116811461011e57600080fd5b919050565b634e487b7160e01b600052604160045260246000fd5b60005b8381101561015457818101518382015260200161013c565b50506000910152565b600082601f83011261016e57600080fd5b81516001600160401b0381111561018757610187610123565b604051601f8201601f19908116603f011681016001600160401b03811182821017156101b5576101b5610123565b6040528181528382016020018510156101cd57600080fd5b6101de826020830160208701610139565b949350505050565b600080600080608085870312156101fc57600080fd5b61020585610107565b60208601519094506001600160401b0381111561022157600080fd5b61022d8782880161015d565b93505061023c60408601610107565b60608601519092506001600160401b0381111561025857600080fd5b6102648782880161015d565b91505092959194509250565b60008251610282818460208701610139565b9190910192915050565b60208152600082518060208401526102ab816040850160208701610139565b601f01601f1916919091016040019291505056fe";
class pS extends ge {
  constructor({ blockNumber: e, chain: n, contract: r }) {
    super(`Chain "${n.name}" does not support contract "${r.name}".`, {
      metaMessages: [
        "This could be due to any of the following:",
        ...(e && r.blockCreated && r.blockCreated > e
          ? [
              `- The contract "${r.name}" was not deployed until block ${r.blockCreated} (current block ${e}).`,
            ]
          : [`- The chain does not have the contract "${r.name}" configured.`]),
      ],
      name: "ChainDoesNotSupportContract",
    });
  }
}
class Bpe extends ge {
  constructor({ chain: e, currentChainId: n }) {
    super(
      `The current chain of the wallet (id: ${n}) does not match the target chain for the transaction (id: ${e.id}  ${e.name}).`,
      {
        metaMessages: [
          `Current Chain ID:  ${n}`,
          `Expected Chain ID: ${e.id}  ${e.name}`,
        ],
        name: "ChainMismatchError",
      }
    );
  }
}
class jpe extends ge {
  constructor() {
    super(
      [
        "No chain was provided to the request.",
        "Please provide a chain with the `chain` argument on the Action, or by supplying a `chain` to WalletClient.",
      ].join(`
`),
      { name: "ChainNotFoundError" }
    );
  }
}
class S6 extends ge {
  constructor() {
    super("No chain was provided to the Client.", {
      name: "ClientChainNotConfiguredError",
    });
  }
}
const aC = "/docs/contract/encodeDeployData";
function A6(t) {
  const { abi: e, args: n, bytecode: r } = t;
  if (!n || n.length === 0) return r;
  const i = e.find((o) => "type" in o && o.type === "constructor");
  if (!i) throw new oue({ docsPath: aC });
  if (!("inputs" in i)) throw new OO({ docsPath: aC });
  if (!i.inputs || i.inputs.length === 0) throw new OO({ docsPath: aC });
  const s = XM(i.inputs, n);
  return jv([r, s]);
}
function _6({ blockNumber: t, chain: e, contract: n }) {
  var i;
  const r = (i = e == null ? void 0 : e.contracts) == null ? void 0 : i[n];
  if (!r) throw new pS({ chain: e, contract: { name: n } });
  if (t && r.blockCreated && r.blockCreated > t)
    throw new pS({
      blockNumber: t,
      chain: e,
      contract: { name: n, blockCreated: r.blockCreated },
    });
  return r.address;
}
function Fpe(t, { docsPath: e, ...n }) {
  const r = (() => {
    const i = XA(t, n);
    return i instanceof Wv ? t : i;
  })();
  return new Mde(r, { docsPath: e, ...n });
}
function I6() {
  let t = () => {},
    e = () => {};
  return {
    promise: new Promise((r, i) => {
      (t = r), (e = i);
    }),
    resolve: t,
    reject: e,
  };
}
const cC = new Map();
function T6({ fn: t, id: e, shouldSplitBatch: n, wait: r = 0, sort: i }) {
  const s = async () => {
      const p = l();
      o();
      const f = p.map(({ args: m }) => m);
      f.length !== 0 &&
        t(f)
          .then((m) => {
            i && Array.isArray(m) && m.sort(i);
            for (let y = 0; y < p.length; y++) {
              const { resolve: g } = p[y];
              g == null || g([m[y], m]);
            }
          })
          .catch((m) => {
            for (let y = 0; y < p.length; y++) {
              const { reject: g } = p[y];
              g == null || g(m);
            }
          });
    },
    o = () => cC.delete(e),
    a = () => l().map(({ args: p }) => p),
    l = () => cC.get(e) || [],
    d = (p) => cC.set(e, [...l(), p]);
  return {
    flush: o,
    async schedule(p) {
      const { promise: f, resolve: m, reject: y } = I6();
      return (
        (n == null ? void 0 : n([...a(), p])) && s(),
        l().length > 0
          ? (d({ args: p, resolve: m, reject: y }), f)
          : (d({ args: p, resolve: m, reject: y }), setTimeout(s, r), f)
      );
    },
  };
}
async function P6(t, e) {
  var q, K, H, $;
  const {
      account: n = t.account,
      batch: r = !!((q = t.batch) != null && q.multicall),
      blockNumber: i,
      blockTag: s = "latest",
      accessList: o,
      blobs: a,
      blockOverrides: l,
      code: d,
      data: p,
      factory: f,
      factoryData: m,
      gas: y,
      gasPrice: g,
      maxFeePerBlobGas: v,
      maxFeePerGas: b,
      maxPriorityFeePerGas: E,
      nonce: S,
      to: C,
      value: _,
      stateOverride: A,
      ...I
    } = e,
    R = n ? Bo(n) : void 0;
  if (d && (f || m))
    throw new ge(
      "Cannot provide both `code` & `factory`/`factoryData` as parameters."
    );
  if (d && C) throw new ge("Cannot provide both `code` & `to` as parameters.");
  const D = d && p,
    k = f && m && C && p,
    T = D || k,
    U = D
      ? Hpe({ code: d, data: p })
      : k
      ? qpe({ data: p, factory: f, factoryData: m, to: C })
      : p;
  try {
    Hv(e);
    const z = (typeof i == "bigint" ? Et(i) : void 0) || s,
      B = l ? $pe(l) : void 0,
      j = c6(A),
      V =
        ($ =
          (H = (K = t.chain) == null ? void 0 : K.formatters) == null
            ? void 0
            : H.transactionRequest) == null
          ? void 0
          : $.format,
      Z = (V || e_)({
        ...JA(I, { format: V }),
        from: R == null ? void 0 : R.address,
        accessList: o,
        blobs: a,
        data: U,
        gas: y,
        gasPrice: g,
        maxFeePerBlobGas: v,
        maxFeePerGas: b,
        maxPriorityFeePerGas: E,
        nonce: S,
        to: T ? void 0 : C,
        value: _,
      });
    if (r && zpe({ request: Z }) && !j && !B)
      try {
        return await Wpe(t, { ...Z, blockNumber: i, blockTag: s });
      } catch (se) {
        if (!(se instanceof S6) && !(se instanceof pS)) throw se;
      }
    const ee = (() => {
        const se = [Z, z];
        return j && B
          ? [...se, j, B]
          : j
          ? [...se, j]
          : B
          ? [...se, {}, B]
          : se;
      })(),
      J = await t.request({ method: "eth_call", params: ee });
    return J === "0x" ? { data: void 0 } : { data: J };
  } catch (M) {
    const z = Vpe(M),
      { offchainLookup: B, offchainLookupSignature: j } = await ei(async () => {
        const { offchainLookup: V, offchainLookupSignature: W } = await import(
          "./ccip-BrCZqkw9.js"
        );
        return { offchainLookup: V, offchainLookupSignature: W };
      }, []);
    if (t.ccipRead !== !1 && (z == null ? void 0 : z.slice(0, 10)) === j && C)
      return { data: await B(t, { data: z, to: C }) };
    throw T && (z == null ? void 0 : z.slice(0, 10)) === "0x101bb98d"
      ? new Bde({ factory: f })
      : Fpe(M, { ...e, account: R, chain: t.chain });
  }
}
function zpe({ request: t }) {
  const { data: e, to: n, ...r } = t;
  return !(
    !e ||
    e.startsWith(Mpe) ||
    !n ||
    Object.values(r).filter((i) => typeof i < "u").length > 0
  );
}
async function Wpe(t, e) {
  var v;
  const { batchSize: n = 1024, wait: r = 0 } =
      typeof ((v = t.batch) == null ? void 0 : v.multicall) == "object"
        ? t.batch.multicall
        : {},
    {
      blockNumber: i,
      blockTag: s = "latest",
      data: o,
      multicallAddress: a,
      to: l,
    } = e;
  let d = a;
  if (!d) {
    if (!t.chain) throw new S6();
    d = _6({ blockNumber: i, chain: t.chain, contract: "multicall3" });
  }
  const f = (typeof i == "bigint" ? Et(i) : void 0) || s,
    { schedule: m } = T6({
      id: `${t.uid}.${f}`,
      wait: r,
      shouldSplitBatch(b) {
        return b.reduce((S, { data: C }) => S + (C.length - 2), 0) > n * 2;
      },
      fn: async (b) => {
        const E = b.map((_) => ({
            allowFailure: !0,
            callData: _.data,
            target: _.to,
          })),
          S = Fv({ abi: dS, args: [E], functionName: "aggregate3" }),
          C = await t.request({
            method: "eth_call",
            params: [{ data: S, to: d }, f],
          });
        return i_({
          abi: dS,
          args: [E],
          functionName: "aggregate3",
          data: C || "0x",
        });
      },
    }),
    [{ returnData: y, success: g }] = await m({ data: o, to: l });
  if (!g) throw new ZA({ data: y });
  return y === "0x" ? { data: void 0 } : { data: y };
}
function Hpe(t) {
  const { code: e, data: n } = t;
  return A6({
    abi: WD(["constructor(bytes, bytes)"]),
    bytecode: Lpe,
    args: [e, n],
  });
}
function qpe(t) {
  const { data: e, factory: n, factoryData: r, to: i } = t;
  return A6({
    abi: WD(["constructor(address, bytes, address, bytes)"]),
    bytecode: Upe,
    args: [i, e, n, r],
  });
}
function Vpe(t) {
  var n;
  if (!(t instanceof ge)) return;
  const e = t.walk();
  return typeof (e == null ? void 0 : e.data) == "object"
    ? (n = e.data) == null
      ? void 0
      : n.data
    : e.data;
}
async function R6(t, e) {
  const { abi: n, address: r, args: i, functionName: s, ...o } = e,
    a = Fv({ abi: n, args: i, functionName: s });
  try {
    const { data: l } = await yn(t, P6, "call")({ ...o, data: a, to: r });
    return i_({ abi: n, args: i, functionName: s, data: l || "0x" });
  } catch (l) {
    throw xw(l, {
      abi: n,
      address: r,
      args: i,
      docsPath: "/docs/contract/readContract",
      functionName: s,
    });
  }
}
const lC = new Map(),
  XO = new Map();
let Gpe = 0;
function _w(t, e, n) {
  const r = ++Gpe,
    i = () => lC.get(t) || [],
    s = () => {
      const p = i();
      lC.set(
        t,
        p.filter((f) => f.id !== r)
      );
    },
    o = () => {
      const p = i();
      if (!p.some((m) => m.id === r)) return;
      const f = XO.get(t);
      p.length === 1 && f && f(), s();
    },
    a = i();
  if ((lC.set(t, [...a, { id: r, fns: e }]), a.length > 0)) return o;
  const l = {};
  for (const p in e)
    l[p] = (...f) => {
      var y, g;
      const m = i();
      if (m.length !== 0)
        for (const v of m) (g = (y = v.fns)[p]) == null || g.call(y, ...f);
    };
  const d = n(l);
  return typeof d == "function" && XO.set(t, d), o;
}
async function Iw(t) {
  return new Promise((e) => setTimeout(e, t));
}
function N6(t, { emitOnBegin: e, initialWaitTime: n, interval: r }) {
  let i = !0;
  const s = () => (i = !1);
  return (
    (async () => {
      let a;
      e && (a = await t({ unpoll: s }));
      const l = (await (n == null ? void 0 : n(a))) ?? r;
      await Iw(l);
      const d = async () => {
        i && (await t({ unpoll: s }), await Iw(r), d());
      };
      d();
    })(),
    s
  );
}
const Kpe = new Map(),
  Ype = new Map();
function Zpe(t) {
  const e = (i, s) => ({
      clear: () => s.delete(i),
      get: () => s.get(i),
      set: (o) => s.set(i, o),
    }),
    n = e(t, Kpe),
    r = e(t, Ype);
  return {
    clear: () => {
      n.clear(), r.clear();
    },
    promise: n,
    response: r,
  };
}
async function Qpe(
  t,
  { cacheKey: e, cacheTime: n = Number.POSITIVE_INFINITY }
) {
  const r = Zpe(e),
    i = r.response.get();
  if (i && n > 0 && new Date().getTime() - i.created.getTime() < n)
    return i.data;
  let s = r.promise.get();
  s || ((s = t()), r.promise.set(s));
  try {
    const o = await s;
    return r.response.set({ created: new Date(), data: o }), o;
  } finally {
    r.promise.clear();
  }
}
const Xpe = (t) => `blockNumber.${t}`;
async function Jpe(t, { cacheTime: e = t.cacheTime } = {}) {
  const n = await Qpe(() => t.request({ method: "eth_blockNumber" }), {
    cacheKey: Xpe(t.uid),
    cacheTime: e,
  });
  return BigInt(n);
}
async function efe(t, { filter: e }) {
  const n = "strict" in e && e.strict,
    r = await e.request({ method: "eth_getFilterChanges", params: [e.id] });
  if (typeof r[0] == "string") return r;
  const i = r.map((s) => E6(s));
  return !("abi" in e) || !e.abi ? i : _pe({ abi: e.abi, logs: i, strict: n });
}
async function tfe(t, { filter: e }) {
  return e.request({ method: "eth_uninstallFilter", params: [e.id] });
}
class s_ extends ge {
  constructor({ docsPath: e } = {}) {
    super(
      [
        "Could not find an Account to execute with this Action.",
        "Please provide an Account with the `account` argument on the Action, or by supplying an `account` to the Client.",
      ].join(`
`),
      { docsPath: e, docsSlug: "account", name: "AccountNotFoundError" }
    );
  }
}
class uC extends ge {
  constructor({ docsPath: e, metaMessages: n, type: r }) {
    super(`Account type "${r}" is not supported.`, {
      docsPath: e,
      metaMessages: n,
      name: "AccountTypeNotSupportedError",
    });
  }
}
function nfe({ chain: t, currentChainId: e }) {
  if (!t) throw new jpe();
  if (e !== t.id) throw new Bpe({ chain: t, currentChainId: e });
}
function rfe(t, { docsPath: e, ...n }) {
  const r = (() => {
    const i = XA(t, n);
    return i instanceof Wv ? t : i;
  })();
  return new kde(r, { docsPath: e, ...n });
}
async function ife(t, { serializedTransaction: e }) {
  return t.request(
    { method: "eth_sendRawTransaction", params: [e] },
    { retryCount: 0 }
  );
}
const dC = new Uv(128);
async function O6(t, e) {
  var S, C, _, A;
  const {
    account: n = t.account,
    chain: r = t.chain,
    accessList: i,
    authorizationList: s,
    blobs: o,
    data: a,
    gas: l,
    gasPrice: d,
    maxFeePerBlobGas: p,
    maxFeePerGas: f,
    maxPriorityFeePerGas: m,
    nonce: y,
    type: g,
    value: v,
    ...b
  } = e;
  if (typeof n > "u")
    throw new s_({ docsPath: "/docs/actions/wallet/sendTransaction" });
  const E = n ? Bo(n) : null;
  try {
    Hv(e);
    const I = await (async () => {
      if (e.to) return e.to;
      if (e.to !== null && s && s.length > 0)
        return await a6({ authorization: s[0] }).catch(() => {
          throw new ge(
            "`to` is required. Could not infer from `authorizationList`."
          );
        });
    })();
    if ((E == null ? void 0 : E.type) === "json-rpc" || E === null) {
      let R;
      r !== null &&
        ((R = await yn(t, y6, "getChainId")({})),
        nfe({ currentChainId: R, chain: r }));
      const D =
          (_ =
            (C = (S = t.chain) == null ? void 0 : S.formatters) == null
              ? void 0
              : C.transactionRequest) == null
            ? void 0
            : _.format,
        T = (D || e_)({
          ...JA(b, { format: D }),
          accessList: i,
          authorizationList: s,
          blobs: o,
          chainId: R,
          data: a,
          from: E == null ? void 0 : E.address,
          gas: l,
          gasPrice: d,
          maxFeePerBlobGas: p,
          maxFeePerGas: f,
          maxPriorityFeePerGas: m,
          nonce: y,
          to: I,
          type: g,
          value: v,
        }),
        U = dC.get(t.uid),
        q = U ? "wallet_sendTransaction" : "eth_sendTransaction";
      try {
        return await t.request({ method: q, params: [T] }, { retryCount: 0 });
      } catch (K) {
        if (U === !1) throw K;
        const H = K;
        if (
          H.name === "InvalidInputRpcError" ||
          H.name === "InvalidParamsRpcError" ||
          H.name === "MethodNotFoundRpcError" ||
          H.name === "MethodNotSupportedRpcError"
        )
          return await t
            .request(
              { method: "wallet_sendTransaction", params: [T] },
              { retryCount: 0 }
            )
            .then(($) => (dC.set(t.uid, !0), $))
            .catch(($) => {
              const M = $;
              throw M.name === "MethodNotFoundRpcError" ||
                M.name === "MethodNotSupportedRpcError"
                ? (dC.set(t.uid, !1), H)
                : M;
            });
        throw H;
      }
    }
    if ((E == null ? void 0 : E.type) === "local") {
      const R = await yn(
          t,
          r_,
          "prepareTransactionRequest"
        )({
          account: E,
          accessList: i,
          authorizationList: s,
          blobs: o,
          chain: r,
          data: a,
          gas: l,
          gasPrice: d,
          maxFeePerBlobGas: p,
          maxFeePerGas: f,
          maxPriorityFeePerGas: m,
          nonce: y,
          nonceManager: E.nonceManager,
          parameters: [...w6, "sidecars"],
          type: g,
          value: v,
          ...b,
          to: I,
        }),
        D =
          (A = r == null ? void 0 : r.serializers) == null
            ? void 0
            : A.transaction,
        k = await E.signTransaction(R, { serializer: D });
      return await yn(
        t,
        ife,
        "sendRawTransaction"
      )({ serializedTransaction: k });
    }
    throw (E == null ? void 0 : E.type) === "smart"
      ? new uC({
          metaMessages: [
            "Consider using the `sendUserOperation` Action instead.",
          ],
          docsPath: "/docs/actions/bundler/sendUserOperation",
          type: "smart",
        })
      : new uC({
          docsPath: "/docs/actions/wallet/sendTransaction",
          type: E == null ? void 0 : E.type,
        });
  } catch (I) {
    throw I instanceof uC
      ? I
      : rfe(I, { ...e, account: E, chain: e.chain || void 0 });
  }
}
async function sfe(t, e) {
  const {
    abi: n,
    account: r = t.account,
    address: i,
    args: s,
    dataSuffix: o,
    functionName: a,
    ...l
  } = e;
  if (typeof r > "u")
    throw new s_({ docsPath: "/docs/contract/writeContract" });
  const d = r ? Bo(r) : null,
    p = Fv({ abi: n, args: s, functionName: a });
  try {
    return await yn(
      t,
      O6,
      "sendTransaction"
    )({ data: `${p}${o ? o.replace("0x", "") : ""}`, to: i, account: d, ...l });
  } catch (f) {
    throw xw(f, {
      abi: n,
      address: i,
      args: s,
      docsPath: "/docs/contract/writeContract",
      functionName: a,
      sender: d == null ? void 0 : d.address,
    });
  }
}
const ofe = { "0x0": "reverted", "0x1": "success" };
function afe(t) {
  const e = {
    ...t,
    blockNumber: t.blockNumber ? BigInt(t.blockNumber) : null,
    contractAddress: t.contractAddress ? t.contractAddress : null,
    cumulativeGasUsed: t.cumulativeGasUsed ? BigInt(t.cumulativeGasUsed) : null,
    effectiveGasPrice: t.effectiveGasPrice ? BigInt(t.effectiveGasPrice) : null,
    gasUsed: t.gasUsed ? BigInt(t.gasUsed) : null,
    logs: t.logs ? t.logs.map((n) => E6(n)) : null,
    to: t.to ? t.to : null,
    transactionIndex: t.transactionIndex ? nu(t.transactionIndex) : null,
    status: t.status ? ofe[t.status] : null,
    type: t.type ? u6[t.type] || t.type : null,
  };
  return (
    t.blobGasPrice && (e.blobGasPrice = BigInt(t.blobGasPrice)),
    t.blobGasUsed && (e.blobGasUsed = BigInt(t.blobGasUsed)),
    e
  );
}
const fS = 256;
let a0 = fS,
  c0;
function k6(t = 11) {
  if (!c0 || a0 + t > fS * 2) {
    (c0 = ""), (a0 = 0);
    for (let e = 0; e < fS; e++)
      c0 += ((256 + Math.random() * 256) | 0).toString(16).substring(1);
  }
  return c0.substring(a0, a0++ + t);
}
function D6(t) {
  const {
      batch: e,
      cacheTime: n = t.pollingInterval ?? 4e3,
      ccipRead: r,
      key: i = "base",
      name: s = "Base Client",
      pollingInterval: o = 4e3,
      type: a = "base",
    } = t,
    l = t.chain,
    d = t.account ? Bo(t.account) : void 0,
    {
      config: p,
      request: f,
      value: m,
    } = t.transport({ chain: l, pollingInterval: o }),
    y = { ...p, ...m },
    g = {
      account: d,
      batch: e,
      cacheTime: n,
      ccipRead: r,
      chain: l,
      key: i,
      name: s,
      pollingInterval: o,
      request: f,
      transport: y,
      type: a,
      uid: k6(),
    };
  function v(b) {
    return (E) => {
      const S = E(b);
      for (const _ in g) delete S[_];
      const C = { ...b, ...S };
      return Object.assign(C, { extend: v(C) });
    };
  }
  return Object.assign(g, { extend: v(g) });
}
const l0 = new Uv(8192);
function cfe(t, { enabled: e = !0, id: n }) {
  if (!e || !n) return t();
  if (l0.get(n)) return l0.get(n);
  const r = t().finally(() => l0.delete(n));
  return l0.set(n, r), r;
}
function Tw(
  t,
  { delay: e = 100, retryCount: n = 2, shouldRetry: r = () => !0 } = {}
) {
  return new Promise((i, s) => {
    const o = async ({ count: a = 0 } = {}) => {
      const l = async ({ error: d }) => {
        const p = typeof e == "function" ? e({ count: a, error: d }) : e;
        p && (await Iw(p)), o({ count: a + 1 });
      };
      try {
        const d = await t();
        i(d);
      } catch (d) {
        if (a < n && (await r({ count: a, error: d }))) return l({ error: d });
        s(d);
      }
    };
    o();
  });
}
function lfe(t, e = {}) {
  return async (n, r = {}) => {
    var f;
    const {
        dedupe: i = !1,
        methods: s,
        retryDelay: o = 150,
        retryCount: a = 3,
        uid: l,
      } = { ...e, ...r },
      { method: d } = n;
    if ((f = s == null ? void 0 : s.exclude) != null && f.includes(d))
      throw new Ol(new Error("method not supported"), { method: d });
    if (s != null && s.include && !s.include.includes(d))
      throw new Ol(new Error("method not supported"), { method: d });
    const p = i ? $v(`${l}.${gs(n)}`) : void 0;
    return cfe(
      () =>
        Tw(
          async () => {
            try {
              return await t(n);
            } catch (m) {
              const y = m;
              switch (y.code) {
                case Zh.code:
                  throw new Zh(y);
                case Qh.code:
                  throw new Qh(y);
                case Xh.code:
                  throw new Xh(y, { method: n.method });
                case Jh.code:
                  throw new Jh(y);
                case iu.code:
                  throw new iu(y);
                case em.code:
                  throw new em(y);
                case tm.code:
                  throw new tm(y);
                case kc.code:
                  throw new kc(y);
                case up.code:
                  throw new up(y);
                case Ol.code:
                  throw new Ol(y, { method: n.method });
                case dp.code:
                  throw new dp(y);
                case nm.code:
                  throw new nm(y);
                case Qn.code:
                  throw new Qn(y);
                case rm.code:
                  throw new rm(y);
                case im.code:
                  throw new im(y);
                case sm.code:
                  throw new sm(y);
                case om.code:
                  throw new om(y);
                case $o.code:
                  throw new $o(y);
                case am.code:
                  throw new am(y);
                case cm.code:
                  throw new cm(y);
                case lm.code:
                  throw new lm(y);
                case um.code:
                  throw new um(y);
                case dm.code:
                  throw new dm(y);
                case pm.code:
                  throw new pm(y);
                case fm.code:
                  throw new fm(y);
                case 5e3:
                  throw new Qn(y);
                default:
                  throw m instanceof ge ? m : new Fde(y);
              }
            }
          },
          {
            delay: ({ count: m, error: y }) => {
              var g;
              if (y && y instanceof xh) {
                const v =
                  (g = y == null ? void 0 : y.headers) == null
                    ? void 0
                    : g.get("Retry-After");
                if (v != null && v.match(/\d/)) return Number.parseInt(v) * 1e3;
              }
              return ~~(1 << m) * o;
            },
            retryCount: a,
            shouldRetry: ({ error: m }) => ufe(m),
          }
        ),
      { enabled: i, id: p }
    );
  };
}
function ufe(t) {
  return "code" in t && typeof t.code == "number"
    ? t.code === -1 || t.code === dp.code || t.code === iu.code
    : t instanceof xh && t.status
    ? t.status === 403 ||
      t.status === 408 ||
      t.status === 413 ||
      t.status === 429 ||
      t.status === 500 ||
      t.status === 502 ||
      t.status === 503 ||
      t.status === 504
    : !0;
}
function o_(
  {
    key: t,
    methods: e,
    name: n,
    request: r,
    retryCount: i = 3,
    retryDelay: s = 150,
    timeout: o,
    type: a,
  },
  l
) {
  const d = k6();
  return {
    config: {
      key: t,
      methods: e,
      name: n,
      request: r,
      retryCount: i,
      retryDelay: s,
      timeout: o,
      type: a,
    },
    request: lfe(r, { methods: e, retryCount: i, retryDelay: s, uid: d }),
    value: l,
  };
}
function dfe(t, e = {}) {
  const {
    key: n = "custom",
    methods: r,
    name: i = "Custom Provider",
    retryDelay: s,
  } = e;
  return ({ retryCount: o }) =>
    o_({
      key: n,
      methods: r,
      name: i,
      request: t.request.bind(t),
      retryCount: e.retryCount ?? o,
      retryDelay: s,
      type: "custom",
    });
}
function JO(t, e = {}) {
  const {
    key: n = "fallback",
    name: r = "Fallback",
    rank: i = !1,
    shouldThrow: s = pfe,
    retryCount: o,
    retryDelay: a,
  } = e;
  return ({ chain: l, pollingInterval: d = 4e3, timeout: p, ...f }) => {
    let m = t,
      y = () => {};
    const g = o_(
      {
        key: n,
        name: r,
        async request({ method: v, params: b }) {
          let E;
          const S = async (C = 0) => {
            const _ = m[C]({ ...f, chain: l, retryCount: 0, timeout: p });
            try {
              const A = await _.request({ method: v, params: b });
              return (
                y({
                  method: v,
                  params: b,
                  response: A,
                  transport: _,
                  status: "success",
                }),
                A
              );
            } catch (A) {
              if (
                (y({
                  error: A,
                  method: v,
                  params: b,
                  transport: _,
                  status: "error",
                }),
                s(A) ||
                  C === m.length - 1 ||
                  (E ??
                    (E = m.slice(C + 1).some((I) => {
                      const { include: R, exclude: D } =
                        I({ chain: l }).config.methods || {};
                      return R ? R.includes(v) : D ? !D.includes(v) : !0;
                    })),
                  !E))
              )
                throw A;
              return S(C + 1);
            }
          };
          return S();
        },
        retryCount: o,
        retryDelay: a,
        type: "fallback",
      },
      {
        onResponse: (v) => (y = v),
        transports: m.map((v) => v({ chain: l, retryCount: 0 })),
      }
    );
    if (i) {
      const v = typeof i == "object" ? i : {};
      ffe({
        chain: l,
        interval: v.interval ?? d,
        onTransports: (b) => (m = b),
        ping: v.ping,
        sampleCount: v.sampleCount,
        timeout: v.timeout,
        transports: m,
        weights: v.weights,
      });
    }
    return g;
  };
}
function pfe(t) {
  return !!(
    "code" in t &&
    typeof t.code == "number" &&
    (t.code === up.code ||
      t.code === Qn.code ||
      kl.nodeMessage.test(t.message) ||
      t.code === 5e3)
  );
}
function ffe({
  chain: t,
  interval: e = 4e3,
  onTransports: n,
  ping: r,
  sampleCount: i = 10,
  timeout: s = 1e3,
  transports: o,
  weights: a = {},
}) {
  const { stability: l = 0.7, latency: d = 0.3 } = a,
    p = [],
    f = async () => {
      const m = await Promise.all(
        o.map(async (v) => {
          const b = v({ chain: t, retryCount: 0, timeout: s }),
            E = Date.now();
          let S, C;
          try {
            await (r
              ? r({ transport: b })
              : b.request({ method: "net_listening" })),
              (C = 1);
          } catch {
            C = 0;
          } finally {
            S = Date.now();
          }
          return { latency: S - E, success: C };
        })
      );
      p.push(m), p.length > i && p.shift();
      const y = Math.max(
          ...p.map((v) => Math.max(...v.map(({ latency: b }) => b)))
        ),
        g = o
          .map((v, b) => {
            const E = p.map((I) => I[b].latency),
              C = 1 - E.reduce((I, R) => I + R, 0) / E.length / y,
              _ = p.map((I) => I[b].success),
              A = _.reduce((I, R) => I + R, 0) / _.length;
            return A === 0 ? [0, b] : [d * C + l * A, b];
          })
          .sort((v, b) => b[0] - v[0]);
      n(g.map(([, v]) => o[v])), await Iw(e), f();
    };
  f();
}
class hfe extends ge {
  constructor() {
    super(
      "No URL was provided to the Transport. Please provide a valid RPC URL to the Transport.",
      { docsPath: "/docs/clients/intro", name: "UrlRequiredError" }
    );
  }
}
function $6(
  t,
  { errorInstance: e = new Error("timed out"), timeout: n, signal: r }
) {
  return new Promise((i, s) => {
    (async () => {
      let o;
      try {
        const a = new AbortController();
        n > 0 &&
          (o = setTimeout(() => {
            r ? a.abort() : s(e);
          }, n)),
          i(await t({ signal: (a == null ? void 0 : a.signal) || null }));
      } catch (a) {
        (a == null ? void 0 : a.name) === "AbortError" && s(e), s(a);
      } finally {
        clearTimeout(o);
      }
    })();
  });
}
function mfe() {
  return {
    current: 0,
    take() {
      return this.current++;
    },
    reset() {
      this.current = 0;
    },
  };
}
const ek = mfe();
function gfe(t, e = {}) {
  return {
    async request(n) {
      var f;
      const {
          body: r,
          onRequest: i = e.onRequest,
          onResponse: s = e.onResponse,
          timeout: o = e.timeout ?? 1e4,
        } = n,
        a = { ...(e.fetchOptions ?? {}), ...(n.fetchOptions ?? {}) },
        { headers: l, method: d, signal: p } = a;
      try {
        const m = await $6(
          async ({ signal: g }) => {
            const v = {
                ...a,
                body: Array.isArray(r)
                  ? gs(
                      r.map((C) => ({
                        jsonrpc: "2.0",
                        id: C.id ?? ek.take(),
                        ...C,
                      }))
                    )
                  : gs({ jsonrpc: "2.0", id: r.id ?? ek.take(), ...r }),
                headers: { "Content-Type": "application/json", ...l },
                method: d || "POST",
                signal: p || (o > 0 ? g : null),
              },
              b = new Request(t, v),
              E = (await (i == null ? void 0 : i(b, v))) ?? { ...v, url: t };
            return await fetch(E.url ?? t, E);
          },
          { errorInstance: new HO({ body: r, url: t }), timeout: o, signal: !0 }
        );
        s && (await s(m));
        let y;
        if (
          (f = m.headers.get("Content-Type")) != null &&
          f.startsWith("application/json")
        )
          y = await m.json();
        else {
          y = await m.text();
          try {
            y = JSON.parse(y || "{}");
          } catch (g) {
            if (m.ok) throw g;
            y = { error: y };
          }
        }
        if (!m.ok)
          throw new xh({
            body: r,
            details: gs(y.error) || m.statusText,
            headers: m.headers,
            status: m.status,
            url: t,
          });
        return y;
      } catch (m) {
        throw m instanceof xh || m instanceof HO
          ? m
          : new xh({ body: r, cause: m, url: t });
      }
    },
  };
}
function u0(t, e = {}) {
  const {
    batch: n,
    fetchOptions: r,
    key: i = "http",
    methods: s,
    name: o = "HTTP JSON-RPC",
    onFetchRequest: a,
    onFetchResponse: l,
    retryDelay: d,
    raw: p,
  } = e;
  return ({ chain: f, retryCount: m, timeout: y }) => {
    const { batchSize: g = 1e3, wait: v = 0 } = typeof n == "object" ? n : {},
      b = e.retryCount ?? m,
      E = y ?? e.timeout ?? 1e4,
      S = t || (f == null ? void 0 : f.rpcUrls.default.http[0]);
    if (!S) throw new hfe();
    const C = gfe(S, {
      fetchOptions: r,
      onRequest: a,
      onResponse: l,
      timeout: E,
    });
    return o_(
      {
        key: i,
        methods: s,
        name: o,
        async request({ method: _, params: A }) {
          const I = { method: _, params: A },
            { schedule: R } = T6({
              id: S,
              wait: v,
              shouldSplitBatch(U) {
                return U.length > g;
              },
              fn: (U) => C.request({ body: U }),
              sort: (U, q) => U.id - q.id,
            }),
            D = async (U) => (n ? R(U) : [await C.request({ body: U })]),
            [{ error: k, result: T }] = await D(I);
          if (p) return { error: k, result: T };
          if (k) throw new QA({ body: I, error: k, url: S });
          return T;
        },
        retryCount: b,
        retryDelay: d,
        timeout: E,
        type: "http",
      },
      { fetchOptions: r, url: S }
    );
  };
}
async function yfe(t) {
  const e = ade(t, { method: "eth_newPendingTransactionFilter" }),
    n = await t.request({ method: "eth_newPendingTransactionFilter" });
  return { id: n, request: e(n), type: "transaction" };
}
function wfe(t) {
  return { formatters: void 0, fees: void 0, serializers: void 0, ...t };
}
class vfe extends ge {
  constructor({ value: e }) {
    super(`Number \`${e}\` is not a valid decimal number.`, {
      name: "InvalidDecimalNumberError",
    });
  }
}
function bd(t, e) {
  if (!/^(-?)([0-9]*)\.?([0-9]*)$/.test(t)) throw new vfe({ value: t });
  let [n, r = "0"] = t.split(".");
  const i = n.startsWith("-");
  if ((i && (n = n.slice(1)), (r = r.replace(/(0+)$/, "")), e === 0))
    Math.round(+`.${r}`) === 1 && (n = `${BigInt(n) + 1n}`), (r = "");
  else if (r.length > e) {
    const [s, o, a] = [r.slice(0, e - 1), r.slice(e - 1, e), r.slice(e)],
      l = Math.round(+`${o}.${a}`);
    l > 9
      ? (r = `${BigInt(s) + BigInt(1)}0`.padStart(s.length + 1, "0"))
      : (r = `${s}${l}`),
      r.length > e && ((r = r.slice(1)), (n = `${BigInt(n) + 1n}`)),
      (r = r.slice(0, e));
  } else r = r.padEnd(e, "0");
  return BigInt(`${i ? "-" : ""}${n}${r}`);
}
async function M6(
  t,
  { blockHash: e, blockNumber: n, blockTag: r, hash: i, index: s }
) {
  var p, f, m;
  const o = r || "latest",
    a = n !== void 0 ? Et(n) : void 0;
  let l = null;
  if (
    (i
      ? (l = await t.request(
          { method: "eth_getTransactionByHash", params: [i] },
          { dedupe: !0 }
        ))
      : e
      ? (l = await t.request(
          {
            method: "eth_getTransactionByBlockHashAndIndex",
            params: [e, Et(s)],
          },
          { dedupe: !0 }
        ))
      : (l = await t.request(
          {
            method: "eth_getTransactionByBlockNumberAndIndex",
            params: [a || o, Et(s)],
          },
          { dedupe: !!a }
        )),
    !l)
  )
    throw new n6({
      blockHash: e,
      blockNumber: n,
      blockTag: o,
      hash: i,
      index: s,
    });
  return (
    ((m =
      (f = (p = t.chain) == null ? void 0 : p.formatters) == null
        ? void 0
        : f.transaction) == null
      ? void 0
      : m.format) || d6
  )(l);
}
async function tk(t, { hash: e }) {
  var i, s, o;
  const n = await t.request(
    { method: "eth_getTransactionReceipt", params: [e] },
    { dedupe: !0 }
  );
  if (!n) throw new r6({ hash: e });
  return (
    ((o =
      (s = (i = t.chain) == null ? void 0 : i.formatters) == null
        ? void 0
        : s.transactionReceipt) == null
      ? void 0
      : o.format) || afe
  )(n);
}
async function bfe(t, e) {
  var b;
  const {
      allowFailure: n = !0,
      batchSize: r,
      blockNumber: i,
      blockTag: s,
      multicallAddress: o,
      stateOverride: a,
    } = e,
    l = e.contracts,
    d =
      r ??
      ((typeof ((b = t.batch) == null ? void 0 : b.multicall) == "object" &&
        t.batch.multicall.batchSize) ||
        1024);
  let p = o;
  if (!p) {
    if (!t.chain)
      throw new Error(
        "client chain not configured. multicallAddress is required."
      );
    p = _6({ blockNumber: i, chain: t.chain, contract: "multicall3" });
  }
  const f = [[]];
  let m = 0,
    y = 0;
  for (let E = 0; E < l.length; E++) {
    const { abi: S, address: C, args: _, functionName: A } = l[E];
    try {
      const I = Fv({ abi: S, args: _, functionName: A });
      (y += (I.length - 2) / 2),
        d > 0 &&
          y > d &&
          f[m].length > 0 &&
          (m++, (y = (I.length - 2) / 2), (f[m] = [])),
        (f[m] = [...f[m], { allowFailure: !0, callData: I, target: C }]);
    } catch (I) {
      const R = xw(I, {
        abi: S,
        address: C,
        args: _,
        docsPath: "/docs/contract/multicall",
        functionName: A,
      });
      if (!n) throw R;
      f[m] = [...f[m], { allowFailure: !0, callData: "0x", target: C }];
    }
  }
  const g = await Promise.allSettled(
      f.map((E) =>
        yn(
          t,
          R6,
          "readContract"
        )({
          abi: dS,
          address: p,
          args: [E],
          blockNumber: i,
          blockTag: s,
          functionName: "aggregate3",
          stateOverride: a,
        })
      )
    ),
    v = [];
  for (let E = 0; E < g.length; E++) {
    const S = g[E];
    if (S.status === "rejected") {
      if (!n) throw S.reason;
      for (let _ = 0; _ < f[E].length; _++)
        v.push({ status: "failure", error: S.reason, result: void 0 });
      continue;
    }
    const C = S.value;
    for (let _ = 0; _ < C.length; _++) {
      const { returnData: A, success: I } = C[_],
        { callData: R } = f[E][_],
        { abi: D, address: k, functionName: T, args: U } = l[v.length];
      try {
        if (R === "0x") throw new Dv();
        if (!I) throw new ZA({ data: A });
        const q = i_({ abi: D, args: U, data: A, functionName: T });
        v.push(n ? { result: q, status: "success" } : q);
      } catch (q) {
        const K = xw(q, {
          abi: D,
          address: k,
          args: U,
          docsPath: "/docs/contract/multicall",
          functionName: T,
        });
        if (!n) throw K;
        v.push({ error: K, result: void 0, status: "failure" });
      }
    }
  }
  if (v.length !== l.length) throw new ge("multicall results mismatch");
  return v;
}
function Efe(
  t,
  {
    emitOnBegin: e = !1,
    emitMissed: n = !1,
    onBlockNumber: r,
    onError: i,
    poll: s,
    pollingInterval: o = t.pollingInterval,
  }
) {
  const a =
    typeof s < "u"
      ? s
      : !(
          t.transport.type === "webSocket" ||
          (t.transport.type === "fallback" &&
            t.transport.transports[0].config.type === "webSocket")
        );
  let l;
  return a
    ? (() => {
        const f = gs(["watchBlockNumber", t.uid, e, n, o]);
        return _w(f, { onBlockNumber: r, onError: i }, (m) =>
          N6(
            async () => {
              var y;
              try {
                const g = await yn(t, Jpe, "getBlockNumber")({ cacheTime: 0 });
                if (l) {
                  if (g === l) return;
                  if (g - l > 1 && n)
                    for (let v = l + 1n; v < g; v++)
                      m.onBlockNumber(v, l), (l = v);
                }
                (!l || g > l) && (m.onBlockNumber(g, l), (l = g));
              } catch (g) {
                (y = m.onError) == null || y.call(m, g);
              }
            },
            { emitOnBegin: e, interval: o }
          )
        );
      })()
    : (() => {
        const f = gs(["watchBlockNumber", t.uid, e, n]);
        return _w(f, { onBlockNumber: r, onError: i }, (m) => {
          let y = !0,
            g = () => (y = !1);
          return (
            (async () => {
              try {
                const v = (() => {
                    if (t.transport.type === "fallback") {
                      const E = t.transport.transports.find(
                        (S) => S.config.type === "webSocket"
                      );
                      return E ? E.value : t.transport;
                    }
                    return t.transport;
                  })(),
                  { unsubscribe: b } = await v.subscribe({
                    params: ["newHeads"],
                    onData(E) {
                      var C;
                      if (!y) return;
                      const S = ap((C = E.result) == null ? void 0 : C.number);
                      m.onBlockNumber(S, l), (l = S);
                    },
                    onError(E) {
                      var S;
                      (S = m.onError) == null || S.call(m, E);
                    },
                  });
                (g = b), y || g();
              } catch (v) {
                i == null || i(v);
              }
            })(),
            () => g()
          );
        });
      })();
}
async function Cfe(
  t,
  {
    confirmations: e = 1,
    hash: n,
    onReplaced: r,
    pollingInterval: i = t.pollingInterval,
    retryCount: s = 6,
    retryDelay: o = ({ count: l }) => ~~(1 << l) * 200,
    timeout: a = 18e4,
  }
) {
  const l = gs(["waitForTransactionReceipt", t.uid, n]);
  let d,
    p,
    f,
    m = !1;
  const { promise: y, resolve: g, reject: v } = I6(),
    b = a ? setTimeout(() => v(new Dde({ hash: n })), a) : void 0,
    E = _w(l, { onReplaced: r, resolve: g, reject: v }, (S) => {
      const C = yn(
        t,
        Efe,
        "watchBlockNumber"
      )({
        emitMissed: !0,
        emitOnBegin: !0,
        poll: !0,
        pollingInterval: i,
        async onBlockNumber(_) {
          const A = (R) => {
            clearTimeout(b), C(), R(), E();
          };
          let I = _;
          if (!m)
            try {
              if (f) {
                if (e > 1 && (!f.blockNumber || I - f.blockNumber + 1n < e))
                  return;
                A(() => S.resolve(f));
                return;
              }
              if (
                (d ||
                  ((m = !0),
                  await Tw(
                    async () => {
                      (d = await yn(t, M6, "getTransaction")({ hash: n })),
                        d.blockNumber && (I = d.blockNumber);
                    },
                    { delay: o, retryCount: s }
                  ),
                  (m = !1)),
                (f = await yn(t, tk, "getTransactionReceipt")({ hash: n })),
                e > 1 && (!f.blockNumber || I - f.blockNumber + 1n < e))
              )
                return;
              A(() => S.resolve(f));
            } catch (R) {
              if (R instanceof n6 || R instanceof r6) {
                if (!d) {
                  m = !1;
                  return;
                }
                try {
                  (p = d), (m = !0);
                  const D = await Tw(
                    () =>
                      yn(
                        t,
                        hm,
                        "getBlock"
                      )({ blockNumber: I, includeTransactions: !0 }),
                    {
                      delay: o,
                      retryCount: s,
                      shouldRetry: ({ error: U }) => U instanceof l6,
                    }
                  );
                  m = !1;
                  const k = D.transactions.find(
                    ({ from: U, nonce: q }) => U === p.from && q === p.nonce
                  );
                  if (
                    !k ||
                    ((f = await yn(
                      t,
                      tk,
                      "getTransactionReceipt"
                    )({ hash: k.hash })),
                    e > 1 && (!f.blockNumber || I - f.blockNumber + 1n < e))
                  )
                    return;
                  let T = "replaced";
                  k.to === p.to && k.value === p.value && k.input === p.input
                    ? (T = "repriced")
                    : k.from === k.to && k.value === 0n && (T = "cancelled"),
                    A(() => {
                      var U;
                      (U = S.onReplaced) == null ||
                        U.call(S, {
                          reason: T,
                          replacedTransaction: p,
                          transaction: k,
                          transactionReceipt: f,
                        }),
                        S.resolve(f);
                    });
                } catch (D) {
                  A(() => S.reject(D));
                }
              } else A(() => S.reject(R));
            }
        },
      });
    });
  return y;
}
function xfe(
  t,
  {
    batch: e = !0,
    onError: n,
    onTransactions: r,
    poll: i,
    pollingInterval: s = t.pollingInterval,
  }
) {
  return (typeof i < "u" ? i : t.transport.type !== "webSocket")
    ? (() => {
        const d = gs(["watchPendingTransactions", t.uid, e, s]);
        return _w(d, { onTransactions: r, onError: n }, (p) => {
          let f;
          const m = N6(
            async () => {
              var y;
              try {
                if (!f)
                  try {
                    f = await yn(t, yfe, "createPendingTransactionFilter")({});
                    return;
                  } catch (v) {
                    throw (m(), v);
                  }
                const g = await yn(t, efe, "getFilterChanges")({ filter: f });
                if (g.length === 0) return;
                if (e) p.onTransactions(g);
                else for (const v of g) p.onTransactions([v]);
              } catch (g) {
                (y = p.onError) == null || y.call(p, g);
              }
            },
            { emitOnBegin: !0, interval: s }
          );
          return async () => {
            f && (await yn(t, tfe, "uninstallFilter")({ filter: f })), m();
          };
        });
      })()
    : (() => {
        let d = !0,
          p = () => (d = !1);
        return (
          (async () => {
            try {
              const { unsubscribe: f } = await t.transport.subscribe({
                params: ["newPendingTransactions"],
                onData(m) {
                  if (!d) return;
                  const y = m.result;
                  r([y]);
                },
                onError(m) {
                  n == null || n(m);
                },
              });
              (p = f), d || p();
            } catch (f) {
              n == null || n(f);
            }
          })(),
          () => p()
        );
      })();
}
async function Sfe(t, { account: e = t.account, message: n }) {
  if (!e) throw new s_({ docsPath: "/docs/actions/wallet/signMessage" });
  const r = Bo(e);
  if (r.signMessage) return r.signMessage({ message: n });
  const i =
    typeof n == "string"
      ? $v(n)
      : n.raw instanceof Uint8Array
      ? cp(n.raw)
      : n.raw;
  return t.request(
    { method: "personal_sign", params: [i, r.address] },
    { retryCount: 0 }
  );
}
const pC = {
    createBalance(t, e) {
      const n = {
        name: t.metadata.name || "",
        symbol: t.metadata.symbol || "",
        decimals: t.metadata.decimals || 0,
        value: t.metadata.value || 0,
        price: t.metadata.price || 0,
        iconUrl: t.metadata.iconUrl || "",
      };
      return {
        name: n.name,
        symbol: n.symbol,
        chainId: e,
        address:
          t.address === "native"
            ? void 0
            : this.convertAddressToCAIP10Address(t.address, e),
        value: n.value,
        price: n.price,
        quantity: {
          decimals: n.decimals.toString(),
          numeric: this.convertHexToBalance({
            hex: t.balance,
            decimals: n.decimals,
          }),
        },
        iconUrl: n.iconUrl,
      };
    },
    convertHexToBalance({ hex: t, decimals: e }) {
      return Ln(BigInt(t), e);
    },
    convertAddressToCAIP10Address(t, e) {
      return `${e}:${t}`;
    },
    createCAIP2ChainId(t, e) {
      return `${e}:${parseInt(t, 16)}`;
    },
    getChainIdHexFromCAIP2ChainId(t) {
      const e = t.split(":");
      if (e.length < 2 || !e[1]) return "0x0";
      const n = e[1],
        r = parseInt(n, 10);
      return isNaN(r) ? "0x0" : `0x${r.toString(16)}`;
    },
    isWalletGetAssetsResponse(t) {
      return typeof t != "object" || t === null
        ? !1
        : Object.values(t).every(
            (e) => Array.isArray(e) && e.every((n) => this.isValidAsset(n))
          );
    },
    isValidAsset(t) {
      return (
        typeof t == "object" &&
        t !== null &&
        typeof t.address == "string" &&
        typeof t.balance == "string" &&
        (t.type === "ERC20" || t.type === "NATIVE") &&
        typeof t.metadata == "object" &&
        t.metadata !== null &&
        typeof t.metadata.name == "string" &&
        typeof t.metadata.symbol == "string" &&
        typeof t.metadata.decimals == "number" &&
        typeof t.metadata.price == "number" &&
        typeof t.metadata.iconUrl == "string"
      );
    },
  },
  nk = {
    async getMyTokensWithBalance(t) {
      const e = Be.state.address,
        n = Y.state.activeCaipNetwork;
      if (!e || !n) return [];
      if (n.chainNamespace === "eip155") {
        const i = await this.getEIP155Balances(e, n);
        if (i) return this.filterLowQualityTokens(i);
      }
      const r = await Xe.getBalance(e, n.caipNetworkId, t);
      return this.filterLowQualityTokens(r.balances);
    },
    async getEIP155Balances(t, e) {
      var n, r;
      try {
        const i = pC.getChainIdHexFromCAIP2ChainId(e.caipNetworkId),
          s = await an.getCapabilities(t);
        if (
          !(
            (r =
              (n = s == null ? void 0 : s[i]) == null
                ? void 0
                : n.assetDiscovery) != null && r.supported
          )
        )
          return null;
        const o = await an.walletGetAssets({ account: t, chainFilter: [i] });
        return pC.isWalletGetAssetsResponse(o)
          ? (o[i] || []).map((l) => pC.createBalance(l, e.caipNetworkId))
          : null;
      } catch {
        return null;
      }
    },
    filterLowQualityTokens(t) {
      return t.filter((e) => e.quantity.decimals !== "0");
    },
    mapBalancesToSwapTokens(t) {
      return (
        (t == null
          ? void 0
          : t.map((e) => ({
              ...e,
              address:
                e != null && e.address
                  ? e.address
                  : Y.getActiveNetworkTokenAddress(),
              decimals: parseInt(e.quantity.decimals, 10),
              logoUri: e.iconUrl,
              eip2612: !1,
            }))) || []
      );
    },
  },
  qt = wn({ tokenBalances: [], loading: !1 }),
  rk = {
    state: qt,
    subscribe(t) {
      return ri(qt, () => t(qt));
    },
    subscribeKey(t, e) {
      return si(qt, t, e);
    },
    setToken(t) {
      t && (qt.token = Kl(t));
    },
    setTokenAmount(t) {
      qt.sendTokenAmount = t;
    },
    setReceiverAddress(t) {
      qt.receiverAddress = t;
    },
    setReceiverProfileImageUrl(t) {
      qt.receiverProfileImageUrl = t;
    },
    setReceiverProfileName(t) {
      qt.receiverProfileName = t;
    },
    setNetworkBalanceInUsd(t) {
      qt.networkBalanceInUSD = t;
    },
    setLoading(t) {
      qt.loading = t;
    },
    async sendToken() {
      var t;
      try {
        switch (
          (this.setLoading(!0),
          (t = Y.state.activeCaipNetwork) == null ? void 0 : t.chainNamespace)
        ) {
          case "eip155":
            await this.sendEvmToken();
            return;
          case "solana":
            await this.sendSolanaToken();
            return;
          default:
            throw new Error("Unsupported chain");
        }
      } finally {
        this.setLoading(!1);
      }
    },
    async sendEvmToken() {
      var n, r, i, s;
      const t = Y.state.activeChain,
        e = (n = Be.state.preferredAccountTypes) == null ? void 0 : n[t];
      if (!this.state.sendTokenAmount || !this.state.receiverAddress)
        throw new Error("An amount and receiver address are required");
      if (!this.state.token) throw new Error("A token is required");
      (r = this.state.token) != null && r.address
        ? (fn.sendEvent({
            type: "track",
            event: "SEND_INITIATED",
            properties: {
              isSmartAccount: e === Rr.ACCOUNT_TYPES.SMART_ACCOUNT,
              token: this.state.token.address,
              amount: this.state.sendTokenAmount,
              network:
                ((i = Y.state.activeCaipNetwork) == null
                  ? void 0
                  : i.caipNetworkId) || "",
            },
          }),
          await this.sendERC20Token({
            receiverAddress: this.state.receiverAddress,
            tokenAddress: this.state.token.address,
            sendTokenAmount: this.state.sendTokenAmount,
            decimals: this.state.token.quantity.decimals,
          }))
        : (fn.sendEvent({
            type: "track",
            event: "SEND_INITIATED",
            properties: {
              isSmartAccount: e === Rr.ACCOUNT_TYPES.SMART_ACCOUNT,
              token: this.state.token.symbol || "",
              amount: this.state.sendTokenAmount,
              network:
                ((s = Y.state.activeCaipNetwork) == null
                  ? void 0
                  : s.caipNetworkId) || "",
            },
          }),
          await this.sendNativeToken({
            receiverAddress: this.state.receiverAddress,
            sendTokenAmount: this.state.sendTokenAmount,
            decimals: this.state.token.quantity.decimals,
          }));
    },
    async fetchTokenBalance(t) {
      var s, o;
      qt.loading = !0;
      const e =
          (s = Y.state.activeCaipNetwork) == null ? void 0 : s.caipNetworkId,
        n = (o = Y.state.activeCaipNetwork) == null ? void 0 : o.chainNamespace,
        r = Y.state.activeCaipAddress,
        i = r ? Je.getPlainAddress(r) : void 0;
      if (qt.lastRetry && !Je.isAllowedRetry(qt.lastRetry, 30 * er.ONE_SEC_MS))
        return (qt.loading = !1), [];
      try {
        if (i && e && n) {
          const a = await nk.getMyTokensWithBalance();
          return (qt.tokenBalances = a), (qt.lastRetry = void 0), a;
        }
      } catch (a) {
        (qt.lastRetry = Date.now()),
          t == null || t(a),
          qs.showError("Token Balance Unavailable");
      } finally {
        qt.loading = !1;
      }
      return [];
    },
    fetchNetworkBalance() {
      if (qt.tokenBalances.length === 0) return;
      const t = nk.mapBalancesToSwapTokens(qt.tokenBalances);
      if (!t) return;
      const e = t.find((n) => n.address === Y.getActiveNetworkTokenAddress());
      e &&
        (qt.networkBalanceInUSD = e
          ? dV.multiply(e.quantity.numeric, e.price).toString()
          : "0");
    },
    async sendNativeToken(t) {
      var o, a, l;
      const e = Y.state.activeChain;
      zt.pushTransactionStack({ view: null, goBack: !1 });
      const n = t.receiverAddress,
        r = Be.state.address,
        i = an.parseUnits(t.sendTokenAmount.toString(), Number(t.decimals));
      await an.sendTransaction({
        chainNamespace: "eip155",
        to: n,
        address: r,
        data: "0x",
        value: i ?? BigInt(0),
      }),
        fn.sendEvent({
          type: "track",
          event: "SEND_SUCCESS",
          properties: {
            isSmartAccount:
              ((o = Be.state.preferredAccountTypes) == null ? void 0 : o[e]) ===
              Rr.ACCOUNT_TYPES.SMART_ACCOUNT,
            token: ((a = this.state.token) == null ? void 0 : a.symbol) || "",
            amount: t.sendTokenAmount,
            network:
              ((l = Y.state.activeCaipNetwork) == null
                ? void 0
                : l.caipNetworkId) || "",
          },
        }),
        this.resetSend();
    },
    async sendERC20Token(t) {
      zt.pushTransactionStack({ view: "Account", goBack: !1 });
      const e = an.parseUnits(t.sendTokenAmount.toString(), Number(t.decimals));
      if (
        Be.state.address &&
        t.sendTokenAmount &&
        t.receiverAddress &&
        t.tokenAddress
      ) {
        const n = Je.getPlainAddress(t.tokenAddress);
        await an.writeContract({
          fromAddress: Be.state.address,
          tokenAddress: n,
          args: [t.receiverAddress, e ?? BigInt(0)],
          method: "transfer",
          abi: mV.getERC20Abi(n),
          chainNamespace: "eip155",
        }),
          this.resetSend();
      }
    },
    async sendSolanaToken() {
      if (!this.state.sendTokenAmount || !this.state.receiverAddress)
        throw new Error("An amount and receiver address are required");
      zt.pushTransactionStack({ view: "Account", goBack: !1 }),
        await an.sendTransaction({
          chainNamespace: "solana",
          to: this.state.receiverAddress,
          value: this.state.sendTokenAmount,
        }),
        this.resetSend(),
        Be.fetchTokenBalance();
    },
    resetSend() {
      (qt.token = void 0),
        (qt.sendTokenAmount = void 0),
        (qt.receiverAddress = void 0),
        (qt.receiverProfileImageUrl = void 0),
        (qt.receiverProfileName = void 0),
        (qt.loading = !1),
        (qt.tokenBalances = []);
    },
  },
  fC = {
    currentTab: 0,
    tokenBalance: [],
    smartAccountDeployed: !1,
    addressLabels: new Map(),
    allAccounts: [],
    user: void 0,
  },
  d0 = {
    caipNetwork: void 0,
    supportsAllNetworks: !0,
    smartAccountEnabledNetworks: [],
  },
  Ae = wn({
    chains: nV(),
    activeCaipAddress: void 0,
    activeChain: void 0,
    activeCaipNetwork: void 0,
    noAdapters: !1,
    universalAdapter: {
      networkControllerClient: void 0,
      connectionControllerClient: void 0,
    },
    isSwitchingNamespace: !1,
  }),
  Y = {
    state: Ae,
    subscribe(t) {
      return ri(Ae, () => {
        t(Ae);
      });
    },
    subscribeKey(t, e) {
      return si(Ae, t, e);
    },
    subscribeChainProp(t, e, n) {
      let r;
      return ri(Ae.chains, () => {
        var s;
        const i = n || Ae.activeChain;
        if (i) {
          const o = (s = Ae.chains.get(i)) == null ? void 0 : s[t];
          r !== o && ((r = o), e(o));
        }
      });
    },
    initialize(t, e, n) {
      const { chainId: r, namespace: i } = Ie.getActiveNetworkProps(),
        s =
          e == null
            ? void 0
            : e.find(
                (p) => p.id.toString() === (r == null ? void 0 : r.toString())
              ),
        a =
          t.find((p) => (p == null ? void 0 : p.namespace) === i) ||
          (t == null ? void 0 : t[0]),
        l = t.map((p) => p.namespace).filter((p) => p !== void 0),
        d = me.state.enableEmbedded
          ? new Set([...l])
          : new Set([
              ...((e == null ? void 0 : e.map((p) => p.chainNamespace)) ?? []),
            ]);
      ((t == null ? void 0 : t.length) === 0 || !a) && (Ae.noAdapters = !0),
        Ae.noAdapters ||
          ((Ae.activeChain = a == null ? void 0 : a.namespace),
          (Ae.activeCaipNetwork = s),
          this.setChainNetworkData(a == null ? void 0 : a.namespace, {
            caipNetwork: s,
          }),
          Ae.activeChain &&
            Ro.set({ activeChain: a == null ? void 0 : a.namespace })),
        d.forEach((p) => {
          const f =
            e == null ? void 0 : e.filter((m) => m.chainNamespace === p);
          Y.state.chains.set(p, {
            namespace: p,
            networkState: wn({ ...d0, caipNetwork: f == null ? void 0 : f[0] }),
            accountState: wn(fC),
            caipNetworks: f ?? [],
            ...n,
          }),
            this.setRequestedCaipNetworks(f ?? [], p);
        });
    },
    removeAdapter(t) {
      var e, n;
      if (Ae.activeChain === t) {
        const r = Array.from(Ae.chains.entries()).find(([i]) => i !== t);
        if (r) {
          const i =
            (n = (e = r[1]) == null ? void 0 : e.caipNetworks) == null
              ? void 0
              : n[0];
          i && this.setActiveCaipNetwork(i);
        }
      }
      Ae.chains.delete(t);
    },
    addAdapter(
      t,
      { networkControllerClient: e, connectionControllerClient: n },
      r
    ) {
      Ae.chains.set(t.namespace, {
        namespace: t.namespace,
        networkState: { ...d0, caipNetwork: r[0] },
        accountState: fC,
        caipNetworks: r,
        connectionControllerClient: n,
        networkControllerClient: e,
      }),
        this.setRequestedCaipNetworks(
          (r == null
            ? void 0
            : r.filter((i) => i.chainNamespace === t.namespace)) ?? [],
          t.namespace
        );
    },
    addNetwork(t) {
      var n;
      const e = Ae.chains.get(t.chainNamespace);
      if (e) {
        const r = [...(e.caipNetworks || [])];
        ((n = e.caipNetworks) != null && n.find((i) => i.id === t.id)) ||
          r.push(t),
          Ae.chains.set(t.chainNamespace, { ...e, caipNetworks: r }),
          this.setRequestedCaipNetworks(r, t.chainNamespace),
          nt.filterByNamespace(t.chainNamespace, !0);
      }
    },
    removeNetwork(t, e) {
      var r, i, s;
      const n = Ae.chains.get(t);
      if (n) {
        const o = ((r = Ae.activeCaipNetwork) == null ? void 0 : r.id) === e,
          a = [
            ...(((i = n.caipNetworks) == null
              ? void 0
              : i.filter((l) => l.id !== e)) || []),
          ];
        o &&
          (s = n == null ? void 0 : n.caipNetworks) != null &&
          s[0] &&
          this.setActiveCaipNetwork(n.caipNetworks[0]),
          Ae.chains.set(t, { ...n, caipNetworks: a }),
          this.setRequestedCaipNetworks(a, t),
          a.length === 0 && nt.filterByNamespace(t, !1);
      }
    },
    setAdapterNetworkState(t, e) {
      const n = Ae.chains.get(t);
      n &&
        ((n.networkState = { ...(n.networkState || d0), ...e }),
        Ae.chains.set(t, n));
    },
    setChainAccountData(t, e, n = !0) {
      if (!t) throw new Error("Chain is required to update chain account data");
      const r = Ae.chains.get(t);
      if (r) {
        const i = { ...(r.accountState || fC), ...e };
        Ae.chains.set(t, { ...r, accountState: i }),
          (Ae.chains.size === 1 || Ae.activeChain === t) &&
            (e.caipAddress && (Ae.activeCaipAddress = e.caipAddress),
            Be.replaceState(i));
      }
    },
    setChainNetworkData(t, e) {
      if (!t) return;
      const n = Ae.chains.get(t);
      if (n) {
        const r = { ...(n.networkState || d0), ...e };
        Ae.chains.set(t, { ...n, networkState: r });
      }
    },
    setAccountProp(t, e, n, r = !0) {
      this.setChainAccountData(n, { [t]: e }, r),
        t === "status" && e === "disconnected" && n && nt.removeConnectorId(n);
    },
    setActiveNamespace(t) {
      var r, i;
      Ae.activeChain = t;
      const e = t ? Ae.chains.get(t) : void 0,
        n =
          (r = e == null ? void 0 : e.networkState) == null
            ? void 0
            : r.caipNetwork;
      n != null &&
        n.id &&
        t &&
        ((Ae.activeCaipAddress =
          (i = e == null ? void 0 : e.accountState) == null
            ? void 0
            : i.caipAddress),
        (Ae.activeCaipNetwork = n),
        this.setChainNetworkData(t, { caipNetwork: n }),
        Ie.setActiveCaipNetworkId(n == null ? void 0 : n.caipNetworkId),
        Ro.set({
          activeChain: t,
          selectedNetworkId: n == null ? void 0 : n.caipNetworkId,
        }));
    },
    setActiveCaipNetwork(t) {
      var r, i, s;
      if (!t) return;
      Ae.activeChain !== t.chainNamespace && this.setIsSwitchingNamespace(!0);
      const e = Ae.chains.get(t.chainNamespace);
      (Ae.activeChain = t.chainNamespace),
        (Ae.activeCaipNetwork = t),
        this.setChainNetworkData(t.chainNamespace, { caipNetwork: t }),
        (r = e == null ? void 0 : e.accountState) != null && r.address
          ? (Ae.activeCaipAddress = `${t.chainNamespace}:${t.id}:${
              (i = e == null ? void 0 : e.accountState) == null
                ? void 0
                : i.address
            }`)
          : (Ae.activeCaipAddress = void 0),
        this.setAccountProp(
          "caipAddress",
          Ae.activeCaipAddress,
          t.chainNamespace
        ),
        e && Be.replaceState(e.accountState),
        rk.resetSend(),
        Ro.set({
          activeChain: Ae.activeChain,
          selectedNetworkId:
            (s = Ae.activeCaipNetwork) == null ? void 0 : s.caipNetworkId,
        }),
        Ie.setActiveCaipNetworkId(t.caipNetworkId),
        !this.checkIfSupportedNetwork(t.chainNamespace) &&
          me.state.enableNetworkSwitch &&
          !me.state.allowUnsupportedChain &&
          !an.state.wcBasic &&
          this.showUnsupportedChainUI();
    },
    addCaipNetwork(t) {
      var n;
      if (!t) return;
      const e = Ae.chains.get(t.chainNamespace);
      e && ((n = e == null ? void 0 : e.caipNetworks) == null || n.push(t));
    },
    async switchActiveNamespace(t) {
      var i;
      if (!t) return;
      const e = t !== Y.state.activeChain,
        n = (i = Y.getNetworkData(t)) == null ? void 0 : i.caipNetwork,
        r = Y.getCaipNetworkByNamespace(t, n == null ? void 0 : n.id);
      e && r && (await Y.switchActiveNetwork(r));
    },
    async switchActiveNetwork(t) {
      var i;
      const e = Y.state.chains.get(Y.state.activeChain);
      !(
        (i = e == null ? void 0 : e.caipNetworks) != null &&
        i.some((s) => {
          var o;
          return s.id === ((o = Ae.activeCaipNetwork) == null ? void 0 : o.id);
        })
      ) && zt.goBack();
      const r = this.getNetworkControllerClient(t.chainNamespace);
      r &&
        (await r.switchCaipNetwork(t),
        fn.sendEvent({
          type: "track",
          event: "SWITCH_NETWORK",
          properties: { network: t.caipNetworkId },
        }));
    },
    getNetworkControllerClient(t) {
      const e = t || Ae.activeChain,
        n = Ae.chains.get(e);
      if (!n) throw new Error("Chain adapter not found");
      if (!n.networkControllerClient)
        throw new Error("NetworkController client not set");
      return n.networkControllerClient;
    },
    getConnectionControllerClient(t) {
      const e = t || Ae.activeChain;
      if (!e)
        throw new Error(
          "Chain is required to get connection controller client"
        );
      const n = Ae.chains.get(e);
      if (!(n != null && n.connectionControllerClient))
        throw new Error("ConnectionController client not set");
      return n.connectionControllerClient;
    },
    getAccountProp(t, e) {
      var i;
      let n = Ae.activeChain;
      if ((e && (n = e), !n)) return;
      const r = (i = Ae.chains.get(n)) == null ? void 0 : i.accountState;
      if (r) return r[t];
    },
    getNetworkProp(t, e) {
      var r;
      const n = (r = Ae.chains.get(e)) == null ? void 0 : r.networkState;
      if (n) return n[t];
    },
    getRequestedCaipNetworks(t) {
      const e = Ae.chains.get(t),
        { approvedCaipNetworkIds: n = [], requestedCaipNetworks: r = [] } =
          (e == null ? void 0 : e.networkState) || {};
      return Je.sortRequestedNetworks(n, r);
    },
    getAllRequestedCaipNetworks() {
      const t = [];
      return (
        Ae.chains.forEach((e) => {
          const n = this.getRequestedCaipNetworks(e.namespace);
          t.push(...n);
        }),
        t
      );
    },
    setRequestedCaipNetworks(t, e) {
      this.setAdapterNetworkState(e, { requestedCaipNetworks: t });
      const r = this.getAllRequestedCaipNetworks().map((s) => s.chainNamespace),
        i = Array.from(new Set(r));
      nt.filterByNamespaces(i);
    },
    getAllApprovedCaipNetworkIds() {
      const t = [];
      return (
        Ae.chains.forEach((e) => {
          const n = this.getApprovedCaipNetworkIds(e.namespace);
          t.push(...n);
        }),
        t
      );
    },
    getActiveCaipNetwork() {
      return Ae.activeCaipNetwork;
    },
    getActiveCaipAddress() {
      return Ae.activeCaipAddress;
    },
    getApprovedCaipNetworkIds(t) {
      var r;
      const e = Ae.chains.get(t);
      return (
        ((r = e == null ? void 0 : e.networkState) == null
          ? void 0
          : r.approvedCaipNetworkIds) || []
      );
    },
    async setApprovedCaipNetworksData(t) {
      const e = this.getNetworkControllerClient(),
        n = await (e == null ? void 0 : e.getApprovedCaipNetworksData());
      this.setAdapterNetworkState(t, {
        approvedCaipNetworkIds: n == null ? void 0 : n.approvedCaipNetworkIds,
        supportsAllNetworks: n == null ? void 0 : n.supportsAllNetworks,
      });
    },
    checkIfSupportedNetwork(t, e) {
      const n = e || Ae.activeCaipNetwork,
        r = this.getRequestedCaipNetworks(t);
      return r.length
        ? r == null
          ? void 0
          : r.some((i) => i.id === (n == null ? void 0 : n.id))
        : !0;
    },
    checkIfSupportedChainId(t) {
      if (!Ae.activeChain) return !0;
      const e = this.getRequestedCaipNetworks(Ae.activeChain);
      return e == null ? void 0 : e.some((n) => n.id === t);
    },
    setSmartAccountEnabledNetworks(t, e) {
      this.setAdapterNetworkState(e, { smartAccountEnabledNetworks: t });
    },
    checkIfSmartAccountEnabled() {
      var r;
      const t = jh.caipNetworkIdToNumber(
          (r = Ae.activeCaipNetwork) == null ? void 0 : r.caipNetworkId
        ),
        e = Ae.activeChain;
      if (!e || !t) return !1;
      const n = this.getNetworkProp("smartAccountEnabledNetworks", e);
      return !!(n != null && n.includes(Number(t)));
    },
    getActiveNetworkTokenAddress() {
      var r, i;
      const t =
          ((r = Ae.activeCaipNetwork) == null ? void 0 : r.chainNamespace) ||
          "eip155",
        e = ((i = Ae.activeCaipNetwork) == null ? void 0 : i.id) || 1,
        n = er.NATIVE_TOKEN_ADDRESS[t];
      return `${t}:${e}:${n}`;
    },
    showUnsupportedChainUI() {
      jn.open({ view: "UnsupportedChain" });
    },
    checkIfNamesSupported() {
      const t = Ae.activeCaipNetwork;
      return !!(
        t != null &&
        t.chainNamespace &&
        er.NAMES_SUPPORTED_CHAIN_NAMESPACES.includes(t.chainNamespace)
      );
    },
    resetNetwork(t) {
      this.setAdapterNetworkState(t, {
        approvedCaipNetworkIds: void 0,
        supportsAllNetworks: !0,
        smartAccountEnabledNetworks: [],
      });
    },
    resetAccount(t) {
      const e = t;
      if (!e) throw new Error("Chain is required to set account prop");
      (Ae.activeCaipAddress = void 0),
        this.setChainAccountData(e, {
          smartAccountDeployed: !1,
          currentTab: 0,
          caipAddress: void 0,
          address: void 0,
          balance: void 0,
          balanceSymbol: void 0,
          profileName: void 0,
          profileImage: void 0,
          addressExplorerUrl: void 0,
          tokenBalance: [],
          connectedWalletInfo: void 0,
          preferredAccountTypes: void 0,
          socialProvider: void 0,
          socialWindow: void 0,
          farcasterUrl: void 0,
          allAccounts: [],
          user: void 0,
          status: "disconnected",
        }),
        nt.removeConnectorId(e);
    },
    async disconnect(t) {
      const e = _V(t);
      try {
        rk.resetSend();
        const n = await Promise.allSettled(
          e.map(async ([i, s]) => {
            var o;
            try {
              const { caipAddress: a } = this.getAccountData(i) || {};
              a &&
                (o = s.connectionControllerClient) != null &&
                o.disconnect &&
                (await s.connectionControllerClient.disconnect(i)),
                this.resetAccount(i),
                this.resetNetwork(i);
            } catch (a) {
              throw new Error(`Failed to disconnect chain ${i}: ${a.message}`);
            }
          })
        );
        an.resetWcConnection();
        const r = n.filter((i) => i.status === "rejected");
        if (r.length > 0)
          throw new Error(r.map((i) => i.reason.message).join(", "));
        Ie.deleteConnectedSocialProvider(),
          t ? nt.removeConnectorId(t) : nt.resetConnectorIds(),
          fn.sendEvent({
            type: "track",
            event: "DISCONNECT_SUCCESS",
            properties: { namespace: t || "all" },
          });
      } catch (n) {
        console.error(n.message || "Failed to disconnect chains"),
          fn.sendEvent({
            type: "track",
            event: "DISCONNECT_ERROR",
            properties: { message: n.message || "Failed to disconnect chains" },
          });
      }
    },
    setIsSwitchingNamespace(t) {
      Ae.isSwitchingNamespace = t;
    },
    getFirstCaipNetworkSupportsAuthConnector() {
      var n, r;
      const t = [];
      let e;
      if (
        (Ae.chains.forEach((i) => {
          ye.AUTH_CONNECTOR_SUPPORTED_CHAINS.find((s) => s === i.namespace) &&
            i.namespace &&
            t.push(i.namespace);
        }),
        t.length > 0)
      ) {
        const i = t[0];
        return (
          (e = i
            ? (r = (n = Ae.chains.get(i)) == null ? void 0 : n.caipNetworks) ==
              null
              ? void 0
              : r[0]
            : void 0),
          e
        );
      }
    },
    getAccountData(t) {
      var e;
      return t
        ? (e = Y.state.chains.get(t)) == null
          ? void 0
          : e.accountState
        : Be.state;
    },
    getNetworkData(t) {
      var n;
      const e = t || Ae.activeChain;
      if (e)
        return (n = Y.state.chains.get(e)) == null ? void 0 : n.networkState;
    },
    getCaipNetworkByNamespace(t, e) {
      var i, s, o;
      if (!t) return;
      const n = Y.state.chains.get(t),
        r =
          (i = n == null ? void 0 : n.caipNetworks) == null
            ? void 0
            : i.find((a) => a.id === e);
      return (
        r ||
        ((s = n == null ? void 0 : n.networkState) == null
          ? void 0
          : s.caipNetwork) ||
        ((o = n == null ? void 0 : n.caipNetworks) == null ? void 0 : o[0])
      );
    },
    getRequestedCaipNetworkIds() {
      const t = nt.state.filterByNamespace;
      return (t ? [Ae.chains.get(t)] : Array.from(Ae.chains.values()))
        .flatMap((n) => (n == null ? void 0 : n.caipNetworks) || [])
        .map((n) => n.caipNetworkId);
    },
    getCaipNetworks(t) {
      return t
        ? Y.getRequestedCaipNetworks(t)
        : Y.getAllRequestedCaipNetworks();
    },
  },
  Afe = {
    purchaseCurrencies: [
      {
        id: "2b92315d-eab7-5bef-84fa-089a131333f5",
        name: "USD Coin",
        symbol: "USDC",
        networks: [
          {
            name: "ethereum-mainnet",
            display_name: "Ethereum",
            chain_id: "1",
            contract_address: "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48",
          },
          {
            name: "polygon-mainnet",
            display_name: "Polygon",
            chain_id: "137",
            contract_address: "0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174",
          },
        ],
      },
      {
        id: "2b92315d-eab7-5bef-84fa-089a131333f5",
        name: "Ether",
        symbol: "ETH",
        networks: [
          {
            name: "ethereum-mainnet",
            display_name: "Ethereum",
            chain_id: "1",
            contract_address: "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48",
          },
          {
            name: "polygon-mainnet",
            display_name: "Polygon",
            chain_id: "137",
            contract_address: "0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174",
          },
        ],
      },
    ],
    paymentCurrencies: [
      {
        id: "USD",
        payment_method_limits: [
          { id: "card", min: "10.00", max: "7500.00" },
          { id: "ach_bank_account", min: "10.00", max: "25000.00" },
        ],
      },
      {
        id: "EUR",
        payment_method_limits: [
          { id: "card", min: "10.00", max: "7500.00" },
          { id: "ach_bank_account", min: "10.00", max: "25000.00" },
        ],
      },
    ],
  },
  L6 = Je.getBlockchainApiUrl(),
  Li = wn({
    clientId: null,
    api: new gv({ baseUrl: L6, clientId: null }),
    supportedChains: { http: [], ws: [] },
  }),
  Xe = {
    state: Li,
    async get(t) {
      const { st: e, sv: n } = Xe.getSdkProperties(),
        r = me.state.projectId,
        i = { ...(t.params || {}), st: e, sv: n, projectId: r };
      return Li.api.get({ ...t, params: i });
    },
    getSdkProperties() {
      const { sdkType: t, sdkVersion: e } = me.state;
      return { st: t || "unknown", sv: e || "unknown" };
    },
    async isNetworkSupported(t) {
      if (!t) return !1;
      try {
        Li.supportedChains.http.length || (await Xe.getSupportedNetworks());
      } catch {
        return !1;
      }
      return Li.supportedChains.http.includes(t);
    },
    async getSupportedNetworks() {
      const t = await Xe.get({ path: "v1/supported-chains" });
      return (Li.supportedChains = t), t;
    },
    async fetchIdentity({ address: t, caipNetworkId: e }) {
      if (!(await Xe.isNetworkSupported(e))) return { avatar: "", name: "" };
      const r = Ie.getIdentityFromCacheForAddress(t);
      if (r) return r;
      const i = await Xe.get({
        path: `/v1/identity/${t}`,
        params: {
          sender: Y.state.activeCaipAddress
            ? Je.getPlainAddress(Y.state.activeCaipAddress)
            : void 0,
        },
      });
      return (
        Ie.updateIdentityCache({
          address: t,
          identity: i,
          timestamp: Date.now(),
        }),
        i
      );
    },
    async fetchTransactions({
      account: t,
      cursor: e,
      onramp: n,
      signal: r,
      cache: i,
      chainId: s,
    }) {
      var a;
      return (await Xe.isNetworkSupported(
        (a = Y.state.activeCaipNetwork) == null ? void 0 : a.caipNetworkId
      ))
        ? Xe.get({
            path: `/v1/account/${t}/history`,
            params: { cursor: e, onramp: n, chainId: s },
            signal: r,
            cache: i,
          })
        : { data: [], next: void 0 };
    },
    async fetchSwapQuote({
      amount: t,
      userAddress: e,
      from: n,
      to: r,
      gasPrice: i,
    }) {
      var o;
      return (await Xe.isNetworkSupported(
        (o = Y.state.activeCaipNetwork) == null ? void 0 : o.caipNetworkId
      ))
        ? Xe.get({
            path: "/v1/convert/quotes",
            headers: { "Content-Type": "application/json" },
            params: { amount: t, userAddress: e, from: n, to: r, gasPrice: i },
          })
        : { quotes: [] };
    },
    async fetchSwapTokens({ chainId: t }) {
      var n;
      return (await Xe.isNetworkSupported(
        (n = Y.state.activeCaipNetwork) == null ? void 0 : n.caipNetworkId
      ))
        ? Xe.get({ path: "/v1/convert/tokens", params: { chainId: t } })
        : { tokens: [] };
    },
    async fetchTokenPrice({ addresses: t }) {
      var n;
      return (await Xe.isNetworkSupported(
        (n = Y.state.activeCaipNetwork) == null ? void 0 : n.caipNetworkId
      ))
        ? Li.api.post({
            path: "/v1/fungible/price",
            body: {
              currency: "usd",
              addresses: t,
              projectId: me.state.projectId,
            },
            headers: { "Content-Type": "application/json" },
          })
        : { fungibles: [] };
    },
    async fetchSwapAllowance({ tokenAddress: t, userAddress: e }) {
      var r;
      return (await Xe.isNetworkSupported(
        (r = Y.state.activeCaipNetwork) == null ? void 0 : r.caipNetworkId
      ))
        ? Xe.get({
            path: "/v1/convert/allowance",
            params: { tokenAddress: t, userAddress: e },
            headers: { "Content-Type": "application/json" },
          })
        : { allowance: "0" };
    },
    async fetchGasPrice({ chainId: t }) {
      var i;
      const { st: e, sv: n } = Xe.getSdkProperties();
      if (
        !(await Xe.isNetworkSupported(
          (i = Y.state.activeCaipNetwork) == null ? void 0 : i.caipNetworkId
        ))
      )
        throw new Error("Network not supported for Gas Price");
      return Xe.get({
        path: "/v1/convert/gas-price",
        headers: { "Content-Type": "application/json" },
        params: { chainId: t, st: e, sv: n },
      });
    },
    async generateSwapCalldata({
      amount: t,
      from: e,
      to: n,
      userAddress: r,
      disableEstimate: i,
    }) {
      var o;
      if (
        !(await Xe.isNetworkSupported(
          (o = Y.state.activeCaipNetwork) == null ? void 0 : o.caipNetworkId
        ))
      )
        throw new Error("Network not supported for Swaps");
      return Li.api.post({
        path: "/v1/convert/build-transaction",
        headers: { "Content-Type": "application/json" },
        body: {
          amount: t,
          eip155: { slippage: er.CONVERT_SLIPPAGE_TOLERANCE },
          projectId: me.state.projectId,
          from: e,
          to: n,
          userAddress: r,
          disableEstimate: i,
        },
      });
    },
    async generateApproveCalldata({ from: t, to: e, userAddress: n }) {
      var o;
      const { st: r, sv: i } = Xe.getSdkProperties();
      if (
        !(await Xe.isNetworkSupported(
          (o = Y.state.activeCaipNetwork) == null ? void 0 : o.caipNetworkId
        ))
      )
        throw new Error("Network not supported for Swaps");
      return Xe.get({
        path: "/v1/convert/build-approve",
        headers: { "Content-Type": "application/json" },
        params: { userAddress: n, from: t, to: e, st: r, sv: i },
      });
    },
    async getBalance(t, e, n) {
      var d;
      const { st: r, sv: i } = Xe.getSdkProperties();
      if (
        !(await Xe.isNetworkSupported(
          (d = Y.state.activeCaipNetwork) == null ? void 0 : d.caipNetworkId
        ))
      )
        return qs.showError("Token Balance Unavailable"), { balances: [] };
      const o = `${e}:${t}`,
        a = Ie.getBalanceCacheForCaipAddress(o);
      if (a) return a;
      const l = await Xe.get({
        path: `/v1/account/${t}/balance`,
        params: { currency: "usd", chainId: e, forceUpdate: n, st: r, sv: i },
      });
      return (
        Ie.updateBalanceCache({
          caipAddress: o,
          balance: l,
          timestamp: Date.now(),
        }),
        l
      );
    },
    async lookupEnsName(t) {
      var n;
      return (await Xe.isNetworkSupported(
        (n = Y.state.activeCaipNetwork) == null ? void 0 : n.caipNetworkId
      ))
        ? Xe.get({
            path: `/v1/profile/account/${t}`,
            params: { apiVersion: "2" },
          })
        : { addresses: {}, attributes: [] };
    },
    async reverseLookupEnsName({ address: t }) {
      var n;
      return (await Xe.isNetworkSupported(
        (n = Y.state.activeCaipNetwork) == null ? void 0 : n.caipNetworkId
      ))
        ? Xe.get({
            path: `/v1/profile/reverse/${t}`,
            params: { sender: Be.state.address, apiVersion: "2" },
          })
        : [];
    },
    async getEnsNameSuggestions(t) {
      var n;
      return (await Xe.isNetworkSupported(
        (n = Y.state.activeCaipNetwork) == null ? void 0 : n.caipNetworkId
      ))
        ? Xe.get({
            path: `/v1/profile/suggestions/${t}`,
            params: { zone: "reown.id" },
          })
        : { suggestions: [] };
    },
    async registerEnsName({
      coinType: t,
      address: e,
      message: n,
      signature: r,
    }) {
      var s;
      return (await Xe.isNetworkSupported(
        (s = Y.state.activeCaipNetwork) == null ? void 0 : s.caipNetworkId
      ))
        ? Li.api.post({
            path: "/v1/profile/account",
            body: { coin_type: t, address: e, message: n, signature: r },
            headers: { "Content-Type": "application/json" },
          })
        : { success: !1 };
    },
    async generateOnRampURL({
      destinationWallets: t,
      partnerUserId: e,
      defaultNetwork: n,
      purchaseAmount: r,
      paymentAmount: i,
    }) {
      var a;
      return (await Xe.isNetworkSupported(
        (a = Y.state.activeCaipNetwork) == null ? void 0 : a.caipNetworkId
      ))
        ? (
            await Li.api.post({
              path: "/v1/generators/onrampurl",
              params: { projectId: me.state.projectId },
              body: {
                destinationWallets: t,
                defaultNetwork: n,
                partnerUserId: e,
                defaultExperience: "buy",
                presetCryptoAmount: r,
                presetFiatAmount: i,
              },
            })
          ).url
        : "";
    },
    async getOnrampOptions() {
      var e;
      if (
        !(await Xe.isNetworkSupported(
          (e = Y.state.activeCaipNetwork) == null ? void 0 : e.caipNetworkId
        ))
      )
        return { paymentCurrencies: [], purchaseCurrencies: [] };
      try {
        return await Xe.get({ path: "/v1/onramp/options" });
      } catch {
        return Afe;
      }
    },
    async getOnrampQuote({
      purchaseCurrency: t,
      paymentCurrency: e,
      amount: n,
      network: r,
    }) {
      var i;
      try {
        return (await Xe.isNetworkSupported(
          (i = Y.state.activeCaipNetwork) == null ? void 0 : i.caipNetworkId
        ))
          ? await Li.api.post({
              path: "/v1/onramp/quote",
              params: { projectId: me.state.projectId },
              body: {
                purchaseCurrency: t,
                paymentCurrency: e,
                amount: n,
                network: r,
              },
            })
          : null;
      } catch {
        return {
          coinbaseFee: { amount: n, currency: e.id },
          networkFee: { amount: n, currency: e.id },
          paymentSubtotal: { amount: n, currency: e.id },
          paymentTotal: { amount: n, currency: e.id },
          purchaseAmount: { amount: n, currency: e.id },
          quoteId: "mocked-quote-id",
        };
      }
    },
    async getSmartSessions(t) {
      var n;
      return (await Xe.isNetworkSupported(
        (n = Y.state.activeCaipNetwork) == null ? void 0 : n.caipNetworkId
      ))
        ? Xe.get({ path: `/v1/sessions/${t}` })
        : [];
    },
    async revokeSmartSession(t, e, n) {
      var i;
      return (await Xe.isNetworkSupported(
        (i = Y.state.activeCaipNetwork) == null ? void 0 : i.caipNetworkId
      ))
        ? Li.api.post({
            path: `/v1/sessions/${t}/revoke`,
            params: { projectId: me.state.projectId },
            body: { pci: e, signature: n },
          })
        : { success: !1 };
    },
    setClientId(t) {
      (Li.clientId = t), (Li.api = new gv({ baseUrl: L6, clientId: t }));
    },
  },
  is = wn({
    currentTab: 0,
    tokenBalance: [],
    smartAccountDeployed: !1,
    addressLabels: new Map(),
    allAccounts: [],
  }),
  Be = {
    state: is,
    replaceState(t) {
      t && Object.assign(is, Kl(t));
    },
    subscribe(t) {
      return Y.subscribeChainProp("accountState", (e) => {
        if (e) return t(e);
      });
    },
    subscribeKey(t, e, n) {
      let r;
      return Y.subscribeChainProp(
        "accountState",
        (i) => {
          if (i) {
            const s = i[t];
            r !== s && ((r = s), e(s));
          }
        },
        n
      );
    },
    setStatus(t, e) {
      Y.setAccountProp("status", t, e);
    },
    getCaipAddress(t) {
      return Y.getAccountProp("caipAddress", t);
    },
    setCaipAddress(t, e) {
      const n = t ? Je.getPlainAddress(t) : void 0;
      e === Y.state.activeChain && (Y.state.activeCaipAddress = t),
        Y.setAccountProp("caipAddress", t, e),
        Y.setAccountProp("address", n, e);
    },
    setBalance(t, e, n) {
      Y.setAccountProp("balance", t, n),
        Y.setAccountProp("balanceSymbol", e, n);
    },
    setProfileName(t, e) {
      Y.setAccountProp("profileName", t, e);
    },
    setProfileImage(t, e) {
      Y.setAccountProp("profileImage", t, e);
    },
    setUser(t, e) {
      Y.setAccountProp("user", t, e);
    },
    setAddressExplorerUrl(t, e) {
      Y.setAccountProp("addressExplorerUrl", t, e);
    },
    setSmartAccountDeployed(t, e) {
      Y.setAccountProp("smartAccountDeployed", t, e);
    },
    setCurrentTab(t) {
      Y.setAccountProp("currentTab", t, Y.state.activeChain);
    },
    setTokenBalance(t, e) {
      t && Y.setAccountProp("tokenBalance", t, e);
    },
    setShouldUpdateToAddress(t, e) {
      Y.setAccountProp("shouldUpdateToAddress", t, e);
    },
    setAllAccounts(t, e) {
      Y.setAccountProp("allAccounts", t, e);
    },
    addAddressLabel(t, e, n) {
      const r = Y.getAccountProp("addressLabels", n) || new Map();
      r.set(t, e), Y.setAccountProp("addressLabels", r, n);
    },
    removeAddressLabel(t, e) {
      const n = Y.getAccountProp("addressLabels", e) || new Map();
      n.delete(t), Y.setAccountProp("addressLabels", n, e);
    },
    setConnectedWalletInfo(t, e) {
      Y.setAccountProp("connectedWalletInfo", t, e, !1);
    },
    setPreferredAccountType(t, e) {
      Y.setAccountProp(
        "preferredAccountTypes",
        { ...is.preferredAccountTypes, [e]: t },
        e
      );
    },
    setPreferredAccountTypes(t) {
      is.preferredAccountTypes = t;
    },
    setSocialProvider(t, e) {
      t && Y.setAccountProp("socialProvider", t, e);
    },
    setSocialWindow(t, e) {
      Y.setAccountProp("socialWindow", t ? Kl(t) : void 0, e);
    },
    setFarcasterUrl(t, e) {
      Y.setAccountProp("farcasterUrl", t, e);
    },
    async fetchTokenBalance(t) {
      var s, o;
      is.balanceLoading = !0;
      const e =
          (s = Y.state.activeCaipNetwork) == null ? void 0 : s.caipNetworkId,
        n = (o = Y.state.activeCaipNetwork) == null ? void 0 : o.chainNamespace,
        r = Y.state.activeCaipAddress,
        i = r ? Je.getPlainAddress(r) : void 0;
      if (is.lastRetry && !Je.isAllowedRetry(is.lastRetry, 30 * er.ONE_SEC_MS))
        return (is.balanceLoading = !1), [];
      try {
        if (i && e && n) {
          const l = (await Xe.getBalance(i, e)).balances.filter(
            (d) => d.quantity.decimals !== "0"
          );
          return (
            this.setTokenBalance(l, n),
            (is.lastRetry = void 0),
            (is.balanceLoading = !1),
            l
          );
        }
      } catch (a) {
        (is.lastRetry = Date.now()),
          t == null || t(a),
          qs.showError("Token Balance Unavailable");
      } finally {
        is.balanceLoading = !1;
      }
      return [];
    },
    resetAccount(t) {
      Y.resetAccount(t);
    },
  },
  mi = wn({
    loading: !1,
    loadingNamespaceMap: new Map(),
    open: !1,
    shake: !1,
    namespace: void 0,
  }),
  jn = {
    state: mi,
    subscribe(t) {
      return ri(mi, () => t(mi));
    },
    subscribeKey(t, e) {
      return si(mi, t, e);
    },
    async open(t) {
      var i;
      const e = Be.state.status === "connected";
      an.state.wcBasic
        ? Ze.prefetch({ fetchNetworkImages: !1, fetchConnectorImages: !1 })
        : await Ze.prefetch({
            fetchConnectorImages: !e,
            fetchFeaturedWallets: !e,
            fetchRecommendedWallets: !e,
          }),
        t != null && t.namespace
          ? (await Y.switchActiveNamespace(t.namespace),
            jn.setLoading(!0, t.namespace))
          : jn.setLoading(!0),
        nt.setFilterByNamespace(t == null ? void 0 : t.namespace);
      const n =
          (i = Y.getAccountData(t == null ? void 0 : t.namespace)) == null
            ? void 0
            : i.caipAddress,
        r = Y.state.noAdapters;
      me.state.manualWCControl || (r && !n)
        ? Je.isMobile()
          ? zt.reset("AllWallets")
          : zt.reset("ConnectingWalletConnectBasic")
        : t != null && t.view
        ? zt.reset(t.view, t.data)
        : n
        ? zt.reset("Account")
        : zt.reset("Connect"),
        (mi.open = !0),
        Ro.set({ open: !0 }),
        fn.sendEvent({
          type: "track",
          event: "MODAL_OPEN",
          properties: { connected: !!n },
        });
    },
    close(t = !1) {
      if (t || zt.state.view !== "ApproveTransaction") {
        const e = me.state.enableEmbedded,
          n = !!Y.state.activeCaipAddress;
        mi.open &&
          fn.sendEvent({
            type: "track",
            event: "MODAL_CLOSE",
            properties: { connected: n },
          }),
          (mi.open = !1),
          jn.clearLoading(),
          e
            ? n
              ? zt.replace("Account")
              : zt.push("Connect")
            : Ro.set({ open: !1 });
      }
      an.resetUri();
    },
    setLoading(t, e) {
      e && mi.loadingNamespaceMap.set(e, t),
        (mi.loading = t),
        Ro.set({ loading: t });
    },
    clearLoading() {
      mi.loadingNamespaceMap.clear(), (mi.loading = !1);
    },
    shake() {
      mi.shake ||
        ((mi.shake = !0),
        setTimeout(() => {
          mi.shake = !1;
        }, 500));
    },
  },
  ik = 2147483648,
  _fe = {
    convertEVMChainIdToCoinType(t) {
      if (t >= ik) throw new Error("Invalid chainId");
      return (ik | t) >>> 0;
    },
  },
  ss = wn({ suggestions: [], loading: !1 }),
  U6 = {
    state: ss,
    subscribe(t) {
      return ri(ss, () => t(ss));
    },
    subscribeKey(t, e) {
      return si(ss, t, e);
    },
    async resolveName(t) {
      var e, n;
      try {
        return await Xe.lookupEnsName(t);
      } catch (r) {
        const i = r;
        throw new Error(
          ((n = (e = i == null ? void 0 : i.reasons) == null ? void 0 : e[0]) ==
          null
            ? void 0
            : n.description) || "Error resolving name"
        );
      }
    },
    async isNameRegistered(t) {
      try {
        return await Xe.lookupEnsName(t), !0;
      } catch {
        return !1;
      }
    },
    async getSuggestions(t) {
      try {
        (ss.loading = !0), (ss.suggestions = []);
        const e = await Xe.getEnsNameSuggestions(t);
        return (
          (ss.suggestions =
            e.suggestions.map((n) => ({ ...n, name: n.name })) || []),
          ss.suggestions
        );
      } catch (e) {
        const n = this.parseEnsApiError(e, "Error fetching name suggestions");
        throw new Error(n);
      } finally {
        ss.loading = !1;
      }
    },
    async getNamesForAddress(t) {
      try {
        if (!Y.state.activeCaipNetwork) return [];
        const n = Ie.getEnsFromCacheForAddress(t);
        if (n) return n;
        const r = await Xe.reverseLookupEnsName({ address: t });
        return (
          Ie.updateEnsCache({ address: t, ens: r, timestamp: Date.now() }), r
        );
      } catch (e) {
        const n = this.parseEnsApiError(e, "Error fetching names for address");
        throw new Error(n);
      }
    },
    async registerName(t) {
      const e = Y.state.activeCaipNetwork;
      if (!e) throw new Error("Network not found");
      const n = Be.state.address,
        r = nt.getAuthConnector();
      if (!n || !r) throw new Error("Address or auth connector not found");
      ss.loading = !0;
      try {
        const i = JSON.stringify({
          name: t,
          attributes: {},
          timestamp: Math.floor(Date.now() / 1e3),
        });
        zt.pushTransactionStack({
          view: "RegisterAccountNameSuccess",
          goBack: !1,
          replace: !0,
          onCancel() {
            ss.loading = !1;
          },
        });
        const s = await an.signMessage(i),
          o = e.id;
        if (!o) throw new Error("Network not found");
        const a = _fe.convertEVMChainIdToCoinType(Number(o));
        await Xe.registerEnsName({
          coinType: a,
          address: n,
          signature: s,
          message: i,
        }),
          Be.setProfileName(t, e.chainNamespace),
          zt.replace("RegisterAccountNameSuccess");
      } catch (i) {
        const s = this.parseEnsApiError(i, `Error registering name ${t}`);
        throw (zt.replace("RegisterAccountName"), new Error(s));
      } finally {
        ss.loading = !1;
      }
    },
    validateName(t) {
      return /^[a-zA-Z0-9-]{4,}$/u.test(t);
    },
    parseEnsApiError(t, e) {
      var r, i;
      const n = t;
      return (
        ((i = (r = n == null ? void 0 : n.reasons) == null ? void 0 : r[0]) ==
        null
          ? void 0
          : i.description) || e
      );
    },
  },
  pn = {
    METMASK_CONNECTOR_NAME: "MetaMask",
    TRUST_CONNECTOR_NAME: "Trust Wallet",
    SOLFLARE_CONNECTOR_NAME: "Solflare",
    PHANTOM_CONNECTOR_NAME: "Phantom",
    COIN98_CONNECTOR_NAME: "Coin98",
    MAGIC_EDEN_CONNECTOR_NAME: "Magic Eden",
    BACKPACK_CONNECTOR_NAME: "Backpack",
    BITGET_CONNECTOR_NAME: "Bitget Wallet",
    FRONTIER_CONNECTOR_NAME: "Frontier",
    XVERSE_CONNECTOR_NAME: "Xverse Wallet",
    LEATHER_CONNECTOR_NAME: "Leather",
    EIP155: "eip155",
    ADD_CHAIN_METHOD: "wallet_addEthereumChain",
    EIP6963_ANNOUNCE_EVENT: "eip6963:announceProvider",
    EIP6963_REQUEST_EVENT: "eip6963:requestProvider",
    CONNECTOR_RDNS_MAP: {
      coinbaseWallet: "com.coinbase.wallet",
      coinbaseWalletSDK: "com.coinbase.wallet",
    },
    CONNECTOR_TYPE_EXTERNAL: "EXTERNAL",
    CONNECTOR_TYPE_WALLET_CONNECT: "WALLET_CONNECT",
    CONNECTOR_TYPE_INJECTED: "INJECTED",
    CONNECTOR_TYPE_ANNOUNCED: "ANNOUNCED",
    CONNECTOR_TYPE_AUTH: "AUTH",
    CONNECTOR_TYPE_MULTI_CHAIN: "MULTI_CHAIN",
    CONNECTOR_TYPE_W3M_AUTH: "ID_AUTH",
  },
  Pc = {
    ConnectorExplorerIds: {
      [ye.CONNECTOR_ID.COINBASE]:
        "fd20dc426fb37566d803205b19bbc1d4096b248ac04548e3cfb6b3a38bd033aa",
      [ye.CONNECTOR_ID.COINBASE_SDK]:
        "fd20dc426fb37566d803205b19bbc1d4096b248ac04548e3cfb6b3a38bd033aa",
      [ye.CONNECTOR_ID.SAFE]:
        "225affb176778569276e484e1b92637ad061b01e13a048b35a9d280c3b58970f",
      [ye.CONNECTOR_ID.LEDGER]:
        "19177a98252e07ddfc9af2083ba8e07ef627cb6103467ffebb3f8f4205fd7927",
      [ye.CONNECTOR_ID.OKX]:
        "971e689d0a5be527bac79629b4ee9b925e82208e5168b733496a09c0faed0709",
      [pn.METMASK_CONNECTOR_NAME]:
        "c57ca95b47569778a828d19178114f4db188b89b763c899ba0be274e97267d96",
      [pn.TRUST_CONNECTOR_NAME]:
        "4622a2b2d6af1c9844944291e5e7351a6aa24cd7b23099efac1b2fd875da31a0",
      [pn.SOLFLARE_CONNECTOR_NAME]:
        "1ca0bdd4747578705b1939af023d120677c64fe6ca76add81fda36e350605e79",
      [pn.PHANTOM_CONNECTOR_NAME]:
        "a797aa35c0fadbfc1a53e7f675162ed5226968b44a19ee3d24385c64d1d3c393",
      [pn.COIN98_CONNECTOR_NAME]:
        "2a3c89040ac3b723a1972a33a125b1db11e258a6975d3a61252cd64e6ea5ea01",
      [pn.MAGIC_EDEN_CONNECTOR_NAME]:
        "8b830a2b724a9c3fbab63af6f55ed29c9dfa8a55e732dc88c80a196a2ba136c6",
      [pn.BACKPACK_CONNECTOR_NAME]:
        "2bd8c14e035c2d48f184aaa168559e86b0e3433228d3c4075900a221785019b0",
      [pn.BITGET_CONNECTOR_NAME]:
        "38f5d18bd8522c244bdd70cb4a68e0e718865155811c043f052fb9f1c51de662",
      [pn.FRONTIER_CONNECTOR_NAME]:
        "85db431492aa2e8672e93f4ea7acf10c88b97b867b0d373107af63dc4880f041",
      [pn.XVERSE_CONNECTOR_NAME]:
        "2a87d74ae02e10bdd1f51f7ce6c4e1cc53cd5f2c0b6b5ad0d7b3007d2b13de7b",
      [pn.LEATHER_CONNECTOR_NAME]:
        "483afe1df1df63daf313109971ff3ef8356ddf1cc4e45877d205eee0b7893a13",
    },
    NetworkImageIds: {
      1: "ba0ba0cd-17c6-4806-ad93-f9d174f17900",
      42161: "3bff954d-5cb0-47a0-9a23-d20192e74600",
      43114: "30c46e53-e989-45fb-4549-be3bd4eb3b00",
      56: "93564157-2e8e-4ce7-81df-b264dbee9b00",
      250: "06b26297-fe0c-4733-5d6b-ffa5498aac00",
      10: "ab9c186a-c52f-464b-2906-ca59d760a400",
      137: "41d04d42-da3b-4453-8506-668cc0727900",
      5e3: "e86fae9b-b770-4eea-e520-150e12c81100",
      295: "6a97d510-cac8-4e58-c7ce-e8681b044c00",
      11155111: "e909ea0a-f92a-4512-c8fc-748044ea6800",
      84532: "a18a7ecd-e307-4360-4746-283182228e00",
      1301: "4eeea7ef-0014-4649-5d1d-07271a80f600",
      130: "2257980a-3463-48c6-cbac-a42d2a956e00",
      10143: "0a728e83-bacb-46db-7844-948f05434900",
      100: "02b53f6a-e3d4-479e-1cb4-21178987d100",
      9001: "f926ff41-260d-4028-635e-91913fc28e00",
      324: "b310f07f-4ef7-49f3-7073-2a0a39685800",
      314: "5a73b3dd-af74-424e-cae0-0de859ee9400",
      4689: "34e68754-e536-40da-c153-6ef2e7188a00",
      1088: "3897a66d-40b9-4833-162f-a2c90531c900",
      1284: "161038da-44ae-4ec7-1208-0ea569454b00",
      1285: "f1d73bb6-5450-4e18-38f7-fb6484264a00",
      7777777: "845c60df-d429-4991-e687-91ae45791600",
      42220: "ab781bbc-ccc6-418d-d32d-789b15da1f00",
      8453: "7289c336-3981-4081-c5f4-efc26ac64a00",
      1313161554: "3ff73439-a619-4894-9262-4470c773a100",
      2020: "b8101fc0-9c19-4b6f-ec65-f6dfff106e00",
      2021: "b8101fc0-9c19-4b6f-ec65-f6dfff106e00",
      80094: "e329c2c9-59b0-4a02-83e4-212ff3779900",
      2741: "fc2427d1-5af9-4a9c-8da5-6f94627cd900",
      "5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp":
        "a1b58899-f671-4276-6a5e-56ca5bd59700",
      "4uhcVJyU9pJkvQyS88uRDiswHXSCkY3z":
        "a1b58899-f671-4276-6a5e-56ca5bd59700",
      EtWTRABZaYq6iMfeYKouRu166VU2xqa1: "a1b58899-f671-4276-6a5e-56ca5bd59700",
      "000000000019d6689c085ae165831e93":
        "0b4838db-0161-4ffe-022d-532bf03dba00",
      "000000000933ea01ad0ee984209779ba":
        "39354064-d79b-420b-065d-f980c4b78200",
    },
    ConnectorImageIds: {
      [ye.CONNECTOR_ID.COINBASE]: "0c2840c3-5b04-4c44-9661-fbd4b49e1800",
      [ye.CONNECTOR_ID.COINBASE_SDK]: "0c2840c3-5b04-4c44-9661-fbd4b49e1800",
      [ye.CONNECTOR_ID.SAFE]: "461db637-8616-43ce-035a-d89b8a1d5800",
      [ye.CONNECTOR_ID.LEDGER]: "54a1aa77-d202-4f8d-0fb2-5d2bb6db0300",
      [ye.CONNECTOR_ID.WALLET_CONNECT]: "ef1a1fcf-7fe8-4d69-bd6d-fda1345b4400",
      [ye.CONNECTOR_ID.INJECTED]: "07ba87ed-43aa-4adf-4540-9e6a2b9cae00",
    },
    ConnectorNamesMap: {
      [ye.CONNECTOR_ID.INJECTED]: "Browser Wallet",
      [ye.CONNECTOR_ID.WALLET_CONNECT]: "WalletConnect",
      [ye.CONNECTOR_ID.COINBASE]: "Coinbase",
      [ye.CONNECTOR_ID.COINBASE_SDK]: "Coinbase",
      [ye.CONNECTOR_ID.LEDGER]: "Ledger",
      [ye.CONNECTOR_ID.SAFE]: "Safe",
    },
    ConnectorTypesMap: {
      [ye.CONNECTOR_ID.INJECTED]: "INJECTED",
      [ye.CONNECTOR_ID.WALLET_CONNECT]: "WALLET_CONNECT",
      [ye.CONNECTOR_ID.EIP6963]: "ANNOUNCED",
      [ye.CONNECTOR_ID.AUTH]: "AUTH",
    },
    WalletConnectRpcChainIds: [
      1, 5, 11155111, 10, 420, 42161, 421613, 137, 80001, 42220, 1313161554,
      1313161555, 56, 97, 43114, 43113, 100, 8453, 84531, 7777777, 999, 324,
      280,
    ],
  },
  qv = {
    getCaipTokens(t) {
      if (!t) return;
      const e = {};
      return (
        Object.entries(t).forEach(([n, r]) => {
          e[`${pn.EIP155}:${n}`] = r;
        }),
        e
      );
    },
    isLowerCaseMatch(t, e) {
      return (
        (t == null ? void 0 : t.toLowerCase()) ===
        (e == null ? void 0 : e.toLowerCase())
      );
    },
  },
  Ife = new AbortController(),
  pr = {
    EmbeddedWalletAbortController: Ife,
    UniversalProviderErrors: {
      UNAUTHORIZED_DOMAIN_NOT_ALLOWED: {
        message: "Unauthorized: origin not allowed",
        alertErrorKey: "INVALID_APP_CONFIGURATION",
      },
      JWT_VALIDATION_ERROR: {
        message: "JWT validation error: JWT Token is not yet valid",
        alertErrorKey: "JWT_TOKEN_NOT_VALID",
      },
      INVALID_KEY: {
        message: "Unauthorized: invalid key",
        alertErrorKey: "INVALID_PROJECT_ID",
      },
    },
    ALERT_ERRORS: {
      SWITCH_NETWORK_NOT_FOUND: {
        shortMessage: "Network Not Found",
        longMessage:
          "Network not found - please make sure it is included in 'networks' array in createAppKit function",
      },
      INVALID_APP_CONFIGURATION: {
        shortMessage: "Invalid App Configuration",
        longMessage: () =>
          `Origin ${
            Tfe() ? window.origin : "unknown"
          } not found on Allowlist - update configuration on cloud.reown.com`,
      },
      IFRAME_LOAD_FAILED: {
        shortMessage: "Network Error - Could not load embedded wallet",
        longMessage: () =>
          "There was an issue loading the embedded wallet. Please try again later.",
      },
      IFRAME_REQUEST_TIMEOUT: {
        shortMessage: "Embedded Wallet Request Timed Out",
        longMessage: () =>
          "There was an issue doing the request to the embedded wallet. Please try again later.",
      },
      UNVERIFIED_DOMAIN: {
        shortMessage: "Invalid App Configuration",
        longMessage: () =>
          "There was an issue loading the embedded wallet. Please verify that your domain is allowed at cloud.reown.com",
      },
      JWT_TOKEN_NOT_VALID: {
        shortMessage: "Session Expired",
        longMessage:
          "Invalid session found on UniversalProvider - please check your time settings and connect again",
      },
      INVALID_PROJECT_ID: {
        shortMessage: "Invalid App Configuration",
        longMessage: "Invalid Project ID - update configuration",
      },
      PROJECT_ID_NOT_CONFIGURED: {
        shortMessage: "Project ID Not Configured",
        longMessage:
          "Project ID Not Configured - update configuration on cloud.reown.com",
      },
    },
  };
function Tfe() {
  return typeof window < "u";
}
const Pfe = {
    createLogger(t, e = "error") {
      const n = _p({ level: e }),
        { logger: r } = yA({ opts: n });
      return (
        (r.error = (...i) => {
          for (const s of i)
            if (s instanceof Error) {
              t(s, ...i);
              return;
            }
          t(void 0, ...i);
        }),
        r
      );
    },
  },
  Rfe = "rpc.walletconnect.org";
function sk(t, e) {
  const n = new URL("https://rpc.walletconnect.org/v1/");
  return (
    n.searchParams.set("chainId", t),
    n.searchParams.set("projectId", e),
    n.toString()
  );
}
const hC = [
    "near:mainnet",
    "solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp",
    "eip155:1101",
    "eip155:56",
    "eip155:42161",
    "eip155:7777777",
    "eip155:59144",
    "eip155:324",
    "solana:EtWTRABZaYq6iMfeYKouRu166VU2xqa1",
    "eip155:5000",
    "solana:4sgjmw1sunhzsxgspuhpqldx6wiyjntz",
    "eip155:80084",
    "eip155:5003",
    "eip155:100",
    "eip155:8453",
    "eip155:42220",
    "eip155:1313161555",
    "eip155:17000",
    "eip155:1",
    "eip155:300",
    "eip155:1313161554",
    "eip155:1329",
    "eip155:84532",
    "eip155:421614",
    "eip155:11155111",
    "eip155:8217",
    "eip155:43114",
    "solana:4uhcVJyU9pJkvQyS88uRDiswHXSCkY3z",
    "eip155:999999999",
    "eip155:11155420",
    "eip155:80002",
    "eip155:97",
    "eip155:43113",
    "eip155:137",
    "eip155:10",
    "eip155:1301",
    "bip122:000000000019d6689c085ae165831e93",
    "bip122:000000000933ea01ad0ee984209779ba",
  ],
  _o = {
    extendRpcUrlWithProjectId(t, e) {
      let n = !1;
      try {
        n = new URL(t).host === Rfe;
      } catch {
        n = !1;
      }
      if (n) {
        const r = new URL(t);
        return (
          r.searchParams.has("projectId") || r.searchParams.set("projectId", e),
          r.toString()
        );
      }
      return t;
    },
    isCaipNetwork(t) {
      return "chainNamespace" in t && "caipNetworkId" in t;
    },
    getChainNamespace(t) {
      return this.isCaipNetwork(t) ? t.chainNamespace : ye.CHAIN.EVM;
    },
    getCaipNetworkId(t) {
      return this.isCaipNetwork(t)
        ? t.caipNetworkId
        : `${ye.CHAIN.EVM}:${t.id}`;
    },
    getDefaultRpcUrl(t, e, n) {
      var i, s, o;
      const r =
        (o =
          (s = (i = t.rpcUrls) == null ? void 0 : i.default) == null
            ? void 0
            : s.http) == null
          ? void 0
          : o[0];
      return hC.includes(e) ? sk(e, n) : r || "";
    },
    extendCaipNetwork(
      t,
      { customNetworkImageUrls: e, projectId: n, customRpcUrls: r }
    ) {
      var m, y, g, v, b;
      const i = this.getChainNamespace(t),
        s = this.getCaipNetworkId(t),
        o = (m = t.rpcUrls.default.http) == null ? void 0 : m[0],
        a = this.getDefaultRpcUrl(t, s, n),
        l =
          ((v =
            (g =
              (y = t == null ? void 0 : t.rpcUrls) == null
                ? void 0
                : y.chainDefault) == null
              ? void 0
              : g.http) == null
            ? void 0
            : v[0]) || o,
        d =
          ((b = r == null ? void 0 : r[s]) == null
            ? void 0
            : b.map((E) => E.url)) || [],
        p = [...d, a],
        f = [...d];
      return (
        l && !f.includes(l) && f.push(l),
        {
          ...t,
          chainNamespace: i,
          caipNetworkId: s,
          assets: {
            imageId: Pc.NetworkImageIds[t.id],
            imageUrl: e == null ? void 0 : e[t.id],
          },
          rpcUrls: {
            ...t.rpcUrls,
            default: { http: p },
            chainDefault: { http: f },
          },
        }
      );
    },
    extendCaipNetworks(
      t,
      { customNetworkImageUrls: e, projectId: n, customRpcUrls: r }
    ) {
      return t.map((i) =>
        _o.extendCaipNetwork(i, {
          customNetworkImageUrls: e,
          customRpcUrls: r,
          projectId: n,
        })
      );
    },
    getViemTransport(t, e, n) {
      var i, s, o;
      const r = [];
      return (
        n == null ||
          n.forEach((a) => {
            r.push(u0(a.url, a.config));
          }),
        hC.includes(t.caipNetworkId) &&
          r.push(
            u0(sk(t.caipNetworkId, e), {
              fetchOptions: { headers: { "Content-Type": "text/plain" } },
            })
          ),
        (o =
          (s =
            (i = t == null ? void 0 : t.rpcUrls) == null
              ? void 0
              : i.default) == null
            ? void 0
            : s.http) == null ||
          o.forEach((a) => {
            r.push(u0(a));
          }),
        JO(r)
      );
    },
    extendWagmiTransports(t, e, n) {
      if (hC.includes(t.caipNetworkId)) {
        const r = this.getDefaultRpcUrl(t, t.caipNetworkId, e);
        return JO([n, u0(r)]);
      }
      return n;
    },
    getUnsupportedNetwork(t) {
      return {
        id: t.split(":")[1],
        caipNetworkId: t,
        name: ye.UNSUPPORTED_NETWORK_NAME,
        chainNamespace: t.split(":")[0],
        nativeCurrency: { name: "", decimals: 0, symbol: "" },
        rpcUrls: { default: { http: [] } },
      };
    },
    getCaipNetworkFromStorage(t) {
      var l;
      const e = Ie.getActiveCaipNetworkId(),
        n = Y.getAllRequestedCaipNetworks(),
        r = Array.from(
          ((l = Y.state.chains) == null ? void 0 : l.keys()) || []
        ),
        i = e == null ? void 0 : e.split(":")[0],
        s = i ? r.includes(i) : !1,
        o = n == null ? void 0 : n.find((d) => d.caipNetworkId === e);
      return s && !o && e
        ? this.getUnsupportedNetwork(e)
        : o || t || (n == null ? void 0 : n[0]);
    },
  },
  Pw = {
    eip155: void 0,
    solana: void 0,
    polkadot: void 0,
    bip122: void 0,
    cosmos: void 0,
  },
  gi = wn({ providers: { ...Pw }, providerIds: { ...Pw } }),
  Gt = {
    state: gi,
    subscribeKey(t, e) {
      return si(gi, t, e);
    },
    subscribe(t) {
      return ri(gi, () => {
        t(gi);
      });
    },
    subscribeProviders(t) {
      return ri(gi.providers, () => t(gi.providers));
    },
    setProvider(t, e) {
      e && (gi.providers[t] = Kl(e));
    },
    getProvider(t) {
      return gi.providers[t];
    },
    setProviderId(t, e) {
      e && (gi.providerIds[t] = e);
    },
    getProviderId(t) {
      if (t) return gi.providerIds[t];
    },
    reset() {
      (gi.providers = { ...Pw }), (gi.providerIds = { ...Pw });
    },
    resetChain(t) {
      (gi.providers[t] = void 0), (gi.providerIds[t] = void 0);
    },
  },
  ok = {
    address: /^0x(?:[A-Fa-f0-9]{40})$/u,
    transactionHash: /^0x(?:[A-Fa-f0-9]{64})$/u,
    signedMessage: /^0x(?:[a-fA-F0-9]{62,})$/u,
  },
  _r = {
    set(t, e) {
      Fi.isClient && localStorage.setItem(`${Me.STORAGE_KEY}${t}`, e);
    },
    get(t) {
      return Fi.isClient ? localStorage.getItem(`${Me.STORAGE_KEY}${t}`) : null;
    },
    delete(t, e) {
      Fi.isClient &&
        (e
          ? localStorage.removeItem(t)
          : localStorage.removeItem(`${Me.STORAGE_KEY}${t}`));
    },
  },
  p0 = 30 * 1e3,
  Fi = {
    checkIfAllowedToTriggerEmail() {
      const t = _r.get(Me.LAST_EMAIL_LOGIN_TIME);
      if (t) {
        const e = Date.now() - Number(t);
        if (e < p0) {
          const n = Math.ceil((p0 - e) / 1e3);
          throw new Error(`Please try again after ${n} seconds`);
        }
      }
    },
    getTimeToNextEmailLogin() {
      const t = _r.get(Me.LAST_EMAIL_LOGIN_TIME);
      if (t) {
        const e = Date.now() - Number(t);
        if (e < p0) return Math.ceil((p0 - e) / 1e3);
      }
      return 0;
    },
    checkIfRequestExists(t) {
      return (
        Rr.NOT_SAFE_RPC_METHODS.includes(t.method) ||
        Rr.SAFE_RPC_METHODS.includes(t.method)
      );
    },
    getResponseType(t) {
      return typeof t == "string" &&
        ((t == null ? void 0 : t.match(ok.transactionHash)) ||
          (t == null ? void 0 : t.match(ok.signedMessage)))
        ? Me.RPC_RESPONSE_TYPE_TX
        : Me.RPC_RESPONSE_TYPE_OBJECT;
    },
    checkIfRequestIsSafe(t) {
      return Rr.SAFE_RPC_METHODS.includes(t.method);
    },
    isClient: typeof window < "u",
  };
var kt;
(function (t) {
  t.assertEqual = (i) => i;
  function e(i) {}
  t.assertIs = e;
  function n(i) {
    throw new Error();
  }
  (t.assertNever = n),
    (t.arrayToEnum = (i) => {
      const s = {};
      for (const o of i) s[o] = o;
      return s;
    }),
    (t.getValidEnumValues = (i) => {
      const s = t.objectKeys(i).filter((a) => typeof i[i[a]] != "number"),
        o = {};
      for (const a of s) o[a] = i[a];
      return t.objectValues(o);
    }),
    (t.objectValues = (i) =>
      t.objectKeys(i).map(function (s) {
        return i[s];
      })),
    (t.objectKeys =
      typeof Object.keys == "function"
        ? (i) => Object.keys(i)
        : (i) => {
            const s = [];
            for (const o in i)
              Object.prototype.hasOwnProperty.call(i, o) && s.push(o);
            return s;
          }),
    (t.find = (i, s) => {
      for (const o of i) if (s(o)) return o;
    }),
    (t.isInteger =
      typeof Number.isInteger == "function"
        ? (i) => Number.isInteger(i)
        : (i) => typeof i == "number" && isFinite(i) && Math.floor(i) === i);
  function r(i, s = " | ") {
    return i.map((o) => (typeof o == "string" ? `'${o}'` : o)).join(s);
  }
  (t.joinValues = r),
    (t.jsonStringifyReplacer = (i, s) =>
      typeof s == "bigint" ? s.toString() : s);
})(kt || (kt = {}));
var hS;
(function (t) {
  t.mergeShapes = (e, n) => ({ ...e, ...n });
})(hS || (hS = {}));
const Te = kt.arrayToEnum([
    "string",
    "nan",
    "number",
    "integer",
    "float",
    "boolean",
    "date",
    "bigint",
    "symbol",
    "function",
    "undefined",
    "null",
    "array",
    "object",
    "unknown",
    "promise",
    "void",
    "never",
    "map",
    "set",
  ]),
  gc = (t) => {
    switch (typeof t) {
      case "undefined":
        return Te.undefined;
      case "string":
        return Te.string;
      case "number":
        return isNaN(t) ? Te.nan : Te.number;
      case "boolean":
        return Te.boolean;
      case "function":
        return Te.function;
      case "bigint":
        return Te.bigint;
      case "symbol":
        return Te.symbol;
      case "object":
        return Array.isArray(t)
          ? Te.array
          : t === null
          ? Te.null
          : t.then &&
            typeof t.then == "function" &&
            t.catch &&
            typeof t.catch == "function"
          ? Te.promise
          : typeof Map < "u" && t instanceof Map
          ? Te.map
          : typeof Set < "u" && t instanceof Set
          ? Te.set
          : typeof Date < "u" && t instanceof Date
          ? Te.date
          : Te.object;
      default:
        return Te.unknown;
    }
  },
  ve = kt.arrayToEnum([
    "invalid_type",
    "invalid_literal",
    "custom",
    "invalid_union",
    "invalid_union_discriminator",
    "invalid_enum_value",
    "unrecognized_keys",
    "invalid_arguments",
    "invalid_return_type",
    "invalid_date",
    "invalid_string",
    "too_small",
    "too_big",
    "invalid_intersection_types",
    "not_multiple_of",
    "not_finite",
  ]),
  Nfe = (t) => JSON.stringify(t, null, 2).replace(/"([^"]+)":/g, "$1:");
class Ys extends Error {
  constructor(e) {
    super(),
      (this.issues = []),
      (this.addIssue = (r) => {
        this.issues = [...this.issues, r];
      }),
      (this.addIssues = (r = []) => {
        this.issues = [...this.issues, ...r];
      });
    const n = new.target.prototype;
    Object.setPrototypeOf
      ? Object.setPrototypeOf(this, n)
      : (this.__proto__ = n),
      (this.name = "ZodError"),
      (this.issues = e);
  }
  get errors() {
    return this.issues;
  }
  format(e) {
    const n =
        e ||
        function (s) {
          return s.message;
        },
      r = { _errors: [] },
      i = (s) => {
        for (const o of s.issues)
          if (o.code === "invalid_union") o.unionErrors.map(i);
          else if (o.code === "invalid_return_type") i(o.returnTypeError);
          else if (o.code === "invalid_arguments") i(o.argumentsError);
          else if (o.path.length === 0) r._errors.push(n(o));
          else {
            let a = r,
              l = 0;
            for (; l < o.path.length; ) {
              const d = o.path[l];
              l === o.path.length - 1
                ? ((a[d] = a[d] || { _errors: [] }), a[d]._errors.push(n(o)))
                : (a[d] = a[d] || { _errors: [] }),
                (a = a[d]),
                l++;
            }
          }
      };
    return i(this), r;
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, kt.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(e = (n) => n.message) {
    const n = {},
      r = [];
    for (const i of this.issues)
      i.path.length > 0
        ? ((n[i.path[0]] = n[i.path[0]] || []), n[i.path[0]].push(e(i)))
        : r.push(e(i));
    return { formErrors: r, fieldErrors: n };
  }
  get formErrors() {
    return this.flatten();
  }
}
Ys.create = (t) => new Ys(t);
const mm = (t, e) => {
  let n;
  switch (t.code) {
    case ve.invalid_type:
      t.received === Te.undefined
        ? (n = "Required")
        : (n = `Expected ${t.expected}, received ${t.received}`);
      break;
    case ve.invalid_literal:
      n = `Invalid literal value, expected ${JSON.stringify(
        t.expected,
        kt.jsonStringifyReplacer
      )}`;
      break;
    case ve.unrecognized_keys:
      n = `Unrecognized key(s) in object: ${kt.joinValues(t.keys, ", ")}`;
      break;
    case ve.invalid_union:
      n = "Invalid input";
      break;
    case ve.invalid_union_discriminator:
      n = `Invalid discriminator value. Expected ${kt.joinValues(t.options)}`;
      break;
    case ve.invalid_enum_value:
      n = `Invalid enum value. Expected ${kt.joinValues(
        t.options
      )}, received '${t.received}'`;
      break;
    case ve.invalid_arguments:
      n = "Invalid function arguments";
      break;
    case ve.invalid_return_type:
      n = "Invalid function return type";
      break;
    case ve.invalid_date:
      n = "Invalid date";
      break;
    case ve.invalid_string:
      typeof t.validation == "object"
        ? "includes" in t.validation
          ? ((n = `Invalid input: must include "${t.validation.includes}"`),
            typeof t.validation.position == "number" &&
              (n = `${n} at one or more positions greater than or equal to ${t.validation.position}`))
          : "startsWith" in t.validation
          ? (n = `Invalid input: must start with "${t.validation.startsWith}"`)
          : "endsWith" in t.validation
          ? (n = `Invalid input: must end with "${t.validation.endsWith}"`)
          : kt.assertNever(t.validation)
        : t.validation !== "regex"
        ? (n = `Invalid ${t.validation}`)
        : (n = "Invalid");
      break;
    case ve.too_small:
      t.type === "array"
        ? (n = `Array must contain ${
            t.exact ? "exactly" : t.inclusive ? "at least" : "more than"
          } ${t.minimum} element(s)`)
        : t.type === "string"
        ? (n = `String must contain ${
            t.exact ? "exactly" : t.inclusive ? "at least" : "over"
          } ${t.minimum} character(s)`)
        : t.type === "number"
        ? (n = `Number must be ${
            t.exact
              ? "exactly equal to "
              : t.inclusive
              ? "greater than or equal to "
              : "greater than "
          }${t.minimum}`)
        : t.type === "date"
        ? (n = `Date must be ${
            t.exact
              ? "exactly equal to "
              : t.inclusive
              ? "greater than or equal to "
              : "greater than "
          }${new Date(Number(t.minimum))}`)
        : (n = "Invalid input");
      break;
    case ve.too_big:
      t.type === "array"
        ? (n = `Array must contain ${
            t.exact ? "exactly" : t.inclusive ? "at most" : "less than"
          } ${t.maximum} element(s)`)
        : t.type === "string"
        ? (n = `String must contain ${
            t.exact ? "exactly" : t.inclusive ? "at most" : "under"
          } ${t.maximum} character(s)`)
        : t.type === "number"
        ? (n = `Number must be ${
            t.exact
              ? "exactly"
              : t.inclusive
              ? "less than or equal to"
              : "less than"
          } ${t.maximum}`)
        : t.type === "bigint"
        ? (n = `BigInt must be ${
            t.exact
              ? "exactly"
              : t.inclusive
              ? "less than or equal to"
              : "less than"
          } ${t.maximum}`)
        : t.type === "date"
        ? (n = `Date must be ${
            t.exact
              ? "exactly"
              : t.inclusive
              ? "smaller than or equal to"
              : "smaller than"
          } ${new Date(Number(t.maximum))}`)
        : (n = "Invalid input");
      break;
    case ve.custom:
      n = "Invalid input";
      break;
    case ve.invalid_intersection_types:
      n = "Intersection results could not be merged";
      break;
    case ve.not_multiple_of:
      n = `Number must be a multiple of ${t.multipleOf}`;
      break;
    case ve.not_finite:
      n = "Number must be finite";
      break;
    default:
      (n = e.defaultError), kt.assertNever(t);
  }
  return { message: n };
};
let B6 = mm;
function Ofe(t) {
  B6 = t;
}
function Rw() {
  return B6;
}
const Nw = (t) => {
    const { data: e, path: n, errorMaps: r, issueData: i } = t,
      s = [...n, ...(i.path || [])],
      o = { ...i, path: s };
    let a = "";
    const l = r
      .filter((d) => !!d)
      .slice()
      .reverse();
    for (const d of l) a = d(o, { data: e, defaultError: a }).message;
    return { ...i, path: s, message: i.message || a };
  },
  kfe = [];
function De(t, e) {
  const n = Nw({
    issueData: e,
    data: t.data,
    path: t.path,
    errorMaps: [t.common.contextualErrorMap, t.schemaErrorMap, Rw(), mm].filter(
      (r) => !!r
    ),
  });
  t.common.issues.push(n);
}
class Vr {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    this.value === "valid" && (this.value = "dirty");
  }
  abort() {
    this.value !== "aborted" && (this.value = "aborted");
  }
  static mergeArray(e, n) {
    const r = [];
    for (const i of n) {
      if (i.status === "aborted") return rt;
      i.status === "dirty" && e.dirty(), r.push(i.value);
    }
    return { status: e.value, value: r };
  }
  static async mergeObjectAsync(e, n) {
    const r = [];
    for (const i of n) r.push({ key: await i.key, value: await i.value });
    return Vr.mergeObjectSync(e, r);
  }
  static mergeObjectSync(e, n) {
    const r = {};
    for (const i of n) {
      const { key: s, value: o } = i;
      if (s.status === "aborted" || o.status === "aborted") return rt;
      s.status === "dirty" && e.dirty(),
        o.status === "dirty" && e.dirty(),
        s.value !== "__proto__" &&
          (typeof o.value < "u" || i.alwaysSet) &&
          (r[s.value] = o.value);
    }
    return { status: e.value, value: r };
  }
}
const rt = Object.freeze({ status: "aborted" }),
  j6 = (t) => ({ status: "dirty", value: t }),
  ii = (t) => ({ status: "valid", value: t }),
  mS = (t) => t.status === "aborted",
  gS = (t) => t.status === "dirty",
  gm = (t) => t.status === "valid",
  Ow = (t) => typeof Promise < "u" && t instanceof Promise;
var qe;
(function (t) {
  (t.errToObj = (e) => (typeof e == "string" ? { message: e } : e || {})),
    (t.toString = (e) =>
      typeof e == "string" ? e : e == null ? void 0 : e.message);
})(qe || (qe = {}));
class Mo {
  constructor(e, n, r, i) {
    (this._cachedPath = []),
      (this.parent = e),
      (this.data = n),
      (this._path = r),
      (this._key = i);
  }
  get path() {
    return (
      this._cachedPath.length ||
        (this._key instanceof Array
          ? this._cachedPath.push(...this._path, ...this._key)
          : this._cachedPath.push(...this._path, this._key)),
      this._cachedPath
    );
  }
}
const ak = (t, e) => {
  if (gm(e)) return { success: !0, data: e.value };
  if (!t.common.issues.length)
    throw new Error("Validation failed but no issues detected.");
  return {
    success: !1,
    get error() {
      if (this._error) return this._error;
      const n = new Ys(t.common.issues);
      return (this._error = n), this._error;
    },
  };
};
function lt(t) {
  if (!t) return {};
  const {
    errorMap: e,
    invalid_type_error: n,
    required_error: r,
    description: i,
  } = t;
  if (e && (n || r))
    throw new Error(
      `Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`
    );
  return e
    ? { errorMap: e, description: i }
    : {
        errorMap: (o, a) =>
          o.code !== "invalid_type"
            ? { message: a.defaultError }
            : typeof a.data > "u"
            ? { message: r ?? a.defaultError }
            : { message: n ?? a.defaultError },
        description: i,
      };
}
class yt {
  constructor(e) {
    (this.spa = this.safeParseAsync),
      (this._def = e),
      (this.parse = this.parse.bind(this)),
      (this.safeParse = this.safeParse.bind(this)),
      (this.parseAsync = this.parseAsync.bind(this)),
      (this.safeParseAsync = this.safeParseAsync.bind(this)),
      (this.spa = this.spa.bind(this)),
      (this.refine = this.refine.bind(this)),
      (this.refinement = this.refinement.bind(this)),
      (this.superRefine = this.superRefine.bind(this)),
      (this.optional = this.optional.bind(this)),
      (this.nullable = this.nullable.bind(this)),
      (this.nullish = this.nullish.bind(this)),
      (this.array = this.array.bind(this)),
      (this.promise = this.promise.bind(this)),
      (this.or = this.or.bind(this)),
      (this.and = this.and.bind(this)),
      (this.transform = this.transform.bind(this)),
      (this.brand = this.brand.bind(this)),
      (this.default = this.default.bind(this)),
      (this.catch = this.catch.bind(this)),
      (this.describe = this.describe.bind(this)),
      (this.pipe = this.pipe.bind(this)),
      (this.readonly = this.readonly.bind(this)),
      (this.isNullable = this.isNullable.bind(this)),
      (this.isOptional = this.isOptional.bind(this));
  }
  get description() {
    return this._def.description;
  }
  _getType(e) {
    return gc(e.data);
  }
  _getOrReturnCtx(e, n) {
    return (
      n || {
        common: e.parent.common,
        data: e.data,
        parsedType: gc(e.data),
        schemaErrorMap: this._def.errorMap,
        path: e.path,
        parent: e.parent,
      }
    );
  }
  _processInputParams(e) {
    return {
      status: new Vr(),
      ctx: {
        common: e.parent.common,
        data: e.data,
        parsedType: gc(e.data),
        schemaErrorMap: this._def.errorMap,
        path: e.path,
        parent: e.parent,
      },
    };
  }
  _parseSync(e) {
    const n = this._parse(e);
    if (Ow(n)) throw new Error("Synchronous parse encountered promise.");
    return n;
  }
  _parseAsync(e) {
    const n = this._parse(e);
    return Promise.resolve(n);
  }
  parse(e, n) {
    const r = this.safeParse(e, n);
    if (r.success) return r.data;
    throw r.error;
  }
  safeParse(e, n) {
    var r;
    const i = {
        common: {
          issues: [],
          async:
            (r = n == null ? void 0 : n.async) !== null && r !== void 0
              ? r
              : !1,
          contextualErrorMap: n == null ? void 0 : n.errorMap,
        },
        path: (n == null ? void 0 : n.path) || [],
        schemaErrorMap: this._def.errorMap,
        parent: null,
        data: e,
        parsedType: gc(e),
      },
      s = this._parseSync({ data: e, path: i.path, parent: i });
    return ak(i, s);
  }
  async parseAsync(e, n) {
    const r = await this.safeParseAsync(e, n);
    if (r.success) return r.data;
    throw r.error;
  }
  async safeParseAsync(e, n) {
    const r = {
        common: {
          issues: [],
          contextualErrorMap: n == null ? void 0 : n.errorMap,
          async: !0,
        },
        path: (n == null ? void 0 : n.path) || [],
        schemaErrorMap: this._def.errorMap,
        parent: null,
        data: e,
        parsedType: gc(e),
      },
      i = this._parse({ data: e, path: r.path, parent: r }),
      s = await (Ow(i) ? i : Promise.resolve(i));
    return ak(r, s);
  }
  refine(e, n) {
    const r = (i) =>
      typeof n == "string" || typeof n > "u"
        ? { message: n }
        : typeof n == "function"
        ? n(i)
        : n;
    return this._refinement((i, s) => {
      const o = e(i),
        a = () => s.addIssue({ code: ve.custom, ...r(i) });
      return typeof Promise < "u" && o instanceof Promise
        ? o.then((l) => (l ? !0 : (a(), !1)))
        : o
        ? !0
        : (a(), !1);
    });
  }
  refinement(e, n) {
    return this._refinement((r, i) =>
      e(r) ? !0 : (i.addIssue(typeof n == "function" ? n(r, i) : n), !1)
    );
  }
  _refinement(e) {
    return new Js({
      schema: this,
      typeName: Qe.ZodEffects,
      effect: { type: "refinement", refinement: e },
    });
  }
  superRefine(e) {
    return this._refinement(e);
  }
  optional() {
    return ba.create(this, this._def);
  }
  nullable() {
    return au.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return Zs.create(this, this._def);
  }
  promise() {
    return fp.create(this, this._def);
  }
  or(e) {
    return bm.create([this, e], this._def);
  }
  and(e) {
    return Em.create(this, e, this._def);
  }
  transform(e) {
    return new Js({
      ...lt(this._def),
      schema: this,
      typeName: Qe.ZodEffects,
      effect: { type: "transform", transform: e },
    });
  }
  default(e) {
    const n = typeof e == "function" ? e : () => e;
    return new _m({
      ...lt(this._def),
      innerType: this,
      defaultValue: n,
      typeName: Qe.ZodDefault,
    });
  }
  brand() {
    return new z6({ typeName: Qe.ZodBranded, type: this, ...lt(this._def) });
  }
  catch(e) {
    const n = typeof e == "function" ? e : () => e;
    return new Mw({
      ...lt(this._def),
      innerType: this,
      catchValue: n,
      typeName: Qe.ZodCatch,
    });
  }
  describe(e) {
    const n = this.constructor;
    return new n({ ...this._def, description: e });
  }
  pipe(e) {
    return ug.create(this, e);
  }
  readonly() {
    return Uw.create(this);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
}
const Dfe = /^c[^\s-]{8,}$/i,
  $fe = /^[a-z][a-z0-9]*$/,
  Mfe = /^[0-9A-HJKMNP-TV-Z]{26}$/,
  Lfe =
    /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i,
  Ufe =
    /^(?!\.)(?!.*\.\.)([A-Z0-9_+-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i,
  Bfe = "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$";
let mC;
const jfe =
    /^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$/,
  Ffe =
    /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/,
  zfe = (t) =>
    t.precision
      ? t.offset
        ? new RegExp(
            `^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${t.precision}}(([+-]\\d{2}(:?\\d{2})?)|Z)$`
          )
        : new RegExp(
            `^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${t.precision}}Z$`
          )
      : t.precision === 0
      ? t.offset
        ? new RegExp(
            "^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(([+-]\\d{2}(:?\\d{2})?)|Z)$"
          )
        : new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z$")
      : t.offset
      ? new RegExp(
          "^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(([+-]\\d{2}(:?\\d{2})?)|Z)$"
        )
      : new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?Z$");
function Wfe(t, e) {
  return !!(
    ((e === "v4" || !e) && jfe.test(t)) ||
    ((e === "v6" || !e) && Ffe.test(t))
  );
}
class Gs extends yt {
  _parse(e) {
    if (
      (this._def.coerce && (e.data = String(e.data)),
      this._getType(e) !== Te.string)
    ) {
      const s = this._getOrReturnCtx(e);
      return (
        De(s, {
          code: ve.invalid_type,
          expected: Te.string,
          received: s.parsedType,
        }),
        rt
      );
    }
    const r = new Vr();
    let i;
    for (const s of this._def.checks)
      if (s.kind === "min")
        e.data.length < s.value &&
          ((i = this._getOrReturnCtx(e, i)),
          De(i, {
            code: ve.too_small,
            minimum: s.value,
            type: "string",
            inclusive: !0,
            exact: !1,
            message: s.message,
          }),
          r.dirty());
      else if (s.kind === "max")
        e.data.length > s.value &&
          ((i = this._getOrReturnCtx(e, i)),
          De(i, {
            code: ve.too_big,
            maximum: s.value,
            type: "string",
            inclusive: !0,
            exact: !1,
            message: s.message,
          }),
          r.dirty());
      else if (s.kind === "length") {
        const o = e.data.length > s.value,
          a = e.data.length < s.value;
        (o || a) &&
          ((i = this._getOrReturnCtx(e, i)),
          o
            ? De(i, {
                code: ve.too_big,
                maximum: s.value,
                type: "string",
                inclusive: !0,
                exact: !0,
                message: s.message,
              })
            : a &&
              De(i, {
                code: ve.too_small,
                minimum: s.value,
                type: "string",
                inclusive: !0,
                exact: !0,
                message: s.message,
              }),
          r.dirty());
      } else if (s.kind === "email")
        Ufe.test(e.data) ||
          ((i = this._getOrReturnCtx(e, i)),
          De(i, {
            validation: "email",
            code: ve.invalid_string,
            message: s.message,
          }),
          r.dirty());
      else if (s.kind === "emoji")
        mC || (mC = new RegExp(Bfe, "u")),
          mC.test(e.data) ||
            ((i = this._getOrReturnCtx(e, i)),
            De(i, {
              validation: "emoji",
              code: ve.invalid_string,
              message: s.message,
            }),
            r.dirty());
      else if (s.kind === "uuid")
        Lfe.test(e.data) ||
          ((i = this._getOrReturnCtx(e, i)),
          De(i, {
            validation: "uuid",
            code: ve.invalid_string,
            message: s.message,
          }),
          r.dirty());
      else if (s.kind === "cuid")
        Dfe.test(e.data) ||
          ((i = this._getOrReturnCtx(e, i)),
          De(i, {
            validation: "cuid",
            code: ve.invalid_string,
            message: s.message,
          }),
          r.dirty());
      else if (s.kind === "cuid2")
        $fe.test(e.data) ||
          ((i = this._getOrReturnCtx(e, i)),
          De(i, {
            validation: "cuid2",
            code: ve.invalid_string,
            message: s.message,
          }),
          r.dirty());
      else if (s.kind === "ulid")
        Mfe.test(e.data) ||
          ((i = this._getOrReturnCtx(e, i)),
          De(i, {
            validation: "ulid",
            code: ve.invalid_string,
            message: s.message,
          }),
          r.dirty());
      else if (s.kind === "url")
        try {
          new URL(e.data);
        } catch {
          (i = this._getOrReturnCtx(e, i)),
            De(i, {
              validation: "url",
              code: ve.invalid_string,
              message: s.message,
            }),
            r.dirty();
        }
      else
        s.kind === "regex"
          ? ((s.regex.lastIndex = 0),
            s.regex.test(e.data) ||
              ((i = this._getOrReturnCtx(e, i)),
              De(i, {
                validation: "regex",
                code: ve.invalid_string,
                message: s.message,
              }),
              r.dirty()))
          : s.kind === "trim"
          ? (e.data = e.data.trim())
          : s.kind === "includes"
          ? e.data.includes(s.value, s.position) ||
            ((i = this._getOrReturnCtx(e, i)),
            De(i, {
              code: ve.invalid_string,
              validation: { includes: s.value, position: s.position },
              message: s.message,
            }),
            r.dirty())
          : s.kind === "toLowerCase"
          ? (e.data = e.data.toLowerCase())
          : s.kind === "toUpperCase"
          ? (e.data = e.data.toUpperCase())
          : s.kind === "startsWith"
          ? e.data.startsWith(s.value) ||
            ((i = this._getOrReturnCtx(e, i)),
            De(i, {
              code: ve.invalid_string,
              validation: { startsWith: s.value },
              message: s.message,
            }),
            r.dirty())
          : s.kind === "endsWith"
          ? e.data.endsWith(s.value) ||
            ((i = this._getOrReturnCtx(e, i)),
            De(i, {
              code: ve.invalid_string,
              validation: { endsWith: s.value },
              message: s.message,
            }),
            r.dirty())
          : s.kind === "datetime"
          ? zfe(s).test(e.data) ||
            ((i = this._getOrReturnCtx(e, i)),
            De(i, {
              code: ve.invalid_string,
              validation: "datetime",
              message: s.message,
            }),
            r.dirty())
          : s.kind === "ip"
          ? Wfe(e.data, s.version) ||
            ((i = this._getOrReturnCtx(e, i)),
            De(i, {
              validation: "ip",
              code: ve.invalid_string,
              message: s.message,
            }),
            r.dirty())
          : kt.assertNever(s);
    return { status: r.value, value: e.data };
  }
  _regex(e, n, r) {
    return this.refinement((i) => e.test(i), {
      validation: n,
      code: ve.invalid_string,
      ...qe.errToObj(r),
    });
  }
  _addCheck(e) {
    return new Gs({ ...this._def, checks: [...this._def.checks, e] });
  }
  email(e) {
    return this._addCheck({ kind: "email", ...qe.errToObj(e) });
  }
  url(e) {
    return this._addCheck({ kind: "url", ...qe.errToObj(e) });
  }
  emoji(e) {
    return this._addCheck({ kind: "emoji", ...qe.errToObj(e) });
  }
  uuid(e) {
    return this._addCheck({ kind: "uuid", ...qe.errToObj(e) });
  }
  cuid(e) {
    return this._addCheck({ kind: "cuid", ...qe.errToObj(e) });
  }
  cuid2(e) {
    return this._addCheck({ kind: "cuid2", ...qe.errToObj(e) });
  }
  ulid(e) {
    return this._addCheck({ kind: "ulid", ...qe.errToObj(e) });
  }
  ip(e) {
    return this._addCheck({ kind: "ip", ...qe.errToObj(e) });
  }
  datetime(e) {
    var n;
    return typeof e == "string"
      ? this._addCheck({
          kind: "datetime",
          precision: null,
          offset: !1,
          message: e,
        })
      : this._addCheck({
          kind: "datetime",
          precision:
            typeof (e == null ? void 0 : e.precision) > "u"
              ? null
              : e == null
              ? void 0
              : e.precision,
          offset:
            (n = e == null ? void 0 : e.offset) !== null && n !== void 0
              ? n
              : !1,
          ...qe.errToObj(e == null ? void 0 : e.message),
        });
  }
  regex(e, n) {
    return this._addCheck({ kind: "regex", regex: e, ...qe.errToObj(n) });
  }
  includes(e, n) {
    return this._addCheck({
      kind: "includes",
      value: e,
      position: n == null ? void 0 : n.position,
      ...qe.errToObj(n == null ? void 0 : n.message),
    });
  }
  startsWith(e, n) {
    return this._addCheck({ kind: "startsWith", value: e, ...qe.errToObj(n) });
  }
  endsWith(e, n) {
    return this._addCheck({ kind: "endsWith", value: e, ...qe.errToObj(n) });
  }
  min(e, n) {
    return this._addCheck({ kind: "min", value: e, ...qe.errToObj(n) });
  }
  max(e, n) {
    return this._addCheck({ kind: "max", value: e, ...qe.errToObj(n) });
  }
  length(e, n) {
    return this._addCheck({ kind: "length", value: e, ...qe.errToObj(n) });
  }
  nonempty(e) {
    return this.min(1, qe.errToObj(e));
  }
  trim() {
    return new Gs({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }],
    });
  }
  toLowerCase() {
    return new Gs({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }],
    });
  }
  toUpperCase() {
    return new Gs({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }],
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((e) => e.kind === "datetime");
  }
  get isEmail() {
    return !!this._def.checks.find((e) => e.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((e) => e.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((e) => e.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((e) => e.kind === "uuid");
  }
  get isCUID() {
    return !!this._def.checks.find((e) => e.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((e) => e.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((e) => e.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((e) => e.kind === "ip");
  }
  get minLength() {
    let e = null;
    for (const n of this._def.checks)
      n.kind === "min" && (e === null || n.value > e) && (e = n.value);
    return e;
  }
  get maxLength() {
    let e = null;
    for (const n of this._def.checks)
      n.kind === "max" && (e === null || n.value < e) && (e = n.value);
    return e;
  }
}
Gs.create = (t) => {
  var e;
  return new Gs({
    checks: [],
    typeName: Qe.ZodString,
    coerce:
      (e = t == null ? void 0 : t.coerce) !== null && e !== void 0 ? e : !1,
    ...lt(t),
  });
};
function Hfe(t, e) {
  const n = (t.toString().split(".")[1] || "").length,
    r = (e.toString().split(".")[1] || "").length,
    i = n > r ? n : r,
    s = parseInt(t.toFixed(i).replace(".", "")),
    o = parseInt(e.toFixed(i).replace(".", ""));
  return (s % o) / Math.pow(10, i);
}
class Fc extends yt {
  constructor() {
    super(...arguments),
      (this.min = this.gte),
      (this.max = this.lte),
      (this.step = this.multipleOf);
  }
  _parse(e) {
    if (
      (this._def.coerce && (e.data = Number(e.data)),
      this._getType(e) !== Te.number)
    ) {
      const s = this._getOrReturnCtx(e);
      return (
        De(s, {
          code: ve.invalid_type,
          expected: Te.number,
          received: s.parsedType,
        }),
        rt
      );
    }
    let r;
    const i = new Vr();
    for (const s of this._def.checks)
      s.kind === "int"
        ? kt.isInteger(e.data) ||
          ((r = this._getOrReturnCtx(e, r)),
          De(r, {
            code: ve.invalid_type,
            expected: "integer",
            received: "float",
            message: s.message,
          }),
          i.dirty())
        : s.kind === "min"
        ? (s.inclusive ? e.data < s.value : e.data <= s.value) &&
          ((r = this._getOrReturnCtx(e, r)),
          De(r, {
            code: ve.too_small,
            minimum: s.value,
            type: "number",
            inclusive: s.inclusive,
            exact: !1,
            message: s.message,
          }),
          i.dirty())
        : s.kind === "max"
        ? (s.inclusive ? e.data > s.value : e.data >= s.value) &&
          ((r = this._getOrReturnCtx(e, r)),
          De(r, {
            code: ve.too_big,
            maximum: s.value,
            type: "number",
            inclusive: s.inclusive,
            exact: !1,
            message: s.message,
          }),
          i.dirty())
        : s.kind === "multipleOf"
        ? Hfe(e.data, s.value) !== 0 &&
          ((r = this._getOrReturnCtx(e, r)),
          De(r, {
            code: ve.not_multiple_of,
            multipleOf: s.value,
            message: s.message,
          }),
          i.dirty())
        : s.kind === "finite"
        ? Number.isFinite(e.data) ||
          ((r = this._getOrReturnCtx(e, r)),
          De(r, { code: ve.not_finite, message: s.message }),
          i.dirty())
        : kt.assertNever(s);
    return { status: i.value, value: e.data };
  }
  gte(e, n) {
    return this.setLimit("min", e, !0, qe.toString(n));
  }
  gt(e, n) {
    return this.setLimit("min", e, !1, qe.toString(n));
  }
  lte(e, n) {
    return this.setLimit("max", e, !0, qe.toString(n));
  }
  lt(e, n) {
    return this.setLimit("max", e, !1, qe.toString(n));
  }
  setLimit(e, n, r, i) {
    return new Fc({
      ...this._def,
      checks: [
        ...this._def.checks,
        { kind: e, value: n, inclusive: r, message: qe.toString(i) },
      ],
    });
  }
  _addCheck(e) {
    return new Fc({ ...this._def, checks: [...this._def.checks, e] });
  }
  int(e) {
    return this._addCheck({ kind: "int", message: qe.toString(e) });
  }
  positive(e) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: !1,
      message: qe.toString(e),
    });
  }
  negative(e) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: !1,
      message: qe.toString(e),
    });
  }
  nonpositive(e) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: !0,
      message: qe.toString(e),
    });
  }
  nonnegative(e) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: !0,
      message: qe.toString(e),
    });
  }
  multipleOf(e, n) {
    return this._addCheck({
      kind: "multipleOf",
      value: e,
      message: qe.toString(n),
    });
  }
  finite(e) {
    return this._addCheck({ kind: "finite", message: qe.toString(e) });
  }
  safe(e) {
    return this._addCheck({
      kind: "min",
      inclusive: !0,
      value: Number.MIN_SAFE_INTEGER,
      message: qe.toString(e),
    })._addCheck({
      kind: "max",
      inclusive: !0,
      value: Number.MAX_SAFE_INTEGER,
      message: qe.toString(e),
    });
  }
  get minValue() {
    let e = null;
    for (const n of this._def.checks)
      n.kind === "min" && (e === null || n.value > e) && (e = n.value);
    return e;
  }
  get maxValue() {
    let e = null;
    for (const n of this._def.checks)
      n.kind === "max" && (e === null || n.value < e) && (e = n.value);
    return e;
  }
  get isInt() {
    return !!this._def.checks.find(
      (e) =>
        e.kind === "int" || (e.kind === "multipleOf" && kt.isInteger(e.value))
    );
  }
  get isFinite() {
    let e = null,
      n = null;
    for (const r of this._def.checks) {
      if (r.kind === "finite" || r.kind === "int" || r.kind === "multipleOf")
        return !0;
      r.kind === "min"
        ? (n === null || r.value > n) && (n = r.value)
        : r.kind === "max" && (e === null || r.value < e) && (e = r.value);
    }
    return Number.isFinite(n) && Number.isFinite(e);
  }
}
Fc.create = (t) =>
  new Fc({
    checks: [],
    typeName: Qe.ZodNumber,
    coerce: (t == null ? void 0 : t.coerce) || !1,
    ...lt(t),
  });
class zc extends yt {
  constructor() {
    super(...arguments), (this.min = this.gte), (this.max = this.lte);
  }
  _parse(e) {
    if (
      (this._def.coerce && (e.data = BigInt(e.data)),
      this._getType(e) !== Te.bigint)
    ) {
      const s = this._getOrReturnCtx(e);
      return (
        De(s, {
          code: ve.invalid_type,
          expected: Te.bigint,
          received: s.parsedType,
        }),
        rt
      );
    }
    let r;
    const i = new Vr();
    for (const s of this._def.checks)
      s.kind === "min"
        ? (s.inclusive ? e.data < s.value : e.data <= s.value) &&
          ((r = this._getOrReturnCtx(e, r)),
          De(r, {
            code: ve.too_small,
            type: "bigint",
            minimum: s.value,
            inclusive: s.inclusive,
            message: s.message,
          }),
          i.dirty())
        : s.kind === "max"
        ? (s.inclusive ? e.data > s.value : e.data >= s.value) &&
          ((r = this._getOrReturnCtx(e, r)),
          De(r, {
            code: ve.too_big,
            type: "bigint",
            maximum: s.value,
            inclusive: s.inclusive,
            message: s.message,
          }),
          i.dirty())
        : s.kind === "multipleOf"
        ? e.data % s.value !== BigInt(0) &&
          ((r = this._getOrReturnCtx(e, r)),
          De(r, {
            code: ve.not_multiple_of,
            multipleOf: s.value,
            message: s.message,
          }),
          i.dirty())
        : kt.assertNever(s);
    return { status: i.value, value: e.data };
  }
  gte(e, n) {
    return this.setLimit("min", e, !0, qe.toString(n));
  }
  gt(e, n) {
    return this.setLimit("min", e, !1, qe.toString(n));
  }
  lte(e, n) {
    return this.setLimit("max", e, !0, qe.toString(n));
  }
  lt(e, n) {
    return this.setLimit("max", e, !1, qe.toString(n));
  }
  setLimit(e, n, r, i) {
    return new zc({
      ...this._def,
      checks: [
        ...this._def.checks,
        { kind: e, value: n, inclusive: r, message: qe.toString(i) },
      ],
    });
  }
  _addCheck(e) {
    return new zc({ ...this._def, checks: [...this._def.checks, e] });
  }
  positive(e) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: !1,
      message: qe.toString(e),
    });
  }
  negative(e) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: !1,
      message: qe.toString(e),
    });
  }
  nonpositive(e) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: !0,
      message: qe.toString(e),
    });
  }
  nonnegative(e) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: !0,
      message: qe.toString(e),
    });
  }
  multipleOf(e, n) {
    return this._addCheck({
      kind: "multipleOf",
      value: e,
      message: qe.toString(n),
    });
  }
  get minValue() {
    let e = null;
    for (const n of this._def.checks)
      n.kind === "min" && (e === null || n.value > e) && (e = n.value);
    return e;
  }
  get maxValue() {
    let e = null;
    for (const n of this._def.checks)
      n.kind === "max" && (e === null || n.value < e) && (e = n.value);
    return e;
  }
}
zc.create = (t) => {
  var e;
  return new zc({
    checks: [],
    typeName: Qe.ZodBigInt,
    coerce:
      (e = t == null ? void 0 : t.coerce) !== null && e !== void 0 ? e : !1,
    ...lt(t),
  });
};
class ym extends yt {
  _parse(e) {
    if (
      (this._def.coerce && (e.data = !!e.data), this._getType(e) !== Te.boolean)
    ) {
      const r = this._getOrReturnCtx(e);
      return (
        De(r, {
          code: ve.invalid_type,
          expected: Te.boolean,
          received: r.parsedType,
        }),
        rt
      );
    }
    return ii(e.data);
  }
}
ym.create = (t) =>
  new ym({
    typeName: Qe.ZodBoolean,
    coerce: (t == null ? void 0 : t.coerce) || !1,
    ...lt(t),
  });
class su extends yt {
  _parse(e) {
    if (
      (this._def.coerce && (e.data = new Date(e.data)),
      this._getType(e) !== Te.date)
    ) {
      const s = this._getOrReturnCtx(e);
      return (
        De(s, {
          code: ve.invalid_type,
          expected: Te.date,
          received: s.parsedType,
        }),
        rt
      );
    }
    if (isNaN(e.data.getTime())) {
      const s = this._getOrReturnCtx(e);
      return De(s, { code: ve.invalid_date }), rt;
    }
    const r = new Vr();
    let i;
    for (const s of this._def.checks)
      s.kind === "min"
        ? e.data.getTime() < s.value &&
          ((i = this._getOrReturnCtx(e, i)),
          De(i, {
            code: ve.too_small,
            message: s.message,
            inclusive: !0,
            exact: !1,
            minimum: s.value,
            type: "date",
          }),
          r.dirty())
        : s.kind === "max"
        ? e.data.getTime() > s.value &&
          ((i = this._getOrReturnCtx(e, i)),
          De(i, {
            code: ve.too_big,
            message: s.message,
            inclusive: !0,
            exact: !1,
            maximum: s.value,
            type: "date",
          }),
          r.dirty())
        : kt.assertNever(s);
    return { status: r.value, value: new Date(e.data.getTime()) };
  }
  _addCheck(e) {
    return new su({ ...this._def, checks: [...this._def.checks, e] });
  }
  min(e, n) {
    return this._addCheck({
      kind: "min",
      value: e.getTime(),
      message: qe.toString(n),
    });
  }
  max(e, n) {
    return this._addCheck({
      kind: "max",
      value: e.getTime(),
      message: qe.toString(n),
    });
  }
  get minDate() {
    let e = null;
    for (const n of this._def.checks)
      n.kind === "min" && (e === null || n.value > e) && (e = n.value);
    return e != null ? new Date(e) : null;
  }
  get maxDate() {
    let e = null;
    for (const n of this._def.checks)
      n.kind === "max" && (e === null || n.value < e) && (e = n.value);
    return e != null ? new Date(e) : null;
  }
}
su.create = (t) =>
  new su({
    checks: [],
    coerce: (t == null ? void 0 : t.coerce) || !1,
    typeName: Qe.ZodDate,
    ...lt(t),
  });
class kw extends yt {
  _parse(e) {
    if (this._getType(e) !== Te.symbol) {
      const r = this._getOrReturnCtx(e);
      return (
        De(r, {
          code: ve.invalid_type,
          expected: Te.symbol,
          received: r.parsedType,
        }),
        rt
      );
    }
    return ii(e.data);
  }
}
kw.create = (t) => new kw({ typeName: Qe.ZodSymbol, ...lt(t) });
class wm extends yt {
  _parse(e) {
    if (this._getType(e) !== Te.undefined) {
      const r = this._getOrReturnCtx(e);
      return (
        De(r, {
          code: ve.invalid_type,
          expected: Te.undefined,
          received: r.parsedType,
        }),
        rt
      );
    }
    return ii(e.data);
  }
}
wm.create = (t) => new wm({ typeName: Qe.ZodUndefined, ...lt(t) });
class vm extends yt {
  _parse(e) {
    if (this._getType(e) !== Te.null) {
      const r = this._getOrReturnCtx(e);
      return (
        De(r, {
          code: ve.invalid_type,
          expected: Te.null,
          received: r.parsedType,
        }),
        rt
      );
    }
    return ii(e.data);
  }
}
vm.create = (t) => new vm({ typeName: Qe.ZodNull, ...lt(t) });
class pp extends yt {
  constructor() {
    super(...arguments), (this._any = !0);
  }
  _parse(e) {
    return ii(e.data);
  }
}
pp.create = (t) => new pp({ typeName: Qe.ZodAny, ...lt(t) });
class zl extends yt {
  constructor() {
    super(...arguments), (this._unknown = !0);
  }
  _parse(e) {
    return ii(e.data);
  }
}
zl.create = (t) => new zl({ typeName: Qe.ZodUnknown, ...lt(t) });
class _a extends yt {
  _parse(e) {
    const n = this._getOrReturnCtx(e);
    return (
      De(n, {
        code: ve.invalid_type,
        expected: Te.never,
        received: n.parsedType,
      }),
      rt
    );
  }
}
_a.create = (t) => new _a({ typeName: Qe.ZodNever, ...lt(t) });
class Dw extends yt {
  _parse(e) {
    if (this._getType(e) !== Te.undefined) {
      const r = this._getOrReturnCtx(e);
      return (
        De(r, {
          code: ve.invalid_type,
          expected: Te.void,
          received: r.parsedType,
        }),
        rt
      );
    }
    return ii(e.data);
  }
}
Dw.create = (t) => new Dw({ typeName: Qe.ZodVoid, ...lt(t) });
class Zs extends yt {
  _parse(e) {
    const { ctx: n, status: r } = this._processInputParams(e),
      i = this._def;
    if (n.parsedType !== Te.array)
      return (
        De(n, {
          code: ve.invalid_type,
          expected: Te.array,
          received: n.parsedType,
        }),
        rt
      );
    if (i.exactLength !== null) {
      const o = n.data.length > i.exactLength.value,
        a = n.data.length < i.exactLength.value;
      (o || a) &&
        (De(n, {
          code: o ? ve.too_big : ve.too_small,
          minimum: a ? i.exactLength.value : void 0,
          maximum: o ? i.exactLength.value : void 0,
          type: "array",
          inclusive: !0,
          exact: !0,
          message: i.exactLength.message,
        }),
        r.dirty());
    }
    if (
      (i.minLength !== null &&
        n.data.length < i.minLength.value &&
        (De(n, {
          code: ve.too_small,
          minimum: i.minLength.value,
          type: "array",
          inclusive: !0,
          exact: !1,
          message: i.minLength.message,
        }),
        r.dirty()),
      i.maxLength !== null &&
        n.data.length > i.maxLength.value &&
        (De(n, {
          code: ve.too_big,
          maximum: i.maxLength.value,
          type: "array",
          inclusive: !0,
          exact: !1,
          message: i.maxLength.message,
        }),
        r.dirty()),
      n.common.async)
    )
      return Promise.all(
        [...n.data].map((o, a) => i.type._parseAsync(new Mo(n, o, n.path, a)))
      ).then((o) => Vr.mergeArray(r, o));
    const s = [...n.data].map((o, a) =>
      i.type._parseSync(new Mo(n, o, n.path, a))
    );
    return Vr.mergeArray(r, s);
  }
  get element() {
    return this._def.type;
  }
  min(e, n) {
    return new Zs({
      ...this._def,
      minLength: { value: e, message: qe.toString(n) },
    });
  }
  max(e, n) {
    return new Zs({
      ...this._def,
      maxLength: { value: e, message: qe.toString(n) },
    });
  }
  length(e, n) {
    return new Zs({
      ...this._def,
      exactLength: { value: e, message: qe.toString(n) },
    });
  }
  nonempty(e) {
    return this.min(1, e);
  }
}
Zs.create = (t, e) =>
  new Zs({
    type: t,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: Qe.ZodArray,
    ...lt(e),
  });
function Ed(t) {
  if (t instanceof Sn) {
    const e = {};
    for (const n in t.shape) {
      const r = t.shape[n];
      e[n] = ba.create(Ed(r));
    }
    return new Sn({ ...t._def, shape: () => e });
  } else
    return t instanceof Zs
      ? new Zs({ ...t._def, type: Ed(t.element) })
      : t instanceof ba
      ? ba.create(Ed(t.unwrap()))
      : t instanceof au
      ? au.create(Ed(t.unwrap()))
      : t instanceof Lo
      ? Lo.create(t.items.map((e) => Ed(e)))
      : t;
}
class Sn extends yt {
  constructor() {
    super(...arguments),
      (this._cached = null),
      (this.nonstrict = this.passthrough),
      (this.augment = this.extend);
  }
  _getCached() {
    if (this._cached !== null) return this._cached;
    const e = this._def.shape(),
      n = kt.objectKeys(e);
    return (this._cached = { shape: e, keys: n });
  }
  _parse(e) {
    if (this._getType(e) !== Te.object) {
      const d = this._getOrReturnCtx(e);
      return (
        De(d, {
          code: ve.invalid_type,
          expected: Te.object,
          received: d.parsedType,
        }),
        rt
      );
    }
    const { status: r, ctx: i } = this._processInputParams(e),
      { shape: s, keys: o } = this._getCached(),
      a = [];
    if (
      !(this._def.catchall instanceof _a && this._def.unknownKeys === "strip")
    )
      for (const d in i.data) o.includes(d) || a.push(d);
    const l = [];
    for (const d of o) {
      const p = s[d],
        f = i.data[d];
      l.push({
        key: { status: "valid", value: d },
        value: p._parse(new Mo(i, f, i.path, d)),
        alwaysSet: d in i.data,
      });
    }
    if (this._def.catchall instanceof _a) {
      const d = this._def.unknownKeys;
      if (d === "passthrough")
        for (const p of a)
          l.push({
            key: { status: "valid", value: p },
            value: { status: "valid", value: i.data[p] },
          });
      else if (d === "strict")
        a.length > 0 &&
          (De(i, { code: ve.unrecognized_keys, keys: a }), r.dirty());
      else if (d !== "strip")
        throw new Error("Internal ZodObject error: invalid unknownKeys value.");
    } else {
      const d = this._def.catchall;
      for (const p of a) {
        const f = i.data[p];
        l.push({
          key: { status: "valid", value: p },
          value: d._parse(new Mo(i, f, i.path, p)),
          alwaysSet: p in i.data,
        });
      }
    }
    return i.common.async
      ? Promise.resolve()
          .then(async () => {
            const d = [];
            for (const p of l) {
              const f = await p.key;
              d.push({ key: f, value: await p.value, alwaysSet: p.alwaysSet });
            }
            return d;
          })
          .then((d) => Vr.mergeObjectSync(r, d))
      : Vr.mergeObjectSync(r, l);
  }
  get shape() {
    return this._def.shape();
  }
  strict(e) {
    return (
      qe.errToObj,
      new Sn({
        ...this._def,
        unknownKeys: "strict",
        ...(e !== void 0
          ? {
              errorMap: (n, r) => {
                var i, s, o, a;
                const l =
                  (o =
                    (s = (i = this._def).errorMap) === null || s === void 0
                      ? void 0
                      : s.call(i, n, r).message) !== null && o !== void 0
                    ? o
                    : r.defaultError;
                return n.code === "unrecognized_keys"
                  ? {
                      message:
                        (a = qe.errToObj(e).message) !== null && a !== void 0
                          ? a
                          : l,
                    }
                  : { message: l };
              },
            }
          : {}),
      })
    );
  }
  strip() {
    return new Sn({ ...this._def, unknownKeys: "strip" });
  }
  passthrough() {
    return new Sn({ ...this._def, unknownKeys: "passthrough" });
  }
  extend(e) {
    return new Sn({
      ...this._def,
      shape: () => ({ ...this._def.shape(), ...e }),
    });
  }
  merge(e) {
    return new Sn({
      unknownKeys: e._def.unknownKeys,
      catchall: e._def.catchall,
      shape: () => ({ ...this._def.shape(), ...e._def.shape() }),
      typeName: Qe.ZodObject,
    });
  }
  setKey(e, n) {
    return this.augment({ [e]: n });
  }
  catchall(e) {
    return new Sn({ ...this._def, catchall: e });
  }
  pick(e) {
    const n = {};
    return (
      kt.objectKeys(e).forEach((r) => {
        e[r] && this.shape[r] && (n[r] = this.shape[r]);
      }),
      new Sn({ ...this._def, shape: () => n })
    );
  }
  omit(e) {
    const n = {};
    return (
      kt.objectKeys(this.shape).forEach((r) => {
        e[r] || (n[r] = this.shape[r]);
      }),
      new Sn({ ...this._def, shape: () => n })
    );
  }
  deepPartial() {
    return Ed(this);
  }
  partial(e) {
    const n = {};
    return (
      kt.objectKeys(this.shape).forEach((r) => {
        const i = this.shape[r];
        e && !e[r] ? (n[r] = i) : (n[r] = i.optional());
      }),
      new Sn({ ...this._def, shape: () => n })
    );
  }
  required(e) {
    const n = {};
    return (
      kt.objectKeys(this.shape).forEach((r) => {
        if (e && !e[r]) n[r] = this.shape[r];
        else {
          let s = this.shape[r];
          for (; s instanceof ba; ) s = s._def.innerType;
          n[r] = s;
        }
      }),
      new Sn({ ...this._def, shape: () => n })
    );
  }
  keyof() {
    return F6(kt.objectKeys(this.shape));
  }
}
Sn.create = (t, e) =>
  new Sn({
    shape: () => t,
    unknownKeys: "strip",
    catchall: _a.create(),
    typeName: Qe.ZodObject,
    ...lt(e),
  });
Sn.strictCreate = (t, e) =>
  new Sn({
    shape: () => t,
    unknownKeys: "strict",
    catchall: _a.create(),
    typeName: Qe.ZodObject,
    ...lt(e),
  });
Sn.lazycreate = (t, e) =>
  new Sn({
    shape: t,
    unknownKeys: "strip",
    catchall: _a.create(),
    typeName: Qe.ZodObject,
    ...lt(e),
  });
class bm extends yt {
  _parse(e) {
    const { ctx: n } = this._processInputParams(e),
      r = this._def.options;
    function i(s) {
      for (const a of s) if (a.result.status === "valid") return a.result;
      for (const a of s)
        if (a.result.status === "dirty")
          return n.common.issues.push(...a.ctx.common.issues), a.result;
      const o = s.map((a) => new Ys(a.ctx.common.issues));
      return De(n, { code: ve.invalid_union, unionErrors: o }), rt;
    }
    if (n.common.async)
      return Promise.all(
        r.map(async (s) => {
          const o = { ...n, common: { ...n.common, issues: [] }, parent: null };
          return {
            result: await s._parseAsync({
              data: n.data,
              path: n.path,
              parent: o,
            }),
            ctx: o,
          };
        })
      ).then(i);
    {
      let s;
      const o = [];
      for (const l of r) {
        const d = { ...n, common: { ...n.common, issues: [] }, parent: null },
          p = l._parseSync({ data: n.data, path: n.path, parent: d });
        if (p.status === "valid") return p;
        p.status === "dirty" && !s && (s = { result: p, ctx: d }),
          d.common.issues.length && o.push(d.common.issues);
      }
      if (s) return n.common.issues.push(...s.ctx.common.issues), s.result;
      const a = o.map((l) => new Ys(l));
      return De(n, { code: ve.invalid_union, unionErrors: a }), rt;
    }
  }
  get options() {
    return this._def.options;
  }
}
bm.create = (t, e) => new bm({ options: t, typeName: Qe.ZodUnion, ...lt(e) });
const j0 = (t) =>
  t instanceof xm
    ? j0(t.schema)
    : t instanceof Js
    ? j0(t.innerType())
    : t instanceof Sm
    ? [t.value]
    : t instanceof Wc
    ? t.options
    : t instanceof Am
    ? Object.keys(t.enum)
    : t instanceof _m
    ? j0(t._def.innerType)
    : t instanceof wm
    ? [void 0]
    : t instanceof vm
    ? [null]
    : null;
class Vv extends yt {
  _parse(e) {
    const { ctx: n } = this._processInputParams(e);
    if (n.parsedType !== Te.object)
      return (
        De(n, {
          code: ve.invalid_type,
          expected: Te.object,
          received: n.parsedType,
        }),
        rt
      );
    const r = this.discriminator,
      i = n.data[r],
      s = this.optionsMap.get(i);
    return s
      ? n.common.async
        ? s._parseAsync({ data: n.data, path: n.path, parent: n })
        : s._parseSync({ data: n.data, path: n.path, parent: n })
      : (De(n, {
          code: ve.invalid_union_discriminator,
          options: Array.from(this.optionsMap.keys()),
          path: [r],
        }),
        rt);
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  static create(e, n, r) {
    const i = new Map();
    for (const s of n) {
      const o = j0(s.shape[e]);
      if (!o)
        throw new Error(
          `A discriminator value for key \`${e}\` could not be extracted from all schema options`
        );
      for (const a of o) {
        if (i.has(a))
          throw new Error(
            `Discriminator property ${String(e)} has duplicate value ${String(
              a
            )}`
          );
        i.set(a, s);
      }
    }
    return new Vv({
      typeName: Qe.ZodDiscriminatedUnion,
      discriminator: e,
      options: n,
      optionsMap: i,
      ...lt(r),
    });
  }
}
function yS(t, e) {
  const n = gc(t),
    r = gc(e);
  if (t === e) return { valid: !0, data: t };
  if (n === Te.object && r === Te.object) {
    const i = kt.objectKeys(e),
      s = kt.objectKeys(t).filter((a) => i.indexOf(a) !== -1),
      o = { ...t, ...e };
    for (const a of s) {
      const l = yS(t[a], e[a]);
      if (!l.valid) return { valid: !1 };
      o[a] = l.data;
    }
    return { valid: !0, data: o };
  } else if (n === Te.array && r === Te.array) {
    if (t.length !== e.length) return { valid: !1 };
    const i = [];
    for (let s = 0; s < t.length; s++) {
      const o = t[s],
        a = e[s],
        l = yS(o, a);
      if (!l.valid) return { valid: !1 };
      i.push(l.data);
    }
    return { valid: !0, data: i };
  } else
    return n === Te.date && r === Te.date && +t == +e
      ? { valid: !0, data: t }
      : { valid: !1 };
}
class Em extends yt {
  _parse(e) {
    const { status: n, ctx: r } = this._processInputParams(e),
      i = (s, o) => {
        if (mS(s) || mS(o)) return rt;
        const a = yS(s.value, o.value);
        return a.valid
          ? ((gS(s) || gS(o)) && n.dirty(), { status: n.value, value: a.data })
          : (De(r, { code: ve.invalid_intersection_types }), rt);
      };
    return r.common.async
      ? Promise.all([
          this._def.left._parseAsync({ data: r.data, path: r.path, parent: r }),
          this._def.right._parseAsync({
            data: r.data,
            path: r.path,
            parent: r,
          }),
        ]).then(([s, o]) => i(s, o))
      : i(
          this._def.left._parseSync({ data: r.data, path: r.path, parent: r }),
          this._def.right._parseSync({ data: r.data, path: r.path, parent: r })
        );
  }
}
Em.create = (t, e, n) =>
  new Em({ left: t, right: e, typeName: Qe.ZodIntersection, ...lt(n) });
class Lo extends yt {
  _parse(e) {
    const { status: n, ctx: r } = this._processInputParams(e);
    if (r.parsedType !== Te.array)
      return (
        De(r, {
          code: ve.invalid_type,
          expected: Te.array,
          received: r.parsedType,
        }),
        rt
      );
    if (r.data.length < this._def.items.length)
      return (
        De(r, {
          code: ve.too_small,
          minimum: this._def.items.length,
          inclusive: !0,
          exact: !1,
          type: "array",
        }),
        rt
      );
    !this._def.rest &&
      r.data.length > this._def.items.length &&
      (De(r, {
        code: ve.too_big,
        maximum: this._def.items.length,
        inclusive: !0,
        exact: !1,
        type: "array",
      }),
      n.dirty());
    const s = [...r.data]
      .map((o, a) => {
        const l = this._def.items[a] || this._def.rest;
        return l ? l._parse(new Mo(r, o, r.path, a)) : null;
      })
      .filter((o) => !!o);
    return r.common.async
      ? Promise.all(s).then((o) => Vr.mergeArray(n, o))
      : Vr.mergeArray(n, s);
  }
  get items() {
    return this._def.items;
  }
  rest(e) {
    return new Lo({ ...this._def, rest: e });
  }
}
Lo.create = (t, e) => {
  if (!Array.isArray(t))
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  return new Lo({ items: t, typeName: Qe.ZodTuple, rest: null, ...lt(e) });
};
class Cm extends yt {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(e) {
    const { status: n, ctx: r } = this._processInputParams(e);
    if (r.parsedType !== Te.object)
      return (
        De(r, {
          code: ve.invalid_type,
          expected: Te.object,
          received: r.parsedType,
        }),
        rt
      );
    const i = [],
      s = this._def.keyType,
      o = this._def.valueType;
    for (const a in r.data)
      i.push({
        key: s._parse(new Mo(r, a, r.path, a)),
        value: o._parse(new Mo(r, r.data[a], r.path, a)),
      });
    return r.common.async
      ? Vr.mergeObjectAsync(n, i)
      : Vr.mergeObjectSync(n, i);
  }
  get element() {
    return this._def.valueType;
  }
  static create(e, n, r) {
    return n instanceof yt
      ? new Cm({ keyType: e, valueType: n, typeName: Qe.ZodRecord, ...lt(r) })
      : new Cm({
          keyType: Gs.create(),
          valueType: e,
          typeName: Qe.ZodRecord,
          ...lt(n),
        });
  }
}
class $w extends yt {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(e) {
    const { status: n, ctx: r } = this._processInputParams(e);
    if (r.parsedType !== Te.map)
      return (
        De(r, {
          code: ve.invalid_type,
          expected: Te.map,
          received: r.parsedType,
        }),
        rt
      );
    const i = this._def.keyType,
      s = this._def.valueType,
      o = [...r.data.entries()].map(([a, l], d) => ({
        key: i._parse(new Mo(r, a, r.path, [d, "key"])),
        value: s._parse(new Mo(r, l, r.path, [d, "value"])),
      }));
    if (r.common.async) {
      const a = new Map();
      return Promise.resolve().then(async () => {
        for (const l of o) {
          const d = await l.key,
            p = await l.value;
          if (d.status === "aborted" || p.status === "aborted") return rt;
          (d.status === "dirty" || p.status === "dirty") && n.dirty(),
            a.set(d.value, p.value);
        }
        return { status: n.value, value: a };
      });
    } else {
      const a = new Map();
      for (const l of o) {
        const d = l.key,
          p = l.value;
        if (d.status === "aborted" || p.status === "aborted") return rt;
        (d.status === "dirty" || p.status === "dirty") && n.dirty(),
          a.set(d.value, p.value);
      }
      return { status: n.value, value: a };
    }
  }
}
$w.create = (t, e, n) =>
  new $w({ valueType: e, keyType: t, typeName: Qe.ZodMap, ...lt(n) });
class ou extends yt {
  _parse(e) {
    const { status: n, ctx: r } = this._processInputParams(e);
    if (r.parsedType !== Te.set)
      return (
        De(r, {
          code: ve.invalid_type,
          expected: Te.set,
          received: r.parsedType,
        }),
        rt
      );
    const i = this._def;
    i.minSize !== null &&
      r.data.size < i.minSize.value &&
      (De(r, {
        code: ve.too_small,
        minimum: i.minSize.value,
        type: "set",
        inclusive: !0,
        exact: !1,
        message: i.minSize.message,
      }),
      n.dirty()),
      i.maxSize !== null &&
        r.data.size > i.maxSize.value &&
        (De(r, {
          code: ve.too_big,
          maximum: i.maxSize.value,
          type: "set",
          inclusive: !0,
          exact: !1,
          message: i.maxSize.message,
        }),
        n.dirty());
    const s = this._def.valueType;
    function o(l) {
      const d = new Set();
      for (const p of l) {
        if (p.status === "aborted") return rt;
        p.status === "dirty" && n.dirty(), d.add(p.value);
      }
      return { status: n.value, value: d };
    }
    const a = [...r.data.values()].map((l, d) =>
      s._parse(new Mo(r, l, r.path, d))
    );
    return r.common.async ? Promise.all(a).then((l) => o(l)) : o(a);
  }
  min(e, n) {
    return new ou({
      ...this._def,
      minSize: { value: e, message: qe.toString(n) },
    });
  }
  max(e, n) {
    return new ou({
      ...this._def,
      maxSize: { value: e, message: qe.toString(n) },
    });
  }
  size(e, n) {
    return this.min(e, n).max(e, n);
  }
  nonempty(e) {
    return this.min(1, e);
  }
}
ou.create = (t, e) =>
  new ou({
    valueType: t,
    minSize: null,
    maxSize: null,
    typeName: Qe.ZodSet,
    ...lt(e),
  });
class kd extends yt {
  constructor() {
    super(...arguments), (this.validate = this.implement);
  }
  _parse(e) {
    const { ctx: n } = this._processInputParams(e);
    if (n.parsedType !== Te.function)
      return (
        De(n, {
          code: ve.invalid_type,
          expected: Te.function,
          received: n.parsedType,
        }),
        rt
      );
    function r(a, l) {
      return Nw({
        data: a,
        path: n.path,
        errorMaps: [
          n.common.contextualErrorMap,
          n.schemaErrorMap,
          Rw(),
          mm,
        ].filter((d) => !!d),
        issueData: { code: ve.invalid_arguments, argumentsError: l },
      });
    }
    function i(a, l) {
      return Nw({
        data: a,
        path: n.path,
        errorMaps: [
          n.common.contextualErrorMap,
          n.schemaErrorMap,
          Rw(),
          mm,
        ].filter((d) => !!d),
        issueData: { code: ve.invalid_return_type, returnTypeError: l },
      });
    }
    const s = { errorMap: n.common.contextualErrorMap },
      o = n.data;
    if (this._def.returns instanceof fp) {
      const a = this;
      return ii(async function (...l) {
        const d = new Ys([]),
          p = await a._def.args.parseAsync(l, s).catch((y) => {
            throw (d.addIssue(r(l, y)), d);
          }),
          f = await Reflect.apply(o, this, p);
        return await a._def.returns._def.type.parseAsync(f, s).catch((y) => {
          throw (d.addIssue(i(f, y)), d);
        });
      });
    } else {
      const a = this;
      return ii(function (...l) {
        const d = a._def.args.safeParse(l, s);
        if (!d.success) throw new Ys([r(l, d.error)]);
        const p = Reflect.apply(o, this, d.data),
          f = a._def.returns.safeParse(p, s);
        if (!f.success) throw new Ys([i(p, f.error)]);
        return f.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...e) {
    return new kd({ ...this._def, args: Lo.create(e).rest(zl.create()) });
  }
  returns(e) {
    return new kd({ ...this._def, returns: e });
  }
  implement(e) {
    return this.parse(e);
  }
  strictImplement(e) {
    return this.parse(e);
  }
  static create(e, n, r) {
    return new kd({
      args: e || Lo.create([]).rest(zl.create()),
      returns: n || zl.create(),
      typeName: Qe.ZodFunction,
      ...lt(r),
    });
  }
}
class xm extends yt {
  get schema() {
    return this._def.getter();
  }
  _parse(e) {
    const { ctx: n } = this._processInputParams(e);
    return this._def.getter()._parse({ data: n.data, path: n.path, parent: n });
  }
}
xm.create = (t, e) => new xm({ getter: t, typeName: Qe.ZodLazy, ...lt(e) });
class Sm extends yt {
  _parse(e) {
    if (e.data !== this._def.value) {
      const n = this._getOrReturnCtx(e);
      return (
        De(n, {
          received: n.data,
          code: ve.invalid_literal,
          expected: this._def.value,
        }),
        rt
      );
    }
    return { status: "valid", value: e.data };
  }
  get value() {
    return this._def.value;
  }
}
Sm.create = (t, e) => new Sm({ value: t, typeName: Qe.ZodLiteral, ...lt(e) });
function F6(t, e) {
  return new Wc({ values: t, typeName: Qe.ZodEnum, ...lt(e) });
}
class Wc extends yt {
  _parse(e) {
    if (typeof e.data != "string") {
      const n = this._getOrReturnCtx(e),
        r = this._def.values;
      return (
        De(n, {
          expected: kt.joinValues(r),
          received: n.parsedType,
          code: ve.invalid_type,
        }),
        rt
      );
    }
    if (this._def.values.indexOf(e.data) === -1) {
      const n = this._getOrReturnCtx(e),
        r = this._def.values;
      return (
        De(n, { received: n.data, code: ve.invalid_enum_value, options: r }), rt
      );
    }
    return ii(e.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const e = {};
    for (const n of this._def.values) e[n] = n;
    return e;
  }
  get Values() {
    const e = {};
    for (const n of this._def.values) e[n] = n;
    return e;
  }
  get Enum() {
    const e = {};
    for (const n of this._def.values) e[n] = n;
    return e;
  }
  extract(e) {
    return Wc.create(e);
  }
  exclude(e) {
    return Wc.create(this.options.filter((n) => !e.includes(n)));
  }
}
Wc.create = F6;
class Am extends yt {
  _parse(e) {
    const n = kt.getValidEnumValues(this._def.values),
      r = this._getOrReturnCtx(e);
    if (r.parsedType !== Te.string && r.parsedType !== Te.number) {
      const i = kt.objectValues(n);
      return (
        De(r, {
          expected: kt.joinValues(i),
          received: r.parsedType,
          code: ve.invalid_type,
        }),
        rt
      );
    }
    if (n.indexOf(e.data) === -1) {
      const i = kt.objectValues(n);
      return (
        De(r, { received: r.data, code: ve.invalid_enum_value, options: i }), rt
      );
    }
    return ii(e.data);
  }
  get enum() {
    return this._def.values;
  }
}
Am.create = (t, e) =>
  new Am({ values: t, typeName: Qe.ZodNativeEnum, ...lt(e) });
class fp extends yt {
  unwrap() {
    return this._def.type;
  }
  _parse(e) {
    const { ctx: n } = this._processInputParams(e);
    if (n.parsedType !== Te.promise && n.common.async === !1)
      return (
        De(n, {
          code: ve.invalid_type,
          expected: Te.promise,
          received: n.parsedType,
        }),
        rt
      );
    const r = n.parsedType === Te.promise ? n.data : Promise.resolve(n.data);
    return ii(
      r.then((i) =>
        this._def.type.parseAsync(i, {
          path: n.path,
          errorMap: n.common.contextualErrorMap,
        })
      )
    );
  }
}
fp.create = (t, e) => new fp({ type: t, typeName: Qe.ZodPromise, ...lt(e) });
class Js extends yt {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === Qe.ZodEffects
      ? this._def.schema.sourceType()
      : this._def.schema;
  }
  _parse(e) {
    const { status: n, ctx: r } = this._processInputParams(e),
      i = this._def.effect || null,
      s = {
        addIssue: (o) => {
          De(r, o), o.fatal ? n.abort() : n.dirty();
        },
        get path() {
          return r.path;
        },
      };
    if (((s.addIssue = s.addIssue.bind(s)), i.type === "preprocess")) {
      const o = i.transform(r.data, s);
      return r.common.issues.length
        ? { status: "dirty", value: r.data }
        : r.common.async
        ? Promise.resolve(o).then((a) =>
            this._def.schema._parseAsync({ data: a, path: r.path, parent: r })
          )
        : this._def.schema._parseSync({ data: o, path: r.path, parent: r });
    }
    if (i.type === "refinement") {
      const o = (a) => {
        const l = i.refinement(a, s);
        if (r.common.async) return Promise.resolve(l);
        if (l instanceof Promise)
          throw new Error(
            "Async refinement encountered during synchronous parse operation. Use .parseAsync instead."
          );
        return a;
      };
      if (r.common.async === !1) {
        const a = this._def.schema._parseSync({
          data: r.data,
          path: r.path,
          parent: r,
        });
        return a.status === "aborted"
          ? rt
          : (a.status === "dirty" && n.dirty(),
            o(a.value),
            { status: n.value, value: a.value });
      } else
        return this._def.schema
          ._parseAsync({ data: r.data, path: r.path, parent: r })
          .then((a) =>
            a.status === "aborted"
              ? rt
              : (a.status === "dirty" && n.dirty(),
                o(a.value).then(() => ({ status: n.value, value: a.value })))
          );
    }
    if (i.type === "transform")
      if (r.common.async === !1) {
        const o = this._def.schema._parseSync({
          data: r.data,
          path: r.path,
          parent: r,
        });
        if (!gm(o)) return o;
        const a = i.transform(o.value, s);
        if (a instanceof Promise)
          throw new Error(
            "Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead."
          );
        return { status: n.value, value: a };
      } else
        return this._def.schema
          ._parseAsync({ data: r.data, path: r.path, parent: r })
          .then((o) =>
            gm(o)
              ? Promise.resolve(i.transform(o.value, s)).then((a) => ({
                  status: n.value,
                  value: a,
                }))
              : o
          );
    kt.assertNever(i);
  }
}
Js.create = (t, e, n) =>
  new Js({ schema: t, typeName: Qe.ZodEffects, effect: e, ...lt(n) });
Js.createWithPreprocess = (t, e, n) =>
  new Js({
    schema: e,
    effect: { type: "preprocess", transform: t },
    typeName: Qe.ZodEffects,
    ...lt(n),
  });
class ba extends yt {
  _parse(e) {
    return this._getType(e) === Te.undefined
      ? ii(void 0)
      : this._def.innerType._parse(e);
  }
  unwrap() {
    return this._def.innerType;
  }
}
ba.create = (t, e) =>
  new ba({ innerType: t, typeName: Qe.ZodOptional, ...lt(e) });
class au extends yt {
  _parse(e) {
    return this._getType(e) === Te.null
      ? ii(null)
      : this._def.innerType._parse(e);
  }
  unwrap() {
    return this._def.innerType;
  }
}
au.create = (t, e) =>
  new au({ innerType: t, typeName: Qe.ZodNullable, ...lt(e) });
class _m extends yt {
  _parse(e) {
    const { ctx: n } = this._processInputParams(e);
    let r = n.data;
    return (
      n.parsedType === Te.undefined && (r = this._def.defaultValue()),
      this._def.innerType._parse({ data: r, path: n.path, parent: n })
    );
  }
  removeDefault() {
    return this._def.innerType;
  }
}
_m.create = (t, e) =>
  new _m({
    innerType: t,
    typeName: Qe.ZodDefault,
    defaultValue: typeof e.default == "function" ? e.default : () => e.default,
    ...lt(e),
  });
class Mw extends yt {
  _parse(e) {
    const { ctx: n } = this._processInputParams(e),
      r = { ...n, common: { ...n.common, issues: [] } },
      i = this._def.innerType._parse({
        data: r.data,
        path: r.path,
        parent: { ...r },
      });
    return Ow(i)
      ? i.then((s) => ({
          status: "valid",
          value:
            s.status === "valid"
              ? s.value
              : this._def.catchValue({
                  get error() {
                    return new Ys(r.common.issues);
                  },
                  input: r.data,
                }),
        }))
      : {
          status: "valid",
          value:
            i.status === "valid"
              ? i.value
              : this._def.catchValue({
                  get error() {
                    return new Ys(r.common.issues);
                  },
                  input: r.data,
                }),
        };
  }
  removeCatch() {
    return this._def.innerType;
  }
}
Mw.create = (t, e) =>
  new Mw({
    innerType: t,
    typeName: Qe.ZodCatch,
    catchValue: typeof e.catch == "function" ? e.catch : () => e.catch,
    ...lt(e),
  });
class Lw extends yt {
  _parse(e) {
    if (this._getType(e) !== Te.nan) {
      const r = this._getOrReturnCtx(e);
      return (
        De(r, {
          code: ve.invalid_type,
          expected: Te.nan,
          received: r.parsedType,
        }),
        rt
      );
    }
    return { status: "valid", value: e.data };
  }
}
Lw.create = (t) => new Lw({ typeName: Qe.ZodNaN, ...lt(t) });
const qfe = Symbol("zod_brand");
class z6 extends yt {
  _parse(e) {
    const { ctx: n } = this._processInputParams(e),
      r = n.data;
    return this._def.type._parse({ data: r, path: n.path, parent: n });
  }
  unwrap() {
    return this._def.type;
  }
}
class ug extends yt {
  _parse(e) {
    const { status: n, ctx: r } = this._processInputParams(e);
    if (r.common.async)
      return (async () => {
        const s = await this._def.in._parseAsync({
          data: r.data,
          path: r.path,
          parent: r,
        });
        return s.status === "aborted"
          ? rt
          : s.status === "dirty"
          ? (n.dirty(), j6(s.value))
          : this._def.out._parseAsync({
              data: s.value,
              path: r.path,
              parent: r,
            });
      })();
    {
      const i = this._def.in._parseSync({
        data: r.data,
        path: r.path,
        parent: r,
      });
      return i.status === "aborted"
        ? rt
        : i.status === "dirty"
        ? (n.dirty(), { status: "dirty", value: i.value })
        : this._def.out._parseSync({ data: i.value, path: r.path, parent: r });
    }
  }
  static create(e, n) {
    return new ug({ in: e, out: n, typeName: Qe.ZodPipeline });
  }
}
class Uw extends yt {
  _parse(e) {
    const n = this._def.innerType._parse(e);
    return gm(n) && (n.value = Object.freeze(n.value)), n;
  }
}
Uw.create = (t, e) =>
  new Uw({ innerType: t, typeName: Qe.ZodReadonly, ...lt(e) });
const W6 = (t, e = {}, n) =>
    t
      ? pp.create().superRefine((r, i) => {
          var s, o;
          if (!t(r)) {
            const a =
                typeof e == "function"
                  ? e(r)
                  : typeof e == "string"
                  ? { message: e }
                  : e,
              l =
                (o = (s = a.fatal) !== null && s !== void 0 ? s : n) !== null &&
                o !== void 0
                  ? o
                  : !0,
              d = typeof a == "string" ? { message: a } : a;
            i.addIssue({ code: "custom", ...d, fatal: l });
          }
        })
      : pp.create(),
  Vfe = { object: Sn.lazycreate };
var Qe;
(function (t) {
  (t.ZodString = "ZodString"),
    (t.ZodNumber = "ZodNumber"),
    (t.ZodNaN = "ZodNaN"),
    (t.ZodBigInt = "ZodBigInt"),
    (t.ZodBoolean = "ZodBoolean"),
    (t.ZodDate = "ZodDate"),
    (t.ZodSymbol = "ZodSymbol"),
    (t.ZodUndefined = "ZodUndefined"),
    (t.ZodNull = "ZodNull"),
    (t.ZodAny = "ZodAny"),
    (t.ZodUnknown = "ZodUnknown"),
    (t.ZodNever = "ZodNever"),
    (t.ZodVoid = "ZodVoid"),
    (t.ZodArray = "ZodArray"),
    (t.ZodObject = "ZodObject"),
    (t.ZodUnion = "ZodUnion"),
    (t.ZodDiscriminatedUnion = "ZodDiscriminatedUnion"),
    (t.ZodIntersection = "ZodIntersection"),
    (t.ZodTuple = "ZodTuple"),
    (t.ZodRecord = "ZodRecord"),
    (t.ZodMap = "ZodMap"),
    (t.ZodSet = "ZodSet"),
    (t.ZodFunction = "ZodFunction"),
    (t.ZodLazy = "ZodLazy"),
    (t.ZodLiteral = "ZodLiteral"),
    (t.ZodEnum = "ZodEnum"),
    (t.ZodEffects = "ZodEffects"),
    (t.ZodNativeEnum = "ZodNativeEnum"),
    (t.ZodOptional = "ZodOptional"),
    (t.ZodNullable = "ZodNullable"),
    (t.ZodDefault = "ZodDefault"),
    (t.ZodCatch = "ZodCatch"),
    (t.ZodPromise = "ZodPromise"),
    (t.ZodBranded = "ZodBranded"),
    (t.ZodPipeline = "ZodPipeline"),
    (t.ZodReadonly = "ZodReadonly");
})(Qe || (Qe = {}));
const Gfe = (t, e = { message: `Input not instance of ${t.name}` }) =>
    W6((n) => n instanceof t, e),
  H6 = Gs.create,
  q6 = Fc.create,
  Kfe = Lw.create,
  Yfe = zc.create,
  V6 = ym.create,
  Zfe = su.create,
  Qfe = kw.create,
  Xfe = wm.create,
  Jfe = vm.create,
  ehe = pp.create,
  the = zl.create,
  nhe = _a.create,
  rhe = Dw.create,
  ihe = Zs.create,
  she = Sn.create,
  ohe = Sn.strictCreate,
  ahe = bm.create,
  che = Vv.create,
  lhe = Em.create,
  uhe = Lo.create,
  dhe = Cm.create,
  phe = $w.create,
  fhe = ou.create,
  hhe = kd.create,
  mhe = xm.create,
  ghe = Sm.create,
  yhe = Wc.create,
  whe = Am.create,
  vhe = fp.create,
  ck = Js.create,
  bhe = ba.create,
  Ehe = au.create,
  Che = Js.createWithPreprocess,
  xhe = ug.create,
  She = () => H6().optional(),
  Ahe = () => q6().optional(),
  _he = () => V6().optional(),
  Ihe = {
    string: (t) => Gs.create({ ...t, coerce: !0 }),
    number: (t) => Fc.create({ ...t, coerce: !0 }),
    boolean: (t) => ym.create({ ...t, coerce: !0 }),
    bigint: (t) => zc.create({ ...t, coerce: !0 }),
    date: (t) => su.create({ ...t, coerce: !0 }),
  },
  The = rt;
var F = Object.freeze({
  __proto__: null,
  defaultErrorMap: mm,
  setErrorMap: Ofe,
  getErrorMap: Rw,
  makeIssue: Nw,
  EMPTY_PATH: kfe,
  addIssueToContext: De,
  ParseStatus: Vr,
  INVALID: rt,
  DIRTY: j6,
  OK: ii,
  isAborted: mS,
  isDirty: gS,
  isValid: gm,
  isAsync: Ow,
  get util() {
    return kt;
  },
  get objectUtil() {
    return hS;
  },
  ZodParsedType: Te,
  getParsedType: gc,
  ZodType: yt,
  ZodString: Gs,
  ZodNumber: Fc,
  ZodBigInt: zc,
  ZodBoolean: ym,
  ZodDate: su,
  ZodSymbol: kw,
  ZodUndefined: wm,
  ZodNull: vm,
  ZodAny: pp,
  ZodUnknown: zl,
  ZodNever: _a,
  ZodVoid: Dw,
  ZodArray: Zs,
  ZodObject: Sn,
  ZodUnion: bm,
  ZodDiscriminatedUnion: Vv,
  ZodIntersection: Em,
  ZodTuple: Lo,
  ZodRecord: Cm,
  ZodMap: $w,
  ZodSet: ou,
  ZodFunction: kd,
  ZodLazy: xm,
  ZodLiteral: Sm,
  ZodEnum: Wc,
  ZodNativeEnum: Am,
  ZodPromise: fp,
  ZodEffects: Js,
  ZodTransformer: Js,
  ZodOptional: ba,
  ZodNullable: au,
  ZodDefault: _m,
  ZodCatch: Mw,
  ZodNaN: Lw,
  BRAND: qfe,
  ZodBranded: z6,
  ZodPipeline: ug,
  ZodReadonly: Uw,
  custom: W6,
  Schema: yt,
  ZodSchema: yt,
  late: Vfe,
  get ZodFirstPartyTypeKind() {
    return Qe;
  },
  coerce: Ihe,
  any: ehe,
  array: ihe,
  bigint: Yfe,
  boolean: V6,
  date: Zfe,
  discriminatedUnion: che,
  effect: ck,
  enum: yhe,
  function: hhe,
  instanceof: Gfe,
  intersection: lhe,
  lazy: mhe,
  literal: ghe,
  map: phe,
  nan: Kfe,
  nativeEnum: whe,
  never: nhe,
  null: Jfe,
  nullable: Ehe,
  number: q6,
  object: she,
  oboolean: _he,
  onumber: Ahe,
  optional: bhe,
  ostring: She,
  pipeline: xhe,
  preprocess: Che,
  promise: vhe,
  record: dhe,
  set: fhe,
  strictObject: ohe,
  string: H6,
  symbol: Qfe,
  transformer: ck,
  tuple: uhe,
  undefined: Xfe,
  union: ahe,
  unknown: the,
  void: rhe,
  NEVER: The,
  ZodIssueCode: ve,
  quotelessJson: Nfe,
  ZodError: Ys,
});
const Pn = F.object({ message: F.string() });
function Oe(t) {
  return F.literal(Me[t]);
}
F.object({
  accessList: F.array(F.string()),
  blockHash: F.string().nullable(),
  blockNumber: F.string().nullable(),
  chainId: F.string().or(F.number()),
  from: F.string(),
  gas: F.string(),
  hash: F.string(),
  input: F.string().nullable(),
  maxFeePerGas: F.string(),
  maxPriorityFeePerGas: F.string(),
  nonce: F.string(),
  r: F.string(),
  s: F.string(),
  to: F.string(),
  transactionIndex: F.string().nullable(),
  type: F.string(),
  v: F.string(),
  value: F.string(),
});
const Phe = F.object({ chainId: F.string().or(F.number()) }),
  Rhe = F.object({ email: F.string().email() }),
  Nhe = F.object({ otp: F.string() }),
  Ohe = F.object({ uri: F.string() }),
  khe = F.object({
    chainId: F.optional(F.string().or(F.number())),
    preferredAccountType: F.optional(F.string()),
  }),
  Dhe = F.object({
    provider: F.enum(["google", "github", "apple", "facebook", "x", "discord"]),
  }),
  $he = F.object({ email: F.string().email() }),
  Mhe = F.object({ otp: F.string() }),
  Lhe = F.object({ otp: F.string() }),
  Uhe = F.object({
    themeMode: F.optional(F.enum(["light", "dark"])),
    themeVariables: F.optional(F.record(F.string(), F.string().or(F.number()))),
    w3mThemeVariables: F.optional(F.record(F.string(), F.string())),
  }),
  Bhe = F.object({
    metadata: F.object({
      name: F.string(),
      description: F.string(),
      url: F.string(),
      icons: F.array(F.string()),
    }).optional(),
    sdkVersion: F.string().optional(),
    sdkType: F.string().optional(),
    projectId: F.string(),
  }),
  jhe = F.object({ type: F.string() }),
  Fhe = F.object({
    action: F.enum(["VERIFY_DEVICE", "VERIFY_OTP", "CONNECT"]),
  }),
  zhe = F.object({ url: F.string() }),
  Whe = F.object({ userName: F.string() }),
  Hhe = F.object({
    email: F.string().optional().nullable(),
    address: F.string(),
    chainId: F.string().or(F.number()),
    accounts: F.array(
      F.object({
        address: F.string(),
        type: F.enum([Rr.ACCOUNT_TYPES.EOA, Rr.ACCOUNT_TYPES.SMART_ACCOUNT]),
      })
    ).optional(),
    userName: F.string().optional().nullable(),
  }),
  qhe = F.object({
    action: F.enum(["VERIFY_PRIMARY_OTP", "VERIFY_SECONDARY_OTP"]),
  }),
  Vhe = F.object({
    email: F.string().email().optional().nullable(),
    address: F.string(),
    chainId: F.string().or(F.number()),
    smartAccountDeployed: F.optional(F.boolean()),
    accounts: F.array(
      F.object({
        address: F.string(),
        type: F.enum([Rr.ACCOUNT_TYPES.EOA, Rr.ACCOUNT_TYPES.SMART_ACCOUNT]),
      })
    ).optional(),
    preferredAccountType: F.optional(F.string()),
  }),
  Ghe = F.object({ uri: F.string() }),
  Khe = F.object({ isConnected: F.boolean() }),
  Yhe = F.object({ chainId: F.string().or(F.number()) }),
  Zhe = F.object({ chainId: F.string().or(F.number()) }),
  Qhe = F.object({ newEmail: F.string().email() }),
  Xhe = F.object({ smartAccountEnabledNetworks: F.array(F.number()) });
F.object({ address: F.string(), isDeployed: F.boolean() });
const Jhe = F.object({ version: F.string().optional() }),
  eme = F.object({ type: F.string(), address: F.string() }),
  tme = F.any(),
  nme = F.object({ method: F.literal("eth_accounts") }),
  rme = F.object({ method: F.literal("eth_blockNumber") }),
  ime = F.object({ method: F.literal("eth_call"), params: F.array(F.any()) }),
  sme = F.object({ method: F.literal("eth_chainId") }),
  ome = F.object({
    method: F.literal("eth_estimateGas"),
    params: F.array(F.any()),
  }),
  ame = F.object({
    method: F.literal("eth_feeHistory"),
    params: F.array(F.any()),
  }),
  cme = F.object({ method: F.literal("eth_gasPrice") }),
  lme = F.object({
    method: F.literal("eth_getAccount"),
    params: F.array(F.any()),
  }),
  ume = F.object({
    method: F.literal("eth_getBalance"),
    params: F.array(F.any()),
  }),
  dme = F.object({
    method: F.literal("eth_getBlockByHash"),
    params: F.array(F.any()),
  }),
  pme = F.object({
    method: F.literal("eth_getBlockByNumber"),
    params: F.array(F.any()),
  }),
  fme = F.object({
    method: F.literal("eth_getBlockReceipts"),
    params: F.array(F.any()),
  }),
  hme = F.object({
    method: F.literal("eth_getBlockTransactionCountByHash"),
    params: F.array(F.any()),
  }),
  mme = F.object({
    method: F.literal("eth_getBlockTransactionCountByNumber"),
    params: F.array(F.any()),
  }),
  gme = F.object({
    method: F.literal("eth_getCode"),
    params: F.array(F.any()),
  }),
  yme = F.object({
    method: F.literal("eth_getFilterChanges"),
    params: F.array(F.any()),
  }),
  wme = F.object({
    method: F.literal("eth_getFilterLogs"),
    params: F.array(F.any()),
  }),
  vme = F.object({
    method: F.literal("eth_getLogs"),
    params: F.array(F.any()),
  }),
  bme = F.object({
    method: F.literal("eth_getProof"),
    params: F.array(F.any()),
  }),
  Eme = F.object({
    method: F.literal("eth_getStorageAt"),
    params: F.array(F.any()),
  }),
  Cme = F.object({
    method: F.literal("eth_getTransactionByBlockHashAndIndex"),
    params: F.array(F.any()),
  }),
  xme = F.object({
    method: F.literal("eth_getTransactionByBlockNumberAndIndex"),
    params: F.array(F.any()),
  }),
  Sme = F.object({
    method: F.literal("eth_getTransactionByHash"),
    params: F.array(F.any()),
  }),
  Ame = F.object({
    method: F.literal("eth_getTransactionCount"),
    params: F.array(F.any()),
  }),
  _me = F.object({
    method: F.literal("eth_getTransactionReceipt"),
    params: F.array(F.any()),
  }),
  Ime = F.object({
    method: F.literal("eth_getUncleCountByBlockHash"),
    params: F.array(F.any()),
  }),
  Tme = F.object({
    method: F.literal("eth_getUncleCountByBlockNumber"),
    params: F.array(F.any()),
  }),
  Pme = F.object({ method: F.literal("eth_maxPriorityFeePerGas") }),
  Rme = F.object({ method: F.literal("eth_newBlockFilter") }),
  Nme = F.object({
    method: F.literal("eth_newFilter"),
    params: F.array(F.any()),
  }),
  Ome = F.object({ method: F.literal("eth_newPendingTransactionFilter") }),
  kme = F.object({
    method: F.literal("eth_sendRawTransaction"),
    params: F.array(F.any()),
  }),
  Dme = F.object({
    method: F.literal("eth_syncing"),
    params: F.array(F.any()),
  }),
  $me = F.object({
    method: F.literal("eth_uninstallFilter"),
    params: F.array(F.any()),
  }),
  lk = F.object({
    method: F.literal("personal_sign"),
    params: F.array(F.any()),
  }),
  Mme = F.object({
    method: F.literal("eth_signTypedData_v4"),
    params: F.array(F.any()),
  }),
  Lme = F.object({
    method: F.literal("eth_sendTransaction"),
    params: F.array(F.any()),
  }),
  Ume = F.object({
    method: F.literal("solana_signMessage"),
    params: F.object({ message: F.string(), pubkey: F.string() }),
  }),
  Bme = F.object({
    method: F.literal("solana_signTransaction"),
    params: F.object({ transaction: F.string() }),
  }),
  jme = F.object({
    method: F.literal("solana_signAllTransactions"),
    params: F.object({ transactions: F.array(F.string()) }),
  }),
  Fme = F.object({
    method: F.literal("solana_signAndSendTransaction"),
    params: F.object({
      transaction: F.string(),
      options: F.object({
        skipPreflight: F.boolean().optional(),
        preflightCommitment: F.enum([
          "processed",
          "confirmed",
          "finalized",
          "recent",
          "single",
          "singleGossip",
          "root",
          "max",
        ]).optional(),
        maxRetries: F.number().optional(),
        minContextSlot: F.number().optional(),
      }).optional(),
    }),
  }),
  zme = F.object({
    method: F.literal("wallet_sendCalls"),
    params: F.array(
      F.object({
        chainId: F.string().or(F.number()).optional(),
        from: F.string().optional(),
        version: F.string().optional(),
        capabilities: F.any().optional(),
        calls: F.array(
          F.object({
            to: F.string().startsWith("0x"),
            data: F.string().startsWith("0x").optional(),
            value: F.string().optional(),
          })
        ),
      })
    ),
  }),
  Wme = F.object({
    method: F.literal("wallet_getCallsStatus"),
    params: F.array(F.string()),
  }),
  Hme = F.object({ method: F.literal("wallet_getCapabilities") }),
  qme = F.object({
    method: F.literal("wallet_grantPermissions"),
    params: F.array(F.any()),
  }),
  Vme = F.object({
    method: F.literal("wallet_revokePermissions"),
    params: F.any(),
  }),
  Gme = F.object({ method: F.literal("wallet_getAssets"), params: F.any() }),
  uk = F.object({ token: F.string() }),
  ke = F.object({ id: F.string().optional() }),
  Yf = {
    appEvent: ke
      .extend({ type: Oe("APP_SWITCH_NETWORK"), payload: Phe })
      .or(ke.extend({ type: Oe("APP_CONNECT_EMAIL"), payload: Rhe }))
      .or(ke.extend({ type: Oe("APP_CONNECT_DEVICE") }))
      .or(ke.extend({ type: Oe("APP_CONNECT_OTP"), payload: Nhe }))
      .or(ke.extend({ type: Oe("APP_CONNECT_SOCIAL"), payload: Ohe }))
      .or(ke.extend({ type: Oe("APP_GET_FARCASTER_URI") }))
      .or(ke.extend({ type: Oe("APP_CONNECT_FARCASTER") }))
      .or(ke.extend({ type: Oe("APP_GET_USER"), payload: F.optional(khe) }))
      .or(ke.extend({ type: Oe("APP_GET_SOCIAL_REDIRECT_URI"), payload: Dhe }))
      .or(ke.extend({ type: Oe("APP_SIGN_OUT") }))
      .or(ke.extend({ type: Oe("APP_IS_CONNECTED"), payload: F.optional(uk) }))
      .or(ke.extend({ type: Oe("APP_GET_CHAIN_ID") }))
      .or(ke.extend({ type: Oe("APP_GET_SMART_ACCOUNT_ENABLED_NETWORKS") }))
      .or(ke.extend({ type: Oe("APP_INIT_SMART_ACCOUNT") }))
      .or(ke.extend({ type: Oe("APP_SET_PREFERRED_ACCOUNT"), payload: jhe }))
      .or(
        ke.extend({
          type: Oe("APP_RPC_REQUEST"),
          payload: lk
            .or(Gme)
            .or(nme)
            .or(rme)
            .or(ime)
            .or(sme)
            .or(ome)
            .or(ame)
            .or(cme)
            .or(lme)
            .or(ume)
            .or(dme)
            .or(pme)
            .or(fme)
            .or(hme)
            .or(mme)
            .or(gme)
            .or(yme)
            .or(wme)
            .or(vme)
            .or(bme)
            .or(Eme)
            .or(Cme)
            .or(xme)
            .or(Sme)
            .or(Ame)
            .or(_me)
            .or(Ime)
            .or(Tme)
            .or(Pme)
            .or(Rme)
            .or(Nme)
            .or(Ome)
            .or(kme)
            .or(Dme)
            .or($me)
            .or(lk)
            .or(Mme)
            .or(Lme)
            .or(Ume)
            .or(Bme)
            .or(jme)
            .or(Fme)
            .or(Wme)
            .or(zme)
            .or(Hme)
            .or(qme)
            .or(Vme),
        })
      )
      .or(ke.extend({ type: Oe("APP_UPDATE_EMAIL"), payload: $he }))
      .or(ke.extend({ type: Oe("APP_UPDATE_EMAIL_PRIMARY_OTP"), payload: Mhe }))
      .or(
        ke.extend({ type: Oe("APP_UPDATE_EMAIL_SECONDARY_OTP"), payload: Lhe })
      )
      .or(ke.extend({ type: Oe("APP_SYNC_THEME"), payload: Uhe }))
      .or(ke.extend({ type: Oe("APP_SYNC_DAPP_DATA"), payload: Bhe }))
      .or(ke.extend({ type: Oe("APP_RELOAD") })),
    frameEvent: ke
      .extend({ type: Oe("FRAME_SWITCH_NETWORK_ERROR"), payload: Pn })
      .or(ke.extend({ type: Oe("FRAME_SWITCH_NETWORK_SUCCESS"), payload: Zhe }))
      .or(ke.extend({ type: Oe("FRAME_CONNECT_EMAIL_SUCCESS"), payload: Fhe }))
      .or(ke.extend({ type: Oe("FRAME_CONNECT_EMAIL_ERROR"), payload: Pn }))
      .or(
        ke.extend({ type: Oe("FRAME_GET_FARCASTER_URI_SUCCESS"), payload: zhe })
      )
      .or(ke.extend({ type: Oe("FRAME_GET_FARCASTER_URI_ERROR"), payload: Pn }))
      .or(
        ke.extend({ type: Oe("FRAME_CONNECT_FARCASTER_SUCCESS"), payload: Whe })
      )
      .or(ke.extend({ type: Oe("FRAME_CONNECT_FARCASTER_ERROR"), payload: Pn }))
      .or(ke.extend({ type: Oe("FRAME_CONNECT_OTP_ERROR"), payload: Pn }))
      .or(ke.extend({ type: Oe("FRAME_CONNECT_OTP_SUCCESS") }))
      .or(ke.extend({ type: Oe("FRAME_CONNECT_DEVICE_ERROR"), payload: Pn }))
      .or(ke.extend({ type: Oe("FRAME_CONNECT_DEVICE_SUCCESS") }))
      .or(ke.extend({ type: Oe("FRAME_CONNECT_SOCIAL_SUCCESS"), payload: Hhe }))
      .or(ke.extend({ type: Oe("FRAME_CONNECT_SOCIAL_ERROR"), payload: Pn }))
      .or(ke.extend({ type: Oe("FRAME_GET_USER_ERROR"), payload: Pn }))
      .or(ke.extend({ type: Oe("FRAME_GET_USER_SUCCESS"), payload: Vhe }))
      .or(
        ke.extend({
          type: Oe("FRAME_GET_SOCIAL_REDIRECT_URI_ERROR"),
          payload: Pn,
        })
      )
      .or(
        ke.extend({
          type: Oe("FRAME_GET_SOCIAL_REDIRECT_URI_SUCCESS"),
          payload: Ghe,
        })
      )
      .or(ke.extend({ type: Oe("FRAME_SIGN_OUT_ERROR"), payload: Pn }))
      .or(ke.extend({ type: Oe("FRAME_SIGN_OUT_SUCCESS") }))
      .or(ke.extend({ type: Oe("FRAME_IS_CONNECTED_ERROR"), payload: Pn }))
      .or(ke.extend({ type: Oe("FRAME_IS_CONNECTED_SUCCESS"), payload: Khe }))
      .or(ke.extend({ type: Oe("FRAME_GET_CHAIN_ID_ERROR"), payload: Pn }))
      .or(ke.extend({ type: Oe("FRAME_GET_CHAIN_ID_SUCCESS"), payload: Yhe }))
      .or(ke.extend({ type: Oe("FRAME_RPC_REQUEST_ERROR"), payload: Pn }))
      .or(ke.extend({ type: Oe("FRAME_RPC_REQUEST_SUCCESS"), payload: tme }))
      .or(ke.extend({ type: Oe("FRAME_SESSION_UPDATE"), payload: uk }))
      .or(ke.extend({ type: Oe("FRAME_UPDATE_EMAIL_ERROR"), payload: Pn }))
      .or(ke.extend({ type: Oe("FRAME_UPDATE_EMAIL_SUCCESS"), payload: qhe }))
      .or(
        ke.extend({
          type: Oe("FRAME_UPDATE_EMAIL_PRIMARY_OTP_ERROR"),
          payload: Pn,
        })
      )
      .or(ke.extend({ type: Oe("FRAME_UPDATE_EMAIL_PRIMARY_OTP_SUCCESS") }))
      .or(
        ke.extend({
          type: Oe("FRAME_UPDATE_EMAIL_SECONDARY_OTP_ERROR"),
          payload: Pn,
        })
      )
      .or(
        ke.extend({
          type: Oe("FRAME_UPDATE_EMAIL_SECONDARY_OTP_SUCCESS"),
          payload: Qhe,
        })
      )
      .or(ke.extend({ type: Oe("FRAME_SYNC_THEME_ERROR"), payload: Pn }))
      .or(ke.extend({ type: Oe("FRAME_SYNC_THEME_SUCCESS") }))
      .or(ke.extend({ type: Oe("FRAME_SYNC_DAPP_DATA_ERROR"), payload: Pn }))
      .or(ke.extend({ type: Oe("FRAME_SYNC_DAPP_DATA_SUCCESS") }))
      .or(
        ke.extend({
          type: Oe("FRAME_GET_SMART_ACCOUNT_ENABLED_NETWORKS_SUCCESS"),
          payload: Xhe,
        })
      )
      .or(
        ke.extend({
          type: Oe("FRAME_GET_SMART_ACCOUNT_ENABLED_NETWORKS_ERROR"),
          payload: Pn,
        })
      )
      .or(
        ke.extend({ type: Oe("FRAME_INIT_SMART_ACCOUNT_ERROR"), payload: Pn })
      )
      .or(
        ke.extend({
          type: Oe("FRAME_SET_PREFERRED_ACCOUNT_SUCCESS"),
          payload: eme,
        })
      )
      .or(
        ke.extend({
          type: Oe("FRAME_SET_PREFERRED_ACCOUNT_ERROR"),
          payload: Pn,
        })
      )
      .or(ke.extend({ type: Oe("FRAME_READY"), payload: Jhe }))
      .or(ke.extend({ type: Oe("FRAME_RELOAD_ERROR"), payload: Pn }))
      .or(ke.extend({ type: Oe("FRAME_RELOAD_SUCCESS") })),
  };
function gC(t, e = {}) {
  var n;
  return (
    typeof (e == null ? void 0 : e.type) == "string" &&
    ((n = e == null ? void 0 : e.type) == null ? void 0 : n.includes(t))
  );
}
class Kme {
  constructor({
    projectId: e,
    isAppClient: n = !1,
    chainId: r = "eip155:1",
    enableLogger: i = !0,
  }) {
    if (
      ((this.iframe = null),
      (this.iframeIsReady = !1),
      (this.rpcUrl = ye.BLOCKCHAIN_API_RPC_URL),
      (this.initFrame = () => {
        const s = document.getElementById("w3m-iframe");
        this.iframe && !s && document.body.appendChild(this.iframe);
      }),
      (this.events = {
        registerFrameEventHandler: (s, o, a) => {
          function l({ data: d }) {
            if (!gC(Me.FRAME_EVENT_KEY, d)) return;
            const p = Yf.frameEvent.parse(d);
            p.id === s && (o(p), window.removeEventListener("message", l));
          }
          Fi.isClient &&
            (window.addEventListener("message", l),
            a.addEventListener("abort", () => {
              window.removeEventListener("message", l);
            }));
        },
        onFrameEvent: (s) => {
          Fi.isClient &&
            window.addEventListener("message", ({ data: o }) => {
              if (!gC(Me.FRAME_EVENT_KEY, o)) return;
              const a = Yf.frameEvent.parse(o);
              s(a);
            });
        },
        onAppEvent: (s) => {
          Fi.isClient &&
            window.addEventListener("message", ({ data: o }) => {
              if (!gC(Me.APP_EVENT_KEY, o)) return;
              const a = Yf.appEvent.parse(o);
              s(a);
            });
        },
        postAppEvent: (s) => {
          var o;
          if (Fi.isClient) {
            if (!((o = this.iframe) != null && o.contentWindow))
              throw new Error("W3mFrame: iframe is not set");
            Yf.appEvent.parse(s), this.iframe.contentWindow.postMessage(s, "*");
          }
        },
        postFrameEvent: (s) => {
          if (Fi.isClient) {
            if (!parent) throw new Error("W3mFrame: parent is not set");
            Yf.frameEvent.parse(s), parent.postMessage(s, "*");
          }
        },
      }),
      (this.projectId = e),
      (this.frameLoadPromise = new Promise((s, o) => {
        this.frameLoadPromiseResolver = { resolve: s, reject: o };
      })),
      n &&
        ((this.frameLoadPromise = new Promise((s, o) => {
          this.frameLoadPromiseResolver = { resolve: s, reject: o };
        })),
        Fi.isClient))
    ) {
      const s = document.createElement("iframe");
      (s.id = "w3m-iframe"),
        (s.src = `${tue}?projectId=${e}&chainId=${r}&version=${rue}&enableLogger=${i}`),
        (s.name = "w3m-secure-iframe"),
        (s.style.position = "fixed"),
        (s.style.zIndex = "999999"),
        (s.style.display = "none"),
        (s.style.border = "none"),
        (s.style.animationDelay = "0s, 50ms"),
        (s.style.borderBottomLeftRadius =
          "clamp(0px, var(--wui-border-radius-l), 44px)"),
        (s.style.borderBottomRightRadius =
          "clamp(0px, var(--wui-border-radius-l), 44px)"),
        (this.iframe = s),
        (this.iframe.onerror = () => {
          var o;
          (o = this.frameLoadPromiseResolver) == null ||
            o.reject("Unable to load email login dependency");
        }),
        this.events.onFrameEvent((o) => {
          var a;
          o.type === "@w3m-frame/READY" &&
            ((this.iframeIsReady = !0),
            (a = this.frameLoadPromiseResolver) == null || a.resolve(void 0));
        });
    }
  }
  get networks() {
    const e = [
      "eip155:1",
      "eip155:5",
      "eip155:11155111",
      "eip155:10",
      "eip155:420",
      "eip155:42161",
      "eip155:421613",
      "eip155:137",
      "eip155:80001",
      "eip155:42220",
      "eip155:1313161554",
      "eip155:1313161555",
      "eip155:56",
      "eip155:97",
      "eip155:43114",
      "eip155:43113",
      "eip155:324",
      "eip155:280",
      "eip155:100",
      "eip155:8453",
      "eip155:84531",
      "eip155:84532",
      "eip155:7777777",
      "eip155:999",
      "solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp",
      "solana:4uhcVJyU9pJkvQyS88uRDiswHXSCkY3z",
      "solana:EtWTRABZaYq6iMfeYKouRu166VU2xqa1",
    ].map((n) => ({
      [n]: {
        rpcUrl: `${this.rpcUrl}/v1/?chainId=${n}&projectId=${this.projectId}`,
        chainId: n,
      },
    }));
    return Object.assign({}, ...e);
  }
}
class Yme {
  constructor(e) {
    var s;
    const n = _p({ level: nue }),
      { logger: r, chunkLoggerController: i } = yA({ opts: n });
    (this.logger = Gr(r, this.constructor.name)),
      (this.chunkLoggerController = i),
      typeof window < "u" &&
        (s = this.chunkLoggerController) != null &&
        s.downloadLogsBlobInBrowser &&
        (window.downloadAppKitLogsBlob || (window.downloadAppKitLogsBlob = {}),
        (window.downloadAppKitLogsBlob.sdk = () => {
          var o;
          (o = this.chunkLoggerController) != null &&
            o.downloadLogsBlobInBrowser &&
            this.chunkLoggerController.downloadLogsBlobInBrowser({
              projectId: e,
            });
        }));
  }
}
class Zme {
  constructor({
    projectId: e,
    chainId: n,
    enableLogger: r = !0,
    onTimeout: i,
    abortController: s,
  }) {
    (this.openRpcRequests = []),
      r && (this.w3mLogger = new Yme(e)),
      (this.abortController = s),
      (this.w3mFrame = new Kme({
        projectId: e,
        isAppClient: !0,
        chainId: n,
        enableLogger: r,
      })),
      (this.onTimeout = i),
      this.getLoginEmailUsed() && this.w3mFrame.initFrame(),
      (this.initPromise = new Promise((o) => {
        this.w3mFrame.events.onFrameEvent(async (a) => {
          a.type === Me.FRAME_READY &&
            ((this.initPromise = void 0),
            await new Promise((l) => {
              setTimeout(l, 500);
            }),
            o());
        });
      }));
  }
  async init() {
    this.w3mFrame.initFrame(), this.initPromise && (await this.initPromise);
  }
  getLoginEmailUsed() {
    return !!_r.get(Me.EMAIL_LOGIN_USED_KEY);
  }
  getEmail() {
    return _r.get(Me.EMAIL);
  }
  getUsername() {
    return _r.get(Me.SOCIAL_USERNAME);
  }
  async reload() {
    var e;
    try {
      this.w3mFrame.initFrame(), await this.appEvent({ type: Me.APP_RELOAD });
    } catch (n) {
      throw (
        ((e = this.w3mLogger) == null ||
          e.logger.error({ error: n }, "Error reloading iframe"),
        n)
      );
    }
  }
  async connectEmail(e) {
    var n;
    try {
      Fi.checkIfAllowedToTriggerEmail(), this.w3mFrame.initFrame();
      const r = await this.appEvent({ type: Me.APP_CONNECT_EMAIL, payload: e });
      return this.setNewLastEmailLoginTime(), r;
    } catch (r) {
      throw (
        ((n = this.w3mLogger) == null ||
          n.logger.error({ error: r }, "Error connecting email"),
        r)
      );
    }
  }
  async connectDevice() {
    var e;
    try {
      return this.appEvent({ type: Me.APP_CONNECT_DEVICE });
    } catch (n) {
      throw (
        ((e = this.w3mLogger) == null ||
          e.logger.error({ error: n }, "Error connecting device"),
        n)
      );
    }
  }
  async connectOtp(e) {
    var n;
    try {
      return this.appEvent({ type: Me.APP_CONNECT_OTP, payload: e });
    } catch (r) {
      throw (
        ((n = this.w3mLogger) == null ||
          n.logger.error({ error: r }, "Error connecting otp"),
        r)
      );
    }
  }
  async isConnected() {
    var e;
    try {
      if (!this.getLoginEmailUsed()) return { isConnected: !1 };
      const n = await this.appEvent({ type: Me.APP_IS_CONNECTED });
      return (n != null && n.isConnected) || this.deleteAuthLoginCache(), n;
    } catch (n) {
      throw (
        (this.deleteAuthLoginCache(),
        (e = this.w3mLogger) == null ||
          e.logger.error({ error: n }, "Error checking connection"),
        n)
      );
    }
  }
  async getChainId() {
    var e;
    try {
      const n = await this.appEvent({ type: Me.APP_GET_CHAIN_ID });
      return this.setLastUsedChainId(n.chainId), n;
    } catch (n) {
      throw (
        ((e = this.w3mLogger) == null ||
          e.logger.error({ error: n }, "Error getting chain id"),
        n)
      );
    }
  }
  async getSocialRedirectUri(e) {
    var n;
    try {
      return (
        this.w3mFrame.initFrame(),
        this.appEvent({ type: Me.APP_GET_SOCIAL_REDIRECT_URI, payload: e })
      );
    } catch (r) {
      throw (
        ((n = this.w3mLogger) == null ||
          n.logger.error({ error: r }, "Error getting social redirect uri"),
        r)
      );
    }
  }
  async updateEmail(e) {
    var n;
    try {
      const r = await this.appEvent({ type: Me.APP_UPDATE_EMAIL, payload: e });
      return this.setNewLastEmailLoginTime(), r;
    } catch (r) {
      throw (
        ((n = this.w3mLogger) == null ||
          n.logger.error({ error: r }, "Error updating email"),
        r)
      );
    }
  }
  async updateEmailPrimaryOtp(e) {
    var n;
    try {
      return this.appEvent({
        type: Me.APP_UPDATE_EMAIL_PRIMARY_OTP,
        payload: e,
      });
    } catch (r) {
      throw (
        ((n = this.w3mLogger) == null ||
          n.logger.error({ error: r }, "Error updating email primary otp"),
        r)
      );
    }
  }
  async updateEmailSecondaryOtp(e) {
    var n;
    try {
      const r = await this.appEvent({
        type: Me.APP_UPDATE_EMAIL_SECONDARY_OTP,
        payload: e,
      });
      return this.setLoginSuccess(r.newEmail), r;
    } catch (r) {
      throw (
        ((n = this.w3mLogger) == null ||
          n.logger.error({ error: r }, "Error updating email secondary otp"),
        r)
      );
    }
  }
  async syncTheme(e) {
    var n;
    try {
      return this.appEvent({ type: Me.APP_SYNC_THEME, payload: e });
    } catch (r) {
      throw (
        ((n = this.w3mLogger) == null ||
          n.logger.error({ error: r }, "Error syncing theme"),
        r)
      );
    }
  }
  async syncDappData(e) {
    var n;
    try {
      return this.appEvent({ type: Me.APP_SYNC_DAPP_DATA, payload: e });
    } catch (r) {
      throw (
        ((n = this.w3mLogger) == null ||
          n.logger.error({ error: r }, "Error syncing dapp data"),
        r)
      );
    }
  }
  async getSmartAccountEnabledNetworks() {
    var e;
    try {
      const n = await this.appEvent({
        type: Me.APP_GET_SMART_ACCOUNT_ENABLED_NETWORKS,
      });
      return (
        this.persistSmartAccountEnabledNetworks(n.smartAccountEnabledNetworks),
        n
      );
    } catch (n) {
      throw (
        (this.persistSmartAccountEnabledNetworks([]),
        (e = this.w3mLogger) == null ||
          e.logger.error(
            { error: n },
            "Error getting smart account enabled networks"
          ),
        n)
      );
    }
  }
  async setPreferredAccount(e) {
    var n;
    try {
      return this.appEvent({
        type: Me.APP_SET_PREFERRED_ACCOUNT,
        payload: { type: e },
      });
    } catch (r) {
      throw (
        ((n = this.w3mLogger) == null ||
          n.logger.error({ error: r }, "Error setting preferred account"),
        r)
      );
    }
  }
  async connect(e) {
    var n;
    try {
      const r =
          (e == null ? void 0 : e.chainId) || this.getLastUsedChainId() || 1,
        i = await this.getUser({
          chainId: r,
          preferredAccountType: e == null ? void 0 : e.preferredAccountType,
        });
      return (
        this.setLoginSuccess(i.email),
        this.setLastUsedChainId(i.chainId),
        (this.user = i),
        i
      );
    } catch (r) {
      throw (
        ((n = this.w3mLogger) == null ||
          n.logger.error({ error: r }, "Error connecting"),
        r)
      );
    }
  }
  async getUser(e) {
    var n;
    try {
      const r =
          (e == null ? void 0 : e.chainId) || this.getLastUsedChainId() || 1,
        i = await this.appEvent({
          type: Me.APP_GET_USER,
          payload: { ...e, chainId: r },
        });
      return (this.user = i), i;
    } catch (r) {
      throw (
        ((n = this.w3mLogger) == null ||
          n.logger.error({ error: r }, "Error connecting"),
        r)
      );
    }
  }
  async connectSocial(e) {
    var n;
    try {
      this.w3mFrame.initFrame();
      const r = await this.appEvent({
        type: Me.APP_CONNECT_SOCIAL,
        payload: { uri: e },
      });
      return r.userName && this.setSocialLoginSuccess(r.userName), r;
    } catch (r) {
      throw (
        ((n = this.w3mLogger) == null ||
          n.logger.error({ error: r }, "Error connecting social"),
        r)
      );
    }
  }
  async getFarcasterUri() {
    var e;
    try {
      return (
        this.w3mFrame.initFrame(),
        await this.appEvent({ type: Me.APP_GET_FARCASTER_URI })
      );
    } catch (n) {
      throw (
        ((e = this.w3mLogger) == null ||
          e.logger.error({ error: n }, "Error getting farcaster uri"),
        n)
      );
    }
  }
  async connectFarcaster() {
    var e;
    try {
      const n = await this.appEvent({ type: Me.APP_CONNECT_FARCASTER });
      return n.userName && this.setSocialLoginSuccess(n.userName), n;
    } catch (n) {
      throw (
        ((e = this.w3mLogger) == null ||
          e.logger.error({ error: n }, "Error connecting farcaster"),
        n)
      );
    }
  }
  async switchNetwork(e) {
    var n;
    try {
      const r = await this.appEvent({
        type: Me.APP_SWITCH_NETWORK,
        payload: { chainId: e },
      });
      return this.setLastUsedChainId(r.chainId), r;
    } catch (r) {
      throw (
        ((n = this.w3mLogger) == null ||
          n.logger.error({ error: r }, "Error switching network"),
        r)
      );
    }
  }
  async disconnect() {
    var e;
    try {
      const n = await this.appEvent({ type: Me.APP_SIGN_OUT });
      return this.deleteAuthLoginCache(), n;
    } catch (n) {
      throw (
        ((e = this.w3mLogger) == null ||
          e.logger.error({ error: n }, "Error disconnecting"),
        n)
      );
    }
  }
  async request(e) {
    var n, r, i, s;
    try {
      if (Rr.GET_CHAIN_ID === e.method) return this.getLastUsedChainId();
      (n = this.rpcRequestHandler) == null || n.call(this, e);
      const o = await this.appEvent({ type: Me.APP_RPC_REQUEST, payload: e });
      return (r = this.rpcSuccessHandler) == null || r.call(this, o, e), o;
    } catch (o) {
      throw (
        ((i = this.rpcErrorHandler) == null || i.call(this, o, e),
        (s = this.w3mLogger) == null ||
          s.logger.error({ error: o }, "Error requesting"),
        o)
      );
    }
  }
  onRpcRequest(e) {
    this.rpcRequestHandler = e;
  }
  onRpcSuccess(e) {
    this.rpcSuccessHandler = e;
  }
  onRpcError(e) {
    this.rpcErrorHandler = e;
  }
  onIsConnected(e) {
    this.w3mFrame.events.onFrameEvent((n) => {
      n.type === Me.FRAME_IS_CONNECTED_SUCCESS && n.payload.isConnected && e();
    });
  }
  onNotConnected(e) {
    this.w3mFrame.events.onFrameEvent((n) => {
      n.type === Me.FRAME_IS_CONNECTED_ERROR && e(),
        n.type === Me.FRAME_IS_CONNECTED_SUCCESS &&
          !n.payload.isConnected &&
          e();
    });
  }
  onConnect(e) {
    this.w3mFrame.events.onFrameEvent((n) => {
      n.type === Me.FRAME_GET_USER_SUCCESS && e(n.payload);
    });
  }
  onSocialConnected(e) {
    this.w3mFrame.events.onFrameEvent((n) => {
      n.type === Me.FRAME_CONNECT_SOCIAL_SUCCESS && e(n.payload);
    });
  }
  async getCapabilities() {
    try {
      return (await this.request({ method: "wallet_getCapabilities" })) || {};
    } catch {
      return {};
    }
  }
  onSetPreferredAccount(e) {
    this.w3mFrame.events.onFrameEvent((n) => {
      n.type === Me.FRAME_SET_PREFERRED_ACCOUNT_SUCCESS
        ? e(n.payload)
        : n.type === Me.FRAME_SET_PREFERRED_ACCOUNT_ERROR &&
          e({ type: Rr.ACCOUNT_TYPES.EOA });
    });
  }
  onGetSmartAccountEnabledNetworks(e) {
    this.w3mFrame.events.onFrameEvent((n) => {
      n.type === Me.FRAME_GET_SMART_ACCOUNT_ENABLED_NETWORKS_SUCCESS
        ? e(n.payload.smartAccountEnabledNetworks)
        : n.type === Me.FRAME_GET_SMART_ACCOUNT_ENABLED_NETWORKS_ERROR && e([]);
    });
  }
  getAvailableChainIds() {
    return Object.keys(this.w3mFrame.networks);
  }
  rejectRpcRequests() {
    var e;
    try {
      this.openRpcRequests.forEach(({ abortController: n, method: r }) => {
        Rr.SAFE_RPC_METHODS.includes(r) || n.abort();
      }),
        (this.openRpcRequests = []);
    } catch (n) {
      (e = this.w3mLogger) == null ||
        e.logger.error({ error: n }, "Error aborting RPC request");
    }
  }
  async appEvent(e) {
    let n, r;
    function i(l) {
      return l.replace("@w3m-app/", "");
    }
    const s = [
        Me.APP_SYNC_DAPP_DATA,
        Me.APP_SYNC_THEME,
        Me.APP_SET_PREFERRED_ACCOUNT,
      ],
      o = i(e.type);
    return (
      !this.w3mFrame.iframeIsReady &&
        !s.includes(e.type) &&
        (r = setTimeout(() => {
          var l;
          (l = this.onTimeout) == null || l.call(this, "iframe_load_failed"),
            this.abortController.abort();
        }, 2e4)),
      await this.w3mFrame.frameLoadPromise,
      clearTimeout(r),
      [
        Me.APP_CONNECT_EMAIL,
        Me.APP_CONNECT_DEVICE,
        Me.APP_CONNECT_OTP,
        Me.APP_CONNECT_SOCIAL,
        Me.APP_GET_SOCIAL_REDIRECT_URI,
      ]
        .map(i)
        .includes(o) &&
        (n = setTimeout(() => {
          var l;
          (l = this.onTimeout) == null ||
            l.call(this, "iframe_request_timeout"),
            this.abortController.abort();
        }, 3e4)),
      new Promise((l, d) => {
        var y, g, v;
        const p = Math.random().toString(36).substring(7);
        (v = (y = this.w3mLogger) == null ? void 0 : (g = y.logger).info) ==
          null || v.call(g, { event: e, id: p }, "Sending app event"),
          this.w3mFrame.events.postAppEvent({ ...e, id: p });
        const f = new AbortController();
        if (o === "RPC_REQUEST") {
          const b = e;
          this.openRpcRequests = [
            ...this.openRpcRequests,
            { ...b.payload, abortController: f },
          ];
        }
        f.signal.addEventListener("abort", () => {
          o === "RPC_REQUEST"
            ? d(new Error("Request was aborted"))
            : o !== "GET_FARCASTER_URI" && d(new Error("Something went wrong"));
        });
        function m(b, E) {
          var S, C, _;
          b.id === p &&
            ((C = E == null ? void 0 : (S = E.logger).info) == null ||
              C.call(S, { framEvent: b, id: p }, "Received frame response"),
            b.type === `@w3m-frame/${o}_SUCCESS`
              ? (n && clearTimeout(n),
                r && clearTimeout(r),
                "payload" in b && l(b.payload),
                l(void 0))
              : b.type === `@w3m-frame/${o}_ERROR` &&
                (n && clearTimeout(n),
                r && clearTimeout(r),
                "payload" in b &&
                  d(
                    new Error(
                      ((_ = b.payload) == null ? void 0 : _.message) ||
                        "An error occurred"
                    )
                  ),
                d(new Error("An error occurred"))));
        }
        this.w3mFrame.events.registerFrameEventHandler(
          p,
          (b) => m(b, this.w3mLogger),
          this.abortController.signal
        );
      })
    );
  }
  setNewLastEmailLoginTime() {
    _r.set(Me.LAST_EMAIL_LOGIN_TIME, Date.now().toString());
  }
  setSocialLoginSuccess(e) {
    _r.set(Me.SOCIAL_USERNAME, e);
  }
  setLoginSuccess(e) {
    e && _r.set(Me.EMAIL, e),
      _r.set(Me.EMAIL_LOGIN_USED_KEY, "true"),
      _r.delete(Me.LAST_EMAIL_LOGIN_TIME);
  }
  deleteAuthLoginCache() {
    _r.delete(Me.EMAIL_LOGIN_USED_KEY),
      _r.delete(Me.EMAIL),
      _r.delete(Me.LAST_USED_CHAIN_KEY),
      _r.delete(Me.SOCIAL_USERNAME);
  }
  setLastUsedChainId(e) {
    e && _r.set(Me.LAST_USED_CHAIN_KEY, String(e));
  }
  getLastUsedChainId() {
    const e = _r.get(Me.LAST_USED_CHAIN_KEY) ?? void 0,
      n = Number(e);
    return isNaN(n) ? e : n;
  }
  persistSmartAccountEnabledNetworks(e) {
    _r.set(Me.SMART_ACCOUNT_ENABLED_NETWORKS, e.join(","));
  }
}
class Wl {
  constructor() {}
  static getInstance({
    projectId: e,
    chainId: n,
    enableLogger: r,
    onTimeout: i,
    abortController: s,
  }) {
    return (
      Wl.instance ||
        (Wl.instance = new Zme({
          projectId: e,
          chainId: n,
          enableLogger: r,
          onTimeout: i,
          abortController: s,
        })),
      Wl.instance
    );
  }
}
var dk = {};
const Qme = {
    ACCOUNT_TABS: [
      { label: "Tokens" },
      { label: "NFTs" },
      { label: "Activity" },
    ],
    SECURE_SITE_ORIGIN:
      (typeof process < "u" && typeof dk < "u"
        ? dk.NEXT_PUBLIC_SECURE_SITE_ORIGIN
        : void 0) || "https://secure.walletconnect.org",
    VIEW_DIRECTION: { Next: "next", Prev: "prev" },
    DEFAULT_CONNECT_METHOD_ORDER: ["email", "social", "wallet"],
    ANIMATION_DURATIONS: {
      HeaderText: 120,
      ModalHeight: 150,
      ViewTransition: 150,
    },
  },
  wS = {
    filterOutDuplicatesByRDNS(t) {
      const e = me.state.enableEIP6963 ? nt.state.connectors : [],
        n = Ie.getRecentWallets(),
        r = e
          .map((a) => {
            var l;
            return (l = a.info) == null ? void 0 : l.rdns;
          })
          .filter(Boolean),
        i = n.map((a) => a.rdns).filter(Boolean),
        s = r.concat(i);
      if (s.includes("io.metamask.mobile") && Je.isMobile()) {
        const a = s.indexOf("io.metamask.mobile");
        s[a] = "io.metamask";
      }
      return t.filter((a) => !s.includes(String(a == null ? void 0 : a.rdns)));
    },
    filterOutDuplicatesByIds(t) {
      const e = nt.state.connectors.filter(
          (a) => a.type === "ANNOUNCED" || a.type === "INJECTED"
        ),
        n = Ie.getRecentWallets(),
        r = e.map((a) => a.explorerId),
        i = n.map((a) => a.id),
        s = r.concat(i);
      return t.filter((a) => !s.includes(a == null ? void 0 : a.id));
    },
    filterOutDuplicateWallets(t) {
      const e = this.filterOutDuplicatesByRDNS(t);
      return this.filterOutDuplicatesByIds(e);
    },
    markWalletsAsInstalled(t) {
      const { connectors: e } = nt.state,
        n = e
          .filter((s) => s.type === "ANNOUNCED")
          .reduce((s, o) => {
            var a;
            return (a = o.info) != null && a.rdns && (s[o.info.rdns] = !0), s;
          }, {});
      return t
        .map((s) => ({ ...s, installed: !!s.rdns && !!n[s.rdns ?? ""] }))
        .sort((s, o) => Number(o.installed) - Number(s.installed));
    },
    getConnectOrderMethod(t, e) {
      var l;
      const n =
          (t == null ? void 0 : t.connectMethodsOrder) ||
          ((l = me.state.features) == null ? void 0 : l.connectMethodsOrder),
        r = e || nt.state.connectors;
      if (n) return n;
      const { injected: i, announced: s } = F0.getConnectorsByType(
          r,
          Ze.state.recommended,
          Ze.state.featured
        ),
        o = i.filter(F0.showConnector),
        a = s.filter(F0.showConnector);
      return o.length || a.length
        ? ["wallet", "email", "social"]
        : Qme.DEFAULT_CONNECT_METHOD_ORDER;
    },
    isExcluded(t) {
      const e =
          !!t.rdns && Ze.state.excludedWallets.some((r) => r.rdns === t.rdns),
        n =
          !!t.name &&
          Ze.state.excludedWallets.some((r) =>
            qv.isLowerCaseMatch(r.name, t.name)
          );
      return e || n;
    },
  },
  F0 = {
    getConnectorsByType(t, e, n) {
      const { customWallets: r } = me.state,
        i = Ie.getRecentWallets(),
        s = wS.filterOutDuplicateWallets(e),
        o = wS.filterOutDuplicateWallets(n),
        a = t.filter((f) => f.type === "MULTI_CHAIN"),
        l = t.filter((f) => f.type === "ANNOUNCED"),
        d = t.filter((f) => f.type === "INJECTED"),
        p = t.filter((f) => f.type === "EXTERNAL");
      return {
        custom: r,
        recent: i,
        external: p,
        multiChain: a,
        announced: l,
        injected: d,
        recommended: s,
        featured: o,
      };
    },
    showConnector(t) {
      var i;
      const e = (i = t.info) == null ? void 0 : i.rdns,
        n =
          !!e && Ze.state.excludedWallets.some((s) => !!s.rdns && s.rdns === e),
        r =
          !!t.name &&
          Ze.state.excludedWallets.some((s) =>
            qv.isLowerCaseMatch(s.name, t.name)
          );
      return !(
        (t.type === "INJECTED" &&
          ((t.name === "Browser Wallet" &&
            (!Je.isMobile() ||
              (Je.isMobile() && !e && !an.checkInstalled()))) ||
            n ||
            r)) ||
        ((t.type === "ANNOUNCED" || t.type === "EXTERNAL") && (n || r))
      );
    },
    getIsConnectedWithWC() {
      return Array.from(Y.state.chains.values()).some(
        (n) => nt.getConnectorId(n.namespace) === ye.CONNECTOR_ID.WALLET_CONNECT
      );
    },
    getConnectorTypeOrder({
      recommended: t,
      featured: e,
      custom: n,
      recent: r,
      announced: i,
      injected: s,
      multiChain: o,
      external: a,
      overriddenConnectors: l = ((d) =>
        (d = me.state.features) == null ? void 0 : d.connectorTypeOrder)() ??
        [],
    }) {
      const p = F0.getIsConnectedWithWC(),
        y = [
          {
            type: "walletConnect",
            isEnabled: me.state.enableWalletConnect && !p,
          },
          { type: "recent", isEnabled: r.length > 0 },
          { type: "injected", isEnabled: [...s, ...i, ...o].length > 0 },
          { type: "featured", isEnabled: e.length > 0 },
          { type: "custom", isEnabled: n && n.length > 0 },
          { type: "external", isEnabled: a.length > 0 },
          { type: "recommended", isEnabled: t.length > 0 },
        ].filter((E) => E.isEnabled),
        g = new Set(y.map((E) => E.type)),
        v = l.filter((E) => g.has(E)).map((E) => ({ type: E, isEnabled: !0 })),
        b = y.filter(({ type: E }) => !v.some(({ type: C }) => C === E));
      return Array.from(new Set([...v, ...b].map(({ type: E }) => E)));
    },
  };
/**
 * @license
 * Copyright 2019 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */ const z0 = globalThis,
  a_ =
    z0.ShadowRoot &&
    (z0.ShadyCSS === void 0 || z0.ShadyCSS.nativeShadow) &&
    "adoptedStyleSheets" in Document.prototype &&
    "replace" in CSSStyleSheet.prototype,
  c_ = Symbol(),
  pk = new WeakMap();
let G6 = class {
  constructor(e, n, r) {
    if (((this._$cssResult$ = !0), r !== c_))
      throw Error(
        "CSSResult is not constructable. Use `unsafeCSS` or `css` instead."
      );
    (this.cssText = e), (this.t = n);
  }
  get styleSheet() {
    let e = this.o;
    const n = this.t;
    if (a_ && e === void 0) {
      const r = n !== void 0 && n.length === 1;
      r && (e = pk.get(n)),
        e === void 0 &&
          ((this.o = e = new CSSStyleSheet()).replaceSync(this.cssText),
          r && pk.set(n, e));
    }
    return e;
  }
  toString() {
    return this.cssText;
  }
};
const os = (t) => new G6(typeof t == "string" ? t : t + "", void 0, c_),
  Dd = (t, ...e) => {
    const n =
      t.length === 1
        ? t[0]
        : e.reduce(
            (r, i, s) =>
              r +
              ((o) => {
                if (o._$cssResult$ === !0) return o.cssText;
                if (typeof o == "number") return o;
                throw Error(
                  "Value passed to 'css' function must be a 'css' function result: " +
                    o +
                    ". Use 'unsafeCSS' to pass non-literal values, but take care to ensure page security."
                );
              })(i) +
              t[s + 1],
            t[0]
          );
    return new G6(n, t, c_);
  },
  Xme = (t, e) => {
    if (a_)
      t.adoptedStyleSheets = e.map((n) =>
        n instanceof CSSStyleSheet ? n : n.styleSheet
      );
    else
      for (const n of e) {
        const r = document.createElement("style"),
          i = z0.litNonce;
        i !== void 0 && r.setAttribute("nonce", i),
          (r.textContent = n.cssText),
          t.appendChild(r);
      }
  },
  fk = a_
    ? (t) => t
    : (t) =>
        t instanceof CSSStyleSheet
          ? ((e) => {
              let n = "";
              for (const r of e.cssRules) n += r.cssText;
              return os(n);
            })(t)
          : t;
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */ const {
    is: Jme,
    defineProperty: ege,
    getOwnPropertyDescriptor: tge,
    getOwnPropertyNames: nge,
    getOwnPropertySymbols: rge,
    getPrototypeOf: ige,
  } = Object,
  Dc = globalThis,
  hk = Dc.trustedTypes,
  sge = hk ? hk.emptyScript : "",
  yC = Dc.reactiveElementPolyfillSupport,
  Sh = (t, e) => t,
  vS = {
    toAttribute(t, e) {
      switch (e) {
        case Boolean:
          t = t ? sge : null;
          break;
        case Object:
        case Array:
          t = t == null ? t : JSON.stringify(t);
      }
      return t;
    },
    fromAttribute(t, e) {
      let n = t;
      switch (e) {
        case Boolean:
          n = t !== null;
          break;
        case Number:
          n = t === null ? null : Number(t);
          break;
        case Object:
        case Array:
          try {
            n = JSON.parse(t);
          } catch {
            n = null;
          }
      }
      return n;
    },
  },
  K6 = (t, e) => !Jme(t, e),
  mk = {
    attribute: !0,
    type: String,
    converter: vS,
    reflect: !1,
    hasChanged: K6,
  };
Symbol.metadata ?? (Symbol.metadata = Symbol("metadata")),
  Dc.litPropertyMetadata ?? (Dc.litPropertyMetadata = new WeakMap());
let Cd = class extends HTMLElement {
  static addInitializer(e) {
    this._$Ei(), (this.l ?? (this.l = [])).push(e);
  }
  static get observedAttributes() {
    return this.finalize(), this._$Eh && [...this._$Eh.keys()];
  }
  static createProperty(e, n = mk) {
    if (
      (n.state && (n.attribute = !1),
      this._$Ei(),
      this.elementProperties.set(e, n),
      !n.noAccessor)
    ) {
      const r = Symbol(),
        i = this.getPropertyDescriptor(e, r, n);
      i !== void 0 && ege(this.prototype, e, i);
    }
  }
  static getPropertyDescriptor(e, n, r) {
    const { get: i, set: s } = tge(this.prototype, e) ?? {
      get() {
        return this[n];
      },
      set(o) {
        this[n] = o;
      },
    };
    return {
      get() {
        return i == null ? void 0 : i.call(this);
      },
      set(o) {
        const a = i == null ? void 0 : i.call(this);
        s.call(this, o), this.requestUpdate(e, a, r);
      },
      configurable: !0,
      enumerable: !0,
    };
  }
  static getPropertyOptions(e) {
    return this.elementProperties.get(e) ?? mk;
  }
  static _$Ei() {
    if (this.hasOwnProperty(Sh("elementProperties"))) return;
    const e = ige(this);
    e.finalize(),
      e.l !== void 0 && (this.l = [...e.l]),
      (this.elementProperties = new Map(e.elementProperties));
  }
  static finalize() {
    if (this.hasOwnProperty(Sh("finalized"))) return;
    if (
      ((this.finalized = !0),
      this._$Ei(),
      this.hasOwnProperty(Sh("properties")))
    ) {
      const n = this.properties,
        r = [...nge(n), ...rge(n)];
      for (const i of r) this.createProperty(i, n[i]);
    }
    const e = this[Symbol.metadata];
    if (e !== null) {
      const n = litPropertyMetadata.get(e);
      if (n !== void 0)
        for (const [r, i] of n) this.elementProperties.set(r, i);
    }
    this._$Eh = new Map();
    for (const [n, r] of this.elementProperties) {
      const i = this._$Eu(n, r);
      i !== void 0 && this._$Eh.set(i, n);
    }
    this.elementStyles = this.finalizeStyles(this.styles);
  }
  static finalizeStyles(e) {
    const n = [];
    if (Array.isArray(e)) {
      const r = new Set(e.flat(1 / 0).reverse());
      for (const i of r) n.unshift(fk(i));
    } else e !== void 0 && n.push(fk(e));
    return n;
  }
  static _$Eu(e, n) {
    const r = n.attribute;
    return r === !1
      ? void 0
      : typeof r == "string"
      ? r
      : typeof e == "string"
      ? e.toLowerCase()
      : void 0;
  }
  constructor() {
    super(),
      (this._$Ep = void 0),
      (this.isUpdatePending = !1),
      (this.hasUpdated = !1),
      (this._$Em = null),
      this._$Ev();
  }
  _$Ev() {
    var e;
    (this._$ES = new Promise((n) => (this.enableUpdating = n))),
      (this._$AL = new Map()),
      this._$E_(),
      this.requestUpdate(),
      (e = this.constructor.l) == null || e.forEach((n) => n(this));
  }
  addController(e) {
    var n;
    (this._$EO ?? (this._$EO = new Set())).add(e),
      this.renderRoot !== void 0 &&
        this.isConnected &&
        ((n = e.hostConnected) == null || n.call(e));
  }
  removeController(e) {
    var n;
    (n = this._$EO) == null || n.delete(e);
  }
  _$E_() {
    const e = new Map(),
      n = this.constructor.elementProperties;
    for (const r of n.keys())
      this.hasOwnProperty(r) && (e.set(r, this[r]), delete this[r]);
    e.size > 0 && (this._$Ep = e);
  }
  createRenderRoot() {
    const e =
      this.shadowRoot ?? this.attachShadow(this.constructor.shadowRootOptions);
    return Xme(e, this.constructor.elementStyles), e;
  }
  connectedCallback() {
    var e;
    this.renderRoot ?? (this.renderRoot = this.createRenderRoot()),
      this.enableUpdating(!0),
      (e = this._$EO) == null ||
        e.forEach((n) => {
          var r;
          return (r = n.hostConnected) == null ? void 0 : r.call(n);
        });
  }
  enableUpdating(e) {}
  disconnectedCallback() {
    var e;
    (e = this._$EO) == null ||
      e.forEach((n) => {
        var r;
        return (r = n.hostDisconnected) == null ? void 0 : r.call(n);
      });
  }
  attributeChangedCallback(e, n, r) {
    this._$AK(e, r);
  }
  _$EC(e, n) {
    var s;
    const r = this.constructor.elementProperties.get(e),
      i = this.constructor._$Eu(e, r);
    if (i !== void 0 && r.reflect === !0) {
      const o = (
        ((s = r.converter) == null ? void 0 : s.toAttribute) !== void 0
          ? r.converter
          : vS
      ).toAttribute(n, r.type);
      (this._$Em = e),
        o == null ? this.removeAttribute(i) : this.setAttribute(i, o),
        (this._$Em = null);
    }
  }
  _$AK(e, n) {
    var s;
    const r = this.constructor,
      i = r._$Eh.get(e);
    if (i !== void 0 && this._$Em !== i) {
      const o = r.getPropertyOptions(i),
        a =
          typeof o.converter == "function"
            ? { fromAttribute: o.converter }
            : ((s = o.converter) == null ? void 0 : s.fromAttribute) !== void 0
            ? o.converter
            : vS;
      (this._$Em = i),
        (this[i] = a.fromAttribute(n, o.type)),
        (this._$Em = null);
    }
  }
  requestUpdate(e, n, r) {
    if (e !== void 0) {
      if (
        (r ?? (r = this.constructor.getPropertyOptions(e)),
        !(r.hasChanged ?? K6)(this[e], n))
      )
        return;
      this.P(e, n, r);
    }
    this.isUpdatePending === !1 && (this._$ES = this._$ET());
  }
  P(e, n, r) {
    this._$AL.has(e) || this._$AL.set(e, n),
      r.reflect === !0 &&
        this._$Em !== e &&
        (this._$Ej ?? (this._$Ej = new Set())).add(e);
  }
  async _$ET() {
    this.isUpdatePending = !0;
    try {
      await this._$ES;
    } catch (n) {
      Promise.reject(n);
    }
    const e = this.scheduleUpdate();
    return e != null && (await e), !this.isUpdatePending;
  }
  scheduleUpdate() {
    return this.performUpdate();
  }
  performUpdate() {
    var r;
    if (!this.isUpdatePending) return;
    if (!this.hasUpdated) {
      if (
        (this.renderRoot ?? (this.renderRoot = this.createRenderRoot()),
        this._$Ep)
      ) {
        for (const [s, o] of this._$Ep) this[s] = o;
        this._$Ep = void 0;
      }
      const i = this.constructor.elementProperties;
      if (i.size > 0)
        for (const [s, o] of i)
          o.wrapped !== !0 ||
            this._$AL.has(s) ||
            this[s] === void 0 ||
            this.P(s, this[s], o);
    }
    let e = !1;
    const n = this._$AL;
    try {
      (e = this.shouldUpdate(n)),
        e
          ? (this.willUpdate(n),
            (r = this._$EO) == null ||
              r.forEach((i) => {
                var s;
                return (s = i.hostUpdate) == null ? void 0 : s.call(i);
              }),
            this.update(n))
          : this._$EU();
    } catch (i) {
      throw ((e = !1), this._$EU(), i);
    }
    e && this._$AE(n);
  }
  willUpdate(e) {}
  _$AE(e) {
    var n;
    (n = this._$EO) == null ||
      n.forEach((r) => {
        var i;
        return (i = r.hostUpdated) == null ? void 0 : i.call(r);
      }),
      this.hasUpdated || ((this.hasUpdated = !0), this.firstUpdated(e)),
      this.updated(e);
  }
  _$EU() {
    (this._$AL = new Map()), (this.isUpdatePending = !1);
  }
  get updateComplete() {
    return this.getUpdateComplete();
  }
  getUpdateComplete() {
    return this._$ES;
  }
  shouldUpdate(e) {
    return !0;
  }
  update(e) {
    this._$Ej && (this._$Ej = this._$Ej.forEach((n) => this._$EC(n, this[n]))),
      this._$EU();
  }
  updated(e) {}
  firstUpdated(e) {}
};
(Cd.elementStyles = []),
  (Cd.shadowRootOptions = { mode: "open" }),
  (Cd[Sh("elementProperties")] = new Map()),
  (Cd[Sh("finalized")] = new Map()),
  yC == null || yC({ ReactiveElement: Cd }),
  (Dc.reactiveElementVersions ?? (Dc.reactiveElementVersions = [])).push(
    "2.0.4"
  );
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */ const Ah = globalThis,
  Bw = Ah.trustedTypes,
  gk = Bw ? Bw.createPolicy("lit-html", { createHTML: (t) => t }) : void 0,
  Y6 = "$lit$",
  yc = `lit$${Math.random().toFixed(9).slice(2)}$`,
  Z6 = "?" + yc,
  oge = `<${Z6}>`,
  cu = document,
  Im = () => cu.createComment(""),
  Tm = (t) => t === null || (typeof t != "object" && typeof t != "function"),
  l_ = Array.isArray,
  age = (t) =>
    l_(t) || typeof (t == null ? void 0 : t[Symbol.iterator]) == "function",
  wC = `[ 	
\f\r]`,
  Zf = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g,
  yk = /-->/g,
  wk = />/g,
  ml = RegExp(
    `>|${wC}(?:([^\\s"'>=/]+)(${wC}*=${wC}*(?:[^ 	
\f\r"'\`<>=]|("|')|))|$)`,
    "g"
  ),
  vk = /'/g,
  bk = /"/g,
  Q6 = /^(?:script|style|textarea|title)$/i,
  X6 =
    (t) =>
    (e, ...n) => ({ _$litType$: t, strings: e, values: n }),
  U1e = X6(1),
  B1e = X6(2),
  hp = Symbol.for("lit-noChange"),
  hr = Symbol.for("lit-nothing"),
  Ek = new WeakMap(),
  Dl = cu.createTreeWalker(cu, 129);
function J6(t, e) {
  if (!l_(t) || !t.hasOwnProperty("raw"))
    throw Error("invalid template strings array");
  return gk !== void 0 ? gk.createHTML(e) : e;
}
const cge = (t, e) => {
  const n = t.length - 1,
    r = [];
  let i,
    s = e === 2 ? "<svg>" : e === 3 ? "<math>" : "",
    o = Zf;
  for (let a = 0; a < n; a++) {
    const l = t[a];
    let d,
      p,
      f = -1,
      m = 0;
    for (; m < l.length && ((o.lastIndex = m), (p = o.exec(l)), p !== null); )
      (m = o.lastIndex),
        o === Zf
          ? p[1] === "!--"
            ? (o = yk)
            : p[1] !== void 0
            ? (o = wk)
            : p[2] !== void 0
            ? (Q6.test(p[2]) && (i = RegExp("</" + p[2], "g")), (o = ml))
            : p[3] !== void 0 && (o = ml)
          : o === ml
          ? p[0] === ">"
            ? ((o = i ?? Zf), (f = -1))
            : p[1] === void 0
            ? (f = -2)
            : ((f = o.lastIndex - p[2].length),
              (d = p[1]),
              (o = p[3] === void 0 ? ml : p[3] === '"' ? bk : vk))
          : o === bk || o === vk
          ? (o = ml)
          : o === yk || o === wk
          ? (o = Zf)
          : ((o = ml), (i = void 0));
    const y = o === ml && t[a + 1].startsWith("/>") ? " " : "";
    s +=
      o === Zf
        ? l + oge
        : f >= 0
        ? (r.push(d), l.slice(0, f) + Y6 + l.slice(f) + yc + y)
        : l + yc + (f === -2 ? a : y);
  }
  return [
    J6(
      t,
      s + (t[n] || "<?>") + (e === 2 ? "</svg>" : e === 3 ? "</math>" : "")
    ),
    r,
  ];
};
class Pm {
  constructor({ strings: e, _$litType$: n }, r) {
    let i;
    this.parts = [];
    let s = 0,
      o = 0;
    const a = e.length - 1,
      l = this.parts,
      [d, p] = cge(e, n);
    if (
      ((this.el = Pm.createElement(d, r)),
      (Dl.currentNode = this.el.content),
      n === 2 || n === 3)
    ) {
      const f = this.el.content.firstChild;
      f.replaceWith(...f.childNodes);
    }
    for (; (i = Dl.nextNode()) !== null && l.length < a; ) {
      if (i.nodeType === 1) {
        if (i.hasAttributes())
          for (const f of i.getAttributeNames())
            if (f.endsWith(Y6)) {
              const m = p[o++],
                y = i.getAttribute(f).split(yc),
                g = /([.?@])?(.*)/.exec(m);
              l.push({
                type: 1,
                index: s,
                name: g[2],
                strings: y,
                ctor:
                  g[1] === "."
                    ? uge
                    : g[1] === "?"
                    ? dge
                    : g[1] === "@"
                    ? pge
                    : Gv,
              }),
                i.removeAttribute(f);
            } else
              f.startsWith(yc) &&
                (l.push({ type: 6, index: s }), i.removeAttribute(f));
        if (Q6.test(i.tagName)) {
          const f = i.textContent.split(yc),
            m = f.length - 1;
          if (m > 0) {
            i.textContent = Bw ? Bw.emptyScript : "";
            for (let y = 0; y < m; y++)
              i.append(f[y], Im()),
                Dl.nextNode(),
                l.push({ type: 2, index: ++s });
            i.append(f[m], Im());
          }
        }
      } else if (i.nodeType === 8)
        if (i.data === Z6) l.push({ type: 2, index: s });
        else {
          let f = -1;
          for (; (f = i.data.indexOf(yc, f + 1)) !== -1; )
            l.push({ type: 7, index: s }), (f += yc.length - 1);
        }
      s++;
    }
  }
  static createElement(e, n) {
    const r = cu.createElement("template");
    return (r.innerHTML = e), r;
  }
}
function mp(t, e, n = t, r) {
  var o, a;
  if (e === hp) return e;
  let i = r !== void 0 ? ((o = n._$Co) == null ? void 0 : o[r]) : n._$Cl;
  const s = Tm(e) ? void 0 : e._$litDirective$;
  return (
    (i == null ? void 0 : i.constructor) !== s &&
      ((a = i == null ? void 0 : i._$AO) == null || a.call(i, !1),
      s === void 0 ? (i = void 0) : ((i = new s(t)), i._$AT(t, n, r)),
      r !== void 0 ? ((n._$Co ?? (n._$Co = []))[r] = i) : (n._$Cl = i)),
    i !== void 0 && (e = mp(t, i._$AS(t, e.values), i, r)),
    e
  );
}
class lge {
  constructor(e, n) {
    (this._$AV = []), (this._$AN = void 0), (this._$AD = e), (this._$AM = n);
  }
  get parentNode() {
    return this._$AM.parentNode;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  u(e) {
    const {
        el: { content: n },
        parts: r,
      } = this._$AD,
      i = ((e == null ? void 0 : e.creationScope) ?? cu).importNode(n, !0);
    Dl.currentNode = i;
    let s = Dl.nextNode(),
      o = 0,
      a = 0,
      l = r[0];
    for (; l !== void 0; ) {
      if (o === l.index) {
        let d;
        l.type === 2
          ? (d = new dg(s, s.nextSibling, this, e))
          : l.type === 1
          ? (d = new l.ctor(s, l.name, l.strings, this, e))
          : l.type === 6 && (d = new fge(s, this, e)),
          this._$AV.push(d),
          (l = r[++a]);
      }
      o !== (l == null ? void 0 : l.index) && ((s = Dl.nextNode()), o++);
    }
    return (Dl.currentNode = cu), i;
  }
  p(e) {
    let n = 0;
    for (const r of this._$AV)
      r !== void 0 &&
        (r.strings !== void 0
          ? (r._$AI(e, r, n), (n += r.strings.length - 2))
          : r._$AI(e[n])),
        n++;
  }
}
class dg {
  get _$AU() {
    var e;
    return ((e = this._$AM) == null ? void 0 : e._$AU) ?? this._$Cv;
  }
  constructor(e, n, r, i) {
    (this.type = 2),
      (this._$AH = hr),
      (this._$AN = void 0),
      (this._$AA = e),
      (this._$AB = n),
      (this._$AM = r),
      (this.options = i),
      (this._$Cv = (i == null ? void 0 : i.isConnected) ?? !0);
  }
  get parentNode() {
    let e = this._$AA.parentNode;
    const n = this._$AM;
    return (
      n !== void 0 &&
        (e == null ? void 0 : e.nodeType) === 11 &&
        (e = n.parentNode),
      e
    );
  }
  get startNode() {
    return this._$AA;
  }
  get endNode() {
    return this._$AB;
  }
  _$AI(e, n = this) {
    (e = mp(this, e, n)),
      Tm(e)
        ? e === hr || e == null || e === ""
          ? (this._$AH !== hr && this._$AR(), (this._$AH = hr))
          : e !== this._$AH && e !== hp && this._(e)
        : e._$litType$ !== void 0
        ? this.$(e)
        : e.nodeType !== void 0
        ? this.T(e)
        : age(e)
        ? this.k(e)
        : this._(e);
  }
  O(e) {
    return this._$AA.parentNode.insertBefore(e, this._$AB);
  }
  T(e) {
    this._$AH !== e && (this._$AR(), (this._$AH = this.O(e)));
  }
  _(e) {
    this._$AH !== hr && Tm(this._$AH)
      ? (this._$AA.nextSibling.data = e)
      : this.T(cu.createTextNode(e)),
      (this._$AH = e);
  }
  $(e) {
    var s;
    const { values: n, _$litType$: r } = e,
      i =
        typeof r == "number"
          ? this._$AC(e)
          : (r.el === void 0 &&
              (r.el = Pm.createElement(J6(r.h, r.h[0]), this.options)),
            r);
    if (((s = this._$AH) == null ? void 0 : s._$AD) === i) this._$AH.p(n);
    else {
      const o = new lge(i, this),
        a = o.u(this.options);
      o.p(n), this.T(a), (this._$AH = o);
    }
  }
  _$AC(e) {
    let n = Ek.get(e.strings);
    return n === void 0 && Ek.set(e.strings, (n = new Pm(e))), n;
  }
  k(e) {
    l_(this._$AH) || ((this._$AH = []), this._$AR());
    const n = this._$AH;
    let r,
      i = 0;
    for (const s of e)
      i === n.length
        ? n.push((r = new dg(this.O(Im()), this.O(Im()), this, this.options)))
        : (r = n[i]),
        r._$AI(s),
        i++;
    i < n.length && (this._$AR(r && r._$AB.nextSibling, i), (n.length = i));
  }
  _$AR(e = this._$AA.nextSibling, n) {
    var r;
    for (
      (r = this._$AP) == null ? void 0 : r.call(this, !1, !0, n);
      e && e !== this._$AB;

    ) {
      const i = e.nextSibling;
      e.remove(), (e = i);
    }
  }
  setConnected(e) {
    var n;
    this._$AM === void 0 &&
      ((this._$Cv = e), (n = this._$AP) == null || n.call(this, e));
  }
}
class Gv {
  get tagName() {
    return this.element.tagName;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  constructor(e, n, r, i, s) {
    (this.type = 1),
      (this._$AH = hr),
      (this._$AN = void 0),
      (this.element = e),
      (this.name = n),
      (this._$AM = i),
      (this.options = s),
      r.length > 2 || r[0] !== "" || r[1] !== ""
        ? ((this._$AH = Array(r.length - 1).fill(new String())),
          (this.strings = r))
        : (this._$AH = hr);
  }
  _$AI(e, n = this, r, i) {
    const s = this.strings;
    let o = !1;
    if (s === void 0)
      (e = mp(this, e, n, 0)),
        (o = !Tm(e) || (e !== this._$AH && e !== hp)),
        o && (this._$AH = e);
    else {
      const a = e;
      let l, d;
      for (e = s[0], l = 0; l < s.length - 1; l++)
        (d = mp(this, a[r + l], n, l)),
          d === hp && (d = this._$AH[l]),
          o || (o = !Tm(d) || d !== this._$AH[l]),
          d === hr ? (e = hr) : e !== hr && (e += (d ?? "") + s[l + 1]),
          (this._$AH[l] = d);
    }
    o && !i && this.j(e);
  }
  j(e) {
    e === hr
      ? this.element.removeAttribute(this.name)
      : this.element.setAttribute(this.name, e ?? "");
  }
}
class uge extends Gv {
  constructor() {
    super(...arguments), (this.type = 3);
  }
  j(e) {
    this.element[this.name] = e === hr ? void 0 : e;
  }
}
class dge extends Gv {
  constructor() {
    super(...arguments), (this.type = 4);
  }
  j(e) {
    this.element.toggleAttribute(this.name, !!e && e !== hr);
  }
}
class pge extends Gv {
  constructor(e, n, r, i, s) {
    super(e, n, r, i, s), (this.type = 5);
  }
  _$AI(e, n = this) {
    if ((e = mp(this, e, n, 0) ?? hr) === hp) return;
    const r = this._$AH,
      i =
        (e === hr && r !== hr) ||
        e.capture !== r.capture ||
        e.once !== r.once ||
        e.passive !== r.passive,
      s = e !== hr && (r === hr || i);
    i && this.element.removeEventListener(this.name, this, r),
      s && this.element.addEventListener(this.name, this, e),
      (this._$AH = e);
  }
  handleEvent(e) {
    var n;
    typeof this._$AH == "function"
      ? this._$AH.call(
          ((n = this.options) == null ? void 0 : n.host) ?? this.element,
          e
        )
      : this._$AH.handleEvent(e);
  }
}
class fge {
  constructor(e, n, r) {
    (this.element = e),
      (this.type = 6),
      (this._$AN = void 0),
      (this._$AM = n),
      (this.options = r);
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AI(e) {
    mp(this, e);
  }
}
const vC = Ah.litHtmlPolyfillSupport;
vC == null || vC(Pm, dg),
  (Ah.litHtmlVersions ?? (Ah.litHtmlVersions = [])).push("3.2.1");
const hge = (t, e, n) => {
  const r = (n == null ? void 0 : n.renderBefore) ?? e;
  let i = r._$litPart$;
  if (i === void 0) {
    const s = (n == null ? void 0 : n.renderBefore) ?? null;
    r._$litPart$ = i = new dg(e.insertBefore(Im(), s), s, void 0, n ?? {});
  }
  return i._$AI(t), i;
};
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */ let W0 = class extends Cd {
  constructor() {
    super(...arguments),
      (this.renderOptions = { host: this }),
      (this._$Do = void 0);
  }
  createRenderRoot() {
    var n;
    const e = super.createRenderRoot();
    return (
      (n = this.renderOptions).renderBefore ?? (n.renderBefore = e.firstChild),
      e
    );
  }
  update(e) {
    const n = this.render();
    this.hasUpdated || (this.renderOptions.isConnected = this.isConnected),
      super.update(e),
      (this._$Do = hge(n, this.renderRoot, this.renderOptions));
  }
  connectedCallback() {
    var e;
    super.connectedCallback(), (e = this._$Do) == null || e.setConnected(!0);
  }
  disconnectedCallback() {
    var e;
    super.disconnectedCallback(), (e = this._$Do) == null || e.setConnected(!1);
  }
  render() {
    return hp;
  }
};
var w5;
(W0._$litElement$ = !0),
  (W0.finalized = !0),
  (w5 = globalThis.litElementHydrateSupport) == null ||
    w5.call(globalThis, { LitElement: W0 });
const bC = globalThis.litElementPolyfillSupport;
bC == null || bC({ LitElement: W0 });
(globalThis.litElementVersions ?? (globalThis.litElementVersions = [])).push(
  "4.1.1"
);
let _h, $c, Mc;
function F1e(t, e) {
  (_h = document.createElement("style")),
    ($c = document.createElement("style")),
    (Mc = document.createElement("style")),
    (_h.textContent = $d(t).core.cssText),
    ($c.textContent = $d(t).dark.cssText),
    (Mc.textContent = $d(t).light.cssText),
    document.head.appendChild(_h),
    document.head.appendChild($c),
    document.head.appendChild(Mc),
    eL(e);
}
function eL(t) {
  $c &&
    Mc &&
    (t === "light"
      ? ($c.removeAttribute("media"), (Mc.media = "enabled"))
      : (Mc.removeAttribute("media"), ($c.media = "enabled")));
}
function mge(t) {
  _h &&
    $c &&
    Mc &&
    ((_h.textContent = $d(t).core.cssText),
    ($c.textContent = $d(t).dark.cssText),
    (Mc.textContent = $d(t).light.cssText));
}
function $d(t) {
  return {
    core: Dd`
      @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');
      @keyframes w3m-shake {
        0% {
          transform: scale(1) rotate(0deg);
        }
        20% {
          transform: scale(1) rotate(-1deg);
        }
        40% {
          transform: scale(1) rotate(1.5deg);
        }
        60% {
          transform: scale(1) rotate(-1.5deg);
        }
        80% {
          transform: scale(1) rotate(1deg);
        }
        100% {
          transform: scale(1) rotate(0deg);
        }
      }
      @keyframes w3m-iframe-fade-out {
        0% {
          opacity: 1;
        }
        100% {
          opacity: 0;
        }
      }
      @keyframes w3m-iframe-zoom-in {
        0% {
          transform: translateY(50px);
          opacity: 0;
        }
        100% {
          transform: translateY(0px);
          opacity: 1;
        }
      }
      @keyframes w3m-iframe-zoom-in-mobile {
        0% {
          transform: scale(0.95);
          opacity: 0;
        }
        100% {
          transform: scale(1);
          opacity: 1;
        }
      }
      :root {
        --w3m-modal-width: 360px;
        --w3m-color-mix-strength: ${os(
          t != null && t["--w3m-color-mix-strength"]
            ? `${t["--w3m-color-mix-strength"]}%`
            : "0%"
        )};
        --w3m-font-family: ${os(
          (t == null ? void 0 : t["--w3m-font-family"]) ||
            "Inter, Segoe UI, Roboto, Oxygen, Ubuntu, Cantarell, Fira Sans, Droid Sans, Helvetica Neue, sans-serif;"
        )};
        --w3m-font-size-master: ${os(
          (t == null ? void 0 : t["--w3m-font-size-master"]) || "10px"
        )};
        --w3m-border-radius-master: ${os(
          (t == null ? void 0 : t["--w3m-border-radius-master"]) || "4px"
        )};
        --w3m-z-index: ${os((t == null ? void 0 : t["--w3m-z-index"]) || 999)};

        --wui-font-family: var(--w3m-font-family);

        --wui-font-size-mini: calc(var(--w3m-font-size-master) * 0.8);
        --wui-font-size-micro: var(--w3m-font-size-master);
        --wui-font-size-tiny: calc(var(--w3m-font-size-master) * 1.2);
        --wui-font-size-small: calc(var(--w3m-font-size-master) * 1.4);
        --wui-font-size-paragraph: calc(var(--w3m-font-size-master) * 1.6);
        --wui-font-size-medium: calc(var(--w3m-font-size-master) * 1.8);
        --wui-font-size-large: calc(var(--w3m-font-size-master) * 2);
        --wui-font-size-title-6: calc(var(--w3m-font-size-master) * 2.2);
        --wui-font-size-medium-title: calc(var(--w3m-font-size-master) * 2.4);
        --wui-font-size-2xl: calc(var(--w3m-font-size-master) * 4);

        --wui-border-radius-5xs: var(--w3m-border-radius-master);
        --wui-border-radius-4xs: calc(var(--w3m-border-radius-master) * 1.5);
        --wui-border-radius-3xs: calc(var(--w3m-border-radius-master) * 2);
        --wui-border-radius-xxs: calc(var(--w3m-border-radius-master) * 3);
        --wui-border-radius-xs: calc(var(--w3m-border-radius-master) * 4);
        --wui-border-radius-s: calc(var(--w3m-border-radius-master) * 5);
        --wui-border-radius-m: calc(var(--w3m-border-radius-master) * 7);
        --wui-border-radius-l: calc(var(--w3m-border-radius-master) * 9);
        --wui-border-radius-3xl: calc(var(--w3m-border-radius-master) * 20);

        --wui-font-weight-light: 400;
        --wui-font-weight-regular: 500;
        --wui-font-weight-medium: 600;
        --wui-font-weight-bold: 700;

        --wui-letter-spacing-2xl: -1.6px;
        --wui-letter-spacing-medium-title: -0.96px;
        --wui-letter-spacing-title-6: -0.88px;
        --wui-letter-spacing-large: -0.8px;
        --wui-letter-spacing-medium: -0.72px;
        --wui-letter-spacing-paragraph: -0.64px;
        --wui-letter-spacing-small: -0.56px;
        --wui-letter-spacing-tiny: -0.48px;
        --wui-letter-spacing-micro: -0.2px;
        --wui-letter-spacing-mini: -0.16px;

        --wui-spacing-0: 0px;
        --wui-spacing-4xs: 2px;
        --wui-spacing-3xs: 4px;
        --wui-spacing-xxs: 6px;
        --wui-spacing-2xs: 7px;
        --wui-spacing-xs: 8px;
        --wui-spacing-1xs: 10px;
        --wui-spacing-s: 12px;
        --wui-spacing-m: 14px;
        --wui-spacing-l: 16px;
        --wui-spacing-2l: 18px;
        --wui-spacing-xl: 20px;
        --wui-spacing-xxl: 24px;
        --wui-spacing-2xl: 32px;
        --wui-spacing-3xl: 40px;
        --wui-spacing-4xl: 90px;
        --wui-spacing-5xl: 95px;

        --wui-icon-box-size-xxs: 14px;
        --wui-icon-box-size-xs: 20px;
        --wui-icon-box-size-sm: 24px;
        --wui-icon-box-size-md: 32px;
        --wui-icon-box-size-mdl: 36px;
        --wui-icon-box-size-lg: 40px;
        --wui-icon-box-size-2lg: 48px;
        --wui-icon-box-size-xl: 64px;

        --wui-icon-size-inherit: inherit;
        --wui-icon-size-xxs: 10px;
        --wui-icon-size-xs: 12px;
        --wui-icon-size-sm: 14px;
        --wui-icon-size-md: 16px;
        --wui-icon-size-mdl: 18px;
        --wui-icon-size-lg: 20px;
        --wui-icon-size-xl: 24px;
        --wui-icon-size-xxl: 28px;

        --wui-wallet-image-size-inherit: inherit;
        --wui-wallet-image-size-sm: 40px;
        --wui-wallet-image-size-md: 56px;
        --wui-wallet-image-size-lg: 80px;

        --wui-visual-size-size-inherit: inherit;
        --wui-visual-size-sm: 40px;
        --wui-visual-size-md: 55px;
        --wui-visual-size-lg: 80px;

        --wui-box-size-md: 100px;
        --wui-box-size-lg: 120px;

        --wui-ease-out-power-2: cubic-bezier(0, 0, 0.22, 1);
        --wui-ease-out-power-1: cubic-bezier(0, 0, 0.55, 1);

        --wui-ease-in-power-3: cubic-bezier(0.66, 0, 1, 1);
        --wui-ease-in-power-2: cubic-bezier(0.45, 0, 1, 1);
        --wui-ease-in-power-1: cubic-bezier(0.3, 0, 1, 1);

        --wui-ease-inout-power-1: cubic-bezier(0.45, 0, 0.55, 1);

        --wui-duration-lg: 200ms;
        --wui-duration-md: 125ms;
        --wui-duration-sm: 75ms;

        --wui-path-network-sm: path(
          'M15.4 2.1a5.21 5.21 0 0 1 5.2 0l11.61 6.7a5.21 5.21 0 0 1 2.61 4.52v13.4c0 1.87-1 3.59-2.6 4.52l-11.61 6.7c-1.62.93-3.6.93-5.22 0l-11.6-6.7a5.21 5.21 0 0 1-2.61-4.51v-13.4c0-1.87 1-3.6 2.6-4.52L15.4 2.1Z'
        );

        --wui-path-network-md: path(
          'M43.4605 10.7248L28.0485 1.61089C25.5438 0.129705 22.4562 0.129705 19.9515 1.61088L4.53951 10.7248C2.03626 12.2051 0.5 14.9365 0.5 17.886V36.1139C0.5 39.0635 2.03626 41.7949 4.53951 43.2752L19.9515 52.3891C22.4562 53.8703 25.5438 53.8703 28.0485 52.3891L43.4605 43.2752C45.9637 41.7949 47.5 39.0635 47.5 36.114V17.8861C47.5 14.9365 45.9637 12.2051 43.4605 10.7248Z'
        );

        --wui-path-network-lg: path(
          'M78.3244 18.926L50.1808 2.45078C45.7376 -0.150261 40.2624 -0.150262 35.8192 2.45078L7.6756 18.926C3.23322 21.5266 0.5 26.3301 0.5 31.5248V64.4752C0.5 69.6699 3.23322 74.4734 7.6756 77.074L35.8192 93.5492C40.2624 96.1503 45.7376 96.1503 50.1808 93.5492L78.3244 77.074C82.7668 74.4734 85.5 69.6699 85.5 64.4752V31.5248C85.5 26.3301 82.7668 21.5266 78.3244 18.926Z'
        );

        --wui-width-network-sm: 36px;
        --wui-width-network-md: 48px;
        --wui-width-network-lg: 86px;

        --wui-height-network-sm: 40px;
        --wui-height-network-md: 54px;
        --wui-height-network-lg: 96px;

        --wui-icon-size-network-xs: 12px;
        --wui-icon-size-network-sm: 16px;
        --wui-icon-size-network-md: 24px;
        --wui-icon-size-network-lg: 42px;

        --wui-color-inherit: inherit;

        --wui-color-inverse-100: #fff;
        --wui-color-inverse-000: #000;

        --wui-cover: rgba(20, 20, 20, 0.8);

        --wui-color-modal-bg: var(--wui-color-modal-bg-base);

        --wui-color-accent-100: var(--wui-color-accent-base-100);
        --wui-color-accent-090: var(--wui-color-accent-base-090);
        --wui-color-accent-080: var(--wui-color-accent-base-080);

        --wui-color-success-100: var(--wui-color-success-base-100);
        --wui-color-success-125: var(--wui-color-success-base-125);

        --wui-color-warning-100: var(--wui-color-warning-base-100);

        --wui-color-error-100: var(--wui-color-error-base-100);
        --wui-color-error-125: var(--wui-color-error-base-125);

        --wui-color-blue-100: var(--wui-color-blue-base-100);
        --wui-color-blue-90: var(--wui-color-blue-base-90);

        --wui-icon-box-bg-error-100: var(--wui-icon-box-bg-error-base-100);
        --wui-icon-box-bg-blue-100: var(--wui-icon-box-bg-blue-base-100);
        --wui-icon-box-bg-success-100: var(--wui-icon-box-bg-success-base-100);
        --wui-icon-box-bg-inverse-100: var(--wui-icon-box-bg-inverse-base-100);

        --wui-all-wallets-bg-100: var(--wui-all-wallets-bg-100);

        --wui-avatar-border: var(--wui-avatar-border-base);

        --wui-thumbnail-border: var(--wui-thumbnail-border-base);

        --wui-wallet-button-bg: var(--wui-wallet-button-bg-base);

        --wui-box-shadow-blue: var(--wui-color-accent-glass-020);
      }

      @supports (background: color-mix(in srgb, white 50%, black)) {
        :root {
          --wui-color-modal-bg: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-modal-bg-base)
          );

          --wui-box-shadow-blue: color-mix(in srgb, var(--wui-color-accent-100) 20%, transparent);

          --wui-color-accent-100: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 100%,
            transparent
          );
          --wui-color-accent-090: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 90%,
            transparent
          );
          --wui-color-accent-080: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 80%,
            transparent
          );
          --wui-color-accent-glass-090: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 90%,
            transparent
          );
          --wui-color-accent-glass-080: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 80%,
            transparent
          );
          --wui-color-accent-glass-020: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 20%,
            transparent
          );
          --wui-color-accent-glass-015: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 15%,
            transparent
          );
          --wui-color-accent-glass-010: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 10%,
            transparent
          );
          --wui-color-accent-glass-005: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 5%,
            transparent
          );
          --wui-color-accent-002: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 2%,
            transparent
          );

          --wui-color-fg-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-100)
          );
          --wui-color-fg-125: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-125)
          );
          --wui-color-fg-150: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-150)
          );
          --wui-color-fg-175: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-175)
          );
          --wui-color-fg-200: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-200)
          );
          --wui-color-fg-225: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-225)
          );
          --wui-color-fg-250: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-250)
          );
          --wui-color-fg-275: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-275)
          );
          --wui-color-fg-300: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-300)
          );
          --wui-color-fg-325: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-325)
          );
          --wui-color-fg-350: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-350)
          );

          --wui-color-bg-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-100)
          );
          --wui-color-bg-125: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-125)
          );
          --wui-color-bg-150: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-150)
          );
          --wui-color-bg-175: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-175)
          );
          --wui-color-bg-200: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-200)
          );
          --wui-color-bg-225: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-225)
          );
          --wui-color-bg-250: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-250)
          );
          --wui-color-bg-275: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-275)
          );
          --wui-color-bg-300: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-300)
          );
          --wui-color-bg-325: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-325)
          );
          --wui-color-bg-350: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-350)
          );

          --wui-color-success-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-success-base-100)
          );
          --wui-color-success-125: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-success-base-125)
          );

          --wui-color-warning-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-warning-base-100)
          );

          --wui-color-error-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-error-base-100)
          );
          --wui-color-blue-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-blue-base-100)
          );
          --wui-color-blue-90: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-blue-base-90)
          );
          --wui-color-error-125: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-error-base-125)
          );

          --wui-icon-box-bg-error-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-icon-box-bg-error-base-100)
          );
          --wui-icon-box-bg-accent-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-icon-box-bg-blue-base-100)
          );
          --wui-icon-box-bg-success-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-icon-box-bg-success-base-100)
          );
          --wui-icon-box-bg-inverse-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-icon-box-bg-inverse-base-100)
          );

          --wui-all-wallets-bg-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-all-wallets-bg-100)
          );

          --wui-avatar-border: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-avatar-border-base)
          );

          --wui-thumbnail-border: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-thumbnail-border-base)
          );

          --wui-wallet-button-bg: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-wallet-button-bg-base)
          );
        }
      }
    `,
    light: Dd`
      :root {
        --w3m-color-mix: ${os(
          (t == null ? void 0 : t["--w3m-color-mix"]) || "#fff"
        )};
        --w3m-accent: ${os(ga(t, "dark")["--w3m-accent"])};
        --w3m-default: #fff;

        --wui-color-modal-bg-base: ${os(ga(t, "dark")["--w3m-background"])};
        --wui-color-accent-base-100: var(--w3m-accent);

        --wui-color-blueberry-100: hsla(230, 100%, 67%, 1);
        --wui-color-blueberry-090: hsla(231, 76%, 61%, 1);
        --wui-color-blueberry-080: hsla(230, 59%, 55%, 1);
        --wui-color-blueberry-050: hsla(231, 100%, 70%, 0.1);

        --wui-color-fg-100: #e4e7e7;
        --wui-color-fg-125: #d0d5d5;
        --wui-color-fg-150: #a8b1b1;
        --wui-color-fg-175: #a8b0b0;
        --wui-color-fg-200: #949e9e;
        --wui-color-fg-225: #868f8f;
        --wui-color-fg-250: #788080;
        --wui-color-fg-275: #788181;
        --wui-color-fg-300: #6e7777;
        --wui-color-fg-325: #9a9a9a;
        --wui-color-fg-350: #363636;

        --wui-color-bg-100: #141414;
        --wui-color-bg-125: #191a1a;
        --wui-color-bg-150: #1e1f1f;
        --wui-color-bg-175: #222525;
        --wui-color-bg-200: #272a2a;
        --wui-color-bg-225: #2c3030;
        --wui-color-bg-250: #313535;
        --wui-color-bg-275: #363b3b;
        --wui-color-bg-300: #3b4040;
        --wui-color-bg-325: #252525;
        --wui-color-bg-350: #ffffff;

        --wui-color-success-base-100: #26d962;
        --wui-color-success-base-125: #30a46b;

        --wui-color-warning-base-100: #f3a13f;

        --wui-color-error-base-100: #f25a67;
        --wui-color-error-base-125: #df4a34;

        --wui-color-blue-base-100: rgba(102, 125, 255, 1);
        --wui-color-blue-base-90: rgba(102, 125, 255, 0.9);

        --wui-color-success-glass-001: rgba(38, 217, 98, 0.01);
        --wui-color-success-glass-002: rgba(38, 217, 98, 0.02);
        --wui-color-success-glass-005: rgba(38, 217, 98, 0.05);
        --wui-color-success-glass-010: rgba(38, 217, 98, 0.1);
        --wui-color-success-glass-015: rgba(38, 217, 98, 0.15);
        --wui-color-success-glass-020: rgba(38, 217, 98, 0.2);
        --wui-color-success-glass-025: rgba(38, 217, 98, 0.25);
        --wui-color-success-glass-030: rgba(38, 217, 98, 0.3);
        --wui-color-success-glass-060: rgba(38, 217, 98, 0.6);
        --wui-color-success-glass-080: rgba(38, 217, 98, 0.8);

        --wui-color-success-glass-reown-020: rgba(48, 164, 107, 0.2);

        --wui-color-warning-glass-reown-020: rgba(243, 161, 63, 0.2);

        --wui-color-error-glass-001: rgba(242, 90, 103, 0.01);
        --wui-color-error-glass-002: rgba(242, 90, 103, 0.02);
        --wui-color-error-glass-005: rgba(242, 90, 103, 0.05);
        --wui-color-error-glass-010: rgba(242, 90, 103, 0.1);
        --wui-color-error-glass-015: rgba(242, 90, 103, 0.15);
        --wui-color-error-glass-020: rgba(242, 90, 103, 0.2);
        --wui-color-error-glass-025: rgba(242, 90, 103, 0.25);
        --wui-color-error-glass-030: rgba(242, 90, 103, 0.3);
        --wui-color-error-glass-060: rgba(242, 90, 103, 0.6);
        --wui-color-error-glass-080: rgba(242, 90, 103, 0.8);

        --wui-color-error-glass-reown-020: rgba(223, 74, 52, 0.2);

        --wui-color-gray-glass-001: rgba(255, 255, 255, 0.01);
        --wui-color-gray-glass-002: rgba(255, 255, 255, 0.02);
        --wui-color-gray-glass-005: rgba(255, 255, 255, 0.05);
        --wui-color-gray-glass-010: rgba(255, 255, 255, 0.1);
        --wui-color-gray-glass-015: rgba(255, 255, 255, 0.15);
        --wui-color-gray-glass-020: rgba(255, 255, 255, 0.2);
        --wui-color-gray-glass-025: rgba(255, 255, 255, 0.25);
        --wui-color-gray-glass-030: rgba(255, 255, 255, 0.3);
        --wui-color-gray-glass-060: rgba(255, 255, 255, 0.6);
        --wui-color-gray-glass-080: rgba(255, 255, 255, 0.8);
        --wui-color-gray-glass-090: rgba(255, 255, 255, 0.9);

        --wui-color-dark-glass-100: rgba(42, 42, 42, 1);

        --wui-icon-box-bg-error-base-100: #3c2426;
        --wui-icon-box-bg-blue-base-100: #20303f;
        --wui-icon-box-bg-success-base-100: #1f3a28;
        --wui-icon-box-bg-inverse-base-100: #243240;

        --wui-all-wallets-bg-100: #222b35;

        --wui-avatar-border-base: #252525;

        --wui-thumbnail-border-base: #252525;

        --wui-wallet-button-bg-base: var(--wui-color-bg-125);

        --w3m-card-embedded-shadow-color: rgb(17 17 18 / 25%);
      }
    `,
    dark: Dd`
      :root {
        --w3m-color-mix: ${os(
          (t == null ? void 0 : t["--w3m-color-mix"]) || "#000"
        )};
        --w3m-accent: ${os(ga(t, "light")["--w3m-accent"])};
        --w3m-default: #000;

        --wui-color-modal-bg-base: ${os(ga(t, "light")["--w3m-background"])};
        --wui-color-accent-base-100: var(--w3m-accent);

        --wui-color-blueberry-100: hsla(231, 100%, 70%, 1);
        --wui-color-blueberry-090: hsla(231, 97%, 72%, 1);
        --wui-color-blueberry-080: hsla(231, 92%, 74%, 1);

        --wui-color-fg-100: #141414;
        --wui-color-fg-125: #2d3131;
        --wui-color-fg-150: #474d4d;
        --wui-color-fg-175: #636d6d;
        --wui-color-fg-200: #798686;
        --wui-color-fg-225: #828f8f;
        --wui-color-fg-250: #8b9797;
        --wui-color-fg-275: #95a0a0;
        --wui-color-fg-300: #9ea9a9;
        --wui-color-fg-325: #9a9a9a;
        --wui-color-fg-350: #d0d0d0;

        --wui-color-bg-100: #ffffff;
        --wui-color-bg-125: #f5fafa;
        --wui-color-bg-150: #f3f8f8;
        --wui-color-bg-175: #eef4f4;
        --wui-color-bg-200: #eaf1f1;
        --wui-color-bg-225: #e5eded;
        --wui-color-bg-250: #e1e9e9;
        --wui-color-bg-275: #dce7e7;
        --wui-color-bg-300: #d8e3e3;
        --wui-color-bg-325: #f3f3f3;
        --wui-color-bg-350: #202020;

        --wui-color-success-base-100: #26b562;
        --wui-color-success-base-125: #30a46b;

        --wui-color-warning-base-100: #f3a13f;

        --wui-color-error-base-100: #f05142;
        --wui-color-error-base-125: #df4a34;

        --wui-color-blue-base-100: rgba(102, 125, 255, 1);
        --wui-color-blue-base-90: rgba(102, 125, 255, 0.9);

        --wui-color-success-glass-001: rgba(38, 181, 98, 0.01);
        --wui-color-success-glass-002: rgba(38, 181, 98, 0.02);
        --wui-color-success-glass-005: rgba(38, 181, 98, 0.05);
        --wui-color-success-glass-010: rgba(38, 181, 98, 0.1);
        --wui-color-success-glass-015: rgba(38, 181, 98, 0.15);
        --wui-color-success-glass-020: rgba(38, 181, 98, 0.2);
        --wui-color-success-glass-025: rgba(38, 181, 98, 0.25);
        --wui-color-success-glass-030: rgba(38, 181, 98, 0.3);
        --wui-color-success-glass-060: rgba(38, 181, 98, 0.6);
        --wui-color-success-glass-080: rgba(38, 181, 98, 0.8);

        --wui-color-success-glass-reown-020: rgba(48, 164, 107, 0.2);

        --wui-color-warning-glass-reown-020: rgba(243, 161, 63, 0.2);

        --wui-color-error-glass-001: rgba(240, 81, 66, 0.01);
        --wui-color-error-glass-002: rgba(240, 81, 66, 0.02);
        --wui-color-error-glass-005: rgba(240, 81, 66, 0.05);
        --wui-color-error-glass-010: rgba(240, 81, 66, 0.1);
        --wui-color-error-glass-015: rgba(240, 81, 66, 0.15);
        --wui-color-error-glass-020: rgba(240, 81, 66, 0.2);
        --wui-color-error-glass-025: rgba(240, 81, 66, 0.25);
        --wui-color-error-glass-030: rgba(240, 81, 66, 0.3);
        --wui-color-error-glass-060: rgba(240, 81, 66, 0.6);
        --wui-color-error-glass-080: rgba(240, 81, 66, 0.8);

        --wui-color-error-glass-reown-020: rgba(223, 74, 52, 0.2);

        --wui-icon-box-bg-error-base-100: #f4dfdd;
        --wui-icon-box-bg-blue-base-100: #d9ecfb;
        --wui-icon-box-bg-success-base-100: #daf0e4;
        --wui-icon-box-bg-inverse-base-100: #dcecfc;

        --wui-all-wallets-bg-100: #e8f1fa;

        --wui-avatar-border-base: #f3f4f4;

        --wui-thumbnail-border-base: #eaefef;

        --wui-wallet-button-bg-base: var(--wui-color-bg-125);

        --wui-color-gray-glass-001: rgba(0, 0, 0, 0.01);
        --wui-color-gray-glass-002: rgba(0, 0, 0, 0.02);
        --wui-color-gray-glass-005: rgba(0, 0, 0, 0.05);
        --wui-color-gray-glass-010: rgba(0, 0, 0, 0.1);
        --wui-color-gray-glass-015: rgba(0, 0, 0, 0.15);
        --wui-color-gray-glass-020: rgba(0, 0, 0, 0.2);
        --wui-color-gray-glass-025: rgba(0, 0, 0, 0.25);
        --wui-color-gray-glass-030: rgba(0, 0, 0, 0.3);
        --wui-color-gray-glass-060: rgba(0, 0, 0, 0.6);
        --wui-color-gray-glass-080: rgba(0, 0, 0, 0.8);
        --wui-color-gray-glass-090: rgba(0, 0, 0, 0.9);

        --wui-color-dark-glass-100: rgba(233, 233, 233, 1);

        --w3m-card-embedded-shadow-color: rgb(224 225 233 / 25%);
      }
    `,
  };
}
const z1e = Dd`
  *,
  *::after,
  *::before,
  :host {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
    font-style: normal;
    text-rendering: optimizeSpeed;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
    -webkit-tap-highlight-color: transparent;
    font-family: var(--wui-font-family);
    backface-visibility: hidden;
  }
`,
  W1e = Dd`
  button,
  a {
    cursor: pointer;
    display: flex;
    justify-content: center;
    align-items: center;
    position: relative;
    transition:
      color var(--wui-duration-lg) var(--wui-ease-out-power-1),
      background-color var(--wui-duration-lg) var(--wui-ease-out-power-1),
      border var(--wui-duration-lg) var(--wui-ease-out-power-1),
      border-radius var(--wui-duration-lg) var(--wui-ease-out-power-1),
      box-shadow var(--wui-duration-lg) var(--wui-ease-out-power-1);
    will-change: background-color, color, border, box-shadow, border-radius;
    outline: none;
    border: none;
    column-gap: var(--wui-spacing-3xs);
    background-color: transparent;
    text-decoration: none;
  }

  wui-flex {
    transition: border-radius var(--wui-duration-lg) var(--wui-ease-out-power-1);
    will-change: border-radius;
  }

  button:disabled > wui-wallet-image,
  button:disabled > wui-all-wallets-image,
  button:disabled > wui-network-image,
  button:disabled > wui-image,
  button:disabled > wui-transaction-visual,
  button:disabled > wui-logo {
    filter: grayscale(1);
  }

  @media (hover: hover) and (pointer: fine) {
    button:hover:enabled {
      background-color: var(--wui-color-gray-glass-005);
    }

    button:active:enabled {
      background-color: var(--wui-color-gray-glass-010);
    }
  }

  button:disabled > wui-icon-box {
    opacity: 0.5;
  }

  input {
    border: none;
    outline: none;
    appearance: none;
  }
`,
  H1e = Dd`
  .wui-color-inherit {
    color: var(--wui-color-inherit);
  }

  .wui-color-accent-100 {
    color: var(--wui-color-accent-100);
  }

  .wui-color-error-100 {
    color: var(--wui-color-error-100);
  }

  .wui-color-blue-100 {
    color: var(--wui-color-blue-100);
  }

  .wui-color-blue-90 {
    color: var(--wui-color-blue-90);
  }

  .wui-color-error-125 {
    color: var(--wui-color-error-125);
  }

  .wui-color-success-100 {
    color: var(--wui-color-success-100);
  }

  .wui-color-success-125 {
    color: var(--wui-color-success-125);
  }

  .wui-color-inverse-100 {
    color: var(--wui-color-inverse-100);
  }

  .wui-color-inverse-000 {
    color: var(--wui-color-inverse-000);
  }

  .wui-color-fg-100 {
    color: var(--wui-color-fg-100);
  }

  .wui-color-fg-200 {
    color: var(--wui-color-fg-200);
  }

  .wui-color-fg-300 {
    color: var(--wui-color-fg-300);
  }

  .wui-color-fg-325 {
    color: var(--wui-color-fg-325);
  }

  .wui-color-fg-350 {
    color: var(--wui-color-fg-350);
  }

  .wui-bg-color-inherit {
    background-color: var(--wui-color-inherit);
  }

  .wui-bg-color-blue-100 {
    background-color: var(--wui-color-accent-100);
  }

  .wui-bg-color-error-100 {
    background-color: var(--wui-color-error-100);
  }

  .wui-bg-color-error-125 {
    background-color: var(--wui-color-error-125);
  }

  .wui-bg-color-success-100 {
    background-color: var(--wui-color-success-100);
  }

  .wui-bg-color-success-125 {
    background-color: var(--wui-color-success-100);
  }

  .wui-bg-color-inverse-100 {
    background-color: var(--wui-color-inverse-100);
  }

  .wui-bg-color-inverse-000 {
    background-color: var(--wui-color-inverse-000);
  }

  .wui-bg-color-fg-100 {
    background-color: var(--wui-color-fg-100);
  }

  .wui-bg-color-fg-200 {
    background-color: var(--wui-color-fg-200);
  }

  .wui-bg-color-fg-300 {
    background-color: var(--wui-color-fg-300);
  }

  .wui-color-fg-325 {
    background-color: var(--wui-color-fg-325);
  }

  .wui-color-fg-350 {
    background-color: var(--wui-color-fg-350);
  }
`,
  dh = {
    ERROR_CODE_UNRECOGNIZED_CHAIN_ID: 4902,
    ERROR_CODE_DEFAULT: 5e3,
    ERROR_INVALID_CHAIN_ID: 32603,
    DEFAULT_ALLOWED_ANCESTORS: [
      "http://localhost:*",
      "https://*.pages.dev",
      "https://*.vercel.app",
      "https://*.ngrok-free.app",
      "https://secure-mobile.walletconnect.com",
      "https://secure-mobile.walletconnect.org",
    ],
  },
  gge = wfe({
    id: 1,
    name: "Ethereum",
    nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
    rpcUrls: { default: { http: ["https://eth.merkle.io"] } },
    blockExplorers: {
      default: {
        name: "Etherscan",
        url: "https://etherscan.io",
        apiUrl: "https://api.etherscan.io/api",
      },
    },
    contracts: {
      ensRegistry: { address: "0x79937da178932489Ee32290baa5622690De709CA" },
      ensUniversalResolver: {
        address: "0xce01f8eee7E479C928F8919abD53E553a36CeF67",
        blockCreated: 19258213,
      },
      multicall3: {
        address: "0xca11bde05977b3631167028862be2a173976ca11",
        blockCreated: 14353601,
      },
    },
  });
function pg(t) {
  return { formatters: void 0, fees: void 0, serializers: void 0, ...t };
}
const Ck = pg({
    id: "5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp",
    name: "Solana",
    network: "solana-mainnet",
    nativeCurrency: { name: "Solana", symbol: "SOL", decimals: 9 },
    rpcUrls: { default: { http: ["https://rpc.walletconnect.org/v1"] } },
    blockExplorers: { default: { name: "Solscan", url: "https://solscan.io" } },
    testnet: !1,
    chainNamespace: "solana",
    caipNetworkId: "solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp",
    deprecatedCaipNetworkId: "solana:4sGjMW1sUnHzSxGspuhpqLDx6wiyjNtZ",
  }),
  xk = pg({
    id: "EtWTRABZaYq6iMfeYKouRu166VU2xqa1",
    name: "Solana Devnet",
    network: "solana-devnet",
    nativeCurrency: { name: "Solana", symbol: "SOL", decimals: 9 },
    rpcUrls: { default: { http: ["https://rpc.walletconnect.org/v1"] } },
    blockExplorers: { default: { name: "Solscan", url: "https://solscan.io" } },
    testnet: !0,
    chainNamespace: "solana",
    caipNetworkId: "solana:EtWTRABZaYq6iMfeYKouRu166VU2xqa1",
    deprecatedCaipNetworkId: "solana:8E9rvCKLFQia2Y35HXjjpWzj8weVo44K",
  });
pg({
  id: "4uhcVJyU9pJkvQyS88uRDiswHXSCkY3z",
  name: "Solana Testnet",
  network: "solana-testnet",
  nativeCurrency: { name: "Solana", symbol: "SOL", decimals: 9 },
  rpcUrls: { default: { http: ["https://rpc.walletconnect.org/v1"] } },
  blockExplorers: { default: { name: "Solscan", url: "https://solscan.io" } },
  testnet: !0,
  chainNamespace: "solana",
  caipNetworkId: "solana:4uhcVJyU9pJkvQyS88uRDiswHXSCkY3z",
});
pg({
  id: "000000000019d6689c085ae165831e93",
  caipNetworkId: "bip122:000000000019d6689c085ae165831e93",
  chainNamespace: "bip122",
  name: "Bitcoin",
  nativeCurrency: { name: "Bitcoin", symbol: "BTC", decimals: 8 },
  rpcUrls: { default: { http: ["https://rpc.walletconnect.org/v1"] } },
});
pg({
  id: "000000000933ea01ad0ee984209779ba",
  caipNetworkId: "bip122:000000000933ea01ad0ee984209779ba",
  chainNamespace: "bip122",
  name: "Bitcoin Testnet",
  nativeCurrency: { name: "Bitcoin", symbol: "BTC", decimals: 8 },
  rpcUrls: { default: { http: ["https://rpc.walletconnect.org/v1"] } },
  testnet: !0,
});
const yge = {
    solana: [
      "solana_signMessage",
      "solana_signTransaction",
      "solana_requestAccounts",
      "solana_getAccounts",
      "solana_signAllTransactions",
      "solana_signAndSendTransaction",
    ],
    eip155: [
      "eth_accounts",
      "eth_requestAccounts",
      "eth_sendRawTransaction",
      "eth_sign",
      "eth_signTransaction",
      "eth_signTypedData",
      "eth_signTypedData_v3",
      "eth_signTypedData_v4",
      "eth_sendTransaction",
      "personal_sign",
      "wallet_switchEthereumChain",
      "wallet_addEthereumChain",
      "wallet_getPermissions",
      "wallet_requestPermissions",
      "wallet_registerOnboarding",
      "wallet_watchAsset",
      "wallet_scanQRCode",
      "wallet_getCallsStatus",
      "wallet_showCallsStatus",
      "wallet_sendCalls",
      "wallet_getCapabilities",
      "wallet_grantPermissions",
      "wallet_revokePermissions",
      "wallet_getAssets",
    ],
    bip122: ["sendTransfer", "signMessage", "signPsbt", "getAccountAddresses"],
  },
  Ih = {
    getMethodsByChainNamespace(t) {
      return yge[t] || [];
    },
    createDefaultNamespace(t) {
      return {
        methods: this.getMethodsByChainNamespace(t),
        events: ["accountsChanged", "chainChanged"],
        chains: [],
        rpcMap: {},
      };
    },
    applyNamespaceOverrides(t, e) {
      if (!e) return { ...t };
      const n = { ...t },
        r = new Set();
      if (
        (e.methods && Object.keys(e.methods).forEach((i) => r.add(i)),
        e.chains && Object.keys(e.chains).forEach((i) => r.add(i)),
        e.events && Object.keys(e.events).forEach((i) => r.add(i)),
        e.rpcMap &&
          Object.keys(e.rpcMap).forEach((i) => {
            const [s] = i.split(":");
            s && r.add(s);
          }),
        r.forEach((i) => {
          n[i] || (n[i] = this.createDefaultNamespace(i));
        }),
        e.methods &&
          Object.entries(e.methods).forEach(([i, s]) => {
            n[i] && (n[i].methods = s);
          }),
        e.chains &&
          Object.entries(e.chains).forEach(([i, s]) => {
            n[i] && (n[i].chains = s);
          }),
        e.events &&
          Object.entries(e.events).forEach(([i, s]) => {
            n[i] && (n[i].events = s);
          }),
        e.rpcMap)
      ) {
        const i = new Set();
        Object.entries(e.rpcMap).forEach(([s, o]) => {
          const [a, l] = s.split(":");
          !a ||
            !l ||
            !n[a] ||
            (n[a].rpcMap || (n[a].rpcMap = {}),
            i.has(a) || ((n[a].rpcMap = {}), i.add(a)),
            (n[a].rpcMap[l] = o));
        });
      }
      return n;
    },
    createNamespaces(t, e) {
      const n = t.reduce((r, i) => {
        const { id: s, chainNamespace: o, rpcUrls: a } = i,
          l = a.default.http[0];
        r[o] || (r[o] = this.createDefaultNamespace(o));
        const d = `${o}:${s}`,
          p = r[o];
        switch ((p.chains.push(d), d)) {
          case Ck.caipNetworkId:
            p.chains.push(Ck.deprecatedCaipNetworkId);
            break;
          case xk.caipNetworkId:
            p.chains.push(xk.deprecatedCaipNetworkId);
            break;
        }
        return p != null && p.rpcMap && l && (p.rpcMap[s] = l), r;
      }, {});
      return this.applyNamespaceOverrides(n, e);
    },
    resolveReownName: async (t) => {
      var r;
      const e = await U6.resolveName(t);
      return (
        ((r = (Object.values(e == null ? void 0 : e.addresses) || [])[0]) ==
        null
          ? void 0
          : r.address) || !1
      );
    },
    getChainsFromNamespaces(t = {}) {
      return Object.values(t).flatMap((e) => {
        const n = e.chains || [],
          r = e.accounts.map((i) => {
            const [s, o] = i.split(":");
            return `${s}:${o}`;
          });
        return Array.from(new Set([...n, ...r]));
      });
    },
    isSessionEventData(t) {
      return (
        typeof t == "object" &&
        t !== null &&
        "id" in t &&
        "topic" in t &&
        "params" in t &&
        typeof t.params == "object" &&
        t.params !== null &&
        "chainId" in t.params &&
        "event" in t.params &&
        typeof t.params.event == "object" &&
        t.params.event !== null
      );
    },
    isOriginAllowed(t, e, n) {
      for (const r of [...e, ...n])
        if (r.includes("*")) {
          const s = `^${r
            .replace(/[.*+?^${}()|[\]\\]/gu, "\\$&")
            .replace(/\\\*/gu, ".*")}$`;
          if (new RegExp(s, "u").test(t)) return !0;
        } else if (r === t) return !0;
      return !1;
    },
  };
class u_ {
  constructor({ provider: e, namespace: n }) {
    (this.id = ye.CONNECTOR_ID.WALLET_CONNECT),
      (this.name = Pc.ConnectorNamesMap[ye.CONNECTOR_ID.WALLET_CONNECT]),
      (this.type = "WALLET_CONNECT"),
      (this.imageId = Pc.ConnectorImageIds[ye.CONNECTOR_ID.WALLET_CONNECT]),
      (this.getCaipNetworks = Y.getCaipNetworks.bind(Y)),
      (this.caipNetworks = this.getCaipNetworks()),
      (this.provider = e),
      (this.chain = n);
  }
  get chains() {
    return this.getCaipNetworks();
  }
  async connectWalletConnect() {
    if (!(await this.authenticate())) {
      const n = this.getCaipNetworks(),
        r = me.state.universalProviderConfigOverride,
        i = Ih.createNamespaces(n, r);
      await this.provider.connect({ optionalNamespaces: i });
    }
    return {
      clientId: await this.provider.client.core.crypto.getClientId(),
      session: this.provider.session,
    };
  }
  async disconnect() {
    await this.provider.disconnect();
  }
  async authenticate() {
    const e = this.chains.map((n) => n.caipNetworkId);
    return Ch.universalProviderAuthenticate({
      universalProvider: this.provider,
      chains: e,
      methods: wge,
    });
  }
}
const wge = [
  "eth_accounts",
  "eth_requestAccounts",
  "eth_sendRawTransaction",
  "eth_sign",
  "eth_signTransaction",
  "eth_signTypedData",
  "eth_signTypedData_v3",
  "eth_signTypedData_v4",
  "eth_sendTransaction",
  "personal_sign",
  "wallet_switchEthereumChain",
  "wallet_addEthereumChain",
  "wallet_getPermissions",
  "wallet_requestPermissions",
  "wallet_registerOnboarding",
  "wallet_watchAsset",
  "wallet_scanQRCode",
  "wallet_getCallsStatus",
  "wallet_sendCalls",
  "wallet_getCapabilities",
  "wallet_grantPermissions",
  "wallet_revokePermissions",
  "wallet_getAssets",
];
class tL {
  constructor(e) {
    (this.availableConnectors = []),
      (this.eventListeners = new Map()),
      (this.getCaipNetworks = (n) => Y.getCaipNetworks(n)),
      e && this.construct(e);
  }
  construct(e) {
    (this.projectId = e.projectId),
      (this.namespace = e.namespace),
      (this.adapterType = e.adapterType);
  }
  get connectors() {
    return this.availableConnectors;
  }
  get networks() {
    return this.getCaipNetworks(this.namespace);
  }
  setAuthProvider(e) {
    this.addConnector({
      id: ye.CONNECTOR_ID.AUTH,
      type: "AUTH",
      name: ye.CONNECTOR_NAMES.AUTH,
      provider: e,
      imageId: Pc.ConnectorImageIds[ye.CONNECTOR_ID.AUTH],
      chain: this.namespace,
      chains: [],
    });
  }
  addConnector(...e) {
    const n = new Set();
    (this.availableConnectors = [...e, ...this.availableConnectors].filter(
      (r) => (n.has(r.id) ? !1 : (n.add(r.id), !0))
    )),
      this.emit("connectors", this.availableConnectors);
  }
  setStatus(e, n) {
    Be.setStatus(e, n);
  }
  on(e, n) {
    var r;
    this.eventListeners.has(e) || this.eventListeners.set(e, new Set()),
      (r = this.eventListeners.get(e)) == null || r.add(n);
  }
  off(e, n) {
    const r = this.eventListeners.get(e);
    r && r.delete(n);
  }
  removeAllEventListeners() {
    this.eventListeners.forEach((e) => {
      e.clear();
    });
  }
  emit(e, n) {
    const r = this.eventListeners.get(e);
    r && r.forEach((i) => i(n));
  }
  async connectWalletConnect(e) {
    return {
      clientId: (await this.getWalletConnectConnector().connectWalletConnect())
        .clientId,
    };
  }
  async switchNetwork(e) {
    var s;
    const { caipNetwork: n, providerType: r } = e;
    if (!e.provider) return;
    const i = "provider" in e.provider ? e.provider.provider : e.provider;
    if (r === "WALLET_CONNECT") {
      i.setDefaultChain(n.caipNetworkId);
      return;
    }
    if (i && r === "AUTH") {
      const o = i,
        a =
          (s = Be.state.preferredAccountTypes) == null
            ? void 0
            : s[n.chainNamespace];
      await o.switchNetwork(n.caipNetworkId);
      const l = await o.getUser({
        chainId: n.caipNetworkId,
        preferredAccountType: a,
      });
      this.emit("switchNetwork", l);
    }
  }
  getWalletConnectConnector() {
    const e = this.connectors.find((n) => n instanceof u_);
    if (!e) throw new Error("WalletConnectConnector not found");
    return e;
  }
}
class vge extends tL {
  setUniversalProvider(e) {
    this.addConnector(
      new u_({
        provider: e,
        caipNetworks: this.getCaipNetworks(),
        namespace: this.namespace,
      })
    );
  }
  async connect(e) {
    return Promise.resolve({
      id: "WALLET_CONNECT",
      type: "WALLET_CONNECT",
      chainId: Number(e.chainId),
      provider: this.provider,
      address: "",
    });
  }
  async disconnect() {
    try {
      await this.getWalletConnectConnector().disconnect();
    } catch (e) {
      console.warn("UniversalAdapter:disconnect - error", e);
    }
  }
  async getAccounts({ namespace: e }) {
    var i, s, o, a;
    const n = this.provider,
      r =
        ((a =
          (o =
            (s =
              (i = n == null ? void 0 : n.session) == null
                ? void 0
                : i.namespaces) == null
              ? void 0
              : s[e]) == null
            ? void 0
            : o.accounts) == null
          ? void 0
          : a
              .map((l) => {
                const [, , d] = l.split(":");
                return d;
              })
              .filter((l, d, p) => p.indexOf(l) === d)) || [];
    return Promise.resolve({
      accounts: r.map((l) =>
        Je.createAccount(e, l, e === "bip122" ? "payment" : "eoa")
      ),
    });
  }
  async syncConnectors() {
    return Promise.resolve();
  }
  async getBalance(e) {
    var s, o, a, l, d;
    if (
      !(
        e.caipNetwork &&
        er.BALANCE_SUPPORTED_CHAINS.includes(
          (s = e.caipNetwork) == null ? void 0 : s.chainNamespace
        )
      ) ||
      ((o = e.caipNetwork) != null && o.testnet)
    )
      return {
        balance: "0.00",
        symbol:
          ((a = e.caipNetwork) == null ? void 0 : a.nativeCurrency.symbol) ||
          "",
      };
    if (
      Be.state.balanceLoading &&
      e.chainId === ((l = Y.state.activeCaipNetwork) == null ? void 0 : l.id)
    )
      return {
        balance: Be.state.balance || "0.00",
        symbol: Be.state.balanceSymbol || "",
      };
    const i = (await Be.fetchTokenBalance()).find((p) => {
      var f, m;
      return (
        p.chainId ===
          `${(f = e.caipNetwork) == null ? void 0 : f.chainNamespace}:${
            e.chainId
          }` &&
        p.symbol ===
          ((m = e.caipNetwork) == null ? void 0 : m.nativeCurrency.symbol)
      );
    });
    return {
      balance: (i == null ? void 0 : i.quantity.numeric) || "0.00",
      symbol:
        (i == null ? void 0 : i.symbol) ||
        ((d = e.caipNetwork) == null ? void 0 : d.nativeCurrency.symbol) ||
        "",
    };
  }
  async signMessage(e) {
    var o, a, l;
    const { provider: n, message: r, address: i } = e;
    if (!n)
      throw new Error("UniversalAdapter:signMessage - provider is undefined");
    let s = "";
    return (
      ((o = Y.state.activeCaipNetwork) == null ? void 0 : o.chainNamespace) ===
      ye.CHAIN.SOLANA
        ? (s = (
            await n.request(
              {
                method: "solana_signMessage",
                params: {
                  message: r$.encode(new TextEncoder().encode(r)),
                  pubkey: i,
                },
              },
              (a = Y.state.activeCaipNetwork) == null ? void 0 : a.caipNetworkId
            )
          ).signature)
        : (s = await n.request(
            { method: "personal_sign", params: [r, i] },
            (l = Y.state.activeCaipNetwork) == null ? void 0 : l.caipNetworkId
          )),
      { signature: s }
    );
  }
  async estimateGas() {
    return Promise.resolve({ gas: BigInt(0) });
  }
  async sendTransaction() {
    return Promise.resolve({ hash: "" });
  }
  walletGetAssets(e) {
    return Promise.resolve({});
  }
  async writeContract() {
    return Promise.resolve({ hash: "" });
  }
  parseUnits() {
    return 0n;
  }
  formatUnits() {
    return "0";
  }
  async getCapabilities() {
    return Promise.resolve({});
  }
  async grantPermissions() {
    return Promise.resolve({});
  }
  async revokePermissions() {
    return Promise.resolve("0x");
  }
  async syncConnection() {
    return Promise.resolve({
      id: "WALLET_CONNECT",
      type: "WALLET_CONNECT",
      chainId: 1,
      provider: this.provider,
      address: "",
    });
  }
  async switchNetwork(e) {
    var i, s, o, a, l, d;
    const { caipNetwork: n } = e,
      r = this.getWalletConnectConnector();
    if (n.chainNamespace === ye.CHAIN.EVM)
      try {
        await ((i = r.provider) == null
          ? void 0
          : i.request({
              method: "wallet_switchEthereumChain",
              params: [{ chainId: cp(n.id) }],
            }));
      } catch (p) {
        if (
          p.code === dh.ERROR_CODE_UNRECOGNIZED_CHAIN_ID ||
          p.code === dh.ERROR_INVALID_CHAIN_ID ||
          p.code === dh.ERROR_CODE_DEFAULT ||
          ((o =
            (s = p == null ? void 0 : p.data) == null
              ? void 0
              : s.originalError) == null
            ? void 0
            : o.code) === dh.ERROR_CODE_UNRECOGNIZED_CHAIN_ID
        )
          try {
            await ((d = r.provider) == null
              ? void 0
              : d.request({
                  method: "wallet_addEthereumChain",
                  params: [
                    {
                      chainId: cp(n.id),
                      rpcUrls: [
                        (a = n == null ? void 0 : n.rpcUrls.chainDefault) ==
                        null
                          ? void 0
                          : a.http,
                      ],
                      chainName: n.name,
                      nativeCurrency: n.nativeCurrency,
                      blockExplorerUrls: [
                        (l = n.blockExplorers) == null ? void 0 : l.default.url,
                      ],
                    },
                  ],
                }));
          } catch {
            throw new Error("Chain is not supported");
          }
      }
    r.provider.setDefaultChain(n.caipNetworkId);
  }
  getWalletConnectProvider() {
    const e = this.connectors.find((r) => r.type === "WALLET_CONNECT");
    return e == null ? void 0 : e.provider;
  }
}
class bge {
  constructor(e) {
    (this.chainNamespaces = []),
      (this.reportedAlertErrors = {}),
      (this.getCaipNetwork = (n, r) => {
        var i, s, o, a;
        if (n) {
          const l =
            (s =
              (i = Y.getNetworkData(n)) == null
                ? void 0
                : i.requestedCaipNetworks) == null
              ? void 0
              : s.find((p) => p.id === r);
          if (l) return l;
          const d = (o = Y.getNetworkData(n)) == null ? void 0 : o.caipNetwork;
          return (
            d ||
            ((a = Y.getRequestedCaipNetworks(n).filter(
              (p) => p.chainNamespace === n
            )) == null
              ? void 0
              : a[0])
          );
        }
        return Y.state.activeCaipNetwork || this.defaultCaipNetwork;
      }),
      (this.getCaipNetworkId = () => {
        const n = this.getCaipNetwork();
        if (n) return n.id;
      }),
      (this.getCaipNetworks = (n) => Y.getCaipNetworks(n)),
      (this.getActiveChainNamespace = () => Y.state.activeChain),
      (this.setRequestedCaipNetworks = (n, r) => {
        Y.setRequestedCaipNetworks(n, r);
      }),
      (this.getApprovedCaipNetworkIds = () => Y.getAllApprovedCaipNetworkIds()),
      (this.getCaipAddress = (n) =>
        Y.state.activeChain === n || !n
          ? Y.state.activeCaipAddress
          : Y.getAccountProp("caipAddress", n)),
      (this.setClientId = (n) => {
        Xe.setClientId(n);
      }),
      (this.getProvider = (n) => Gt.getProvider(n)),
      (this.getProviderType = (n) => Gt.getProviderId(n)),
      (this.getPreferredAccountType = (n) => {
        var r;
        return (r = Be.state.preferredAccountTypes) == null ? void 0 : r[n];
      }),
      (this.setCaipAddress = (n, r) => {
        Be.setCaipAddress(n, r);
      }),
      (this.setBalance = (n, r, i) => {
        Be.setBalance(n, r, i);
      }),
      (this.setProfileName = (n, r) => {
        Be.setProfileName(n, r);
      }),
      (this.setProfileImage = (n, r) => {
        Be.setProfileImage(n, r);
      }),
      (this.setUser = (n, r) => {
        Be.setUser(n, r), me.state.enableEmbedded && jn.close();
      }),
      (this.resetAccount = (n) => {
        Be.resetAccount(n);
      }),
      (this.setCaipNetwork = (n) => {
        Y.setActiveCaipNetwork(n);
      }),
      (this.setCaipNetworkOfNamespace = (n, r) => {
        Y.setChainNetworkData(r, { caipNetwork: n });
      }),
      (this.setAllAccounts = (n, r) => {
        Be.setAllAccounts(n, r),
          me.setHasMultipleAddresses((n == null ? void 0 : n.length) > 1);
      }),
      (this.setStatus = (n, r) => {
        Be.setStatus(n, r),
          nt.isConnected()
            ? Ie.setConnectionStatus("connected")
            : Ie.setConnectionStatus("disconnected");
      }),
      (this.getAddressByChainNamespace = (n) => Y.getAccountProp("address", n)),
      (this.setConnectors = (n) => {
        const r = [...nt.state.allConnectors, ...n];
        nt.setConnectors(r);
      }),
      (this.fetchIdentity = (n) => Xe.fetchIdentity(n)),
      (this.getReownName = (n) => U6.getNamesForAddress(n)),
      (this.getConnectors = () => nt.getConnectors()),
      (this.getConnectorImage = (n) => K3.getConnectorImage(n)),
      (this.setConnectedWalletInfo = (n, r) => {
        const i = Gt.getProviderId(r),
          s = n ? { ...n, type: i } : void 0;
        Be.setConnectedWalletInfo(s, r);
      }),
      (this.getIsConnectedState = () => !!Y.state.activeCaipAddress),
      (this.addAddressLabel = (n, r, i) => {
        Be.addAddressLabel(n, r, i);
      }),
      (this.removeAddressLabel = (n, r) => {
        Be.removeAddressLabel(n, r);
      }),
      (this.getAddress = (n) =>
        Y.state.activeChain === n || !n
          ? Be.state.address
          : Y.getAccountProp("address", n)),
      (this.setApprovedCaipNetworksData = (n) =>
        Y.setApprovedCaipNetworksData(n)),
      (this.resetNetwork = (n) => {
        Y.resetNetwork(n);
      }),
      (this.addConnector = (n) => {
        nt.addConnector(n);
      }),
      (this.resetWcConnection = () => {
        an.resetWcConnection();
      }),
      (this.setAddressExplorerUrl = (n, r) => {
        Be.setAddressExplorerUrl(n, r);
      }),
      (this.setSmartAccountDeployed = (n, r) => {
        Be.setSmartAccountDeployed(n, r);
      }),
      (this.setSmartAccountEnabledNetworks = (n, r) => {
        Y.setSmartAccountEnabledNetworks(n, r);
      }),
      (this.setPreferredAccountType = (n, r) => {
        Be.setPreferredAccountType(n, r);
      }),
      (this.setEIP6963Enabled = (n) => {
        me.setEIP6963Enabled(n);
      }),
      (this.handleUnsafeRPCRequest = () => {
        if (this.isOpen()) {
          if (this.isTransactionStackEmpty()) return;
          this.redirect("ApproveTransaction");
        } else this.open({ view: "ApproveTransaction" });
      }),
      (this.options = e),
      (this.version = e.sdkVersion),
      (this.caipNetworks = this.extendCaipNetworks(e)),
      (this.chainNamespaces = this.getChainNamespacesSet(
        e.adapters,
        this.caipNetworks
      )),
      (this.defaultCaipNetwork = this.extendDefaultCaipNetwork(e)),
      (this.chainAdapters = this.createAdapters(e.adapters)),
      this.initialize(e);
  }
  getChainNamespacesSet(e, n) {
    const r = e == null ? void 0 : e.map((s) => s.namespace).filter((s) => !!s);
    if (r != null && r.length) return [...new Set(r)];
    const i = n == null ? void 0 : n.map((s) => s.chainNamespace);
    return [...new Set(i)];
  }
  async initialize(e) {
    var n, r, i;
    this.initControllers(e),
      await this.initChainAdapters(),
      await this.injectModalUi(),
      this.sendInitializeEvent(e),
      Ro.set({ initialized: !0 }),
      await this.syncExistingConnection(),
      (((n = me.state.features) != null && n.email) ||
        (Array.isArray((r = me.state.features) == null ? void 0 : r.socials) &&
          ((i = me.state.features) == null ? void 0 : i.socials.length) > 0)) &&
        (await this.checkAllowedOrigins());
  }
  async checkAllowedOrigins() {
    const e = await Ze.fetchAllowedOrigins();
    if (e && Je.isClient()) {
      const n = window.location.origin;
      Ih.isOriginAllowed(n, e, dh.DEFAULT_ALLOWED_ANCESTORS) ||
        ti.open(pr.ALERT_ERRORS.INVALID_APP_CONFIGURATION, "error");
    } else ti.open(pr.ALERT_ERRORS.PROJECT_ID_NOT_CONFIGURED, "error");
  }
  sendInitializeEvent(e) {
    var r;
    const { ...n } = e;
    delete n.adapters,
      delete n.universalProvider,
      fn.sendEvent({
        type: "track",
        event: "INITIALIZE",
        properties: {
          ...n,
          networks: e.networks.map((i) => i.id),
          siweConfig: {
            options: ((r = e.siweConfig) == null ? void 0 : r.options) || {},
          },
        },
      });
  }
  initControllers(e) {
    this.initializeOptionsController(e),
      this.initializeChainController(e),
      this.initializeThemeController(e),
      this.initializeConnectionController(e),
      this.initializeConnectorController();
  }
  initializeThemeController(e) {
    e.themeMode && Hr.setThemeMode(e.themeMode),
      e.themeVariables && Hr.setThemeVariables(e.themeVariables);
  }
  initializeChainController(e) {
    if (!this.connectionControllerClient || !this.networkControllerClient)
      throw new Error(
        "ConnectionControllerClient and NetworkControllerClient must be set"
      );
    Y.initialize(e.adapters ?? [], this.caipNetworks, {
      connectionControllerClient: this.connectionControllerClient,
      networkControllerClient: this.networkControllerClient,
    });
    const n = this.getDefaultNetwork();
    n && Y.setActiveCaipNetwork(n);
  }
  initializeConnectionController(e) {
    an.setWcBasic(e.basic ?? !1);
  }
  initializeConnectorController() {
    nt.initialize(this.chainNamespaces);
  }
  initializeOptionsController(e) {
    var o;
    me.setDebug(e.debug !== !1),
      me.setEnableWalletConnect(e.enableWalletConnect !== !1),
      me.setEnableWalletGuide(e.enableWalletGuide !== !1),
      me.setEnableWallets(e.enableWallets !== !1),
      me.setEIP6963Enabled(e.enableEIP6963 !== !1),
      me.setEnableNetworkSwitch(e.enableNetworkSwitch !== !1),
      me.setEnableAuthLogger(e.enableAuthLogger !== !1),
      me.setCustomRpcUrls(e.customRpcUrls),
      me.setSdkVersion(e.sdkVersion),
      me.setProjectId(e.projectId),
      me.setEnableEmbedded(e.enableEmbedded),
      me.setAllWallets(e.allWallets),
      me.setIncludeWalletIds(e.includeWalletIds),
      me.setExcludeWalletIds(e.excludeWalletIds),
      me.setFeaturedWalletIds(e.featuredWalletIds),
      me.setTokens(e.tokens),
      me.setTermsConditionsUrl(e.termsConditionsUrl),
      me.setPrivacyPolicyUrl(e.privacyPolicyUrl),
      me.setCustomWallets(e.customWallets),
      me.setFeatures(e.features),
      me.setAllowUnsupportedChain(e.allowUnsupportedChain),
      me.setUniversalProviderConfigOverride(e.universalProviderConfigOverride),
      me.setDefaultAccountTypes(e.defaultAccountTypes);
    const n = Ie.getPreferredAccountTypes(),
      r = { ...me.state.defaultAccountTypes, ...n };
    Be.setPreferredAccountTypes(r);
    const i = this.getDefaultMetaData();
    if (
      (!e.metadata && i && (e.metadata = i),
      me.setMetadata(e.metadata),
      me.setDisableAppend(e.disableAppend),
      me.setEnableEmbedded(e.enableEmbedded),
      me.setSIWX(e.siwx),
      !e.projectId)
    ) {
      ti.open(pr.ALERT_ERRORS.PROJECT_ID_NOT_CONFIGURED, "error");
      return;
    }
    if (
      ((o = e.adapters) == null
        ? void 0
        : o.find((a) => a.namespace === ye.CHAIN.EVM)) &&
      e.siweConfig
    ) {
      if (e.siwx)
        throw new Error("Cannot set both `siweConfig` and `siwx` options");
      me.setSIWX(e.siweConfig.mapToSIWX());
    }
  }
  getDefaultMetaData() {
    var e, n, r, i;
    return typeof window < "u" && typeof document < "u"
      ? {
          name:
            ((n =
              (e = document.getElementsByTagName("title")) == null
                ? void 0
                : e[0]) == null
              ? void 0
              : n.textContent) || "",
          description:
            ((r = document.querySelector('meta[property="og:description"]')) ==
            null
              ? void 0
              : r.content) || "",
          url: window.location.origin,
          icons: [
            ((i = document.querySelector('link[rel~="icon"]')) == null
              ? void 0
              : i.href) || "",
          ],
        }
      : null;
  }
  setUnsupportedNetwork(e) {
    const n = this.getActiveChainNamespace();
    if (n) {
      const r = _o.getUnsupportedNetwork(`${n}:${e}`);
      Y.setActiveCaipNetwork(r);
    }
  }
  getDefaultNetwork() {
    return _o.getCaipNetworkFromStorage(this.defaultCaipNetwork);
  }
  extendCaipNetwork(e, n) {
    return _o.extendCaipNetwork(e, {
      customNetworkImageUrls: n.chainImages,
      projectId: n.projectId,
    });
  }
  extendCaipNetworks(e) {
    return _o.extendCaipNetworks(e.networks, {
      customNetworkImageUrls: e.chainImages,
      customRpcUrls: e.customRpcUrls,
      projectId: e.projectId,
    });
  }
  extendDefaultCaipNetwork(e) {
    const n = e.networks.find((i) => {
      var s;
      return i.id === ((s = e.defaultNetwork) == null ? void 0 : s.id);
    });
    return n
      ? _o.extendCaipNetwork(n, {
          customNetworkImageUrls: e.chainImages,
          customRpcUrls: e.customRpcUrls,
          projectId: e.projectId,
        })
      : void 0;
  }
  createClients() {
    (this.connectionControllerClient = {
      connectWalletConnect: async () => {
        var s;
        const e = Y.state.activeChain,
          n = this.getAdapter(e),
          r = (s = this.getCaipNetwork(e)) == null ? void 0 : s.id;
        if (!n) throw new Error("Adapter not found");
        const i = await n.connectWalletConnect(r);
        this.close(),
          this.setClientId((i == null ? void 0 : i.clientId) || null),
          Ie.setConnectedNamespaces([...Y.state.chains.keys()]),
          this.chainNamespaces.forEach((o) => {
            nt.setConnectorId(pn.CONNECTOR_TYPE_WALLET_CONNECT, o);
          }),
          await this.syncWalletConnectAccount();
      },
      connectExternal: async ({
        id: e,
        info: n,
        type: r,
        provider: i,
        chain: s,
        caipNetwork: o,
      }) => {
        var y, g, v, b, E, S;
        const a = Y.state.activeChain,
          l = s || a,
          d = this.getAdapter(l);
        if (s && s !== a && !o) {
          const C = this.getCaipNetworks().find((_) => _.chainNamespace === s);
          C && this.setCaipNetwork(C);
        }
        if (!d) throw new Error("Adapter not found");
        const p = this.getCaipNetwork(l),
          f = await d.connect({
            id: e,
            info: n,
            type: r,
            provider: i,
            chainId: (o == null ? void 0 : o.id) || (p == null ? void 0 : p.id),
            rpcUrl:
              ((v =
                (g =
                  (y = o == null ? void 0 : o.rpcUrls) == null
                    ? void 0
                    : y.default) == null
                  ? void 0
                  : g.http) == null
                ? void 0
                : v[0]) ||
              ((S =
                (E =
                  (b = p == null ? void 0 : p.rpcUrls) == null
                    ? void 0
                    : b.default) == null
                  ? void 0
                  : E.http) == null
                ? void 0
                : S[0]),
          });
        if (!f) return;
        Ie.addConnectedNamespace(l),
          this.syncProvider({ ...f, chainNamespace: l });
        const { accounts: m } = await d.getAccounts({ namespace: l, id: e });
        this.setAllAccounts(m, l),
          this.setStatus("connected", l),
          this.syncConnectedWalletInfo(l);
      },
      reconnectExternal: async ({ id: e, info: n, type: r, provider: i }) => {
        var a;
        const s = Y.state.activeChain,
          o = this.getAdapter(s);
        o != null &&
          o.reconnect &&
          (await (o == null
            ? void 0
            : o.reconnect({
                id: e,
                info: n,
                type: r,
                provider: i,
                chainId: (a = this.getCaipNetwork()) == null ? void 0 : a.id,
              })),
          Ie.addConnectedNamespace(s),
          this.syncConnectedWalletInfo(s));
      },
      disconnect: async (e) => {
        const n = e || Y.state.activeChain,
          r = this.getAdapter(n),
          i = Gt.getProvider(n),
          s = Gt.getProviderId(n);
        await (r == null
          ? void 0
          : r.disconnect({ provider: i, providerType: s })),
          Ie.removeConnectedNamespace(n),
          Gt.resetChain(n),
          this.setUser(void 0, n),
          this.setStatus("disconnected", n),
          this.setConnectedWalletInfo(void 0, n);
      },
      checkInstalled: (e) =>
        e
          ? e.some((n) => {
              var r;
              return !!((r = window.ethereum) != null && r[String(n)]);
            })
          : !!window.ethereum,
      signMessage: async (e) => {
        const n = this.getAdapter(Y.state.activeChain),
          r = await (n == null
            ? void 0
            : n.signMessage({
                message: e,
                address: Be.state.address,
                provider: Gt.getProvider(Y.state.activeChain),
              }));
        return (r == null ? void 0 : r.signature) || "";
      },
      sendTransaction: async (e) => {
        const n = e.chainNamespace;
        if (er.SEND_SUPPORTED_NAMESPACES.includes(n)) {
          const r = this.getAdapter(Y.state.activeChain),
            i = Gt.getProvider(n),
            s = await (r == null
              ? void 0
              : r.sendTransaction({
                  ...e,
                  caipNetwork: this.getCaipNetwork(),
                  provider: i,
                }));
          return (s == null ? void 0 : s.hash) || "";
        }
        return "";
      },
      estimateGas: async (e) => {
        if (e.chainNamespace === ye.CHAIN.EVM) {
          const n = this.getAdapter(Y.state.activeChain),
            r = Gt.getProvider(Y.state.activeChain),
            i = this.getCaipNetwork();
          if (!i) throw new Error("CaipNetwork is undefined");
          const s = await (n == null
            ? void 0
            : n.estimateGas({ ...e, provider: r, caipNetwork: i }));
          return (s == null ? void 0 : s.gas) || 0n;
        }
        return 0n;
      },
      getEnsAvatar: async () => {
        var e;
        return (
          await this.syncIdentity({
            address: Be.state.address,
            chainId: Number(
              (e = this.getCaipNetwork()) == null ? void 0 : e.id
            ),
            chainNamespace: Y.state.activeChain,
          }),
          Be.state.profileImage || !1
        );
      },
      getEnsAddress: async (e) => await Ih.resolveReownName(e),
      writeContract: async (e) => {
        const n = this.getAdapter(Y.state.activeChain),
          r = this.getCaipNetwork(),
          i = this.getCaipAddress(),
          s = Gt.getProvider(Y.state.activeChain);
        if (!r || !i)
          throw new Error("CaipNetwork or CaipAddress is undefined");
        const o = await (n == null
          ? void 0
          : n.writeContract({
              ...e,
              caipNetwork: r,
              provider: s,
              caipAddress: i,
            }));
        return o == null ? void 0 : o.hash;
      },
      parseUnits: (e, n) => {
        const r = this.getAdapter(Y.state.activeChain);
        return (
          (r == null ? void 0 : r.parseUnits({ value: e, decimals: n })) ?? 0n
        );
      },
      formatUnits: (e, n) => {
        const r = this.getAdapter(Y.state.activeChain);
        return (
          (r == null ? void 0 : r.formatUnits({ value: e, decimals: n })) ?? "0"
        );
      },
      getCapabilities: async (e) => {
        const n = this.getAdapter(Y.state.activeChain);
        return await (n == null ? void 0 : n.getCapabilities(e));
      },
      grantPermissions: async (e) => {
        const n = this.getAdapter(Y.state.activeChain);
        return await (n == null ? void 0 : n.grantPermissions(e));
      },
      revokePermissions: async (e) => {
        const n = this.getAdapter(Y.state.activeChain);
        return n != null && n.revokePermissions
          ? await n.revokePermissions(e)
          : "0x";
      },
      walletGetAssets: async (e) => {
        const n = this.getAdapter(Y.state.activeChain);
        return (await (n == null ? void 0 : n.walletGetAssets(e))) ?? {};
      },
    }),
      (this.networkControllerClient = {
        switchCaipNetwork: async (e) => await this.switchCaipNetwork(e),
        getApprovedCaipNetworksData: async () =>
          this.getApprovedCaipNetworksData(),
      }),
      an.setClient(this.connectionControllerClient);
  }
  getApprovedCaipNetworksData() {
    var n, r, i, s, o;
    if (
      Gt.getProviderId(Y.state.activeChain) === pn.CONNECTOR_TYPE_WALLET_CONNECT
    ) {
      const a =
        (r = (n = this.universalProvider) == null ? void 0 : n.session) == null
          ? void 0
          : r.namespaces;
      return {
        supportsAllNetworks:
          ((o =
            (s = (i = this.universalProvider) == null ? void 0 : i.session) ==
            null
              ? void 0
              : s.peer) == null
            ? void 0
            : o.metadata.name) === "MetaMask Wallet",
        approvedCaipNetworkIds: this.getChainsFromNamespaces(a),
      };
    }
    return { supportsAllNetworks: !0, approvedCaipNetworkIds: [] };
  }
  async switchCaipNetwork(e) {
    if (!e) return;
    const n = e.chainNamespace;
    if (this.getAddressByChainNamespace(e.chainNamespace)) {
      const i = Gt.getProvider(n),
        s = Gt.getProviderId(n);
      if (e.chainNamespace === Y.state.activeChain) {
        const o = this.getAdapter(n);
        await (o == null
          ? void 0
          : o.switchNetwork({ caipNetwork: e, provider: i, providerType: s }));
      } else if (
        (this.setCaipNetwork(e), s === pn.CONNECTOR_TYPE_WALLET_CONNECT)
      )
        this.syncWalletConnectAccount();
      else {
        const o = this.getAddressByChainNamespace(n);
        o && this.syncAccount({ address: o, chainId: e.id, chainNamespace: n });
      }
    } else this.setCaipNetwork(e);
  }
  getChainsFromNamespaces(e = {}) {
    return Object.values(e).flatMap((n) => {
      const r = n.chains || [],
        i = n.accounts.map((s) => {
          const { chainId: o, chainNamespace: a } = tc.parseCaipAddress(s);
          return `${a}:${o}`;
        });
      return Array.from(new Set([...r, ...i]));
    });
  }
  createAdapters(e) {
    return (
      this.createClients(),
      this.chainNamespaces.reduce((n, r) => {
        var s;
        const i = e == null ? void 0 : e.find((o) => o.namespace === r);
        return (
          i
            ? (i.construct({
                namespace: r,
                projectId: (s = this.options) == null ? void 0 : s.projectId,
                networks: this.getCaipNetworks(),
              }),
              (n[r] = i))
            : (n[r] = new vge({
                namespace: r,
                networks: this.getCaipNetworks(),
              })),
          n
        );
      }, {})
    );
  }
  async initChainAdapter(e) {
    var n;
    this.onConnectors(e),
      this.listenAdapter(e),
      (n = this.chainAdapters) == null ||
        n[e].syncConnectors(this.options, this),
      await this.createUniversalProviderForAdapter(e);
  }
  async initChainAdapters() {
    await Promise.all(
      this.chainNamespaces.map(async (e) => {
        await this.initChainAdapter(e);
      })
    );
  }
  onConnectors(e) {
    const n = this.getAdapter(e);
    n == null || n.on("connectors", this.setConnectors.bind(this));
  }
  listenAdapter(e) {
    const n = this.getAdapter(e);
    if (!n) return;
    const r = Ie.getConnectionStatus();
    r === "connected"
      ? this.setStatus("connecting", e)
      : r === "disconnected"
      ? (Ie.clearAddressCache(), this.setStatus(r, e))
      : this.setStatus(r, e),
      n.on("switchNetwork", ({ address: i, chainId: s }) => {
        const o = this.getCaipNetworks().find(
            (d) => d.id === s || d.caipNetworkId === s
          ),
          a = Y.state.activeChain === e,
          l = Y.getAccountProp("address", e);
        if (o) {
          const d = a && i ? i : l;
          d &&
            this.syncAccount({ address: d, chainId: o.id, chainNamespace: e });
        } else this.setUnsupportedNetwork(s);
      }),
      n.on("disconnect", this.disconnect.bind(this, e)),
      n.on("pendingTransactions", () => {
        const i = Be.state.address,
          s = Y.state.activeCaipNetwork;
        !i ||
          !(s != null && s.id) ||
          this.updateNativeBalance(i, s.id, s.chainNamespace);
      }),
      n.on("accountChanged", ({ address: i, chainId: s }) => {
        var a, l;
        const o = Y.state.activeChain === e;
        o && s
          ? this.syncAccount({ address: i, chainId: s, chainNamespace: e })
          : o && (a = Y.state.activeCaipNetwork) != null && a.id
          ? this.syncAccount({
              address: i,
              chainId: (l = Y.state.activeCaipNetwork) == null ? void 0 : l.id,
              chainNamespace: e,
            })
          : this.syncAccountInfo(i, s, e),
          this.syncAllAccounts(e);
      });
  }
  async createUniversalProviderForAdapter(e) {
    var n, r, i;
    await this.getUniversalProvider(),
      this.universalProvider &&
        ((i =
          (r = (n = this.chainAdapters) == null ? void 0 : n[e]) == null
            ? void 0
            : r.setUniversalProvider) == null ||
          i.call(r, this.universalProvider));
  }
  async syncExistingConnection() {
    await Promise.allSettled(
      this.chainNamespaces.map((e) => this.syncNamespaceConnection(e))
    );
  }
  async syncNamespaceConnection(e) {
    try {
      const n = nt.getConnectorId(e);
      switch ((this.setStatus("connecting", e), n)) {
        case ye.CONNECTOR_ID.WALLET_CONNECT:
          await this.syncWalletConnectAccount();
          break;
        case ye.CONNECTOR_ID.AUTH:
          break;
        default:
          await this.syncAdapterConnection(e);
      }
    } catch (n) {
      console.warn("AppKit couldn't sync existing connection", n),
        this.setStatus("disconnected", e);
    }
  }
  async syncAdapterConnection(e) {
    var o, a, l;
    const n = this.getAdapter(e),
      r = nt.getConnectorId(e),
      i = this.getCaipNetwork(e),
      s = nt.getConnectors(e).find((d) => d.id === r);
    try {
      if (!n || !s)
        throw new Error(`Adapter or connector not found for namespace ${e}`);
      if (!(i != null && i.id)) throw new Error("CaipNetwork not found");
      const d = await (n == null
        ? void 0
        : n.syncConnection({
            namespace: e,
            id: s.id,
            chainId: i.id,
            rpcUrl:
              (l =
                (a =
                  (o = i == null ? void 0 : i.rpcUrls) == null
                    ? void 0
                    : o.default) == null
                  ? void 0
                  : a.http) == null
                ? void 0
                : l[0],
          }));
      if (d) {
        const p = await (n == null
          ? void 0
          : n.getAccounts({ namespace: e, id: s.id }));
        p && p.accounts.length > 0
          ? this.setAllAccounts(p.accounts, e)
          : this.setAllAccounts([Je.createAccount(e, d.address, "eoa")], e),
          this.syncProvider({ ...d, chainNamespace: e }),
          await this.syncAccount({ ...d, chainNamespace: e }),
          this.setStatus("connected", e);
      } else this.setStatus("disconnected", e);
    } catch {
      this.setStatus("disconnected", e);
    }
  }
  async syncWalletConnectAccount() {
    const e = this.chainNamespaces.map(async (n) => {
      var a, l, d, p, f;
      const r = this.getAdapter(n),
        i =
          ((p =
            (d =
              (l = (a = this.universalProvider) == null ? void 0 : a.session) ==
              null
                ? void 0
                : l.namespaces) == null
              ? void 0
              : d[n]) == null
            ? void 0
            : p.accounts) || [],
        s = (f = Y.state.activeCaipNetwork) == null ? void 0 : f.id,
        o =
          i.find((m) => {
            const { chainId: y } = tc.parseCaipAddress(m);
            return y === (s == null ? void 0 : s.toString());
          }) || i[0];
      if (o) {
        const m = tc.validateCaipAddress(o),
          { chainId: y, address: g } = tc.parseCaipAddress(m);
        if (
          (Gt.setProviderId(n, pn.CONNECTOR_TYPE_WALLET_CONNECT),
          this.caipNetworks &&
            Y.state.activeCaipNetwork &&
            (r == null ? void 0 : r.namespace) !== ye.CHAIN.EVM)
        ) {
          const v =
            r == null
              ? void 0
              : r.getWalletConnectProvider({
                  caipNetworks: this.getCaipNetworks(),
                  provider: this.universalProvider,
                  activeCaipNetwork: Y.state.activeCaipNetwork,
                });
          Gt.setProvider(n, v);
        } else Gt.setProvider(n, this.universalProvider);
        nt.setConnectorId(ye.CONNECTOR_ID.WALLET_CONNECT, n),
          Ie.addConnectedNamespace(n),
          this.syncWalletConnectAccounts(n),
          await this.syncAccount({ address: g, chainId: y, chainNamespace: n });
      } else this.setStatus("disconnected", n);
      this.syncConnectedWalletInfo(n), await Y.setApprovedCaipNetworksData(n);
    });
    await Promise.all(e);
  }
  syncWalletConnectAccounts(e) {
    var r, i, s, o, a;
    const n =
      (a =
        (o =
          (s =
            (i = (r = this.universalProvider) == null ? void 0 : r.session) ==
            null
              ? void 0
              : i.namespaces) == null
            ? void 0
            : s[e]) == null
          ? void 0
          : o.accounts) == null
        ? void 0
        : a
            .map((l) => {
              const { address: d } = tc.parseCaipAddress(l);
              return d;
            })
            .filter((l, d, p) => p.indexOf(l) === d);
    n &&
      this.setAllAccounts(
        n.map((l) =>
          Je.createAccount(e, l, e === "bip122" ? "payment" : "eoa")
        ),
        e
      );
  }
  syncProvider({ type: e, provider: n, id: r, chainNamespace: i }) {
    Gt.setProviderId(i, e), Gt.setProvider(i, n), nt.setConnectorId(r, i);
  }
  async syncAllAccounts(e) {
    const n = nt.getConnectorId(e);
    if (!n) return;
    const r = this.getAdapter(e),
      i = await (r == null ? void 0 : r.getAccounts({ namespace: e, id: n }));
    i && i.accounts.length > 0 && this.setAllAccounts(i.accounts, e);
  }
  async syncAccount(e) {
    var f, m;
    const n = e.chainNamespace === Y.state.activeChain,
      r = Y.getCaipNetworkByNamespace(e.chainNamespace, e.chainId),
      { address: i, chainId: s, chainNamespace: o } = e,
      { chainId: a } = Ie.getActiveNetworkProps(),
      l = s || a,
      d =
        ((f = Y.state.activeCaipNetwork) == null ? void 0 : f.name) ===
        ye.UNSUPPORTED_NETWORK_NAME,
      p = Y.getNetworkProp("supportsAllNetworks", o);
    if ((this.setStatus("connected", o), !(d && !p) && l)) {
      let y = this.getCaipNetworks().find(
          (b) => b.id.toString() === l.toString()
        ),
        g = this.getCaipNetworks().find((b) => b.chainNamespace === o);
      if (!p && !y && !g) {
        const b = this.getApprovedCaipNetworkIds() || [],
          E = b.find((C) => {
            var _;
            return (
              ((_ = tc.parseCaipNetworkId(C)) == null ? void 0 : _.chainId) ===
              l.toString()
            );
          }),
          S = b.find((C) => {
            var _;
            return (
              ((_ = tc.parseCaipNetworkId(C)) == null
                ? void 0
                : _.chainNamespace) === o
            );
          });
        (y = this.getCaipNetworks().find((C) => C.caipNetworkId === E)),
          (g = this.getCaipNetworks().find(
            (C) =>
              C.caipNetworkId === S ||
              ("deprecatedCaipNetworkId" in C &&
                C.deprecatedCaipNetworkId === S)
          ));
      }
      const v = y || g;
      (v == null ? void 0 : v.chainNamespace) === Y.state.activeChain
        ? me.state.enableNetworkSwitch &&
          !me.state.allowUnsupportedChain &&
          ((m = Y.state.activeCaipNetwork) == null ? void 0 : m.name) ===
            ye.UNSUPPORTED_NETWORK_NAME
          ? Y.showUnsupportedChainUI()
          : this.setCaipNetwork(v)
        : n || (r && this.setCaipNetworkOfNamespace(r, o)),
        this.syncConnectedWalletInfo(o),
        qv.isLowerCaseMatch(i, Be.state.address) ||
          this.syncAccountInfo(i, v == null ? void 0 : v.id, o),
        n
          ? await this.syncBalance({
              address: i,
              chainId: v == null ? void 0 : v.id,
              chainNamespace: o,
            })
          : await this.syncBalance({
              address: i,
              chainId: r == null ? void 0 : r.id,
              chainNamespace: o,
            });
    }
  }
  async syncAccountInfo(e, n, r) {
    const i = this.getCaipAddress(r),
      s = n || (i == null ? void 0 : i.split(":")[1]);
    if (!s) return;
    const o = `${r}:${s}:${e}`;
    this.setCaipAddress(o, r),
      await this.syncIdentity({ address: e, chainId: s, chainNamespace: r });
  }
  async syncReownName(e, n) {
    try {
      const r = await this.getReownName(e);
      if (r[0]) {
        const i = r[0];
        this.setProfileName(i.name, n);
      } else this.setProfileName(null, n);
    } catch {
      this.setProfileName(null, n);
    }
  }
  syncConnectedWalletInfo(e) {
    var i;
    const n = nt.getConnectorId(e),
      r = Gt.getProviderId(e);
    if (r === pn.CONNECTOR_TYPE_ANNOUNCED || r === pn.CONNECTOR_TYPE_INJECTED) {
      if (n) {
        const s = this.getConnectors().find((o) => o.id === n);
        if (s) {
          const { info: o, name: a, imageUrl: l } = s,
            d = l || this.getConnectorImage(s);
          this.setConnectedWalletInfo({ name: a, icon: d, ...o }, e);
        }
      }
    } else if (r === pn.CONNECTOR_TYPE_WALLET_CONNECT) {
      const s = Gt.getProvider(e);
      s != null &&
        s.session &&
        this.setConnectedWalletInfo(
          {
            ...s.session.peer.metadata,
            name: s.session.peer.metadata.name,
            icon: (i = s.session.peer.metadata.icons) == null ? void 0 : i[0],
          },
          e
        );
    } else if (n)
      if (n === ye.CONNECTOR_ID.COINBASE) {
        const s = this.getConnectors().find(
          (o) => o.id === ye.CONNECTOR_ID.COINBASE
        );
        this.setConnectedWalletInfo(
          { name: "Coinbase Wallet", icon: this.getConnectorImage(s) },
          e
        );
      } else this.setConnectedWalletInfo({ name: n }, e);
  }
  async syncBalance(e) {
    !jh
      .getNetworksByNamespace(this.getCaipNetworks(), e.chainNamespace)
      .find((r) => {
        var i;
        return (
          r.id.toString() === ((i = e.chainId) == null ? void 0 : i.toString())
        );
      }) ||
      !e.chainId ||
      (await this.updateNativeBalance(e.address, e.chainId, e.chainNamespace));
  }
  async updateNativeBalance(e, n, r) {
    const i = this.getAdapter(r),
      s = Y.getCaipNetworkByNamespace(r, n);
    if (i) {
      const o = await i.getBalance({
        address: e,
        chainId: n,
        caipNetwork: s,
        tokens: this.options.tokens,
      });
      this.setBalance(o.balance, o.symbol, r);
    }
  }
  async initializeUniversalAdapter() {
    var r, i, s, o, a, l, d, p, f, m;
    const e = Pfe.createLogger((y, ...g) => {
        y && this.handleAlertError(y), console.error(...g);
      }),
      n = {
        projectId: (r = this.options) == null ? void 0 : r.projectId,
        metadata: {
          name:
            (i = this.options) != null && i.metadata
              ? (s = this.options) == null
                ? void 0
                : s.metadata.name
              : "",
          description:
            (o = this.options) != null && o.metadata
              ? (a = this.options) == null
                ? void 0
                : a.metadata.description
              : "",
          url:
            (l = this.options) != null && l.metadata
              ? (d = this.options) == null
                ? void 0
                : d.metadata.url
              : "",
          icons:
            (p = this.options) != null && p.metadata
              ? (f = this.options) == null
                ? void 0
                : f.metadata.icons
              : [""],
        },
        logger: e,
      };
    me.setManualWCControl(!!((m = this.options) != null && m.manualWCControl)),
      (this.universalProvider =
        this.options.universalProvider ?? (await Jle.init(n))),
      this.listenWalletConnect();
  }
  listenWalletConnect() {
    this.universalProvider &&
      (this.universalProvider.on("display_uri", (e) => {
        an.setUri(e);
      }),
      this.universalProvider.on("connect", an.finalizeWcConnection),
      this.universalProvider.on("disconnect", () => {
        this.chainNamespaces.forEach((e) => {
          this.resetAccount(e);
        }),
          an.resetWcConnection();
      }),
      this.universalProvider.on("chainChanged", (e) => {
        const n = this.getCaipNetworks().find((i) => i.id == e),
          r = this.getCaipNetwork();
        if (!n) {
          this.setUnsupportedNetwork(e);
          return;
        }
        (r == null ? void 0 : r.id) !== (n == null ? void 0 : n.id) &&
          this.setCaipNetwork(n);
      }),
      this.universalProvider.on("session_event", (e) => {
        if (Ih.isSessionEventData(e)) {
          const { name: n, data: r } = e.params.event;
          n === "accountsChanged" &&
            Array.isArray(r) &&
            Je.isCaipAddress(r[0]) &&
            this.syncAccount(tc.parseCaipAddress(r[0]));
        }
      }));
  }
  createUniversalProvider() {
    var e;
    return (
      !this.universalProviderInitPromise &&
        Je.isClient() &&
        (e = this.options) != null &&
        e.projectId &&
        (this.universalProviderInitPromise = this.initializeUniversalAdapter()),
      this.universalProviderInitPromise
    );
  }
  async getUniversalProvider() {
    if (!this.universalProvider)
      try {
        await this.createUniversalProvider();
      } catch (e) {
        fn.sendEvent({
          type: "error",
          event: "INTERNAL_SDK_ERROR",
          properties: {
            errorType: "UniversalProviderInitError",
            errorMessage: e instanceof Error ? e.message : "Unknown",
            uncaught: !1,
          },
        }),
          console.error(
            "AppKit:getUniversalProvider - Cannot create provider",
            e
          );
      }
    return this.universalProvider;
  }
  handleAlertError(e) {
    const n = Object.entries(pr.UniversalProviderErrors).find(
        ([, { message: a }]) => e.message.includes(a)
      ),
      [r, i] = n ?? [],
      { message: s, alertErrorKey: o } = i ?? {};
    if (r && s && !this.reportedAlertErrors[r]) {
      const a = pr.ALERT_ERRORS[o];
      a && (ti.open(a, "error"), (this.reportedAlertErrors[r] = !0));
    }
  }
  getAdapter(e) {
    var n;
    if (e) return (n = this.chainAdapters) == null ? void 0 : n[e];
  }
  createAdapter(e) {
    var i;
    if (!e) return;
    const n = e.namespace;
    if (!n) return;
    this.createClients();
    const r = e;
    (r.namespace = n),
      r.construct({
        namespace: n,
        projectId: (i = this.options) == null ? void 0 : i.projectId,
        networks: this.getCaipNetworks(),
      }),
      this.chainNamespaces.includes(n) || this.chainNamespaces.push(n),
      this.chainAdapters && (this.chainAdapters[n] = r);
  }
  async open(e) {
    if (
      (await this.injectModalUi(),
      e != null && e.uri && an.setUri(e.uri),
      e != null && e.arguments)
    )
      switch (e == null ? void 0 : e.view) {
        case "Swap":
          return jn.open({ ...e, data: { swap: e.arguments } });
      }
    return jn.open(e);
  }
  async close(e = !1) {
    await this.injectModalUi(), jn.close(e);
  }
  setLoading(e, n) {
    jn.setLoading(e, n);
  }
  async disconnect(e) {
    await an.disconnect(e);
  }
  getSIWX() {
    return me.state.siwx;
  }
  getError() {
    return "";
  }
  getChainId() {
    var e;
    return (e = Y.state.activeCaipNetwork) == null ? void 0 : e.id;
  }
  async switchNetwork(e) {
    const n = this.getCaipNetworks().find((r) => r.id === e.id);
    if (!n) {
      ti.open(pr.ALERT_ERRORS.SWITCH_NETWORK_NOT_FOUND, "error");
      return;
    }
    await Y.switchActiveNetwork(n);
  }
  getWalletProvider() {
    return Y.state.activeChain ? Gt.state.providers[Y.state.activeChain] : null;
  }
  getWalletProviderType() {
    return Gt.getProviderId(Y.state.activeChain);
  }
  subscribeProviders(e) {
    return Gt.subscribeProviders(e);
  }
  getThemeMode() {
    return Hr.state.themeMode;
  }
  getThemeVariables() {
    return Hr.state.themeVariables;
  }
  setThemeMode(e) {
    Hr.setThemeMode(e), eL(Hr.state.themeMode);
  }
  setTermsConditionsUrl(e) {
    me.setTermsConditionsUrl(e);
  }
  setPrivacyPolicyUrl(e) {
    me.setPrivacyPolicyUrl(e);
  }
  setThemeVariables(e) {
    Hr.setThemeVariables(e), mge(Hr.state.themeVariables);
  }
  subscribeTheme(e) {
    return Hr.subscribe(e);
  }
  getWalletInfo() {
    return Be.state.connectedWalletInfo;
  }
  getAccount(e) {
    var o;
    const n = nt.getAuthConnector(e),
      r = Y.getAccountData(e),
      i = Y.state.activeChain,
      s = Ie.getConnectedConnectorId(e);
    if (r)
      return {
        allAccounts: r.allAccounts,
        caipAddress: r.caipAddress,
        address: Je.getPlainAddress(r.caipAddress),
        isConnected: !!r.caipAddress,
        status: r.status,
        embeddedWalletInfo:
          n && s === ye.CONNECTOR_ID.AUTH
            ? {
                user: r.user
                  ? { ...r.user, username: Ie.getConnectedSocialUsername() }
                  : void 0,
                authProvider: r.socialProvider || "email",
                accountType:
                  (o = r.preferredAccountTypes) == null ? void 0 : o[e || i],
                isSmartAccountDeployed: !!r.smartAccountDeployed,
              }
            : void 0,
      };
  }
  subscribeAccount(e, n) {
    const r = () => {
      const i = this.getAccount(n);
      i && e(i);
    };
    n ? Y.subscribeChainProp("accountState", r, n) : Y.subscribe(r),
      nt.subscribe(r);
  }
  subscribeNetwork(e) {
    return Y.subscribe(({ activeCaipNetwork: n }) => {
      e({
        caipNetwork: n,
        chainId: n == null ? void 0 : n.id,
        caipNetworkId: n == null ? void 0 : n.caipNetworkId,
      });
    });
  }
  subscribeWalletInfo(e) {
    return Be.subscribeKey("connectedWalletInfo", e);
  }
  subscribeShouldUpdateToAddress(e) {
    Be.subscribeKey("shouldUpdateToAddress", e);
  }
  subscribeCaipNetworkChange(e) {
    Y.subscribeKey("activeCaipNetwork", e);
  }
  getState() {
    return Ro.state;
  }
  subscribeState(e) {
    return Ro.subscribe(e);
  }
  showErrorMessage(e) {
    qs.showError(e);
  }
  showSuccessMessage(e) {
    qs.showSuccess(e);
  }
  getEvent() {
    return { ...fn.state };
  }
  subscribeEvents(e) {
    return fn.subscribe(e);
  }
  replace(e) {
    zt.replace(e);
  }
  redirect(e) {
    zt.push(e);
  }
  popTransactionStack(e) {
    zt.popTransactionStack(e);
  }
  isOpen() {
    return jn.state.open;
  }
  isTransactionStackEmpty() {
    return zt.state.transactionStack.length === 0;
  }
  isTransactionShouldReplaceView() {
    var e;
    return (e =
      zt.state.transactionStack[zt.state.transactionStack.length - 1]) == null
      ? void 0
      : e.replace;
  }
  static getInstance() {
    return this.instance;
  }
  updateFeatures(e) {
    me.setFeatures(e);
  }
  updateOptions(e) {
    const r = { ...(me.state || {}), ...e };
    me.setOptions(r);
  }
  setConnectMethodsOrder(e) {
    me.setConnectMethodsOrder(e);
  }
  setWalletFeaturesOrder(e) {
    me.setWalletFeaturesOrder(e);
  }
  setCollapseWallets(e) {
    me.setCollapseWallets(e);
  }
  setSocialsOrder(e) {
    me.setSocialsOrder(e);
  }
  getConnectMethodsOrder() {
    return wS.getConnectOrderMethod(me.state.features, nt.getConnectors());
  }
  addNetwork(e, n) {
    if (this.chainAdapters && !this.chainAdapters[e])
      throw new Error(`Adapter for namespace ${e} doesn't exist`);
    const r = this.extendCaipNetwork(n, this.options);
    this.getCaipNetworks().find((i) => i.id === r.id) || Y.addNetwork(r);
  }
  removeNetwork(e, n) {
    if (this.chainAdapters && !this.chainAdapters[e])
      throw new Error(`Adapter for namespace ${e} doesn't exist`);
    this.getCaipNetworks().find((i) => i.id === n) && Y.removeNetwork(e, n);
  }
}
let Sk = !1;
class Ege extends bge {
  setupAuthConnectorListeners(e) {
    e.onRpcRequest((n) => {
      Fi.checkIfRequestExists(n)
        ? Fi.checkIfRequestIsSafe(n) || this.handleUnsafeRPCRequest()
        : (this.open(),
          console.error(Rr.RPC_METHOD_NOT_ALLOWED_MESSAGE, {
            method: n.method,
          }),
          setTimeout(() => {
            this.showErrorMessage(Rr.RPC_METHOD_NOT_ALLOWED_UI_MESSAGE);
          }, 300),
          e.rejectRpcRequests());
    }),
      e.onRpcError(() => {
        this.isOpen() &&
          (this.isTransactionStackEmpty()
            ? this.close(!0)
            : this.popTransactionStack(!0));
      }),
      e.onRpcSuccess((n, r) => {
        const i = Fi.checkIfRequestIsSafe(r),
          s = Be.state.address,
          o = Y.state.activeCaipNetwork;
        i ||
          (this.isTransactionStackEmpty()
            ? (this.close(!0),
              s &&
                o != null &&
                o.id &&
                this.updateNativeBalance(s, o.id, o.chainNamespace))
            : (this.popTransactionStack(),
              s &&
                o != null &&
                o.id &&
                this.updateNativeBalance(s, o.id, o.chainNamespace)));
      }),
      e.onNotConnected(() => {
        const n = Y.state.activeChain;
        nt.getConnectorId(n) === ye.CONNECTOR_ID.AUTH &&
          (this.setCaipAddress(void 0, n), this.setLoading(!1, n));
      }),
      e.onConnect(async (n) => {
        var a, l;
        const r = Y.state.activeChain,
          i =
            r === ye.CHAIN.EVM
              ? `eip155:${n.chainId}:${n.address}`
              : `${n.chainId}:${n.address}`,
          s =
            n.preferredAccountType ||
            ((a = Be.state.preferredAccountTypes) == null ? void 0 : a[r]) ||
            me.state.defaultAccountTypes[r];
        qv.isLowerCaseMatch(n.address, Be.state.address) ||
          this.syncIdentity({
            address: n.address,
            chainId: n.chainId,
            chainNamespace: r,
          }),
          this.setCaipAddress(i, r),
          this.setUser({ ...(Be.state.user || {}), ...n }, r),
          this.setSmartAccountDeployed(!!n.smartAccountDeployed, r),
          this.setPreferredAccountType(s, r);
        const o =
          (l = n.accounts) == null
            ? void 0
            : l.map((d) => {
                var p;
                return Je.createAccount(
                  r,
                  d.address,
                  d.type ||
                    ((p = Be.state.preferredAccountTypes) == null
                      ? void 0
                      : p[r]) ||
                    me.state.defaultAccountTypes[r]
                );
              });
        this.setAllAccounts(
          o || [Je.createAccount(r, n.address, n.preferredAccountType || s)],
          r
        ),
          await e.getSmartAccountEnabledNetworks(),
          this.setLoading(!1, r);
      }),
      e.onSocialConnected(({ userName: n }) => {
        this.setUser(
          { ...(Be.state.user || {}), username: n },
          Y.state.activeChain
        );
      }),
      e.onGetSmartAccountEnabledNetworks((n) => {
        this.setSmartAccountEnabledNetworks(n, Y.state.activeChain);
      }),
      e.onSetPreferredAccount(({ address: n, type: r }) => {
        n && this.setPreferredAccountType(r, Y.state.activeChain);
      });
  }
  async syncAuthConnector(e, n) {
    var p, f, m, y;
    const r = ye.AUTH_CONNECTOR_SUPPORTED_CHAINS.includes(n);
    if (!r) return;
    this.setLoading(!0, n);
    const i = e.getLoginEmailUsed();
    this.setLoading(i, n), i && this.setStatus("connecting", n);
    const s = e.getEmail(),
      o = e.getUsername();
    this.setUser(
      {
        ...(((p = Be.state) == null ? void 0 : p.user) || {}),
        username: o,
        email: s,
      },
      Y.state.activeChain
    ),
      this.setupAuthConnectorListeners(e);
    const { isConnected: a } = await e.isConnected(),
      l = Hr.getSnapshot(),
      d = me.getSnapshot();
    e.syncDappData({
      metadata: d.metadata,
      sdkVersion: d.sdkVersion,
      projectId: d.projectId,
      sdkType: d.sdkType,
    }),
      e.syncTheme({
        themeMode: l.themeMode,
        themeVariables: l.themeVariables,
        w3mThemeVariables: ga(l.themeVariables, l.themeMode),
      }),
      n &&
        r &&
        (a && (f = this.connectionControllerClient) != null && f.connectExternal
          ? (await ((y = this.connectionControllerClient) == null
              ? void 0
              : y.connectExternal({
                  id: ye.CONNECTOR_ID.AUTH,
                  info: { name: ye.CONNECTOR_ID.AUTH },
                  type: pn.CONNECTOR_TYPE_AUTH,
                  provider: e,
                  chainId:
                    (m = Y.state.activeCaipNetwork) == null ? void 0 : m.id,
                  chain: n,
                })),
            this.setStatus("connected", n))
          : nt.getConnectorId(n) === ye.CONNECTOR_ID.AUTH &&
            (this.setStatus("disconnected", n),
            Ie.removeConnectedNamespace(n))),
      this.setLoading(!1, n);
  }
  async checkExistingTelegramSocialConnection(e) {
    var n;
    try {
      if (!Je.isTelegram()) return;
      const r = Ie.getTelegramSocialProvider();
      if (!r || typeof window > "u" || typeof document > "u") return;
      const s = new URL(window.location.href).searchParams.get("result_uri");
      if (!s) return;
      Be.setSocialProvider(r, e),
        await ((n = this.authProvider) == null ? void 0 : n.init());
      const o = nt.getAuthConnector();
      r &&
        o &&
        (this.setLoading(!0, e),
        await o.provider.connectSocial(s),
        await an.connectExternal(o, o.chain),
        Ie.setConnectedSocialProvider(r),
        Ie.removeTelegramSocialProvider(),
        fn.sendEvent({
          type: "track",
          event: "SOCIAL_LOGIN_SUCCESS",
          properties: { provider: r },
        }));
    } catch (r) {
      this.setLoading(!1, e),
        console.error("checkExistingSTelegramocialConnection error", r);
    }
    try {
      const r = new URL(window.location.href);
      r.searchParams.delete("result_uri"),
        window.history.replaceState({}, document.title, r.toString());
    } catch (r) {
      console.error("tma social login failed", r);
    }
  }
  createAuthProvider(e) {
    var o, a, l, d, p, f, m, y, g, v, b, E, S, C, _;
    if (!ye.AUTH_CONNECTOR_SUPPORTED_CHAINS.includes(e)) return;
    const r =
        ((a = (o = this.options) == null ? void 0 : o.features) == null
          ? void 0
          : a.email) === void 0
          ? er.DEFAULT_FEATURES.email
          : (d = (l = this.options) == null ? void 0 : l.features) == null
          ? void 0
          : d.email,
      i =
        (f = (p = this.options) == null ? void 0 : p.features) != null &&
        f.socials
          ? ((g =
              (y = (m = this.options) == null ? void 0 : m.features) == null
                ? void 0
                : y.socials) == null
              ? void 0
              : g.length) > 0
          : ((b = (v = this.options) == null ? void 0 : v.features) == null
              ? void 0
              : b.socials) ?? er.DEFAULT_FEATURES.socials,
      s = r || i;
    !this.authProvider &&
      (E = this.options) != null &&
      E.projectId &&
      s &&
      ((this.authProvider = Wl.getInstance({
        projectId: this.options.projectId,
        enableLogger: this.options.enableAuthLogger,
        chainId:
          (S = this.getCaipNetwork(e)) == null ? void 0 : S.caipNetworkId,
        abortController: pr.EmbeddedWalletAbortController,
        onTimeout: (A) => {
          A === "iframe_load_failed"
            ? ti.open(pr.ALERT_ERRORS.IFRAME_LOAD_FAILED, "error")
            : A === "iframe_request_timeout"
            ? ti.open(pr.ALERT_ERRORS.IFRAME_REQUEST_TIMEOUT, "error")
            : A === "unverified_domain" &&
              ti.open(pr.ALERT_ERRORS.UNVERIFIED_DOMAIN, "error");
        },
      })),
      Ro.subscribeOpen((A) => {
        var I;
        !A &&
          this.isTransactionStackEmpty() &&
          ((I = this.authProvider) == null || I.rejectRpcRequests());
      }),
      e === ye.CHAIN.EVM &&
        (C = Be.state.preferredAccountTypes) != null &&
        C.eip155 &&
        this.authProvider.setPreferredAccount(
          (_ = Be.state.preferredAccountTypes) == null ? void 0 : _.eip155
        ),
      this.syncAuthConnector(this.authProvider, e),
      this.checkExistingTelegramSocialConnection(e));
  }
  createAuthProviderForAdapter(e) {
    var n, r, i;
    this.createAuthProvider(e),
      this.authProvider &&
        ((i =
          (r = (n = this.chainAdapters) == null ? void 0 : n[e]) == null
            ? void 0
            : r.setAuthProvider) == null ||
          i.call(r, this.authProvider));
  }
  initControllers(e) {
    super.initControllers(e),
      this.options.excludeWalletIds &&
        Ze.initializeExcludedWallets({ ids: this.options.excludeWalletIds });
  }
  async switchCaipNetwork(e) {
    var s, o;
    if (!e) return;
    const n = Y.state.activeChain,
      r = e.chainNamespace,
      i = this.getAddressByChainNamespace(e.chainNamespace);
    if (e.chainNamespace === Y.state.activeChain && i) {
      const a = this.getAdapter(r),
        l = Gt.getProvider(r),
        d = Gt.getProviderId(r);
      await (a == null
        ? void 0
        : a.switchNetwork({ caipNetwork: e, provider: l, providerType: d })),
        this.setCaipNetwork(e);
    } else {
      const l = Gt.getProviderId(n) === pn.CONNECTOR_TYPE_AUTH,
        d = Gt.getProviderId(r),
        p = d === pn.CONNECTOR_TYPE_AUTH,
        f = ye.AUTH_CONNECTOR_SUPPORTED_CHAINS.includes(r);
      if ((l || p) && f)
        try {
          (Y.state.activeChain = e.chainNamespace),
            await ((o =
              (s = this.connectionControllerClient) == null
                ? void 0
                : s.connectExternal) == null
              ? void 0
              : o.call(s, {
                  id: ye.CONNECTOR_ID.AUTH,
                  provider: this.authProvider,
                  chain: r,
                  chainId: e.id,
                  type: pn.CONNECTOR_TYPE_AUTH,
                  caipNetwork: e,
                })),
            this.setCaipNetwork(e);
        } catch {
          const y = this.getAdapter(r);
          await (y == null
            ? void 0
            : y.switchNetwork({
                caipNetwork: e,
                provider: this.authProvider,
                providerType: d,
              }));
        }
      else
        d === pn.CONNECTOR_TYPE_WALLET_CONNECT
          ? (this.setCaipNetwork(e), this.syncWalletConnectAccount())
          : (this.setCaipNetwork(e),
            i &&
              this.syncAccount({
                address: i,
                chainId: e.id,
                chainNamespace: r,
              }));
    }
  }
  async initChainAdapter(e) {
    await super.initChainAdapter(e), this.createAuthProviderForAdapter(e);
  }
  async syncIdentity({ address: e, chainId: n, chainNamespace: r }) {
    var o;
    const i = `${r}:${n}`,
      s =
        (o = this.caipNetworks) == null
          ? void 0
          : o.find((a) => a.caipNetworkId === i);
    if (r !== ye.CHAIN.EVM || (s != null && s.testnet)) {
      this.setProfileName(null, r), this.setProfileImage(null, r);
      return;
    }
    try {
      const { name: a, avatar: l } = await this.fetchIdentity({
        address: e,
        caipNetworkId: i,
      });
      this.setProfileName(a, r), this.setProfileImage(l, r);
    } catch {
      await this.syncReownName(e, r), n !== 1 && this.setProfileImage(null, r);
    }
  }
  syncConnectedWalletInfo(e) {
    const n = Gt.getProviderId(e);
    if (n === pn.CONNECTOR_TYPE_AUTH) {
      const r = this.authProvider;
      if (r) {
        const i = Ie.getConnectedSocialProvider() ?? "email",
          s = r.getEmail() ?? r.getUsername();
        this.setConnectedWalletInfo({ name: n, identifier: s, social: i }, e);
      }
    } else super.syncConnectedWalletInfo(e);
  }
  async injectModalUi() {
    if (!Sk && Je.isClient()) {
      const e = { ...er.DEFAULT_FEATURES, ...this.options.features },
        n = [];
      if (
        ((e.email || (e.socials && e.socials.length)) &&
          n.push(
            ei(
              () => import("./embedded-wallet-9Mr_gfy5.js"),
              __vite__mapDeps([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])
            )
          ),
        e.email &&
          n.push(
            ei(
              () => import("./email-C2igh4f6.js"),
              __vite__mapDeps([12, 1, 11, 5, 10, 4, 9, 13, 6])
            )
          ),
        e.socials &&
          n.push(
            ei(
              () => import("./socials-BuxvScHX.js"),
              __vite__mapDeps([
                14, 1, 15, 4, 16, 17, 10, 18, 9, 5, 11, 19, 3, 20,
              ])
            )
          ),
        e.swaps &&
          n.push(
            ei(
              () => import("./swaps-DEFkLK3n.js"),
              __vite__mapDeps([21, 1, 9, 5, 22, 23, 24, 3, 10, 20, 6, 4])
            )
          ),
        e.send &&
          n.push(
            ei(
              () => import("./send-DSdN0Cjf.js"),
              __vite__mapDeps([25, 1, 9, 5, 10, 4, 16, 11, 24, 3, 6, 26, 27])
            )
          ),
        e.receive &&
          n.push(
            ei(
              () => import("./receive-CGDBu_L8.js"),
              __vite__mapDeps([28, 1, 29, 3, 19])
            )
          ),
        e.onramp &&
          n.push(
            ei(
              () => import("./onramp-dhC80NgT.js"),
              __vite__mapDeps([
                30, 1, 31, 20, 10, 3, 5, 32, 15, 4, 16, 33, 11, 9, 18, 6,
              ])
            )
          ),
        e.history &&
          n.push(
            ei(
              () => import("./transactions-DlTHesjF.js"),
              __vite__mapDeps([34, 1, 35, 31, 20, 10, 11, 3])
            )
          ),
        e.pay &&
          n.push(
            ei(
              () => import("./index-DyCZFNHX.js"),
              __vite__mapDeps([36, 1, 9, 5, 37, 3, 10, 7, 32, 27, 18])
            )
          ),
        await Promise.all([
          ...n,
          ei(
            () => import("./index-DCYaHz8t.js"),
            __vite__mapDeps([
              38, 1, 3, 5, 26, 10, 39, 23, 7, 32, 9, 8, 37, 35, 31, 20, 11, 22,
              4, 6, 27, 13, 15, 16, 17, 2, 18, 29, 19, 33,
            ])
          ),
          ei(
            () => import("./w3m-modal-BRRiU4tk.js"),
            __vite__mapDeps([40, 1, 7, 3, 10, 8, 5, 23, 39])
          ),
        ]),
        !document.querySelector("w3m-modal"))
      ) {
        const i = document.createElement("w3m-modal");
        !me.state.disableAppend &&
          !me.state.enableEmbedded &&
          document.body.insertAdjacentElement("beforeend", i);
      }
      Sk = !0;
    }
  }
}
let uc;
function Cge(t) {
  t && (uc = t);
}
function nL() {
  if (!uc)
    throw new Error('Please call "createAppKit" before using "useAppKit" hook');
  async function t(n) {
    await (uc == null ? void 0 : uc.open(n));
  }
  async function e() {
    await (uc == null ? void 0 : uc.close());
  }
  return { open: t, close: e };
}
const xge = "1.7.4";
let f0;
function Sge(t) {
  return (
    f0 ||
      ((f0 = new Ege({
        ...t,
        sdkVersion: Je.generateSdkVersion(t.adapters ?? [], "react", xge),
      })),
      Cge(f0)),
    f0
  );
}
function rL(t) {
  var e,
    n,
    r = "";
  if (typeof t == "string" || typeof t == "number") r += t;
  else if (typeof t == "object")
    if (Array.isArray(t))
      for (e = 0; e < t.length; e++)
        t[e] && (n = rL(t[e])) && (r && (r += " "), (r += n));
    else for (e in t) t[e] && (r && (r += " "), (r += e));
  return r;
}
function Ia() {
  for (var t, e, n = 0, r = ""; n < arguments.length; )
    (t = arguments[n++]) && (e = rL(t)) && (r && (r += " "), (r += e));
  return r;
}
const q1e = Object.freeze(
  Object.defineProperty(
    { __proto__: null, clsx: Ia, default: Ia },
    Symbol.toStringTag,
    { value: "Module" }
  )
);
let Age = { data: "" },
  _ge = (t) =>
    typeof window == "object"
      ? (
          (t ? t.querySelector("#_goober") : window._goober) ||
          Object.assign(
            (t || document.head).appendChild(document.createElement("style")),
            { innerHTML: " ", id: "_goober" }
          )
        ).firstChild
      : t || Age,
  Ige = /(?:([\u0080-\uFFFF\w-%@]+) *:? *([^{;]+?);|([^;}{]*?) *{)|(}\s*)/g,
  Tge = /\/\*[^]*?\*\/|  +/g,
  Ak = /\n+/g,
  _l = (t, e) => {
    let n = "",
      r = "",
      i = "";
    for (let s in t) {
      let o = t[s];
      s[0] == "@"
        ? s[1] == "i"
          ? (n = s + " " + o + ";")
          : (r +=
              s[1] == "f"
                ? _l(o, s)
                : s + "{" + _l(o, s[1] == "k" ? "" : e) + "}")
        : typeof o == "object"
        ? (r += _l(
            o,
            e
              ? e.replace(/([^,])+/g, (a) =>
                  s.replace(/([^,]*:\S+\([^)]*\))|([^,])+/g, (l) =>
                    /&/.test(l) ? l.replace(/&/g, a) : a ? a + " " + l : l
                  )
                )
              : s
          ))
        : o != null &&
          ((s = /^--/.test(s) ? s : s.replace(/[A-Z]/g, "-$&").toLowerCase()),
          (i += _l.p ? _l.p(s, o) : s + ":" + o + ";"));
    }
    return n + (e && i ? e + "{" + i + "}" : i) + r;
  },
  oa = {},
  iL = (t) => {
    if (typeof t == "object") {
      let e = "";
      for (let n in t) e += n + iL(t[n]);
      return e;
    }
    return t;
  },
  Pge = (t, e, n, r, i) => {
    let s = iL(t),
      o =
        oa[s] ||
        (oa[s] = ((l) => {
          let d = 0,
            p = 11;
          for (; d < l.length; ) p = (101 * p + l.charCodeAt(d++)) >>> 0;
          return "go" + p;
        })(s));
    if (!oa[o]) {
      let l =
        s !== t
          ? t
          : ((d) => {
              let p,
                f,
                m = [{}];
              for (; (p = Ige.exec(d.replace(Tge, ""))); )
                p[4]
                  ? m.shift()
                  : p[3]
                  ? ((f = p[3].replace(Ak, " ").trim()),
                    m.unshift((m[0][f] = m[0][f] || {})))
                  : (m[0][p[1]] = p[2].replace(Ak, " ").trim());
              return m[0];
            })(t);
      oa[o] = _l(i ? { ["@keyframes " + o]: l } : l, n ? "" : "." + o);
    }
    let a = n && oa.g ? oa.g : null;
    return (
      n && (oa.g = oa[o]),
      ((l, d, p, f) => {
        f
          ? (d.data = d.data.replace(f, l))
          : d.data.indexOf(l) === -1 && (d.data = p ? l + d.data : d.data + l);
      })(oa[o], e, r, a),
      o
    );
  },
  Rge = (t, e, n) =>
    t.reduce((r, i, s) => {
      let o = e[s];
      if (o && o.call) {
        let a = o(n),
          l = (a && a.props && a.props.className) || (/^go/.test(a) && a);
        o = l
          ? "." + l
          : a && typeof a == "object"
          ? a.props
            ? ""
            : _l(a, "")
          : a === !1
          ? ""
          : a;
      }
      return r + i + (o ?? "");
    }, "");
function d_(t) {
  let e = this || {},
    n = t.call ? t(e.p) : t;
  return Pge(
    n.unshift
      ? n.raw
        ? Rge(n, [].slice.call(arguments, 1), e.p)
        : n.reduce((r, i) => Object.assign(r, i && i.call ? i(e.p) : i), {})
      : n,
    _ge(e.target),
    e.g,
    e.o,
    e.k
  );
}
d_.bind({ g: 1 });
d_.bind({ k: 1 });
function Nge(t, e) {
  for (var n = 0; n < e.length; n++) {
    var r = e[n];
    (r.enumerable = r.enumerable || !1),
      (r.configurable = !0),
      "value" in r && (r.writable = !0),
      Object.defineProperty(t, r.key, r);
  }
}
function sL(t, e, n) {
  return e && Nge(t.prototype, e), t;
}
function Yt() {
  return (
    (Yt =
      Object.assign ||
      function (t) {
        for (var e = 1; e < arguments.length; e++) {
          var n = arguments[e];
          for (var r in n)
            Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r]);
        }
        return t;
      }),
    Yt.apply(this, arguments)
  );
}
function oL(t, e) {
  (t.prototype = Object.create(e.prototype)),
    (t.prototype.constructor = t),
    (t.__proto__ = e);
}
function fg(t, e) {
  if (t == null) return {};
  var n = {},
    r = Object.keys(t),
    i,
    s;
  for (s = 0; s < r.length; s++)
    (i = r[s]), !(e.indexOf(i) >= 0) && (n[i] = t[i]);
  return n;
}
function _k(t) {
  if (t === void 0)
    throw new ReferenceError(
      "this hasn't been initialised - super() hasn't been called"
    );
  return t;
}
var Ik = function () {
    return "";
  },
  Oge = gt.createContext({ enqueueSnackbar: Ik, closeSnackbar: Ik }),
  El = {
    downXs: "@media (max-width:599.95px)",
    upSm: "@media (min-width:600px)",
  },
  Tk = function (e) {
    return e.charAt(0).toUpperCase() + e.slice(1);
  },
  p_ = function (e) {
    return "" + Tk(e.vertical) + Tk(e.horizontal);
  },
  h0 = function (e) {
    return !!e || e === 0;
  },
  m0 = "unmounted",
  fd = "exited",
  hd = "entering",
  Qf = "entered",
  Pk = "exiting",
  f_ = (function (t) {
    oL(e, t);
    function e(r) {
      var i;
      i = t.call(this, r) || this;
      var s = r.appear,
        o;
      return (
        (i.appearStatus = null),
        r.in
          ? s
            ? ((o = fd), (i.appearStatus = hd))
            : (o = Qf)
          : r.unmountOnExit || r.mountOnEnter
          ? (o = m0)
          : (o = fd),
        (i.state = { status: o }),
        (i.nextCallback = null),
        i
      );
    }
    e.getDerivedStateFromProps = function (i, s) {
      var o = i.in;
      return o && s.status === m0 ? { status: fd } : null;
    };
    var n = e.prototype;
    return (
      (n.componentDidMount = function () {
        this.updateStatus(!0, this.appearStatus);
      }),
      (n.componentDidUpdate = function (i) {
        var s = null;
        if (i !== this.props) {
          var o = this.state.status;
          this.props.in
            ? o !== hd && o !== Qf && (s = hd)
            : (o === hd || o === Qf) && (s = Pk);
        }
        this.updateStatus(!1, s);
      }),
      (n.componentWillUnmount = function () {
        this.cancelNextCallback();
      }),
      (n.getTimeouts = function () {
        var i = this.props.timeout,
          s = i,
          o = i;
        return (
          i != null &&
            typeof i != "number" &&
            typeof i != "string" &&
            ((o = i.exit), (s = i.enter)),
          { exit: o, enter: s }
        );
      }),
      (n.updateStatus = function (i, s) {
        i === void 0 && (i = !1),
          s !== null
            ? (this.cancelNextCallback(),
              s === hd ? this.performEnter(i) : this.performExit())
            : this.props.unmountOnExit &&
              this.state.status === fd &&
              this.setState({ status: m0 });
      }),
      (n.performEnter = function (i) {
        var s = this,
          o = this.props.enter,
          a = i,
          l = this.getTimeouts();
        if (!i && !o) {
          this.safeSetState({ status: Qf }, function () {
            s.props.onEntered && s.props.onEntered(s.node, a);
          });
          return;
        }
        this.props.onEnter && this.props.onEnter(this.node, a),
          this.safeSetState({ status: hd }, function () {
            s.props.onEntering && s.props.onEntering(s.node, a),
              s.onTransitionEnd(l.enter, function () {
                s.safeSetState({ status: Qf }, function () {
                  s.props.onEntered && s.props.onEntered(s.node, a);
                });
              });
          });
      }),
      (n.performExit = function () {
        var i = this,
          s = this.props.exit,
          o = this.getTimeouts();
        if (!s) {
          this.safeSetState({ status: fd }, function () {
            i.props.onExited && i.props.onExited(i.node);
          });
          return;
        }
        this.props.onExit && this.props.onExit(this.node),
          this.safeSetState({ status: Pk }, function () {
            i.props.onExiting && i.props.onExiting(i.node),
              i.onTransitionEnd(o.exit, function () {
                i.safeSetState({ status: fd }, function () {
                  i.props.onExited && i.props.onExited(i.node);
                });
              });
          });
      }),
      (n.cancelNextCallback = function () {
        this.nextCallback !== null &&
          this.nextCallback.cancel &&
          (this.nextCallback.cancel(), (this.nextCallback = null));
      }),
      (n.safeSetState = function (i, s) {
        (s = this.setNextCallback(s)), this.setState(i, s);
      }),
      (n.setNextCallback = function (i) {
        var s = this,
          o = !0;
        return (
          (this.nextCallback = function () {
            o && ((o = !1), (s.nextCallback = null), i());
          }),
          (this.nextCallback.cancel = function () {
            o = !1;
          }),
          this.nextCallback
        );
      }),
      (n.onTransitionEnd = function (i, s) {
        this.setNextCallback(s);
        var o = i == null && !this.props.addEndListener;
        if (!this.node || o) {
          setTimeout(this.nextCallback, 0);
          return;
        }
        this.props.addEndListener &&
          this.props.addEndListener(this.node, this.nextCallback),
          i != null && setTimeout(this.nextCallback, i);
      }),
      (n.render = function () {
        var i = this.state.status;
        if (i === m0) return null;
        var s = this.props,
          o = s.children,
          a = fg(s, [
            "children",
            "in",
            "mountOnEnter",
            "unmountOnExit",
            "appear",
            "enter",
            "exit",
            "timeout",
            "addEndListener",
            "onEnter",
            "onEntering",
            "onEntered",
            "onExit",
            "onExiting",
            "onExited",
            "nodeRef",
          ]);
        return o(i, a);
      }),
      sL(e, [
        {
          key: "node",
          get: function () {
            var i,
              s =
                (i = this.props.nodeRef) === null || i === void 0
                  ? void 0
                  : i.current;
            if (!s)
              throw new Error(
                "notistack - Custom snackbar is not refForwarding"
              );
            return s;
          },
        },
      ]),
      e
    );
  })(gt.Component);
function md() {}
f_.defaultProps = {
  in: !1,
  mountOnEnter: !1,
  unmountOnExit: !1,
  appear: !1,
  enter: !0,
  exit: !0,
  onEnter: md,
  onEntering: md,
  onEntered: md,
  onExit: md,
  onExiting: md,
  onExited: md,
};
function Rk(t, e) {
  typeof t == "function" ? t(e) : t && (t.current = e);
}
function bS(t, e) {
  return N.useMemo(
    function () {
      return t == null && e == null
        ? null
        : function (n) {
            Rk(t, n), Rk(e, n);
          };
    },
    [t, e]
  );
}
function jw(t) {
  var e = t.timeout,
    n = t.style,
    r = n === void 0 ? {} : n,
    i = t.mode;
  return {
    duration: typeof e == "object" ? e[i] || 0 : e,
    easing: r.transitionTimingFunction,
    delay: r.transitionDelay,
  };
}
var ES = {
    easeInOut: "cubic-bezier(0.4, 0, 0.2, 1)",
    easeOut: "cubic-bezier(0.0, 0, 0.2, 1)",
    easeIn: "cubic-bezier(0.4, 0, 1, 1)",
    sharp: "cubic-bezier(0.4, 0, 0.6, 1)",
  },
  aL = function (e) {
    e.scrollTop = e.scrollTop;
  },
  Nk = function (e) {
    return Math.round(e) + "ms";
  };
function _d(t, e) {
  t === void 0 && (t = ["all"]);
  var n = e || {},
    r = n.duration,
    i = r === void 0 ? 300 : r,
    s = n.easing,
    o = s === void 0 ? ES.easeInOut : s,
    a = n.delay,
    l = a === void 0 ? 0 : a,
    d = Array.isArray(t) ? t : [t];
  return d
    .map(function (p) {
      var f = typeof i == "string" ? i : Nk(i),
        m = typeof l == "string" ? l : Nk(l);
      return p + " " + f + " " + o + " " + m;
    })
    .join(",");
}
function kge(t) {
  return (t && t.ownerDocument) || document;
}
function cL(t) {
  var e = kge(t);
  return e.defaultView || window;
}
function Dge(t, e) {
  e === void 0 && (e = 166);
  var n;
  function r() {
    for (
      var i = this, s = arguments.length, o = new Array(s), a = 0;
      a < s;
      a++
    )
      o[a] = arguments[a];
    var l = function () {
      t.apply(i, o);
    };
    clearTimeout(n), (n = setTimeout(l, e));
  }
  return (
    (r.clear = function () {
      clearTimeout(n);
    }),
    r
  );
}
function $ge(t, e) {
  var n = e.getBoundingClientRect(),
    r = cL(e),
    i;
  if (e.fakeTransform) i = e.fakeTransform;
  else {
    var s = r.getComputedStyle(e);
    i =
      s.getPropertyValue("-webkit-transform") ||
      s.getPropertyValue("transform");
  }
  var o = 0,
    a = 0;
  if (i && i !== "none" && typeof i == "string") {
    var l = i.split("(")[1].split(")")[0].split(",");
    (o = parseInt(l[4], 10)), (a = parseInt(l[5], 10));
  }
  switch (t) {
    case "left":
      return "translateX(" + (r.innerWidth + o - n.left) + "px)";
    case "right":
      return "translateX(-" + (n.left + n.width - o) + "px)";
    case "up":
      return "translateY(" + (r.innerHeight + a - n.top) + "px)";
    default:
      return "translateY(-" + (n.top + n.height - a) + "px)";
  }
}
function g0(t, e) {
  if (e) {
    var n = $ge(t, e);
    n && ((e.style.webkitTransform = n), (e.style.transform = n));
  }
}
var lL = N.forwardRef(function (t, e) {
  var n = t.children,
    r = t.direction,
    i = r === void 0 ? "down" : r,
    s = t.in,
    o = t.style,
    a = t.timeout,
    l = a === void 0 ? 0 : a,
    d = t.onEnter,
    p = t.onEntered,
    f = t.onExit,
    m = t.onExited,
    y = fg(t, [
      "children",
      "direction",
      "in",
      "style",
      "timeout",
      "onEnter",
      "onEntered",
      "onExit",
      "onExited",
    ]),
    g = N.useRef(null),
    v = bS(n.ref, g),
    b = bS(v, e),
    E = function (R, D) {
      g0(i, R), aL(R), d && d(R, D);
    },
    S = function (R) {
      var D = (o == null ? void 0 : o.transitionTimingFunction) || ES.easeOut,
        k = jw({
          timeout: l,
          mode: "enter",
          style: Yt({}, o, { transitionTimingFunction: D }),
        });
      (R.style.webkitTransition = _d("-webkit-transform", k)),
        (R.style.transition = _d("transform", k)),
        (R.style.webkitTransform = "none"),
        (R.style.transform = "none");
    },
    C = function (R) {
      var D = (o == null ? void 0 : o.transitionTimingFunction) || ES.sharp,
        k = jw({
          timeout: l,
          mode: "exit",
          style: Yt({}, o, { transitionTimingFunction: D }),
        });
      (R.style.webkitTransition = _d("-webkit-transform", k)),
        (R.style.transition = _d("transform", k)),
        g0(i, R),
        f && f(R);
    },
    _ = function (R) {
      (R.style.webkitTransition = ""), (R.style.transition = ""), m && m(R);
    },
    A = N.useCallback(
      function () {
        g.current && g0(i, g.current);
      },
      [i]
    );
  return (
    N.useEffect(
      function () {
        if (!(s || i === "down" || i === "right")) {
          var I = Dge(function () {
              g.current && g0(i, g.current);
            }),
            R = cL(g.current);
          return (
            R.addEventListener("resize", I),
            function () {
              I.clear(), R.removeEventListener("resize", I);
            }
          );
        }
      },
      [i, s]
    ),
    N.useEffect(
      function () {
        s || A();
      },
      [s, A]
    ),
    N.createElement(
      f_,
      Object.assign(
        {
          appear: !0,
          nodeRef: g,
          onEnter: E,
          onEntered: p,
          onEntering: S,
          onExit: C,
          onExited: _,
          in: s,
          timeout: l,
        },
        y
      ),
      function (I, R) {
        return N.cloneElement(
          n,
          Yt(
            {
              ref: b,
              style: Yt(
                { visibility: I === "exited" && !s ? "hidden" : void 0 },
                o,
                {},
                n.props.style
              ),
            },
            R
          )
        );
      }
    )
  );
});
lL.displayName = "Slide";
var Kv = function (e) {
    return gt.createElement(
      "svg",
      Object.assign(
        {
          viewBox: "0 0 24 24",
          focusable: "false",
          style: {
            fontSize: 20,
            marginInlineEnd: 8,
            userSelect: "none",
            width: "1em",
            height: "1em",
            display: "inline-block",
            fill: "currentColor",
            flexShrink: 0,
          },
        },
        e
      )
    );
  },
  Mge = function () {
    return gt.createElement(
      Kv,
      null,
      gt.createElement("path", {
        d: `M12 2C6.5 2 2 6.5 2 12S6.5 22 12 22 22 17.5 22 12 17.5 2 12 2M10 17L5 12L6.41
        10.59L10 14.17L17.59 6.58L19 8L10 17Z`,
      })
    );
  },
  Lge = function () {
    return gt.createElement(
      Kv,
      null,
      gt.createElement("path", {
        d: "M13,14H11V10H13M13,18H11V16H13M1,21H23L12,2L1,21Z",
      })
    );
  },
  Uge = function () {
    return gt.createElement(
      Kv,
      null,
      gt.createElement("path", {
        d: `M12,2C17.53,2 22,6.47 22,12C22,17.53 17.53,22 12,22C6.47,22 2,17.53 2,12C2,
        6.47 6.47,2 12,2M15.59,7L12,10.59L8.41,7L7,8.41L10.59,12L7,15.59L8.41,17L12,
        13.41L15.59,17L17,15.59L13.41,12L17,8.41L15.59,7Z`,
      })
    );
  },
  Bge = function () {
    return gt.createElement(
      Kv,
      null,
      gt.createElement("path", {
        d: `M13,9H11V7H13M13,17H11V11H13M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,
        0 22,12A10,10 0 0,0 12,2Z`,
      })
    );
  },
  jge = {
    default: void 0,
    success: gt.createElement(Mge, null),
    warning: gt.createElement(Lge, null),
    error: gt.createElement(Uge, null),
    info: gt.createElement(Bge, null),
  },
  Hl = {
    maxSnack: 3,
    persist: !1,
    hideIconVariant: !1,
    disableWindowBlurListener: !1,
    variant: "default",
    autoHideDuration: 5e3,
    iconVariant: jge,
    anchorOrigin: { vertical: "bottom", horizontal: "left" },
    TransitionComponent: lL,
    transitionDuration: { enter: 225, exit: 195 },
  },
  Fge = function (e, n) {
    var r = function (s) {
      return typeof s == "number" || s === null;
    };
    return r(e) ? e : r(n) ? n : Hl.autoHideDuration;
  },
  zge = function (e, n) {
    var r = function (s, o) {
      return o.some(function (a) {
        return typeof s === a;
      });
    };
    return r(e, ["string", "number"])
      ? e
      : r(e, ["object"])
      ? Yt({}, Hl.transitionDuration, {}, r(n, ["object"]) && n, {}, e)
      : r(n, ["string", "number"])
      ? n
      : r(n, ["object"])
      ? Yt({}, Hl.transitionDuration, {}, n)
      : Hl.transitionDuration;
  },
  Wge = function (e, n) {
    return function (r, i) {
      return (
        i === void 0 && (i = !1),
        i
          ? Yt({}, Hl[r], {}, n[r], {}, e[r])
          : r === "autoHideDuration"
          ? Fge(e.autoHideDuration, n.autoHideDuration)
          : r === "transitionDuration"
          ? zge(e.transitionDuration, n.transitionDuration)
          : e[r] || n[r] || Hl[r]
      );
    };
  };
function hg(t) {
  return Object.entries(t).reduce(function (e, n) {
    var r,
      i = n[0],
      s = n[1];
    return Yt({}, e, ((r = {}), (r[i] = d_(s)), r));
  }, {});
}
var gp = {
    SnackbarContainer: "notistack-SnackbarContainer",
    Snackbar: "notistack-Snackbar",
    CollapseWrapper: "notistack-CollapseWrapper",
    MuiContent: "notistack-MuiContent",
    MuiContentVariant: function (e) {
      return "notistack-MuiContent-" + e;
    },
  },
  Ok = hg({ root: { height: 0 }, entered: { height: "auto" } }),
  EC = "0px",
  CC = 175,
  uL = N.forwardRef(function (t, e) {
    var n = t.children,
      r = t.in,
      i = t.onExited,
      s = N.useRef(null),
      o = N.useRef(null),
      a = bS(e, o),
      l = function () {
        return s.current ? s.current.clientHeight : 0;
      },
      d = function (v) {
        v.style.height = EC;
      },
      p = function (v) {
        var b = l(),
          E = jw({ timeout: CC, mode: "enter" }),
          S = E.duration,
          C = E.easing;
        (v.style.transitionDuration = typeof S == "string" ? S : S + "ms"),
          (v.style.height = b + "px"),
          (v.style.transitionTimingFunction = C || "");
      },
      f = function (v) {
        v.style.height = "auto";
      },
      m = function (v) {
        v.style.height = l() + "px";
      },
      y = function (v) {
        aL(v);
        var b = jw({ timeout: CC, mode: "exit" }),
          E = b.duration,
          S = b.easing;
        (v.style.transitionDuration = typeof E == "string" ? E : E + "ms"),
          (v.style.height = EC),
          (v.style.transitionTimingFunction = S || "");
      };
    return N.createElement(
      f_,
      {
        in: r,
        unmountOnExit: !0,
        onEnter: d,
        onEntered: f,
        onEntering: p,
        onExit: m,
        onExited: i,
        onExiting: y,
        nodeRef: o,
        timeout: CC,
      },
      function (g, v) {
        return N.createElement(
          "div",
          Object.assign(
            {
              ref: a,
              className: Ia(Ok.root, g === "entered" && Ok.entered),
              style: Yt(
                {
                  pointerEvents: "all",
                  overflow: "hidden",
                  minHeight: EC,
                  transition: _d("height"),
                },
                g === "entered" && { overflow: "visible" },
                {},
                g === "exited" && !r && { visibility: "hidden" }
              ),
            },
            v
          ),
          N.createElement(
            "div",
            {
              ref: s,
              className: gp.CollapseWrapper,
              style: { display: "flex", width: "100%" },
            },
            n
          )
        );
      }
    );
  });
uL.displayName = "Collapse";
var kk = { right: "left", left: "right", bottom: "up", top: "down" },
  Hge = function (e) {
    return e.horizontal !== "center" ? kk[e.horizontal] : kk[e.vertical];
  },
  qge = function (e) {
    return "anchorOrigin" + p_(e);
  },
  Vge = function (e) {
    e === void 0 && (e = {});
    var n = {
      containerRoot: !0,
      containerAnchorOriginTopCenter: !0,
      containerAnchorOriginBottomCenter: !0,
      containerAnchorOriginTopRight: !0,
      containerAnchorOriginBottomRight: !0,
      containerAnchorOriginTopLeft: !0,
      containerAnchorOriginBottomLeft: !0,
    };
    return Object.keys(e)
      .filter(function (r) {
        return !n[r];
      })
      .reduce(function (r, i) {
        var s;
        return Yt({}, r, ((s = {}), (s[i] = e[i]), s));
      }, {});
  },
  Gge = function () {};
function Th(t, e) {
  return t.reduce(function (n, r) {
    return r == null
      ? n
      : function () {
          for (var s = arguments.length, o = new Array(s), a = 0; a < s; a++)
            o[a] = arguments[a];
          var l = [].concat(o);
          e && l.indexOf(e) === -1 && l.push(e),
            n.apply(this, l),
            r.apply(this, l);
        };
  }, Gge);
}
var Kge = typeof window < "u" ? N.useLayoutEffect : N.useEffect;
function Dk(t) {
  var e = N.useRef(t);
  return (
    Kge(function () {
      e.current = t;
    }),
    N.useCallback(function () {
      return e.current.apply(void 0, arguments);
    }, [])
  );
}
var dL = N.forwardRef(function (t, e) {
  var n = t.children,
    r = t.className,
    i = t.autoHideDuration,
    s = t.disableWindowBlurListener,
    o = s === void 0 ? !1 : s,
    a = t.onClose,
    l = t.id,
    d = t.open,
    p = t.SnackbarProps,
    f = p === void 0 ? {} : p,
    m = N.useRef(),
    y = Dk(function () {
      a && a.apply(void 0, arguments);
    }),
    g = Dk(function (C) {
      !a ||
        C == null ||
        (m.current && clearTimeout(m.current),
        (m.current = setTimeout(function () {
          y(null, "timeout", l);
        }, C)));
    });
  N.useEffect(
    function () {
      return (
        d && g(i),
        function () {
          m.current && clearTimeout(m.current);
        }
      );
    },
    [d, i, g]
  );
  var v = function () {
      m.current && clearTimeout(m.current);
    },
    b = N.useCallback(
      function () {
        i != null && g(i * 0.5);
      },
      [i, g]
    ),
    E = function (_) {
      f.onMouseEnter && f.onMouseEnter(_), v();
    },
    S = function (_) {
      f.onMouseLeave && f.onMouseLeave(_), b();
    };
  return (
    N.useEffect(
      function () {
        if (!o && d)
          return (
            window.addEventListener("focus", b),
            window.addEventListener("blur", v),
            function () {
              window.removeEventListener("focus", b),
                window.removeEventListener("blur", v);
            }
          );
      },
      [o, b, d]
    ),
    N.createElement(
      "div",
      Object.assign({ ref: e }, f, {
        className: Ia(gp.Snackbar, r),
        onMouseEnter: E,
        onMouseLeave: S,
      }),
      n
    )
  );
});
dL.displayName = "Snackbar";
var xC,
  Yge = hg({
    root:
      ((xC = { display: "flex", flexWrap: "wrap", flexGrow: 1 }),
      (xC[El.upSm] = { flexGrow: "initial", minWidth: "288px" }),
      xC),
  }),
  pL = N.forwardRef(function (t, e) {
    var n = t.className,
      r = fg(t, ["className"]);
    return gt.createElement(
      "div",
      Object.assign({ ref: e, className: Ia(Yge.root, n) }, r)
    );
  });
pL.displayName = "SnackbarContent";
var Xf = hg({
    root: {
      backgroundColor: "#313131",
      fontSize: "0.875rem",
      lineHeight: 1.43,
      letterSpacing: "0.01071em",
      color: "#fff",
      alignItems: "center",
      padding: "6px 16px",
      borderRadius: "4px",
      boxShadow:
        "0px 3px 5px -1px rgba(0,0,0,0.2),0px 6px 10px 0px rgba(0,0,0,0.14),0px 1px 18px 0px rgba(0,0,0,0.12)",
    },
    lessPadding: { paddingLeft: 8 * 2.5 + "px" },
    default: { backgroundColor: "#313131" },
    success: { backgroundColor: "#43a047" },
    error: { backgroundColor: "#d32f2f" },
    warning: { backgroundColor: "#ff9800" },
    info: { backgroundColor: "#2196f3" },
    message: { display: "flex", alignItems: "center", padding: "8px 0" },
    action: {
      display: "flex",
      alignItems: "center",
      marginLeft: "auto",
      paddingLeft: "16px",
      marginRight: "-8px",
    },
  }),
  $k = "notistack-snackbar",
  fL = N.forwardRef(function (t, e) {
    var n = t.id,
      r = t.message,
      i = t.action,
      s = t.iconVariant,
      o = t.variant,
      a = t.hideIconVariant,
      l = t.style,
      d = t.className,
      p = s[o],
      f = i;
    return (
      typeof f == "function" && (f = f(n)),
      gt.createElement(
        pL,
        {
          ref: e,
          role: "alert",
          "aria-describedby": $k,
          style: l,
          className: Ia(
            gp.MuiContent,
            gp.MuiContentVariant(o),
            Xf.root,
            Xf[o],
            d,
            !a && p && Xf.lessPadding
          ),
        },
        gt.createElement(
          "div",
          { id: $k, className: Xf.message },
          a ? null : p,
          r
        ),
        f && gt.createElement("div", { className: Xf.action }, f)
      )
    );
  });
fL.displayName = "MaterialDesignContent";
var Zge = N.memo(fL),
  Qge = hg({
    wrappedRoot: {
      width: "100%",
      position: "relative",
      transform: "translateX(0)",
      top: 0,
      right: 0,
      bottom: 0,
      left: 0,
      minWidth: "288px",
    },
  }),
  Xge = function (e) {
    var n = N.useRef(),
      r = N.useState(!0),
      i = r[0],
      s = r[1],
      o = Th([e.snack.onClose, e.onClose]),
      a = function () {
        e.snack.requestClose && o(null, "instructed", e.snack.id);
      },
      l = N.useCallback(function () {
        n.current = setTimeout(function () {
          s(function (k) {
            return !k;
          });
        }, 125);
      }, []);
    N.useEffect(function () {
      return function () {
        n.current && clearTimeout(n.current);
      };
    }, []);
    var d = e.snack,
      p = e.classes,
      f = e.Component,
      m = f === void 0 ? Zge : f,
      y = N.useMemo(
        function () {
          return Vge(p);
        },
        [p]
      ),
      g = d.open,
      v = d.SnackbarProps,
      b = d.TransitionComponent,
      E = d.TransitionProps,
      S = d.transitionDuration,
      C = d.disableWindowBlurListener,
      _ = d.content,
      A = fg(d, [
        "open",
        "SnackbarProps",
        "TransitionComponent",
        "TransitionProps",
        "transitionDuration",
        "disableWindowBlurListener",
        "content",
        "entered",
        "requestClose",
        "onEnter",
        "onEntered",
        "onExit",
        "onExited",
      ]),
      I = Yt({ direction: Hge(A.anchorOrigin), timeout: S }, E),
      R = _;
    typeof R == "function" && (R = R(A.id, A.message));
    var D = ["onEnter", "onEntered", "onExit", "onExited"].reduce(function (
      k,
      T
    ) {
      var U;
      return Yt({}, k, ((U = {}), (U[T] = Th([e.snack[T], e[T]], A.id)), U));
    },
    {});
    return gt.createElement(
      uL,
      { in: i, onExited: D.onExited },
      gt.createElement(
        dL,
        {
          open: g,
          id: A.id,
          disableWindowBlurListener: C,
          autoHideDuration: A.autoHideDuration,
          className: Ia(Qge.wrappedRoot, y.root, y[qge(A.anchorOrigin)]),
          SnackbarProps: v,
          onClose: o,
        },
        gt.createElement(
          b,
          Object.assign({}, I, {
            appear: !0,
            in: g,
            onExit: D.onExit,
            onExited: l,
            onEnter: D.onEnter,
            onEntered: Th([D.onEntered, a], A.id),
          }),
          R || gt.createElement(m, Object.assign({}, A))
        )
      )
    );
  },
  Jf,
  SC,
  y0,
  w0,
  AC,
  aa = { view: { default: 20, dense: 4 }, snackbar: { default: 6, dense: 2 } },
  Mk = "." + gp.CollapseWrapper,
  _C = 16,
  v0 = hg({
    root:
      ((Jf = {
        boxSizing: "border-box",
        display: "flex",
        maxHeight: "100%",
        position: "fixed",
        zIndex: 1400,
        height: "auto",
        width: "auto",
        transition: _d(["top", "right", "bottom", "left", "max-width"], {
          duration: 300,
          easing: "ease",
        }),
        pointerEvents: "none",
      }),
      (Jf[Mk] = {
        padding: aa.snackbar.default + "px 0px",
        transition: "padding 300ms ease 0ms",
      }),
      (Jf.maxWidth = "calc(100% - " + aa.view.default * 2 + "px)"),
      (Jf[El.downXs] = {
        width: "100%",
        maxWidth: "calc(100% - " + _C * 2 + "px)",
      }),
      Jf),
    rootDense:
      ((SC = {}), (SC[Mk] = { padding: aa.snackbar.dense + "px 0px" }), SC),
    top: {
      top: aa.view.default - aa.snackbar.default + "px",
      flexDirection: "column",
    },
    bottom: {
      bottom: aa.view.default - aa.snackbar.default + "px",
      flexDirection: "column-reverse",
    },
    left:
      ((y0 = { left: aa.view.default + "px" }),
      (y0[El.upSm] = { alignItems: "flex-start" }),
      (y0[El.downXs] = { left: _C + "px" }),
      y0),
    right:
      ((w0 = { right: aa.view.default + "px" }),
      (w0[El.upSm] = { alignItems: "flex-end" }),
      (w0[El.downXs] = { right: _C + "px" }),
      w0),
    center:
      ((AC = { left: "50%", transform: "translateX(-50%)" }),
      (AC[El.upSm] = { alignItems: "center" }),
      AC),
  }),
  Jge = function (e) {
    var n = e.classes,
      r = n === void 0 ? {} : n,
      i = e.anchorOrigin,
      s = e.dense,
      o = e.children,
      a = Ia(
        gp.SnackbarContainer,
        v0[i.vertical],
        v0[i.horizontal],
        v0.root,
        r.containerRoot,
        r["containerAnchorOrigin" + p_(i)],
        s && v0.rootDense
      );
    return gt.createElement("div", { className: a }, o);
  },
  eye = N.memo(Jge),
  Lk = function (e) {
    var n = typeof e == "string" || N.isValidElement(e);
    return !n;
  },
  tye = (function (t) {
    oL(e, t);
    function e(r) {
      var i;
      return (
        (i = t.call(this, r) || this),
        (i.enqueueSnackbar = function (s, o) {
          if ((o === void 0 && (o = {}), s == null))
            throw new Error("enqueueSnackbar called with invalid argument");
          var a = Lk(s) ? s : o,
            l = Lk(s) ? s.message : s,
            d = a.key,
            p = a.preventDuplicate,
            f = fg(a, ["key", "preventDuplicate"]),
            m = h0(d),
            y = m ? d : new Date().getTime() + Math.random(),
            g = Wge(f, i.props),
            v = Yt({ id: y }, f, {
              message: l,
              open: !0,
              entered: !1,
              requestClose: !1,
              persist: g("persist"),
              action: g("action"),
              content: g("content"),
              variant: g("variant"),
              anchorOrigin: g("anchorOrigin"),
              disableWindowBlurListener: g("disableWindowBlurListener"),
              autoHideDuration: g("autoHideDuration"),
              hideIconVariant: g("hideIconVariant"),
              TransitionComponent: g("TransitionComponent"),
              transitionDuration: g("transitionDuration"),
              TransitionProps: g("TransitionProps", !0),
              iconVariant: g("iconVariant", !0),
              style: g("style", !0),
              SnackbarProps: g("SnackbarProps", !0),
              className: Ia(i.props.className, f.className),
            });
          return (
            v.persist && (v.autoHideDuration = void 0),
            i.setState(function (b) {
              if ((p === void 0 && i.props.preventDuplicate) || p) {
                var E = function (A) {
                    return m ? A.id === y : A.message === l;
                  },
                  S = b.queue.findIndex(E) > -1,
                  C = b.snacks.findIndex(E) > -1;
                if (S || C) return b;
              }
              return i.handleDisplaySnack(
                Yt({}, b, { queue: [].concat(b.queue, [v]) })
              );
            }),
            y
          );
        }),
        (i.handleDisplaySnack = function (s) {
          var o = s.snacks;
          return o.length >= i.maxSnack
            ? i.handleDismissOldest(s)
            : i.processQueue(s);
        }),
        (i.processQueue = function (s) {
          var o = s.queue,
            a = s.snacks;
          return o.length > 0
            ? Yt({}, s, {
                snacks: [].concat(a, [o[0]]),
                queue: o.slice(1, o.length),
              })
            : s;
        }),
        (i.handleDismissOldest = function (s) {
          if (
            s.snacks.some(function (p) {
              return !p.open || p.requestClose;
            })
          )
            return s;
          var o = !1,
            a = !1,
            l = s.snacks.reduce(function (p, f) {
              return p + (f.open && f.persist ? 1 : 0);
            }, 0);
          l === i.maxSnack && (a = !0);
          var d = s.snacks.map(function (p) {
            return !o && (!p.persist || a)
              ? ((o = !0),
                p.entered
                  ? (p.onClose && p.onClose(null, "maxsnack", p.id),
                    i.props.onClose && i.props.onClose(null, "maxsnack", p.id),
                    Yt({}, p, { open: !1 }))
                  : Yt({}, p, { requestClose: !0 }))
              : Yt({}, p);
          });
          return Yt({}, s, { snacks: d });
        }),
        (i.handleEnteredSnack = function (s, o, a) {
          if (!h0(a))
            throw new Error(
              "handleEnteredSnack Cannot be called with undefined key"
            );
          i.setState(function (l) {
            var d = l.snacks;
            return {
              snacks: d.map(function (p) {
                return p.id === a ? Yt({}, p, { entered: !0 }) : Yt({}, p);
              }),
            };
          });
        }),
        (i.handleCloseSnack = function (s, o, a) {
          i.props.onClose && i.props.onClose(s, o, a);
          var l = a === void 0;
          i.setState(function (d) {
            var p = d.snacks,
              f = d.queue;
            return {
              snacks: p.map(function (m) {
                return !l && m.id !== a
                  ? Yt({}, m)
                  : m.entered
                  ? Yt({}, m, { open: !1 })
                  : Yt({}, m, { requestClose: !0 });
              }),
              queue: f.filter(function (m) {
                return m.id !== a;
              }),
            };
          });
        }),
        (i.closeSnackbar = function (s) {
          var o = i.state.snacks.find(function (a) {
            return a.id === s;
          });
          h0(s) && o && o.onClose && o.onClose(null, "instructed", s),
            i.handleCloseSnack(null, "instructed", s);
        }),
        (i.handleExitedSnack = function (s, o) {
          if (!h0(o))
            throw new Error(
              "handleExitedSnack Cannot be called with undefined key"
            );
          i.setState(function (a) {
            var l = i.processQueue(
              Yt({}, a, {
                snacks: a.snacks.filter(function (d) {
                  return d.id !== o;
                }),
              })
            );
            return l.queue.length === 0 ? l : i.handleDismissOldest(l);
          });
        }),
        i.enqueueSnackbar,
        i.closeSnackbar,
        (i.state = {
          snacks: [],
          queue: [],
          contextValue: {
            enqueueSnackbar: i.enqueueSnackbar.bind(_k(i)),
            closeSnackbar: i.closeSnackbar.bind(_k(i)),
          },
        }),
        i
      );
    }
    var n = e.prototype;
    return (
      (n.render = function () {
        var i = this,
          s = this.state.contextValue,
          o = this.props,
          a = o.domRoot,
          l = o.children,
          d = o.dense,
          p = d === void 0 ? !1 : d,
          f = o.Components,
          m = f === void 0 ? {} : f,
          y = o.classes,
          g = this.state.snacks.reduce(function (b, E) {
            var S,
              C = p_(E.anchorOrigin),
              _ = b[C] || [];
            return Yt({}, b, ((S = {}), (S[C] = [].concat(_, [E])), S));
          }, {}),
          v = Object.keys(g).map(function (b) {
            var E = g[b],
              S = E[0];
            return gt.createElement(
              eye,
              { key: b, dense: p, anchorOrigin: S.anchorOrigin, classes: y },
              E.map(function (C) {
                return gt.createElement(Xge, {
                  key: C.id,
                  snack: C,
                  classes: y,
                  Component: m[C.variant],
                  onClose: i.handleCloseSnack,
                  onEnter: i.props.onEnter,
                  onExit: i.props.onExit,
                  onExited: Th([i.handleExitedSnack, i.props.onExited], C.id),
                  onEntered: Th(
                    [i.handleEnteredSnack, i.props.onEntered],
                    C.id
                  ),
                });
              })
            );
          });
        return gt.createElement(
          Oge.Provider,
          { value: s },
          l,
          a ? KS.createPortal(v, a) : v
        );
      }),
      sL(e, [
        {
          key: "maxSnack",
          get: function () {
            return this.props.maxSnack || Hl.maxSnack;
          },
        },
      ]),
      e
    );
  })(N.Component);
function nye({ alertState: t, setAlertState: e }) {
  return O.jsx(
    Tq,
    {
      anchorOrigin: { vertical: "top", horizontal: "center" },
      open: t.open,
      autoHideDuration: 1e4,
      onClose: () => e({ ...t, open: !1 }),
      children: O.jsx(hz, {
        onClose: () => e({ ...t, open: !1 }),
        severity: t.severity,
        children: t.message,
      }),
    },
    "top center"
  );
}
function hL({ children: t, ...e }) {
  return O.jsx(O.Fragment, {
    children: O.jsx(ha, {
      ...e,
      sx: {
        color: "#ffffff",
        background: "#006c28",
        boxShadow: "inset 0 -4px 0 rgba(0, 0, 0, 0.25), 0 3px 0 #000",
        textTransform: "capitalize",
        height: "50px",
        fontSize: "22px",
        fontFamily: "Sour Gummy",
        borderRadius: "10px",
        border: "1px solid #000",
        width: e.width,
        "&.Mui-disabled": { color: "#979EA7" },
        "&:hover": { background: "#f87113", color: "#000" },
      },
      children: t,
    }),
  });
}
function ys(t, e, n) {
  const r = t[e.name];
  if (typeof r == "function") return r;
  const i = t[n];
  return typeof i == "function" ? i : (s) => e(t, s);
}
const H0 = "2.17.1",
  rye = () => `@wagmi/core@${H0}`;
var mL = function (t, e, n, r) {
    if (n === "a" && !r)
      throw new TypeError("Private accessor was defined without a getter");
    if (typeof e == "function" ? t !== e || !r : !e.has(t))
      throw new TypeError(
        "Cannot read private member from an object whose class did not declare it"
      );
    return n === "m" ? r : n === "a" ? r.call(t) : r ? r.value : e.get(t);
  },
  Fw,
  gL;
let Na = class CS extends Error {
  get docsBaseUrl() {
    return "https://wagmi.sh/core";
  }
  get version() {
    return rye();
  }
  constructor(e, n = {}) {
    var s;
    super(),
      Fw.add(this),
      Object.defineProperty(this, "details", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0,
      }),
      Object.defineProperty(this, "docsPath", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0,
      }),
      Object.defineProperty(this, "metaMessages", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0,
      }),
      Object.defineProperty(this, "shortMessage", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0,
      }),
      Object.defineProperty(this, "name", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: "WagmiCoreError",
      });
    const r =
        n.cause instanceof CS
          ? n.cause.details
          : (s = n.cause) != null && s.message
          ? n.cause.message
          : n.details,
      i = (n.cause instanceof CS && n.cause.docsPath) || n.docsPath;
    (this.message = [
      e || "An error occurred.",
      "",
      ...(n.metaMessages ? [...n.metaMessages, ""] : []),
      ...(i
        ? [
            `Docs: ${this.docsBaseUrl}${i}.html${
              n.docsSlug ? `#${n.docsSlug}` : ""
            }`,
          ]
        : []),
      ...(r ? [`Details: ${r}`] : []),
      `Version: ${this.version}`,
    ].join(`
`)),
      n.cause && (this.cause = n.cause),
      (this.details = r),
      (this.docsPath = i),
      (this.metaMessages = n.metaMessages),
      (this.shortMessage = e);
  }
  walk(e) {
    return mL(this, Fw, "m", gL).call(this, this, e);
  }
};
(Fw = new WeakSet()),
  (gL = function t(e, n) {
    return n != null && n(e)
      ? e
      : e.cause
      ? mL(this, Fw, "m", t).call(this, e.cause, n)
      : e;
  });
class Rm extends Na {
  constructor() {
    super("Chain not configured."),
      Object.defineProperty(this, "name", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: "ChainNotConfiguredError",
      });
  }
}
class iye extends Na {
  constructor() {
    super("Connector already connected."),
      Object.defineProperty(this, "name", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: "ConnectorAlreadyConnectedError",
      });
  }
}
class sye extends Na {
  constructor() {
    super("Connector not connected."),
      Object.defineProperty(this, "name", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: "ConnectorNotConnectedError",
      });
  }
}
class oye extends Na {
  constructor({ address: e, connector: n }) {
    super(`Account "${e}" not found for connector "${n.name}".`),
      Object.defineProperty(this, "name", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: "ConnectorAccountNotFoundError",
      });
  }
}
class aye extends Na {
  constructor({ connectionChainId: e, connectorChainId: n }) {
    super(
      `The current chain of the connector (id: ${n}) does not match the connection's chain (id: ${e}).`,
      { metaMessages: [`Current Chain ID:  ${n}`, `Expected Chain ID: ${e}`] }
    ),
      Object.defineProperty(this, "name", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: "ConnectorChainMismatchError",
      });
  }
}
class cye extends Na {
  constructor({ connector: e }) {
    super(`Connector "${e.name}" unavailable while reconnecting.`, {
      details: [
        "During the reconnection step, the only connector methods guaranteed to be available are: `id`, `name`, `type`, `uid`.",
        "All other methods are not guaranteed to be available until reconnection completes and connectors are fully restored.",
        "This error commonly occurs for connectors that asynchronously inject after reconnection has already started.",
      ].join(" "),
    }),
      Object.defineProperty(this, "name", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: "ConnectorUnavailableReconnectingError",
      });
  }
}
async function Uk(t, e) {
  var r;
  let n;
  if (
    (typeof e.connector == "function"
      ? (n = t._internal.connectors.setup(e.connector))
      : (n = e.connector),
    n.uid === t.state.current)
  )
    throw new iye();
  try {
    t.setState((l) => ({ ...l, status: "connecting" })),
      n.emitter.emit("message", { type: "connecting" });
    const { connector: i, ...s } = e,
      o = await n.connect(s),
      a = o.accounts;
    return (
      n.emitter.off("connect", t._internal.events.connect),
      n.emitter.on("change", t._internal.events.change),
      n.emitter.on("disconnect", t._internal.events.disconnect),
      await ((r = t.storage) == null
        ? void 0
        : r.setItem("recentConnectorId", n.id)),
      t.setState((l) => ({
        ...l,
        connections: new Map(l.connections).set(n.uid, {
          accounts: a,
          chainId: o.chainId,
          connector: n,
        }),
        current: n.uid,
        status: "connected",
      })),
      { accounts: a, chainId: o.chainId }
    );
  } catch (i) {
    throw (
      (t.setState((s) => ({
        ...s,
        status: s.current ? "connected" : "disconnected",
      })),
      i)
    );
  }
}
async function Yv(t, e = {}) {
  let n;
  if (e.connector) {
    const { connector: d } = e;
    if (t.state.status === "reconnecting" && !d.getAccounts && !d.getChainId)
      throw new cye({ connector: d });
    const [p, f] = await Promise.all([
      d.getAccounts().catch((m) => {
        if (e.account === null) return [];
        throw m;
      }),
      d.getChainId(),
    ]);
    n = { accounts: p, chainId: f, connector: d };
  } else n = t.state.connections.get(t.state.current);
  if (!n) throw new sye();
  const r = e.chainId ?? n.chainId,
    i = await n.connector.getChainId();
  if (i !== n.chainId)
    throw new aye({ connectionChainId: n.chainId, connectorChainId: i });
  const s = n.connector;
  if (s.getClient) return s.getClient({ chainId: r });
  const o = Bo(e.account ?? n.accounts[0]);
  if (
    (o && (o.address = Nl(o.address)),
    e.account &&
      !n.accounts.some((d) => d.toLowerCase() === o.address.toLowerCase()))
  )
    throw new oye({ address: o.address, connector: s });
  const a = t.chains.find((d) => d.id === r),
    l = await n.connector.getProvider({ chainId: r });
  return D6({
    account: o,
    chain: a,
    name: "Connector Client",
    transport: (d) => dfe(l)({ ...d, retryCount: 0 }),
  });
}
async function lye(t, e = {}) {
  var i, s;
  let n;
  if (e.connector) n = e.connector;
  else {
    const { connections: o, current: a } = t.state,
      l = o.get(a);
    n = l == null ? void 0 : l.connector;
  }
  const r = t.state.connections;
  n &&
    (await n.disconnect(),
    n.emitter.off("change", t._internal.events.change),
    n.emitter.off("disconnect", t._internal.events.disconnect),
    n.emitter.on("connect", t._internal.events.connect),
    r.delete(n.uid)),
    t.setState((o) => {
      if (r.size === 0)
        return {
          ...o,
          connections: new Map(),
          current: null,
          status: "disconnected",
        };
      const a = r.values().next().value;
      return { ...o, connections: new Map(r), current: a.connector.uid };
    });
  {
    const o = t.state.current;
    if (!o) return;
    const a = (i = t.state.connections.get(o)) == null ? void 0 : i.connector;
    if (!a) return;
    await ((s = t.storage) == null
      ? void 0
      : s.setItem("recentConnectorId", a.id));
  }
}
async function uye(t, e) {
  const { chainId: n, connector: r, ...i } = e;
  let s;
  e.account
    ? (s = e.account)
    : (s = (await Yv(t, { account: e.account, chainId: n, connector: r }))
        .account);
  const o = t.getClient({ chainId: n });
  return ys(o, b6, "estimateGas")({ ...i, account: s });
}
function yL(t) {
  return typeof t == "number" ? t : t === "wei" ? 0 : Math.abs(Ide[t]);
}
function Nm(t) {
  const e = t.state.current,
    n = t.state.connections.get(e),
    r = n == null ? void 0 : n.accounts,
    i = r == null ? void 0 : r[0],
    s = t.chains.find((a) => a.id === (n == null ? void 0 : n.chainId)),
    o = t.state.status;
  switch (o) {
    case "connected":
      return {
        address: i,
        addresses: r,
        chain: s,
        chainId: n == null ? void 0 : n.chainId,
        connector: n == null ? void 0 : n.connector,
        isConnected: !0,
        isConnecting: !1,
        isDisconnected: !1,
        isReconnecting: !1,
        status: o,
      };
    case "reconnecting":
      return {
        address: i,
        addresses: r,
        chain: s,
        chainId: n == null ? void 0 : n.chainId,
        connector: n == null ? void 0 : n.connector,
        isConnected: !!i,
        isConnecting: !1,
        isDisconnected: !1,
        isReconnecting: !0,
        status: o,
      };
    case "connecting":
      return {
        address: i,
        addresses: r,
        chain: s,
        chainId: n == null ? void 0 : n.chainId,
        connector: n == null ? void 0 : n.connector,
        isConnected: !1,
        isConnecting: !0,
        isDisconnected: !1,
        isReconnecting: !1,
        status: o,
      };
    case "disconnected":
      return {
        address: void 0,
        addresses: void 0,
        chain: void 0,
        chainId: void 0,
        connector: void 0,
        isConnected: !1,
        isConnecting: !1,
        isDisconnected: !0,
        isReconnecting: !1,
        status: o,
      };
  }
}
async function dye(t, e) {
  const { allowFailure: n = !0, chainId: r, contracts: i, ...s } = e,
    o = t.getClient({ chainId: r });
  return ys(o, bfe, "multicall")({ allowFailure: n, contracts: i, ...s });
}
function Zv(t, e) {
  const { chainId: n, ...r } = e,
    i = t.getClient({ chainId: n });
  return ys(i, R6, "readContract")(r);
}
async function pye(t, e) {
  var a;
  const { allowFailure: n = !0, blockNumber: r, blockTag: i, ...s } = e,
    o = e.contracts;
  try {
    const l = {};
    for (const [m, y] of o.entries()) {
      const g = y.chainId ?? t.state.chainId;
      l[g] || (l[g] = []),
        (a = l[g]) == null || a.push({ contract: y, index: m });
    }
    const d = () =>
        Object.entries(l).map(([m, y]) =>
          dye(t, {
            ...s,
            allowFailure: n,
            blockNumber: r,
            blockTag: i,
            chainId: Number.parseInt(m),
            contracts: y.map(({ contract: g }) => g),
          })
        ),
      p = (await Promise.all(d())).flat(),
      f = Object.values(l).flatMap((m) => m.map(({ index: y }) => y));
    return p.reduce((m, y, g) => (m && (m[f[g]] = y), m), []);
  } catch (l) {
    if (l instanceof i6) throw l;
    const d = () => o.map((p) => Zv(t, { ...p, blockNumber: r, blockTag: i }));
    return n
      ? (await Promise.allSettled(d())).map((p) =>
          p.status === "fulfilled"
            ? { result: p.value, status: "success" }
            : { error: p.reason, result: void 0, status: "failure" }
        )
      : await Promise.all(d());
  }
}
async function wL(t, e) {
  const {
    address: n,
    blockNumber: r,
    blockTag: i,
    chainId: s,
    token: o,
    unit: a = "ether",
  } = e;
  if (o)
    try {
      return await Bk(t, {
        balanceAddress: n,
        chainId: s,
        symbolType: "string",
        tokenAddress: o,
      });
    } catch (m) {
      if (m.name === "ContractFunctionExecutionError") {
        const y = await Bk(t, {
            balanceAddress: n,
            chainId: s,
            symbolType: "bytes32",
            tokenAddress: o,
          }),
          g = BM(ag(y.symbol, { dir: "right" }));
        return { ...y, symbol: g };
      }
      throw m;
    }
  const l = t.getClient({ chainId: s }),
    p = await ys(
      l,
      v6,
      "getBalance"
    )(r ? { address: n, blockNumber: r } : { address: n, blockTag: i }),
    f = t.chains.find((m) => m.id === s) ?? l.chain;
  return {
    decimals: f.nativeCurrency.decimals,
    formatted: Ln(p, yL(a)),
    symbol: f.nativeCurrency.symbol,
    value: p,
  };
}
async function Bk(t, e) {
  const {
      balanceAddress: n,
      chainId: r,
      symbolType: i,
      tokenAddress: s,
      unit: o,
    } = e,
    a = {
      abi: [
        {
          type: "function",
          name: "balanceOf",
          stateMutability: "view",
          inputs: [{ type: "address" }],
          outputs: [{ type: "uint256" }],
        },
        {
          type: "function",
          name: "decimals",
          stateMutability: "view",
          inputs: [],
          outputs: [{ type: "uint8" }],
        },
        {
          type: "function",
          name: "symbol",
          stateMutability: "view",
          inputs: [],
          outputs: [{ type: i }],
        },
      ],
      address: s,
    },
    [l, d, p] = await pye(t, {
      allowFailure: !1,
      contracts: [
        { ...a, functionName: "balanceOf", args: [n], chainId: r },
        { ...a, functionName: "decimals", chainId: r },
        { ...a, functionName: "symbol", chainId: r },
      ],
    }),
    f = Ln(l ?? "0", yL(o ?? d));
  return { decimals: d, formatted: f, symbol: p, value: l };
}
function yp(t, e) {
  if (t === e) return !0;
  if (t && e && typeof t == "object" && typeof e == "object") {
    if (t.constructor !== e.constructor) return !1;
    let n, r;
    if (Array.isArray(t) && Array.isArray(e)) {
      if (((n = t.length), n !== e.length)) return !1;
      for (r = n; r-- !== 0; ) if (!yp(t[r], e[r])) return !1;
      return !0;
    }
    if (t.valueOf !== Object.prototype.valueOf)
      return t.valueOf() === e.valueOf();
    if (t.toString !== Object.prototype.toString)
      return t.toString() === e.toString();
    const i = Object.keys(t);
    if (((n = i.length), n !== Object.keys(e).length)) return !1;
    for (r = n; r-- !== 0; )
      if (!Object.prototype.hasOwnProperty.call(e, i[r])) return !1;
    for (r = n; r-- !== 0; ) {
      const s = i[r];
      if (s && !yp(t[s], e[s])) return !1;
    }
    return !0;
  }
  return t !== t && e !== e;
}
let IC = [];
function jk(t) {
  const e = t.chains;
  return yp(IC, e) ? IC : ((IC = e), e);
}
let b0 = [];
function gl(t) {
  const e = [...t.state.connections.values()];
  return t.state.status === "reconnecting" || yp(b0, e) ? b0 : ((b0 = e), e);
}
async function fye(t, e) {
  const { account: n, chainId: r, ...i } = e,
    s = n ?? Nm(t).address,
    o = t.getClient({ chainId: r });
  return ys(
    o,
    r_,
    "prepareTransactionRequest"
  )({ ...i, ...(s ? { account: s } : {}) });
}
let TC = !1;
async function xS(t, e = {}) {
  var d, p;
  if (TC) return [];
  (TC = !0),
    t.setState((f) => ({
      ...f,
      status: f.current ? "reconnecting" : "connecting",
    }));
  const n = [];
  if ((d = e.connectors) != null && d.length)
    for (const f of e.connectors) {
      let m;
      typeof f == "function" ? (m = t._internal.connectors.setup(f)) : (m = f),
        n.push(m);
    }
  else n.push(...t.connectors);
  let r;
  try {
    r = await ((p = t.storage) == null
      ? void 0
      : p.getItem("recentConnectorId"));
  } catch {}
  const i = {};
  for (const [, f] of t.state.connections) i[f.connector.id] = 1;
  r && (i[r] = 0);
  const s =
    Object.keys(i).length > 0
      ? [...n].sort((f, m) => (i[f.id] ?? 10) - (i[m.id] ?? 10))
      : n;
  let o = !1;
  const a = [],
    l = [];
  for (const f of s) {
    const m = await f.getProvider().catch(() => {});
    if (!m || l.some((v) => v === m) || !(await f.isAuthorized())) continue;
    const g = await f.connect({ isReconnecting: !0 }).catch(() => null);
    g &&
      (f.emitter.off("connect", t._internal.events.connect),
      f.emitter.on("change", t._internal.events.change),
      f.emitter.on("disconnect", t._internal.events.disconnect),
      t.setState((v) => {
        const b = new Map(o ? v.connections : new Map()).set(f.uid, {
          accounts: g.accounts,
          chainId: g.chainId,
          connector: f,
        });
        return { ...v, current: o ? v.current : f.uid, connections: b };
      }),
      a.push({ accounts: g.accounts, chainId: g.chainId, connector: f }),
      l.push(m),
      (o = !0));
  }
  return (
    (t.state.status === "reconnecting" || t.state.status === "connecting") &&
      (o
        ? t.setState((f) => ({ ...f, status: "connected" }))
        : t.setState((f) => ({
            ...f,
            connections: new Map(),
            current: null,
            status: "disconnected",
          }))),
    (TC = !1),
    a
  );
}
async function hye(t, e) {
  const { account: n, chainId: r, connector: i, ...s } = e;
  let o;
  return (
    typeof n == "object" && (n == null ? void 0 : n.type) === "local"
      ? (o = t.getClient({ chainId: r }))
      : (o = await Yv(t, { account: n ?? void 0, chainId: r, connector: i })),
    await ys(
      o,
      O6,
      "sendTransaction"
    )({
      ...s,
      ...(n ? { account: n } : {}),
      chain: r ? { id: r } : null,
      gas: s.gas ?? void 0,
    })
  );
}
async function mye(t, e) {
  const { account: n, connector: r, ...i } = e;
  let s;
  return (
    typeof n == "object" && n.type === "local"
      ? (s = t.getClient())
      : (s = await Yv(t, { account: n, connector: r })),
    ys(s, Sfe, "signMessage")({ ...i, ...(n ? { account: n } : {}) })
  );
}
class hc extends Na {
  constructor() {
    super("Provider not found."),
      Object.defineProperty(this, "name", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: "ProviderNotFoundError",
      });
  }
}
class gye extends Na {
  constructor({ connector: e }) {
    super(`"${e.name}" does not support programmatic chain switching.`),
      Object.defineProperty(this, "name", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: "SwitchChainNotSupportedError",
      });
  }
}
async function SS(t, e) {
  var o;
  const { addEthereumChainParameter: n, chainId: r } = e,
    i = t.state.connections.get(
      ((o = e.connector) == null ? void 0 : o.uid) ?? t.state.current
    );
  if (i) {
    const a = i.connector;
    if (!a.switchChain) throw new gye({ connector: a });
    return await a.switchChain({ addEthereumChainParameter: n, chainId: r });
  }
  const s = t.chains.find((a) => a.id === r);
  if (!s) throw new Rm();
  return t.setState((a) => ({ ...a, chainId: r })), s;
}
function vL(t, e) {
  const { onChange: n } = e;
  return t.subscribe(() => Nm(t), n, {
    equalityFn(r, i) {
      const { connector: s, ...o } = r,
        { connector: a, ...l } = i;
      return (
        yp(o, l) &&
        (s == null ? void 0 : s.id) === (a == null ? void 0 : a.id) &&
        (s == null ? void 0 : s.uid) === (a == null ? void 0 : a.uid)
      );
    },
  });
}
function yye(t, e) {
  const { onChange: n } = e;
  return t._internal.connectors.subscribe((r, i) => {
    n(Object.values(r), i);
  });
}
function wye(t, e) {
  const { syncConnectedChain: n = t._internal.syncConnectedChain, ...r } = e;
  let i;
  const s = (l) => {
      i && i();
      const d = t.getClient({ chainId: l });
      return (i = ys(d, xfe, "watchPendingTransactions")(r)), i;
    },
    o = s(e.chainId);
  let a;
  return (
    n &&
      !e.chainId &&
      (a = t.subscribe(
        ({ chainId: l }) => l,
        async (l) => s(l)
      )),
    () => {
      o == null || o(), a == null || a();
    }
  );
}
async function Qv(t, e) {
  const { chainId: n, timeout: r = 0, ...i } = e,
    s = t.getClient({ chainId: n }),
    a = await ys(s, Cfe, "waitForTransactionReceipt")({ ...i, timeout: r });
  if (a.status === "reverted") {
    const d = await ys(s, M6, "getTransaction")({ hash: a.transactionHash }),
      f = await ys(
        s,
        P6,
        "call"
      )({
        ...d,
        data: d.input,
        gasPrice: d.type !== "eip1559" ? d.gasPrice : void 0,
        maxFeePerGas: d.type === "eip1559" ? d.maxFeePerGas : void 0,
        maxPriorityFeePerGas:
          d.type === "eip1559" ? d.maxPriorityFeePerGas : void 0,
      }),
      m =
        f != null && f.data
          ? BM(`0x${f.data.substring(138)}`)
          : "unknown reason";
    throw new Error(m);
  }
  return { ...a, chainId: s.chain.id };
}
async function Xv(t, e) {
  const { account: n, chainId: r, connector: i, ...s } = e;
  let o;
  return (
    typeof n == "object" && (n == null ? void 0 : n.type) === "local"
      ? (o = t.getClient({ chainId: r }))
      : (o = await Yv(t, { account: n ?? void 0, chainId: r, connector: i })),
    await ys(
      o,
      sfe,
      "writeContract"
    )({ ...s, ...(n ? { account: n } : {}), chain: r ? { id: r } : null })
  );
}
function V1e(t) {
  return t;
}
Jv.type = "injected";
function Jv(t = {}) {
  const { shimDisconnect: e = !0, unstable_shimAsyncInject: n } = t;
  function r() {
    const l = t.target;
    if (typeof l == "function") {
      const d = l();
      if (d) return d;
    }
    return typeof l == "object"
      ? l
      : typeof l == "string"
      ? {
          ...(vye[l] ?? {
            id: l,
            name: `${l[0].toUpperCase()}${l.slice(1)}`,
            provider: `is${l[0].toUpperCase()}${l.slice(1)}`,
          }),
        }
      : {
          id: "injected",
          name: "Injected",
          provider(d) {
            return d == null ? void 0 : d.ethereum;
          },
        };
  }
  let i, s, o, a;
  return (l) => ({
    get icon() {
      return r().icon;
    },
    get id() {
      return r().id;
    },
    get name() {
      return r().name;
    },
    get supportsSimulation() {
      return !0;
    },
    type: Jv.type,
    async setup() {
      const d = await this.getProvider();
      d != null &&
        d.on &&
        t.target &&
        (o || ((o = this.onConnect.bind(this)), d.on("connect", o)),
        i ||
          ((i = this.onAccountsChanged.bind(this)),
          d.on("accountsChanged", i)));
    },
    async connect({ chainId: d, isReconnecting: p } = {}) {
      var y, g, v, b, E, S;
      const f = await this.getProvider();
      if (!f) throw new hc();
      let m = [];
      if (p) m = await this.getAccounts().catch(() => []);
      else if (e)
        try {
          (m =
            (b =
              (v =
                (g =
                  (y = (
                    await f.request({
                      method: "wallet_requestPermissions",
                      params: [{ eth_accounts: {} }],
                    })
                  )[0]) == null
                    ? void 0
                    : y.caveats) == null
                  ? void 0
                  : g[0]) == null
                ? void 0
                : v.value) == null
              ? void 0
              : b.map((_) => Nl(_))),
            m.length > 0 && (m = await this.getAccounts());
        } catch (C) {
          const _ = C;
          if (_.code === Qn.code) throw new Qn(_);
          if (_.code === kc.code) throw _;
        }
      try {
        !(m != null && m.length) &&
          !p &&
          (m = (await f.request({ method: "eth_requestAccounts" })).map((A) =>
            Nl(A)
          )),
          o && (f.removeListener("connect", o), (o = void 0)),
          i ||
            ((i = this.onAccountsChanged.bind(this)),
            f.on("accountsChanged", i)),
          s || ((s = this.onChainChanged.bind(this)), f.on("chainChanged", s)),
          a || ((a = this.onDisconnect.bind(this)), f.on("disconnect", a));
        let C = await this.getChainId();
        if (d && C !== d) {
          const _ = await this.switchChain({ chainId: d }).catch((A) => {
            if (A.code === Qn.code) throw A;
            return { id: C };
          });
          C = (_ == null ? void 0 : _.id) ?? C;
        }
        return (
          e &&
            (await ((E = l.storage) == null
              ? void 0
              : E.removeItem(`${this.id}.disconnected`))),
          t.target ||
            (await ((S = l.storage) == null
              ? void 0
              : S.setItem("injected.connected", !0))),
          { accounts: m, chainId: C }
        );
      } catch (C) {
        const _ = C;
        throw _.code === Qn.code
          ? new Qn(_)
          : _.code === kc.code
          ? new kc(_)
          : _;
      }
    },
    async disconnect() {
      var p, f;
      const d = await this.getProvider();
      if (!d) throw new hc();
      s && (d.removeListener("chainChanged", s), (s = void 0)),
        a && (d.removeListener("disconnect", a), (a = void 0)),
        o || ((o = this.onConnect.bind(this)), d.on("connect", o));
      try {
        await $6(
          () =>
            d.request({
              method: "wallet_revokePermissions",
              params: [{ eth_accounts: {} }],
            }),
          { timeout: 100 }
        );
      } catch {}
      e &&
        (await ((p = l.storage) == null
          ? void 0
          : p.setItem(`${this.id}.disconnected`, !0))),
        t.target ||
          (await ((f = l.storage) == null
            ? void 0
            : f.removeItem("injected.connected")));
    },
    async getAccounts() {
      const d = await this.getProvider();
      if (!d) throw new hc();
      return (await d.request({ method: "eth_accounts" })).map((f) => Nl(f));
    },
    async getChainId() {
      const d = await this.getProvider();
      if (!d) throw new hc();
      const p = await d.request({ method: "eth_chainId" });
      return Number(p);
    },
    async getProvider() {
      if (typeof window > "u") return;
      let d;
      const p = r();
      return (
        typeof p.provider == "function"
          ? (d = p.provider(window))
          : typeof p.provider == "string"
          ? (d = q0(window, p.provider))
          : (d = p.provider),
        d &&
          !d.removeListener &&
          ("off" in d && typeof d.off == "function"
            ? (d.removeListener = d.off)
            : (d.removeListener = () => {})),
        d
      );
    },
    async isAuthorized() {
      var d, p;
      try {
        if (
          (e &&
            (await ((d = l.storage) == null
              ? void 0
              : d.getItem(`${this.id}.disconnected`)))) ||
          (!t.target &&
            !(await ((p = l.storage) == null
              ? void 0
              : p.getItem("injected.connected"))))
        )
          return !1;
        if (!(await this.getProvider())) {
          if (n !== void 0 && n !== !1) {
            const g = async () => (
                typeof window < "u" &&
                  window.removeEventListener("ethereum#initialized", g),
                !!(await this.getProvider())
              ),
              v = typeof n == "number" ? n : 1e3;
            if (
              await Promise.race([
                ...(typeof window < "u"
                  ? [
                      new Promise((E) =>
                        window.addEventListener(
                          "ethereum#initialized",
                          () => E(g()),
                          { once: !0 }
                        )
                      ),
                    ]
                  : []),
                new Promise((E) => setTimeout(() => E(g()), v)),
              ])
            )
              return !0;
          }
          throw new hc();
        }
        return !!(await Tw(() => this.getAccounts())).length;
      } catch {
        return !1;
      }
    },
    async switchChain({ addEthereumChainParameter: d, chainId: p }) {
      var g, v, b, E;
      const f = await this.getProvider();
      if (!f) throw new hc();
      const m = l.chains.find((S) => S.id === p);
      if (!m) throw new $o(new Rm());
      const y = new Promise((S) => {
        const C = (_) => {
          "chainId" in _ &&
            _.chainId === p &&
            (l.emitter.off("change", C), S());
        };
        l.emitter.on("change", C);
      });
      try {
        return (
          await Promise.all([
            f
              .request({
                method: "wallet_switchEthereumChain",
                params: [{ chainId: Et(p) }],
              })
              .then(async () => {
                (await this.getChainId()) === p &&
                  l.emitter.emit("change", { chainId: p });
              }),
            y,
          ]),
          m
        );
      } catch (S) {
        const C = S;
        if (
          C.code === 4902 ||
          ((v =
            (g = C == null ? void 0 : C.data) == null
              ? void 0
              : g.originalError) == null
            ? void 0
            : v.code) === 4902
        )
          try {
            const { default: _, ...A } = m.blockExplorers ?? {};
            let I;
            d != null && d.blockExplorerUrls
              ? (I = d.blockExplorerUrls)
              : _ && (I = [_.url, ...Object.values(A).map((k) => k.url)]);
            let R;
            (b = d == null ? void 0 : d.rpcUrls) != null && b.length
              ? (R = d.rpcUrls)
              : (R = [
                  ((E = m.rpcUrls.default) == null ? void 0 : E.http[0]) ?? "",
                ]);
            const D = {
              blockExplorerUrls: I,
              chainId: Et(p),
              chainName: (d == null ? void 0 : d.chainName) ?? m.name,
              iconUrls: d == null ? void 0 : d.iconUrls,
              nativeCurrency:
                (d == null ? void 0 : d.nativeCurrency) ?? m.nativeCurrency,
              rpcUrls: R,
            };
            return (
              await Promise.all([
                f
                  .request({ method: "wallet_addEthereumChain", params: [D] })
                  .then(async () => {
                    if ((await this.getChainId()) === p)
                      l.emitter.emit("change", { chainId: p });
                    else
                      throw new Qn(
                        new Error("User rejected switch after adding network.")
                      );
                  }),
                y,
              ]),
              m
            );
          } catch (_) {
            throw new Qn(_);
          }
        throw C.code === Qn.code ? new Qn(C) : new $o(C);
      }
    },
    async onAccountsChanged(d) {
      var p;
      if (d.length === 0) this.onDisconnect();
      else if (l.emitter.listenerCount("connect")) {
        const f = (await this.getChainId()).toString();
        this.onConnect({ chainId: f }),
          e &&
            (await ((p = l.storage) == null
              ? void 0
              : p.removeItem(`${this.id}.disconnected`)));
      } else l.emitter.emit("change", { accounts: d.map((f) => Nl(f)) });
    },
    onChainChanged(d) {
      const p = Number(d);
      l.emitter.emit("change", { chainId: p });
    },
    async onConnect(d) {
      const p = await this.getAccounts();
      if (p.length === 0) return;
      const f = Number(d.chainId);
      l.emitter.emit("connect", { accounts: p, chainId: f });
      const m = await this.getProvider();
      m &&
        (o && (m.removeListener("connect", o), (o = void 0)),
        i ||
          ((i = this.onAccountsChanged.bind(this)), m.on("accountsChanged", i)),
        s || ((s = this.onChainChanged.bind(this)), m.on("chainChanged", s)),
        a || ((a = this.onDisconnect.bind(this)), m.on("disconnect", a)));
    },
    async onDisconnect(d) {
      const p = await this.getProvider();
      (d && d.code === 1013 && p && (await this.getAccounts()).length) ||
        (l.emitter.emit("disconnect"),
        p &&
          (s && (p.removeListener("chainChanged", s), (s = void 0)),
          a && (p.removeListener("disconnect", a), (a = void 0)),
          o || ((o = this.onConnect.bind(this)), p.on("connect", o))));
    },
  });
}
const vye = {
  coinbaseWallet: {
    id: "coinbaseWallet",
    name: "Coinbase Wallet",
    provider(t) {
      return t != null && t.coinbaseWalletExtension
        ? t.coinbaseWalletExtension
        : q0(t, "isCoinbaseWallet");
    },
  },
  metaMask: {
    id: "metaMask",
    name: "MetaMask",
    provider(t) {
      return q0(t, (e) => {
        if (!e.isMetaMask || (e.isBraveWallet && !e._events && !e._state))
          return !1;
        const n = [
          "isApexWallet",
          "isAvalanche",
          "isBitKeep",
          "isBlockWallet",
          "isKuCoinWallet",
          "isMathWallet",
          "isOkxWallet",
          "isOKExWallet",
          "isOneInchIOSWallet",
          "isOneInchAndroidWallet",
          "isOpera",
          "isPhantom",
          "isPortal",
          "isRabby",
          "isTokenPocket",
          "isTokenary",
          "isUniswapWallet",
          "isZerion",
        ];
        for (const r of n) if (e[r]) return !1;
        return !0;
      });
    },
  },
  phantom: {
    id: "phantom",
    name: "Phantom",
    provider(t) {
      var e, n;
      return (e = t == null ? void 0 : t.phantom) != null && e.ethereum
        ? (n = t.phantom) == null
          ? void 0
          : n.ethereum
        : q0(t, "isPhantom");
    },
  },
};
function q0(t, e) {
  function n(i) {
    return typeof e == "function" ? e(i) : typeof e == "string" ? i[e] : !0;
  }
  const r = t.ethereum;
  if (r != null && r.providers) return r.providers.find((i) => n(i));
  if (r && n(r)) return r;
}
function bye(t) {
  if (typeof window > "u") return;
  const e = (n) => t(n.detail);
  return (
    window.addEventListener("eip6963:announceProvider", e),
    window.dispatchEvent(new CustomEvent("eip6963:requestProvider")),
    () => window.removeEventListener("eip6963:announceProvider", e)
  );
}
function Eye() {
  const t = new Set();
  let e = [];
  const n = () =>
    bye((i) => {
      e.some(({ info: s }) => s.uuid === i.info.uuid) ||
        ((e = [...e, i]), t.forEach((s) => s(e, { added: [i] })));
    });
  let r = n();
  return {
    _listeners() {
      return t;
    },
    clear() {
      t.forEach((i) => i([], { removed: [...e] })), (e = []);
    },
    destroy() {
      this.clear(), t.clear(), r == null || r();
    },
    findProvider({ rdns: i }) {
      return e.find((s) => s.info.rdns === i);
    },
    getProviders() {
      return e;
    },
    reset() {
      this.clear(), r == null || r(), (r = n());
    },
    subscribe(i, { emitImmediately: s } = {}) {
      return t.add(i), s && i(e, { added: e }), () => t.delete(i);
    },
  };
}
const Cye = (t) => (e, n, r) => {
    const i = r.subscribe;
    return (
      (r.subscribe = (o, a, l) => {
        let d = o;
        if (a) {
          const p = (l == null ? void 0 : l.equalityFn) || Object.is;
          let f = o(r.getState());
          (d = (m) => {
            const y = o(m);
            if (!p(f, y)) {
              const g = f;
              a((f = y), g);
            }
          }),
            l != null && l.fireImmediately && a(f, f);
        }
        return i(d);
      }),
      t(e, n, r)
    );
  },
  xye = Cye;
function Sye(t, e) {
  let n;
  try {
    n = t();
  } catch {
    return;
  }
  return {
    getItem: (i) => {
      var s;
      const o = (l) => (l === null ? null : JSON.parse(l, void 0)),
        a = (s = n.getItem(i)) != null ? s : null;
      return a instanceof Promise ? a.then(o) : o(a);
    },
    setItem: (i, s) => n.setItem(i, JSON.stringify(s, void 0)),
    removeItem: (i) => n.removeItem(i),
  };
}
const AS = (t) => (e) => {
    try {
      const n = t(e);
      return n instanceof Promise
        ? n
        : {
            then(r) {
              return AS(r)(n);
            },
            catch(r) {
              return this;
            },
          };
    } catch (n) {
      return {
        then(r) {
          return this;
        },
        catch(r) {
          return AS(r)(n);
        },
      };
    }
  },
  Aye = (t, e) => (n, r, i) => {
    let s = {
        storage: Sye(() => localStorage),
        partialize: (v) => v,
        version: 0,
        merge: (v, b) => ({ ...b, ...v }),
        ...e,
      },
      o = !1;
    const a = new Set(),
      l = new Set();
    let d = s.storage;
    if (!d)
      return t(
        (...v) => {
          console.warn(
            `[zustand persist middleware] Unable to update item '${s.name}', the given storage is currently unavailable.`
          ),
            n(...v);
        },
        r,
        i
      );
    const p = () => {
        const v = s.partialize({ ...r() });
        return d.setItem(s.name, { state: v, version: s.version });
      },
      f = i.setState;
    i.setState = (v, b) => {
      f(v, b), p();
    };
    const m = t(
      (...v) => {
        n(...v), p();
      },
      r,
      i
    );
    i.getInitialState = () => m;
    let y;
    const g = () => {
      var v, b;
      if (!d) return;
      (o = !1),
        a.forEach((S) => {
          var C;
          return S((C = r()) != null ? C : m);
        });
      const E =
        ((b = s.onRehydrateStorage) == null
          ? void 0
          : b.call(s, (v = r()) != null ? v : m)) || void 0;
      return AS(d.getItem.bind(d))(s.name)
        .then((S) => {
          if (S)
            if (typeof S.version == "number" && S.version !== s.version) {
              if (s.migrate) return [!0, s.migrate(S.state, S.version)];
              console.error(
                "State loaded from storage couldn't be migrated since no migrate function was provided"
              );
            } else return [!1, S.state];
          return [!1, void 0];
        })
        .then((S) => {
          var C;
          const [_, A] = S;
          if (((y = s.merge(A, (C = r()) != null ? C : m)), n(y, !0), _))
            return p();
        })
        .then(() => {
          E == null || E(y, void 0),
            (y = r()),
            (o = !0),
            l.forEach((S) => S(y));
        })
        .catch((S) => {
          E == null || E(void 0, S);
        });
    };
    return (
      (i.persist = {
        setOptions: (v) => {
          (s = { ...s, ...v }), v.storage && (d = v.storage);
        },
        clearStorage: () => {
          d == null || d.removeItem(s.name);
        },
        getOptions: () => s,
        rehydrate: () => g(),
        hasHydrated: () => o,
        onHydrate: (v) => (
          a.add(v),
          () => {
            a.delete(v);
          }
        ),
        onFinishHydration: (v) => (
          l.add(v),
          () => {
            l.delete(v);
          }
        ),
      }),
      s.skipHydration || g(),
      y || m
    );
  },
  _ye = Aye,
  Fk = (t) => {
    let e;
    const n = new Set(),
      r = (d, p) => {
        const f = typeof d == "function" ? d(e) : d;
        if (!Object.is(f, e)) {
          const m = e;
          (e =
            p ?? (typeof f != "object" || f === null)
              ? f
              : Object.assign({}, e, f)),
            n.forEach((y) => y(e, m));
        }
      },
      i = () => e,
      a = {
        setState: r,
        getState: i,
        getInitialState: () => l,
        subscribe: (d) => (n.add(d), () => n.delete(d)),
      },
      l = (e = t(r, i, a));
    return a;
  },
  PC = (t) => (t ? Fk(t) : Fk);
var RC = { exports: {} },
  zk;
function Iye() {
  return (
    zk ||
      ((zk = 1),
      (function (t) {
        var e = Object.prototype.hasOwnProperty,
          n = "~";
        function r() {}
        Object.create &&
          ((r.prototype = Object.create(null)), new r().__proto__ || (n = !1));
        function i(l, d, p) {
          (this.fn = l), (this.context = d), (this.once = p || !1);
        }
        function s(l, d, p, f, m) {
          if (typeof p != "function")
            throw new TypeError("The listener must be a function");
          var y = new i(p, f || l, m),
            g = n ? n + d : d;
          return (
            l._events[g]
              ? l._events[g].fn
                ? (l._events[g] = [l._events[g], y])
                : l._events[g].push(y)
              : ((l._events[g] = y), l._eventsCount++),
            l
          );
        }
        function o(l, d) {
          --l._eventsCount === 0 ? (l._events = new r()) : delete l._events[d];
        }
        function a() {
          (this._events = new r()), (this._eventsCount = 0);
        }
        (a.prototype.eventNames = function () {
          var d = [],
            p,
            f;
          if (this._eventsCount === 0) return d;
          for (f in (p = this._events))
            e.call(p, f) && d.push(n ? f.slice(1) : f);
          return Object.getOwnPropertySymbols
            ? d.concat(Object.getOwnPropertySymbols(p))
            : d;
        }),
          (a.prototype.listeners = function (d) {
            var p = n ? n + d : d,
              f = this._events[p];
            if (!f) return [];
            if (f.fn) return [f.fn];
            for (var m = 0, y = f.length, g = new Array(y); m < y; m++)
              g[m] = f[m].fn;
            return g;
          }),
          (a.prototype.listenerCount = function (d) {
            var p = n ? n + d : d,
              f = this._events[p];
            return f ? (f.fn ? 1 : f.length) : 0;
          }),
          (a.prototype.emit = function (d, p, f, m, y, g) {
            var v = n ? n + d : d;
            if (!this._events[v]) return !1;
            var b = this._events[v],
              E = arguments.length,
              S,
              C;
            if (b.fn) {
              switch ((b.once && this.removeListener(d, b.fn, void 0, !0), E)) {
                case 1:
                  return b.fn.call(b.context), !0;
                case 2:
                  return b.fn.call(b.context, p), !0;
                case 3:
                  return b.fn.call(b.context, p, f), !0;
                case 4:
                  return b.fn.call(b.context, p, f, m), !0;
                case 5:
                  return b.fn.call(b.context, p, f, m, y), !0;
                case 6:
                  return b.fn.call(b.context, p, f, m, y, g), !0;
              }
              for (C = 1, S = new Array(E - 1); C < E; C++)
                S[C - 1] = arguments[C];
              b.fn.apply(b.context, S);
            } else {
              var _ = b.length,
                A;
              for (C = 0; C < _; C++)
                switch (
                  (b[C].once && this.removeListener(d, b[C].fn, void 0, !0), E)
                ) {
                  case 1:
                    b[C].fn.call(b[C].context);
                    break;
                  case 2:
                    b[C].fn.call(b[C].context, p);
                    break;
                  case 3:
                    b[C].fn.call(b[C].context, p, f);
                    break;
                  case 4:
                    b[C].fn.call(b[C].context, p, f, m);
                    break;
                  default:
                    if (!S)
                      for (A = 1, S = new Array(E - 1); A < E; A++)
                        S[A - 1] = arguments[A];
                    b[C].fn.apply(b[C].context, S);
                }
            }
            return !0;
          }),
          (a.prototype.on = function (d, p, f) {
            return s(this, d, p, f, !1);
          }),
          (a.prototype.once = function (d, p, f) {
            return s(this, d, p, f, !0);
          }),
          (a.prototype.removeListener = function (d, p, f, m) {
            var y = n ? n + d : d;
            if (!this._events[y]) return this;
            if (!p) return o(this, y), this;
            var g = this._events[y];
            if (g.fn)
              g.fn === p &&
                (!m || g.once) &&
                (!f || g.context === f) &&
                o(this, y);
            else {
              for (var v = 0, b = [], E = g.length; v < E; v++)
                (g[v].fn !== p ||
                  (m && !g[v].once) ||
                  (f && g[v].context !== f)) &&
                  b.push(g[v]);
              b.length
                ? (this._events[y] = b.length === 1 ? b[0] : b)
                : o(this, y);
            }
            return this;
          }),
          (a.prototype.removeAllListeners = function (d) {
            var p;
            return (
              d
                ? ((p = n ? n + d : d), this._events[p] && o(this, p))
                : ((this._events = new r()), (this._eventsCount = 0)),
              this
            );
          }),
          (a.prototype.off = a.prototype.removeListener),
          (a.prototype.addListener = a.prototype.on),
          (a.prefixed = n),
          (a.EventEmitter = a),
          (t.exports = a);
      })(RC)),
    RC.exports
  );
}
var Tye = Iye();
const Pye = Hc(Tye);
class Rye {
  constructor(e) {
    Object.defineProperty(this, "uid", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: e,
    }),
      Object.defineProperty(this, "_emitter", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: new Pye(),
      });
  }
  on(e, n) {
    this._emitter.on(e, n);
  }
  once(e, n) {
    this._emitter.once(e, n);
  }
  off(e, n) {
    this._emitter.off(e, n);
  }
  emit(e, ...n) {
    const r = n[0];
    this._emitter.emit(e, { uid: this.uid, ...r });
  }
  listenerCount(e) {
    return this._emitter.listenerCount(e);
  }
}
function Nye(t) {
  return new Rye(t);
}
function Oye(t, e) {
  return JSON.parse(t, (n, r) => {
    let i = r;
    return (
      (i == null ? void 0 : i.__type) === "bigint" && (i = BigInt(i.value)),
      (i == null ? void 0 : i.__type) === "Map" && (i = new Map(i.value)),
      (e == null ? void 0 : e(n, i)) ?? i
    );
  });
}
function Wk(t, e) {
  return t.slice(0, e).join(".") || ".";
}
function Hk(t, e) {
  const { length: n } = t;
  for (let r = 0; r < n; ++r) if (t[r] === e) return r + 1;
  return 0;
}
function kye(t, e) {
  const n = typeof t == "function",
    r = typeof e == "function",
    i = [],
    s = [];
  return function (a, l) {
    if (typeof l == "object")
      if (i.length) {
        const d = Hk(i, this);
        d === 0 ? (i[i.length] = this) : (i.splice(d), s.splice(d)),
          (s[s.length] = a);
        const p = Hk(i, l);
        if (p !== 0)
          return r ? e.call(this, a, l, Wk(s, p)) : `[ref=${Wk(s, p)}]`;
      } else (i[0] = l), (s[0] = a);
    return n ? t.call(this, a, l) : l;
  };
}
function Dye(t, e, n, r) {
  return JSON.stringify(
    t,
    kye((i, s) => {
      let o = s;
      return (
        typeof o == "bigint" && (o = { __type: "bigint", value: s.toString() }),
        o instanceof Map &&
          (o = { __type: "Map", value: Array.from(s.entries()) }),
        (e == null ? void 0 : e(i, o)) ?? o
      );
    }, r),
    n ?? void 0
  );
}
function $ye(t) {
  const {
    deserialize: e = Oye,
    key: n = "wagmi",
    serialize: r = Dye,
    storage: i = bL,
  } = t;
  function s(o) {
    return o instanceof Promise ? o.then((a) => a).catch(() => null) : o;
  }
  return {
    ...i,
    key: n,
    async getItem(o, a) {
      const l = i.getItem(`${n}.${o}`),
        d = await s(l);
      return d ? e(d) ?? null : a ?? null;
    },
    async setItem(o, a) {
      const l = `${n}.${o}`;
      a === null ? await s(i.removeItem(l)) : await s(i.setItem(l, r(a)));
    },
    async removeItem(o) {
      await s(i.removeItem(`${n}.${o}`));
    },
  };
}
const bL = { getItem: () => null, setItem: () => {}, removeItem: () => {} };
function Mye() {
  const t =
    typeof window < "u" && window.localStorage ? window.localStorage : bL;
  return {
    getItem(e) {
      return t.getItem(e);
    },
    removeItem(e) {
      t.removeItem(e);
    },
    setItem(e, n) {
      try {
        t.setItem(e, n);
      } catch {}
    },
  };
}
const _S = 256;
let E0 = _S,
  C0;
function Lye(t = 11) {
  if (!C0 || E0 + t > _S * 2) {
    (C0 = ""), (E0 = 0);
    for (let e = 0; e < _S; e++)
      C0 += ((256 + Math.random() * 256) | 0).toString(16).substring(1);
  }
  return C0.substring(E0, E0++ + t);
}
function Uye(t) {
  const {
      multiInjectedProviderDiscovery: e = !0,
      storage: n = $ye({ storage: Mye() }),
      syncConnectedChain: r = !0,
      ssr: i = !1,
      ...s
    } = t,
    o = typeof window < "u" && e ? Eye() : void 0,
    a = PC(() => s.chains),
    l = PC(() => {
      const A = [],
        I = new Set();
      for (const R of s.connectors ?? []) {
        const D = d(R);
        if ((A.push(D), !i && D.rdns)) {
          const k = typeof D.rdns == "string" ? [D.rdns] : D.rdns;
          for (const T of k) I.add(T);
        }
      }
      if (!i && o) {
        const R = o.getProviders();
        for (const D of R) I.has(D.info.rdns) || A.push(d(p(D)));
      }
      return A;
    });
  function d(A) {
    var D;
    const I = Nye(Lye()),
      R = {
        ...A({
          emitter: I,
          chains: a.getState(),
          storage: n,
          transports: s.transports,
        }),
        emitter: I,
        uid: I.uid,
      };
    return I.on("connect", C), (D = R.setup) == null || D.call(R), R;
  }
  function p(A) {
    const { info: I } = A,
      R = A.provider;
    return Jv({ target: { ...I, id: I.rdns, provider: R } });
  }
  const f = new Map();
  function m(A = {}) {
    const I = A.chainId ?? b.getState().chainId,
      R = a.getState().find((k) => k.id === I);
    if (A.chainId && !R) throw new Rm();
    {
      const k = f.get(b.getState().chainId);
      if (k && !R) return k;
      if (!R) throw new Rm();
    }
    {
      const k = f.get(I);
      if (k) return k;
    }
    let D;
    if (s.client) D = s.client({ chain: R });
    else {
      const k = R.id,
        T = a.getState().map((K) => K.id),
        U = {},
        q = Object.entries(s);
      for (const [K, H] of q)
        if (
          !(
            K === "chains" ||
            K === "client" ||
            K === "connectors" ||
            K === "transports"
          )
        )
          if (typeof H == "object")
            if (k in H) U[K] = H[k];
            else {
              if (T.some((M) => M in H)) continue;
              U[K] = H;
            }
          else U[K] = H;
      D = D6({
        ...U,
        chain: R,
        batch: U.batch ?? { multicall: !0 },
        transport: (K) => s.transports[k]({ ...K, connectors: l }),
      });
    }
    return f.set(I, D), D;
  }
  function y() {
    return {
      chainId: a.getState()[0].id,
      connections: new Map(),
      current: null,
      status: "disconnected",
    };
  }
  let g;
  const v = "0.0.0-canary-";
  H0.startsWith(v)
    ? (g = Number.parseInt(H0.replace(v, "")))
    : (g = Number.parseInt(H0.split(".")[0] ?? "0"));
  const b = PC(
    xye(
      n
        ? _ye(y, {
            migrate(A, I) {
              if (I === g) return A;
              const R = y(),
                D = E(A, R.chainId);
              return { ...R, chainId: D };
            },
            name: "store",
            partialize(A) {
              return {
                connections: {
                  __type: "Map",
                  value: Array.from(A.connections.entries()).map(([I, R]) => {
                    const { id: D, name: k, type: T, uid: U } = R.connector;
                    return [
                      I,
                      { ...R, connector: { id: D, name: k, type: T, uid: U } },
                    ];
                  }),
                },
                chainId: A.chainId,
                current: A.current,
              };
            },
            merge(A, I) {
              typeof A == "object" && A && "status" in A && delete A.status;
              const R = E(A, I.chainId);
              return { ...I, ...A, chainId: R };
            },
            skipHydration: i,
            storage: n,
            version: g,
          })
        : y
    )
  );
  b.setState(y());
  function E(A, I) {
    return A &&
      typeof A == "object" &&
      "chainId" in A &&
      typeof A.chainId == "number" &&
      a.getState().some((R) => R.id === A.chainId)
      ? A.chainId
      : I;
  }
  r &&
    b.subscribe(
      ({ connections: A, current: I }) => {
        var R;
        return I ? ((R = A.get(I)) == null ? void 0 : R.chainId) : void 0;
      },
      (A) => {
        if (a.getState().some((R) => R.id === A))
          return b.setState((R) => ({ ...R, chainId: A ?? R.chainId }));
      }
    ),
    o == null ||
      o.subscribe((A) => {
        const I = new Set(),
          R = new Set();
        for (const k of l.getState())
          if ((I.add(k.id), k.rdns)) {
            const T = typeof k.rdns == "string" ? [k.rdns] : k.rdns;
            for (const U of T) R.add(U);
          }
        const D = [];
        for (const k of A) {
          if (R.has(k.info.rdns)) continue;
          const T = d(p(k));
          I.has(T.id) || D.push(T);
        }
        (n && !b.persist.hasHydrated()) || l.setState((k) => [...k, ...D], !0);
      });
  function S(A) {
    b.setState((I) => {
      const R = I.connections.get(A.uid);
      return R
        ? {
            ...I,
            connections: new Map(I.connections).set(A.uid, {
              accounts: A.accounts ?? R.accounts,
              chainId: A.chainId ?? R.chainId,
              connector: R.connector,
            }),
          }
        : I;
    });
  }
  function C(A) {
    b.getState().status === "connecting" ||
      b.getState().status === "reconnecting" ||
      b.setState((I) => {
        const R = l.getState().find((D) => D.uid === A.uid);
        return R
          ? (R.emitter.listenerCount("connect") && R.emitter.off("connect", S),
            R.emitter.listenerCount("change") || R.emitter.on("change", S),
            R.emitter.listenerCount("disconnect") ||
              R.emitter.on("disconnect", _),
            {
              ...I,
              connections: new Map(I.connections).set(A.uid, {
                accounts: A.accounts,
                chainId: A.chainId,
                connector: R,
              }),
              current: A.uid,
              status: "connected",
            })
          : I;
      });
  }
  function _(A) {
    b.setState((I) => {
      const R = I.connections.get(A.uid);
      if (R) {
        const k = R.connector;
        k.emitter.listenerCount("change") &&
          R.connector.emitter.off("change", S),
          k.emitter.listenerCount("disconnect") &&
            R.connector.emitter.off("disconnect", _),
          k.emitter.listenerCount("connect") ||
            R.connector.emitter.on("connect", C);
      }
      if ((I.connections.delete(A.uid), I.connections.size === 0))
        return {
          ...I,
          connections: new Map(),
          current: null,
          status: "disconnected",
        };
      const D = I.connections.values().next().value;
      return {
        ...I,
        connections: new Map(I.connections),
        current: D.connector.uid,
      };
    });
  }
  return {
    get chains() {
      return a.getState();
    },
    get connectors() {
      return l.getState();
    },
    storage: n,
    getClient: m,
    get state() {
      return b.getState();
    },
    setState(A) {
      let I;
      typeof A == "function" ? (I = A(b.getState())) : (I = A);
      const R = y();
      typeof I != "object" && (I = R),
        Object.keys(R).some((k) => !(k in I)) && (I = R),
        b.setState(I, !0);
    },
    subscribe(A, I, R) {
      return b.subscribe(
        A,
        I,
        R ? { ...R, fireImmediately: R.emitImmediately } : void 0
      );
    },
    _internal: {
      mipd: o,
      store: b,
      ssr: !!i,
      syncConnectedChain: r,
      transports: s.transports,
      chains: {
        setState(A) {
          const I = typeof A == "function" ? A(a.getState()) : A;
          if (I.length !== 0) return a.setState(I, !0);
        },
        subscribe(A) {
          return a.subscribe(A);
        },
      },
      connectors: {
        providerDetailToConnector: p,
        setup: d,
        setState(A) {
          return l.setState(typeof A == "function" ? A(l.getState()) : A, !0);
        },
        subscribe(A) {
          return l.subscribe(A);
        },
      },
      events: { change: S, connect: C, disconnect: _ },
    },
  };
}
function Bye(t, e) {
  const { initialState: n, reconnectOnMount: r } = e;
  return (
    n &&
      !t._internal.store.persist.hasHydrated() &&
      t.setState({
        ...n,
        chainId: t.chains.some((i) => i.id === n.chainId)
          ? n.chainId
          : t.chains[0].id,
        connections: r ? n.connections : new Map(),
        status: r ? "reconnecting" : "disconnected",
      }),
    {
      async onMount() {
        t._internal.ssr &&
          (await t._internal.store.persist.rehydrate(),
          t._internal.mipd &&
            t._internal.connectors.setState((i) => {
              var l;
              const s = new Set();
              for (const d of i ?? [])
                if (d.rdns) {
                  const p = Array.isArray(d.rdns) ? d.rdns : [d.rdns];
                  for (const f of p) s.add(f);
                }
              const o = [],
                a =
                  ((l = t._internal.mipd) == null
                    ? void 0
                    : l.getProviders()) ?? [];
              for (const d of a) {
                if (s.has(d.info.rdns)) continue;
                const p = t._internal.connectors.providerDetailToConnector(d),
                  f = t._internal.connectors.setup(p);
                o.push(f);
              }
              return [...i, ...o];
            })),
          r
            ? xS(t)
            : t.storage &&
              t.setState((i) => ({ ...i, connections: new Map() }));
      },
    }
  );
}
function jye(t) {
  const {
      children: e,
      config: n,
      initialState: r,
      reconnectOnMount: i = !0,
    } = t,
    { onMount: s } = Bye(n, { initialState: r, reconnectOnMount: i });
  n._internal.ssr || s();
  const o = N.useRef(!0);
  return (
    N.useEffect(() => {
      if (o.current && n._internal.ssr)
        return (
          s(),
          () => {
            o.current = !1;
          }
        );
    }, []),
    e
  );
}
const EL = N.createContext(void 0);
function Fye(t) {
  const { children: e, config: n } = t,
    r = { value: n };
  return N.createElement(jye, t, N.createElement(EL.Provider, r, e));
}
const zye = "2.15.2",
  Wye = () => `wagmi@${zye}`;
class Hye extends Na {
  constructor() {
    super(...arguments),
      Object.defineProperty(this, "name", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: "WagmiError",
      });
  }
  get docsBaseUrl() {
    return "https://wagmi.sh/react";
  }
  get version() {
    return Wye();
  }
}
class qye extends Hye {
  constructor() {
    super("`useConfig` must be used within `WagmiProvider`.", {
      docsPath: "/api/WagmiProvider",
    }),
      Object.defineProperty(this, "name", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: "WagmiProviderNotFoundError",
      });
  }
}
function eb(t = {}) {
  const e = t.config ?? N.useContext(EL);
  if (!e) throw new qye();
  return e;
}
function Vye(t, e) {
  const { onChange: n } = e;
  return t._internal.chains.subscribe((r, i) => {
    n(r, i);
  });
}
var NC = { exports: {} },
  OC = {},
  kC = { exports: {} },
  DC = {};
/**
 * @license React
 * use-sync-external-store-shim.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var qk;
function Gye() {
  if (qk) return DC;
  qk = 1;
  var t = wp();
  function e(f, m) {
    return (f === m && (f !== 0 || 1 / f === 1 / m)) || (f !== f && m !== m);
  }
  var n = typeof Object.is == "function" ? Object.is : e,
    r = t.useState,
    i = t.useEffect,
    s = t.useLayoutEffect,
    o = t.useDebugValue;
  function a(f, m) {
    var y = m(),
      g = r({ inst: { value: y, getSnapshot: m } }),
      v = g[0].inst,
      b = g[1];
    return (
      s(
        function () {
          (v.value = y), (v.getSnapshot = m), l(v) && b({ inst: v });
        },
        [f, y, m]
      ),
      i(
        function () {
          return (
            l(v) && b({ inst: v }),
            f(function () {
              l(v) && b({ inst: v });
            })
          );
        },
        [f]
      ),
      o(y),
      y
    );
  }
  function l(f) {
    var m = f.getSnapshot;
    f = f.value;
    try {
      var y = m();
      return !n(f, y);
    } catch {
      return !0;
    }
  }
  function d(f, m) {
    return m();
  }
  var p =
    typeof window > "u" ||
    typeof window.document > "u" ||
    typeof window.document.createElement > "u"
      ? d
      : a;
  return (
    (DC.useSyncExternalStore =
      t.useSyncExternalStore !== void 0 ? t.useSyncExternalStore : p),
    DC
  );
}
var Vk;
function Kye() {
  return Vk || ((Vk = 1), (kC.exports = Gye())), kC.exports;
}
/**
 * @license React
 * use-sync-external-store-shim/with-selector.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var Gk;
function Yye() {
  if (Gk) return OC;
  Gk = 1;
  var t = wp(),
    e = Kye();
  function n(d, p) {
    return (d === p && (d !== 0 || 1 / d === 1 / p)) || (d !== d && p !== p);
  }
  var r = typeof Object.is == "function" ? Object.is : n,
    i = e.useSyncExternalStore,
    s = t.useRef,
    o = t.useEffect,
    a = t.useMemo,
    l = t.useDebugValue;
  return (
    (OC.useSyncExternalStoreWithSelector = function (d, p, f, m, y) {
      var g = s(null);
      if (g.current === null) {
        var v = { hasValue: !1, value: null };
        g.current = v;
      } else v = g.current;
      g = a(
        function () {
          function E(I) {
            if (!S) {
              if (((S = !0), (C = I), (I = m(I)), y !== void 0 && v.hasValue)) {
                var R = v.value;
                if (y(R, I)) return (_ = R);
              }
              return (_ = I);
            }
            if (((R = _), r(C, I))) return R;
            var D = m(I);
            return y !== void 0 && y(R, D) ? ((C = I), R) : ((C = I), (_ = D));
          }
          var S = !1,
            C,
            _,
            A = f === void 0 ? null : f;
          return [
            function () {
              return E(p());
            },
            A === null
              ? void 0
              : function () {
                  return E(A());
                },
          ];
        },
        [p, f, m, y]
      );
      var b = i(d, g[0], g[1]);
      return (
        o(
          function () {
            (v.hasValue = !0), (v.value = b);
          },
          [b]
        ),
        l(b),
        b
      );
    }),
    OC
  );
}
var Kk;
function Zye() {
  return Kk || ((Kk = 1), (NC.exports = Yye())), NC.exports;
}
var Qye = Zye();
const $C = (t) => typeof t == "object" && !Array.isArray(t);
function Xye(t, e, n = e, r = yp) {
  const i = N.useRef([]),
    s = Qye.useSyncExternalStoreWithSelector(
      t,
      e,
      n,
      (o) => o,
      (o, a) => {
        if ($C(o) && $C(a) && i.current.length) {
          for (const l of i.current) if (!r(o[l], a[l])) return !1;
          return !0;
        }
        return r(o, a);
      }
    );
  return N.useMemo(() => {
    if ($C(s)) {
      const o = { ...s };
      let a = {};
      for (const [l, d] of Object.entries(o))
        a = {
          ...a,
          [l]: {
            configurable: !1,
            enumerable: !0,
            get: () => (i.current.includes(l) || i.current.push(l), d),
          },
        };
      return Object.defineProperties(o, a), o;
    }
    return s;
  }, [s]);
}
function Jye(t = {}) {
  const e = eb(t);
  return Xye(
    (n) => vL(e, { onChange: n }),
    () => Nm(e)
  );
}
var mg = class {
    constructor() {
      (this.listeners = new Set()),
        (this.subscribe = this.subscribe.bind(this));
    }
    subscribe(t) {
      return (
        this.listeners.add(t),
        this.onSubscribe(),
        () => {
          this.listeners.delete(t), this.onUnsubscribe();
        }
      );
    }
    hasListeners() {
      return this.listeners.size > 0;
    }
    onSubscribe() {}
    onUnsubscribe() {}
  },
  tb = typeof window > "u" || "Deno" in globalThis;
function js() {}
function e0e(t, e) {
  return typeof t == "function" ? t(e) : t;
}
function t0e(t) {
  return typeof t == "number" && t >= 0 && t !== 1 / 0;
}
function n0e(t, e) {
  return Math.max(t + (e || 0) - Date.now(), 0);
}
function Yk(t, e) {
  return typeof t == "function" ? t(e) : t;
}
function r0e(t, e) {
  return typeof t == "function" ? t(e) : t;
}
function Zk(t, e) {
  const {
    type: n = "all",
    exact: r,
    fetchStatus: i,
    predicate: s,
    queryKey: o,
    stale: a,
  } = t;
  if (o) {
    if (r) {
      if (e.queryHash !== h_(o, e.options)) return !1;
    } else if (!Om(e.queryKey, o)) return !1;
  }
  if (n !== "all") {
    const l = e.isActive();
    if ((n === "active" && !l) || (n === "inactive" && l)) return !1;
  }
  return !(
    (typeof a == "boolean" && e.isStale() !== a) ||
    (i && i !== e.state.fetchStatus) ||
    (s && !s(e))
  );
}
function Qk(t, e) {
  const { exact: n, status: r, predicate: i, mutationKey: s } = t;
  if (s) {
    if (!e.options.mutationKey) return !1;
    if (n) {
      if (lu(e.options.mutationKey) !== lu(s)) return !1;
    } else if (!Om(e.options.mutationKey, s)) return !1;
  }
  return !((r && e.state.status !== r) || (i && !i(e)));
}
function h_(t, e) {
  return ((e == null ? void 0 : e.queryKeyHashFn) || lu)(t);
}
function lu(t) {
  return JSON.stringify(t, (e, n) =>
    IS(n)
      ? Object.keys(n)
          .sort()
          .reduce((r, i) => ((r[i] = n[i]), r), {})
      : n
  );
}
function Om(t, e) {
  return t === e
    ? !0
    : typeof t != typeof e
    ? !1
    : t && e && typeof t == "object" && typeof e == "object"
    ? Object.keys(e).every((n) => Om(t[n], e[n]))
    : !1;
}
function CL(t, e) {
  if (t === e) return t;
  const n = Xk(t) && Xk(e);
  if (n || (IS(t) && IS(e))) {
    const r = n ? t : Object.keys(t),
      i = r.length,
      s = n ? e : Object.keys(e),
      o = s.length,
      a = n ? [] : {};
    let l = 0;
    for (let d = 0; d < o; d++) {
      const p = n ? d : s[d];
      ((!n && r.includes(p)) || n) && t[p] === void 0 && e[p] === void 0
        ? ((a[p] = void 0), l++)
        : ((a[p] = CL(t[p], e[p])), a[p] === t[p] && t[p] !== void 0 && l++);
    }
    return i === o && l === i ? t : a;
  }
  return e;
}
function i0e(t, e) {
  if (!e || Object.keys(t).length !== Object.keys(e).length) return !1;
  for (const n in t) if (t[n] !== e[n]) return !1;
  return !0;
}
function Xk(t) {
  return Array.isArray(t) && t.length === Object.keys(t).length;
}
function IS(t) {
  if (!Jk(t)) return !1;
  const e = t.constructor;
  if (e === void 0) return !0;
  const n = e.prototype;
  return !(
    !Jk(n) ||
    !n.hasOwnProperty("isPrototypeOf") ||
    Object.getPrototypeOf(t) !== Object.prototype
  );
}
function Jk(t) {
  return Object.prototype.toString.call(t) === "[object Object]";
}
function s0e(t) {
  return new Promise((e) => {
    setTimeout(e, t);
  });
}
function o0e(t, e, n) {
  return typeof n.structuralSharing == "function"
    ? n.structuralSharing(t, e)
    : n.structuralSharing !== !1
    ? CL(t, e)
    : e;
}
function a0e(t, e, n = 0) {
  const r = [...t, e];
  return n && r.length > n ? r.slice(1) : r;
}
function c0e(t, e, n = 0) {
  const r = [e, ...t];
  return n && r.length > n ? r.slice(0, -1) : r;
}
var m_ = Symbol();
function xL(t, e) {
  return !t.queryFn && e != null && e.initialPromise
    ? () => e.initialPromise
    : !t.queryFn || t.queryFn === m_
    ? () => Promise.reject(new Error(`Missing queryFn: '${t.queryHash}'`))
    : t.queryFn;
}
var $l,
  wc,
  Ld,
  v5,
  l0e =
    ((v5 = class extends mg {
      constructor() {
        super();
        Ct(this, $l);
        Ct(this, wc);
        Ct(this, Ld);
        tt(this, Ld, (e) => {
          if (!tb && window.addEventListener) {
            const n = () => e();
            return (
              window.addEventListener("visibilitychange", n, !1),
              () => {
                window.removeEventListener("visibilitychange", n);
              }
            );
          }
        });
      }
      onSubscribe() {
        oe(this, wc) || this.setEventListener(oe(this, Ld));
      }
      onUnsubscribe() {
        var e;
        this.hasListeners() ||
          ((e = oe(this, wc)) == null || e.call(this), tt(this, wc, void 0));
      }
      setEventListener(e) {
        var n;
        tt(this, Ld, e),
          (n = oe(this, wc)) == null || n.call(this),
          tt(
            this,
            wc,
            e((r) => {
              typeof r == "boolean" ? this.setFocused(r) : this.onFocus();
            })
          );
      }
      setFocused(e) {
        oe(this, $l) !== e && (tt(this, $l, e), this.onFocus());
      }
      onFocus() {
        const e = this.isFocused();
        this.listeners.forEach((n) => {
          n(e);
        });
      }
      isFocused() {
        var e;
        return typeof oe(this, $l) == "boolean"
          ? oe(this, $l)
          : ((e = globalThis.document) == null ? void 0 : e.visibilityState) !==
              "hidden";
      }
    }),
    ($l = new WeakMap()),
    (wc = new WeakMap()),
    (Ld = new WeakMap()),
    v5),
  SL = new l0e(),
  Ud,
  vc,
  Bd,
  b5,
  u0e =
    ((b5 = class extends mg {
      constructor() {
        super();
        Ct(this, Ud, !0);
        Ct(this, vc);
        Ct(this, Bd);
        tt(this, Bd, (e) => {
          if (!tb && window.addEventListener) {
            const n = () => e(!0),
              r = () => e(!1);
            return (
              window.addEventListener("online", n, !1),
              window.addEventListener("offline", r, !1),
              () => {
                window.removeEventListener("online", n),
                  window.removeEventListener("offline", r);
              }
            );
          }
        });
      }
      onSubscribe() {
        oe(this, vc) || this.setEventListener(oe(this, Bd));
      }
      onUnsubscribe() {
        var e;
        this.hasListeners() ||
          ((e = oe(this, vc)) == null || e.call(this), tt(this, vc, void 0));
      }
      setEventListener(e) {
        var n;
        tt(this, Bd, e),
          (n = oe(this, vc)) == null || n.call(this),
          tt(this, vc, e(this.setOnline.bind(this)));
      }
      setOnline(e) {
        oe(this, Ud) !== e &&
          (tt(this, Ud, e),
          this.listeners.forEach((r) => {
            r(e);
          }));
      }
      isOnline() {
        return oe(this, Ud);
      }
    }),
    (Ud = new WeakMap()),
    (vc = new WeakMap()),
    (Bd = new WeakMap()),
    b5),
  zw = new u0e();
function d0e() {
  let t, e;
  const n = new Promise((i, s) => {
    (t = i), (e = s);
  });
  (n.status = "pending"), n.catch(() => {});
  function r(i) {
    Object.assign(n, i), delete n.resolve, delete n.reject;
  }
  return (
    (n.resolve = (i) => {
      r({ status: "fulfilled", value: i }), t(i);
    }),
    (n.reject = (i) => {
      r({ status: "rejected", reason: i }), e(i);
    }),
    n
  );
}
function p0e(t) {
  return Math.min(1e3 * 2 ** t, 3e4);
}
function AL(t) {
  return (t ?? "online") === "online" ? zw.isOnline() : !0;
}
var _L = class extends Error {
  constructor(t) {
    super("CancelledError"),
      (this.revert = t == null ? void 0 : t.revert),
      (this.silent = t == null ? void 0 : t.silent);
  }
};
function MC(t) {
  return t instanceof _L;
}
function IL(t) {
  let e = !1,
    n = 0,
    r = !1,
    i;
  const s = d0e(),
    o = (v) => {
      var b;
      r || (m(new _L(v)), (b = t.abort) == null || b.call(t));
    },
    a = () => {
      e = !0;
    },
    l = () => {
      e = !1;
    },
    d = () =>
      SL.isFocused() &&
      (t.networkMode === "always" || zw.isOnline()) &&
      t.canRun(),
    p = () => AL(t.networkMode) && t.canRun(),
    f = (v) => {
      var b;
      r ||
        ((r = !0),
        (b = t.onSuccess) == null || b.call(t, v),
        i == null || i(),
        s.resolve(v));
    },
    m = (v) => {
      var b;
      r ||
        ((r = !0),
        (b = t.onError) == null || b.call(t, v),
        i == null || i(),
        s.reject(v));
    },
    y = () =>
      new Promise((v) => {
        var b;
        (i = (E) => {
          (r || d()) && v(E);
        }),
          (b = t.onPause) == null || b.call(t);
      }).then(() => {
        var v;
        (i = void 0), r || (v = t.onContinue) == null || v.call(t);
      }),
    g = () => {
      if (r) return;
      let v;
      const b = n === 0 ? t.initialPromise : void 0;
      try {
        v = b ?? t.fn();
      } catch (E) {
        v = Promise.reject(E);
      }
      Promise.resolve(v)
        .then(f)
        .catch((E) => {
          var I;
          if (r) return;
          const S = t.retry ?? (tb ? 0 : 3),
            C = t.retryDelay ?? p0e,
            _ = typeof C == "function" ? C(n, E) : C,
            A =
              S === !0 ||
              (typeof S == "number" && n < S) ||
              (typeof S == "function" && S(n, E));
          if (e || !A) {
            m(E);
            return;
          }
          n++,
            (I = t.onFail) == null || I.call(t, n, E),
            s0e(_)
              .then(() => (d() ? void 0 : y()))
              .then(() => {
                e ? m(E) : g();
              });
        });
    };
  return {
    promise: s,
    cancel: o,
    continue: () => (i == null || i(), s),
    cancelRetry: a,
    continueRetry: l,
    canStart: p,
    start: () => (p() ? g() : y().then(g), s),
  };
}
var f0e = (t) => setTimeout(t, 0);
function h0e() {
  let t = [],
    e = 0,
    n = (a) => {
      a();
    },
    r = (a) => {
      a();
    },
    i = f0e;
  const s = (a) => {
      e
        ? t.push(a)
        : i(() => {
            n(a);
          });
    },
    o = () => {
      const a = t;
      (t = []),
        a.length &&
          i(() => {
            r(() => {
              a.forEach((l) => {
                n(l);
              });
            });
          });
    };
  return {
    batch: (a) => {
      let l;
      e++;
      try {
        l = a();
      } finally {
        e--, e || o();
      }
      return l;
    },
    batchCalls:
      (a) =>
      (...l) => {
        s(() => {
          a(...l);
        });
      },
    schedule: s,
    setNotifyFunction: (a) => {
      n = a;
    },
    setBatchNotifyFunction: (a) => {
      r = a;
    },
    setScheduler: (a) => {
      i = a;
    },
  };
}
var Pr = h0e(),
  Ml,
  E5,
  TL =
    ((E5 = class {
      constructor() {
        Ct(this, Ml);
      }
      destroy() {
        this.clearGcTimeout();
      }
      scheduleGc() {
        this.clearGcTimeout(),
          t0e(this.gcTime) &&
            tt(
              this,
              Ml,
              setTimeout(() => {
                this.optionalRemove();
              }, this.gcTime)
            );
      }
      updateGcTime(t) {
        this.gcTime = Math.max(
          this.gcTime || 0,
          t ?? (tb ? 1 / 0 : 5 * 60 * 1e3)
        );
      }
      clearGcTimeout() {
        oe(this, Ml) && (clearTimeout(oe(this, Ml)), tt(this, Ml, void 0));
      }
    }),
    (Ml = new WeakMap()),
    E5),
  jd,
  Fd,
  cs,
  Ll,
  Wr,
  Dm,
  Ul,
  Fs,
  la,
  C5,
  m0e =
    ((C5 = class extends TL {
      constructor(e) {
        super();
        Ct(this, Fs);
        Ct(this, jd);
        Ct(this, Fd);
        Ct(this, cs);
        Ct(this, Ll);
        Ct(this, Wr);
        Ct(this, Dm);
        Ct(this, Ul);
        tt(this, Ul, !1),
          tt(this, Dm, e.defaultOptions),
          this.setOptions(e.options),
          (this.observers = []),
          tt(this, Ll, e.client),
          tt(this, cs, oe(this, Ll).getQueryCache()),
          (this.queryKey = e.queryKey),
          (this.queryHash = e.queryHash),
          tt(this, jd, y0e(this.options)),
          (this.state = e.state ?? oe(this, jd)),
          this.scheduleGc();
      }
      get meta() {
        return this.options.meta;
      }
      get promise() {
        var e;
        return (e = oe(this, Wr)) == null ? void 0 : e.promise;
      }
      setOptions(e) {
        (this.options = { ...oe(this, Dm), ...e }),
          this.updateGcTime(this.options.gcTime);
      }
      optionalRemove() {
        !this.observers.length &&
          this.state.fetchStatus === "idle" &&
          oe(this, cs).remove(this);
      }
      setData(e, n) {
        const r = o0e(this.state.data, e, this.options);
        return (
          Mn(this, Fs, la).call(this, {
            data: r,
            type: "success",
            dataUpdatedAt: n == null ? void 0 : n.updatedAt,
            manual: n == null ? void 0 : n.manual,
          }),
          r
        );
      }
      setState(e, n) {
        Mn(this, Fs, la).call(this, {
          type: "setState",
          state: e,
          setStateOptions: n,
        });
      }
      cancel(e) {
        var r, i;
        const n = (r = oe(this, Wr)) == null ? void 0 : r.promise;
        return (
          (i = oe(this, Wr)) == null || i.cancel(e),
          n ? n.then(js).catch(js) : Promise.resolve()
        );
      }
      destroy() {
        super.destroy(), this.cancel({ silent: !0 });
      }
      reset() {
        this.destroy(), this.setState(oe(this, jd));
      }
      isActive() {
        return this.observers.some((e) => r0e(e.options.enabled, this) !== !1);
      }
      isDisabled() {
        return this.getObserversCount() > 0
          ? !this.isActive()
          : this.options.queryFn === m_ ||
              this.state.dataUpdateCount + this.state.errorUpdateCount === 0;
      }
      isStale() {
        return this.state.isInvalidated
          ? !0
          : this.getObserversCount() > 0
          ? this.observers.some((e) => e.getCurrentResult().isStale)
          : this.state.data === void 0;
      }
      isStaleByTime(e = 0) {
        return (
          this.state.isInvalidated ||
          this.state.data === void 0 ||
          !n0e(this.state.dataUpdatedAt, e)
        );
      }
      onFocus() {
        var n;
        const e = this.observers.find((r) => r.shouldFetchOnWindowFocus());
        e == null || e.refetch({ cancelRefetch: !1 }),
          (n = oe(this, Wr)) == null || n.continue();
      }
      onOnline() {
        var n;
        const e = this.observers.find((r) => r.shouldFetchOnReconnect());
        e == null || e.refetch({ cancelRefetch: !1 }),
          (n = oe(this, Wr)) == null || n.continue();
      }
      addObserver(e) {
        this.observers.includes(e) ||
          (this.observers.push(e),
          this.clearGcTimeout(),
          oe(this, cs).notify({
            type: "observerAdded",
            query: this,
            observer: e,
          }));
      }
      removeObserver(e) {
        this.observers.includes(e) &&
          ((this.observers = this.observers.filter((n) => n !== e)),
          this.observers.length ||
            (oe(this, Wr) &&
              (oe(this, Ul)
                ? oe(this, Wr).cancel({ revert: !0 })
                : oe(this, Wr).cancelRetry()),
            this.scheduleGc()),
          oe(this, cs).notify({
            type: "observerRemoved",
            query: this,
            observer: e,
          }));
      }
      getObserversCount() {
        return this.observers.length;
      }
      invalidate() {
        this.state.isInvalidated ||
          Mn(this, Fs, la).call(this, { type: "invalidate" });
      }
      fetch(e, n) {
        var l, d, p;
        if (this.state.fetchStatus !== "idle") {
          if (this.state.data !== void 0 && n != null && n.cancelRefetch)
            this.cancel({ silent: !0 });
          else if (oe(this, Wr))
            return oe(this, Wr).continueRetry(), oe(this, Wr).promise;
        }
        if ((e && this.setOptions(e), !this.options.queryFn)) {
          const f = this.observers.find((m) => m.options.queryFn);
          f && this.setOptions(f.options);
        }
        const r = new AbortController(),
          i = (f) => {
            Object.defineProperty(f, "signal", {
              enumerable: !0,
              get: () => (tt(this, Ul, !0), r.signal),
            });
          },
          s = () => {
            const f = xL(this.options, n),
              m = {
                client: oe(this, Ll),
                queryKey: this.queryKey,
                meta: this.meta,
              };
            return (
              i(m),
              tt(this, Ul, !1),
              this.options.persister ? this.options.persister(f, m, this) : f(m)
            );
          },
          o = {
            fetchOptions: n,
            options: this.options,
            queryKey: this.queryKey,
            client: oe(this, Ll),
            state: this.state,
            fetchFn: s,
          };
        i(o),
          (l = this.options.behavior) == null || l.onFetch(o, this),
          tt(this, Fd, this.state),
          (this.state.fetchStatus === "idle" ||
            this.state.fetchMeta !==
              ((d = o.fetchOptions) == null ? void 0 : d.meta)) &&
            Mn(this, Fs, la).call(this, {
              type: "fetch",
              meta: (p = o.fetchOptions) == null ? void 0 : p.meta,
            });
        const a = (f) => {
          var m, y, g, v;
          (MC(f) && f.silent) ||
            Mn(this, Fs, la).call(this, { type: "error", error: f }),
            MC(f) ||
              ((y = (m = oe(this, cs).config).onError) == null ||
                y.call(m, f, this),
              (v = (g = oe(this, cs).config).onSettled) == null ||
                v.call(g, this.state.data, f, this)),
            this.scheduleGc();
        };
        return (
          tt(
            this,
            Wr,
            IL({
              initialPromise: n == null ? void 0 : n.initialPromise,
              fn: o.fetchFn,
              abort: r.abort.bind(r),
              onSuccess: (f) => {
                var m, y, g, v;
                if (f === void 0) {
                  a(new Error(`${this.queryHash} data is undefined`));
                  return;
                }
                try {
                  this.setData(f);
                } catch (b) {
                  a(b);
                  return;
                }
                (y = (m = oe(this, cs).config).onSuccess) == null ||
                  y.call(m, f, this),
                  (v = (g = oe(this, cs).config).onSettled) == null ||
                    v.call(g, f, this.state.error, this),
                  this.scheduleGc();
              },
              onError: a,
              onFail: (f, m) => {
                Mn(this, Fs, la).call(this, {
                  type: "failed",
                  failureCount: f,
                  error: m,
                });
              },
              onPause: () => {
                Mn(this, Fs, la).call(this, { type: "pause" });
              },
              onContinue: () => {
                Mn(this, Fs, la).call(this, { type: "continue" });
              },
              retry: o.options.retry,
              retryDelay: o.options.retryDelay,
              networkMode: o.options.networkMode,
              canRun: () => !0,
            })
          ),
          oe(this, Wr).start()
        );
      }
    }),
    (jd = new WeakMap()),
    (Fd = new WeakMap()),
    (cs = new WeakMap()),
    (Ll = new WeakMap()),
    (Wr = new WeakMap()),
    (Dm = new WeakMap()),
    (Ul = new WeakMap()),
    (Fs = new WeakSet()),
    (la = function (e) {
      const n = (r) => {
        switch (e.type) {
          case "failed":
            return {
              ...r,
              fetchFailureCount: e.failureCount,
              fetchFailureReason: e.error,
            };
          case "pause":
            return { ...r, fetchStatus: "paused" };
          case "continue":
            return { ...r, fetchStatus: "fetching" };
          case "fetch":
            return {
              ...r,
              ...g0e(r.data, this.options),
              fetchMeta: e.meta ?? null,
            };
          case "success":
            return {
              ...r,
              data: e.data,
              dataUpdateCount: r.dataUpdateCount + 1,
              dataUpdatedAt: e.dataUpdatedAt ?? Date.now(),
              error: null,
              isInvalidated: !1,
              status: "success",
              ...(!e.manual && {
                fetchStatus: "idle",
                fetchFailureCount: 0,
                fetchFailureReason: null,
              }),
            };
          case "error":
            const i = e.error;
            return MC(i) && i.revert && oe(this, Fd)
              ? { ...oe(this, Fd), fetchStatus: "idle" }
              : {
                  ...r,
                  error: i,
                  errorUpdateCount: r.errorUpdateCount + 1,
                  errorUpdatedAt: Date.now(),
                  fetchFailureCount: r.fetchFailureCount + 1,
                  fetchFailureReason: i,
                  fetchStatus: "idle",
                  status: "error",
                };
          case "invalidate":
            return { ...r, isInvalidated: !0 };
          case "setState":
            return { ...r, ...e.state };
        }
      };
      (this.state = n(this.state)),
        Pr.batch(() => {
          this.observers.forEach((r) => {
            r.onQueryUpdate();
          }),
            oe(this, cs).notify({ query: this, type: "updated", action: e });
        });
    }),
    C5);
function g0e(t, e) {
  return {
    fetchFailureCount: 0,
    fetchFailureReason: null,
    fetchStatus: AL(e.networkMode) ? "fetching" : "paused",
    ...(t === void 0 && { error: null, status: "pending" }),
  };
}
function y0e(t) {
  const e =
      typeof t.initialData == "function" ? t.initialData() : t.initialData,
    n = e !== void 0,
    r = n
      ? typeof t.initialDataUpdatedAt == "function"
        ? t.initialDataUpdatedAt()
        : t.initialDataUpdatedAt
      : 0;
  return {
    data: e,
    dataUpdateCount: 0,
    dataUpdatedAt: n ? r ?? Date.now() : 0,
    error: null,
    errorUpdateCount: 0,
    errorUpdatedAt: 0,
    fetchFailureCount: 0,
    fetchFailureReason: null,
    fetchMeta: null,
    isInvalidated: !1,
    status: n ? "success" : "pending",
    fetchStatus: "idle",
  };
}
var wo,
  x5,
  w0e =
    ((x5 = class extends mg {
      constructor(e = {}) {
        super();
        Ct(this, wo);
        (this.config = e), tt(this, wo, new Map());
      }
      build(e, n, r) {
        const i = n.queryKey,
          s = n.queryHash ?? h_(i, n);
        let o = this.get(s);
        return (
          o ||
            ((o = new m0e({
              client: e,
              queryKey: i,
              queryHash: s,
              options: e.defaultQueryOptions(n),
              state: r,
              defaultOptions: e.getQueryDefaults(i),
            })),
            this.add(o)),
          o
        );
      }
      add(e) {
        oe(this, wo).has(e.queryHash) ||
          (oe(this, wo).set(e.queryHash, e),
          this.notify({ type: "added", query: e }));
      }
      remove(e) {
        const n = oe(this, wo).get(e.queryHash);
        n &&
          (e.destroy(),
          n === e && oe(this, wo).delete(e.queryHash),
          this.notify({ type: "removed", query: e }));
      }
      clear() {
        Pr.batch(() => {
          this.getAll().forEach((e) => {
            this.remove(e);
          });
        });
      }
      get(e) {
        return oe(this, wo).get(e);
      }
      getAll() {
        return [...oe(this, wo).values()];
      }
      find(e) {
        const n = { exact: !0, ...e };
        return this.getAll().find((r) => Zk(n, r));
      }
      findAll(e = {}) {
        const n = this.getAll();
        return Object.keys(e).length > 0 ? n.filter((r) => Zk(e, r)) : n;
      }
      notify(e) {
        Pr.batch(() => {
          this.listeners.forEach((n) => {
            n(e);
          });
        });
      }
      onFocus() {
        Pr.batch(() => {
          this.getAll().forEach((e) => {
            e.onFocus();
          });
        });
      }
      onOnline() {
        Pr.batch(() => {
          this.getAll().forEach((e) => {
            e.onOnline();
          });
        });
      }
    }),
    (wo = new WeakMap()),
    x5),
  vo,
  Jr,
  Bl,
  bo,
  dc,
  S5,
  v0e =
    ((S5 = class extends TL {
      constructor(e) {
        super();
        Ct(this, bo);
        Ct(this, vo);
        Ct(this, Jr);
        Ct(this, Bl);
        (this.mutationId = e.mutationId),
          tt(this, Jr, e.mutationCache),
          tt(this, vo, []),
          (this.state = e.state || PL()),
          this.setOptions(e.options),
          this.scheduleGc();
      }
      setOptions(e) {
        (this.options = e), this.updateGcTime(this.options.gcTime);
      }
      get meta() {
        return this.options.meta;
      }
      addObserver(e) {
        oe(this, vo).includes(e) ||
          (oe(this, vo).push(e),
          this.clearGcTimeout(),
          oe(this, Jr).notify({
            type: "observerAdded",
            mutation: this,
            observer: e,
          }));
      }
      removeObserver(e) {
        tt(
          this,
          vo,
          oe(this, vo).filter((n) => n !== e)
        ),
          this.scheduleGc(),
          oe(this, Jr).notify({
            type: "observerRemoved",
            mutation: this,
            observer: e,
          });
      }
      optionalRemove() {
        oe(this, vo).length ||
          (this.state.status === "pending"
            ? this.scheduleGc()
            : oe(this, Jr).remove(this));
      }
      continue() {
        var e;
        return (
          ((e = oe(this, Bl)) == null ? void 0 : e.continue()) ??
          this.execute(this.state.variables)
        );
      }
      async execute(e) {
        var s, o, a, l, d, p, f, m, y, g, v, b, E, S, C, _, A, I, R, D;
        const n = () => {
          Mn(this, bo, dc).call(this, { type: "continue" });
        };
        tt(
          this,
          Bl,
          IL({
            fn: () =>
              this.options.mutationFn
                ? this.options.mutationFn(e)
                : Promise.reject(new Error("No mutationFn found")),
            onFail: (k, T) => {
              Mn(this, bo, dc).call(this, {
                type: "failed",
                failureCount: k,
                error: T,
              });
            },
            onPause: () => {
              Mn(this, bo, dc).call(this, { type: "pause" });
            },
            onContinue: n,
            retry: this.options.retry ?? 0,
            retryDelay: this.options.retryDelay,
            networkMode: this.options.networkMode,
            canRun: () => oe(this, Jr).canRun(this),
          })
        );
        const r = this.state.status === "pending",
          i = !oe(this, Bl).canStart();
        try {
          if (r) n();
          else {
            Mn(this, bo, dc).call(this, {
              type: "pending",
              variables: e,
              isPaused: i,
            }),
              await ((o = (s = oe(this, Jr).config).onMutate) == null
                ? void 0
                : o.call(s, e, this));
            const T = await ((l = (a = this.options).onMutate) == null
              ? void 0
              : l.call(a, e));
            T !== this.state.context &&
              Mn(this, bo, dc).call(this, {
                type: "pending",
                context: T,
                variables: e,
                isPaused: i,
              });
          }
          const k = await oe(this, Bl).start();
          return (
            await ((p = (d = oe(this, Jr).config).onSuccess) == null
              ? void 0
              : p.call(d, k, e, this.state.context, this)),
            await ((m = (f = this.options).onSuccess) == null
              ? void 0
              : m.call(f, k, e, this.state.context)),
            await ((g = (y = oe(this, Jr).config).onSettled) == null
              ? void 0
              : g.call(
                  y,
                  k,
                  null,
                  this.state.variables,
                  this.state.context,
                  this
                )),
            await ((b = (v = this.options).onSettled) == null
              ? void 0
              : b.call(v, k, null, e, this.state.context)),
            Mn(this, bo, dc).call(this, { type: "success", data: k }),
            k
          );
        } catch (k) {
          try {
            throw (
              (await ((S = (E = oe(this, Jr).config).onError) == null
                ? void 0
                : S.call(E, k, e, this.state.context, this)),
              await ((_ = (C = this.options).onError) == null
                ? void 0
                : _.call(C, k, e, this.state.context)),
              await ((I = (A = oe(this, Jr).config).onSettled) == null
                ? void 0
                : I.call(
                    A,
                    void 0,
                    k,
                    this.state.variables,
                    this.state.context,
                    this
                  )),
              await ((D = (R = this.options).onSettled) == null
                ? void 0
                : D.call(R, void 0, k, e, this.state.context)),
              k)
            );
          } finally {
            Mn(this, bo, dc).call(this, { type: "error", error: k });
          }
        } finally {
          oe(this, Jr).runNext(this);
        }
      }
    }),
    (vo = new WeakMap()),
    (Jr = new WeakMap()),
    (Bl = new WeakMap()),
    (bo = new WeakSet()),
    (dc = function (e) {
      const n = (r) => {
        switch (e.type) {
          case "failed":
            return {
              ...r,
              failureCount: e.failureCount,
              failureReason: e.error,
            };
          case "pause":
            return { ...r, isPaused: !0 };
          case "continue":
            return { ...r, isPaused: !1 };
          case "pending":
            return {
              ...r,
              context: e.context,
              data: void 0,
              failureCount: 0,
              failureReason: null,
              error: null,
              isPaused: e.isPaused,
              status: "pending",
              variables: e.variables,
              submittedAt: Date.now(),
            };
          case "success":
            return {
              ...r,
              data: e.data,
              failureCount: 0,
              failureReason: null,
              error: null,
              status: "success",
              isPaused: !1,
            };
          case "error":
            return {
              ...r,
              data: void 0,
              error: e.error,
              failureCount: r.failureCount + 1,
              failureReason: e.error,
              isPaused: !1,
              status: "error",
            };
        }
      };
      (this.state = n(this.state)),
        Pr.batch(() => {
          oe(this, vo).forEach((r) => {
            r.onMutationUpdate(e);
          }),
            oe(this, Jr).notify({ mutation: this, type: "updated", action: e });
        });
    }),
    S5);
function PL() {
  return {
    context: void 0,
    data: void 0,
    error: null,
    failureCount: 0,
    failureReason: null,
    isPaused: !1,
    status: "idle",
    variables: void 0,
    submittedAt: 0,
  };
}
var pa,
  zs,
  $m,
  A5,
  b0e =
    ((A5 = class extends mg {
      constructor(e = {}) {
        super();
        Ct(this, pa);
        Ct(this, zs);
        Ct(this, $m);
        (this.config = e),
          tt(this, pa, new Set()),
          tt(this, zs, new Map()),
          tt(this, $m, 0);
      }
      build(e, n, r) {
        const i = new v0e({
          mutationCache: this,
          mutationId: ++Ry(this, $m)._,
          options: e.defaultMutationOptions(n),
          state: r,
        });
        return this.add(i), i;
      }
      add(e) {
        oe(this, pa).add(e);
        const n = x0(e);
        if (typeof n == "string") {
          const r = oe(this, zs).get(n);
          r ? r.push(e) : oe(this, zs).set(n, [e]);
        }
        this.notify({ type: "added", mutation: e });
      }
      remove(e) {
        if (oe(this, pa).delete(e)) {
          const n = x0(e);
          if (typeof n == "string") {
            const r = oe(this, zs).get(n);
            if (r)
              if (r.length > 1) {
                const i = r.indexOf(e);
                i !== -1 && r.splice(i, 1);
              } else r[0] === e && oe(this, zs).delete(n);
          }
        }
        this.notify({ type: "removed", mutation: e });
      }
      canRun(e) {
        const n = x0(e);
        if (typeof n == "string") {
          const r = oe(this, zs).get(n),
            i =
              r == null ? void 0 : r.find((s) => s.state.status === "pending");
          return !i || i === e;
        } else return !0;
      }
      runNext(e) {
        var r;
        const n = x0(e);
        if (typeof n == "string") {
          const i =
            (r = oe(this, zs).get(n)) == null
              ? void 0
              : r.find((s) => s !== e && s.state.isPaused);
          return (i == null ? void 0 : i.continue()) ?? Promise.resolve();
        } else return Promise.resolve();
      }
      clear() {
        Pr.batch(() => {
          oe(this, pa).forEach((e) => {
            this.notify({ type: "removed", mutation: e });
          }),
            oe(this, pa).clear(),
            oe(this, zs).clear();
        });
      }
      getAll() {
        return Array.from(oe(this, pa));
      }
      find(e) {
        const n = { exact: !0, ...e };
        return this.getAll().find((r) => Qk(n, r));
      }
      findAll(e = {}) {
        return this.getAll().filter((n) => Qk(e, n));
      }
      notify(e) {
        Pr.batch(() => {
          this.listeners.forEach((n) => {
            n(e);
          });
        });
      }
      resumePausedMutations() {
        const e = this.getAll().filter((n) => n.state.isPaused);
        return Pr.batch(() =>
          Promise.all(e.map((n) => n.continue().catch(js)))
        );
      }
    }),
    (pa = new WeakMap()),
    (zs = new WeakMap()),
    ($m = new WeakMap()),
    A5);
function x0(t) {
  var e;
  return (e = t.options.scope) == null ? void 0 : e.id;
}
function e5(t) {
  return {
    onFetch: (e, n) => {
      var p, f, m, y, g;
      const r = e.options,
        i =
          (m =
            (f = (p = e.fetchOptions) == null ? void 0 : p.meta) == null
              ? void 0
              : f.fetchMore) == null
            ? void 0
            : m.direction,
        s = ((y = e.state.data) == null ? void 0 : y.pages) || [],
        o = ((g = e.state.data) == null ? void 0 : g.pageParams) || [];
      let a = { pages: [], pageParams: [] },
        l = 0;
      const d = async () => {
        let v = !1;
        const b = (C) => {
            Object.defineProperty(C, "signal", {
              enumerable: !0,
              get: () => (
                e.signal.aborted
                  ? (v = !0)
                  : e.signal.addEventListener("abort", () => {
                      v = !0;
                    }),
                e.signal
              ),
            });
          },
          E = xL(e.options, e.fetchOptions),
          S = async (C, _, A) => {
            if (v) return Promise.reject();
            if (_ == null && C.pages.length) return Promise.resolve(C);
            const I = {
              client: e.client,
              queryKey: e.queryKey,
              pageParam: _,
              direction: A ? "backward" : "forward",
              meta: e.options.meta,
            };
            b(I);
            const R = await E(I),
              { maxPages: D } = e.options,
              k = A ? c0e : a0e;
            return {
              pages: k(C.pages, R, D),
              pageParams: k(C.pageParams, _, D),
            };
          };
        if (i && s.length) {
          const C = i === "backward",
            _ = C ? E0e : t5,
            A = { pages: s, pageParams: o },
            I = _(r, A);
          a = await S(A, I, C);
        } else {
          const C = t ?? s.length;
          do {
            const _ = l === 0 ? o[0] ?? r.initialPageParam : t5(r, a);
            if (l > 0 && _ == null) break;
            (a = await S(a, _)), l++;
          } while (l < C);
        }
        return a;
      };
      e.options.persister
        ? (e.fetchFn = () => {
            var v, b;
            return (b = (v = e.options).persister) == null
              ? void 0
              : b.call(
                  v,
                  d,
                  {
                    client: e.client,
                    queryKey: e.queryKey,
                    meta: e.options.meta,
                    signal: e.signal,
                  },
                  n
                );
          })
        : (e.fetchFn = d);
    },
  };
}
function t5(t, { pages: e, pageParams: n }) {
  const r = e.length - 1;
  return e.length > 0 ? t.getNextPageParam(e[r], e, n[r], n) : void 0;
}
function E0e(t, { pages: e, pageParams: n }) {
  var r;
  return e.length > 0
    ? (r = t.getPreviousPageParam) == null
      ? void 0
      : r.call(t, e[0], e, n[0], n)
    : void 0;
}
var On,
  bc,
  Ec,
  zd,
  Wd,
  Cc,
  Hd,
  qd,
  _5,
  C0e =
    ((_5 = class {
      constructor(t = {}) {
        Ct(this, On);
        Ct(this, bc);
        Ct(this, Ec);
        Ct(this, zd);
        Ct(this, Wd);
        Ct(this, Cc);
        Ct(this, Hd);
        Ct(this, qd);
        tt(this, On, t.queryCache || new w0e()),
          tt(this, bc, t.mutationCache || new b0e()),
          tt(this, Ec, t.defaultOptions || {}),
          tt(this, zd, new Map()),
          tt(this, Wd, new Map()),
          tt(this, Cc, 0);
      }
      mount() {
        Ry(this, Cc)._++,
          oe(this, Cc) === 1 &&
            (tt(
              this,
              Hd,
              SL.subscribe(async (t) => {
                t &&
                  (await this.resumePausedMutations(), oe(this, On).onFocus());
              })
            ),
            tt(
              this,
              qd,
              zw.subscribe(async (t) => {
                t &&
                  (await this.resumePausedMutations(), oe(this, On).onOnline());
              })
            ));
      }
      unmount() {
        var t, e;
        Ry(this, Cc)._--,
          oe(this, Cc) === 0 &&
            ((t = oe(this, Hd)) == null || t.call(this),
            tt(this, Hd, void 0),
            (e = oe(this, qd)) == null || e.call(this),
            tt(this, qd, void 0));
      }
      isFetching(t) {
        return oe(this, On).findAll({ ...t, fetchStatus: "fetching" }).length;
      }
      isMutating(t) {
        return oe(this, bc).findAll({ ...t, status: "pending" }).length;
      }
      getQueryData(t) {
        var n;
        const e = this.defaultQueryOptions({ queryKey: t });
        return (n = oe(this, On).get(e.queryHash)) == null
          ? void 0
          : n.state.data;
      }
      ensureQueryData(t) {
        const e = this.defaultQueryOptions(t),
          n = oe(this, On).build(this, e),
          r = n.state.data;
        return r === void 0
          ? this.fetchQuery(t)
          : (t.revalidateIfStale &&
              n.isStaleByTime(Yk(e.staleTime, n)) &&
              this.prefetchQuery(e),
            Promise.resolve(r));
      }
      getQueriesData(t) {
        return oe(this, On)
          .findAll(t)
          .map(({ queryKey: e, state: n }) => {
            const r = n.data;
            return [e, r];
          });
      }
      setQueryData(t, e, n) {
        const r = this.defaultQueryOptions({ queryKey: t }),
          i = oe(this, On).get(r.queryHash),
          s = i == null ? void 0 : i.state.data,
          o = e0e(e, s);
        if (o !== void 0)
          return oe(this, On)
            .build(this, r)
            .setData(o, { ...n, manual: !0 });
      }
      setQueriesData(t, e, n) {
        return Pr.batch(() =>
          oe(this, On)
            .findAll(t)
            .map(({ queryKey: r }) => [r, this.setQueryData(r, e, n)])
        );
      }
      getQueryState(t) {
        var n;
        const e = this.defaultQueryOptions({ queryKey: t });
        return (n = oe(this, On).get(e.queryHash)) == null ? void 0 : n.state;
      }
      removeQueries(t) {
        const e = oe(this, On);
        Pr.batch(() => {
          e.findAll(t).forEach((n) => {
            e.remove(n);
          });
        });
      }
      resetQueries(t, e) {
        const n = oe(this, On);
        return Pr.batch(
          () => (
            n.findAll(t).forEach((r) => {
              r.reset();
            }),
            this.refetchQueries({ type: "active", ...t }, e)
          )
        );
      }
      cancelQueries(t, e = {}) {
        const n = { revert: !0, ...e },
          r = Pr.batch(() =>
            oe(this, On)
              .findAll(t)
              .map((i) => i.cancel(n))
          );
        return Promise.all(r).then(js).catch(js);
      }
      invalidateQueries(t, e = {}) {
        return Pr.batch(
          () => (
            oe(this, On)
              .findAll(t)
              .forEach((n) => {
                n.invalidate();
              }),
            (t == null ? void 0 : t.refetchType) === "none"
              ? Promise.resolve()
              : this.refetchQueries(
                  {
                    ...t,
                    type:
                      (t == null ? void 0 : t.refetchType) ??
                      (t == null ? void 0 : t.type) ??
                      "active",
                  },
                  e
                )
          )
        );
      }
      refetchQueries(t, e = {}) {
        const n = { ...e, cancelRefetch: e.cancelRefetch ?? !0 },
          r = Pr.batch(() =>
            oe(this, On)
              .findAll(t)
              .filter((i) => !i.isDisabled())
              .map((i) => {
                let s = i.fetch(void 0, n);
                return (
                  n.throwOnError || (s = s.catch(js)),
                  i.state.fetchStatus === "paused" ? Promise.resolve() : s
                );
              })
          );
        return Promise.all(r).then(js);
      }
      fetchQuery(t) {
        const e = this.defaultQueryOptions(t);
        e.retry === void 0 && (e.retry = !1);
        const n = oe(this, On).build(this, e);
        return n.isStaleByTime(Yk(e.staleTime, n))
          ? n.fetch(e)
          : Promise.resolve(n.state.data);
      }
      prefetchQuery(t) {
        return this.fetchQuery(t).then(js).catch(js);
      }
      fetchInfiniteQuery(t) {
        return (t.behavior = e5(t.pages)), this.fetchQuery(t);
      }
      prefetchInfiniteQuery(t) {
        return this.fetchInfiniteQuery(t).then(js).catch(js);
      }
      ensureInfiniteQueryData(t) {
        return (t.behavior = e5(t.pages)), this.ensureQueryData(t);
      }
      resumePausedMutations() {
        return zw.isOnline()
          ? oe(this, bc).resumePausedMutations()
          : Promise.resolve();
      }
      getQueryCache() {
        return oe(this, On);
      }
      getMutationCache() {
        return oe(this, bc);
      }
      getDefaultOptions() {
        return oe(this, Ec);
      }
      setDefaultOptions(t) {
        tt(this, Ec, t);
      }
      setQueryDefaults(t, e) {
        oe(this, zd).set(lu(t), { queryKey: t, defaultOptions: e });
      }
      getQueryDefaults(t) {
        const e = [...oe(this, zd).values()],
          n = {};
        return (
          e.forEach((r) => {
            Om(t, r.queryKey) && Object.assign(n, r.defaultOptions);
          }),
          n
        );
      }
      setMutationDefaults(t, e) {
        oe(this, Wd).set(lu(t), { mutationKey: t, defaultOptions: e });
      }
      getMutationDefaults(t) {
        const e = [...oe(this, Wd).values()],
          n = {};
        return (
          e.forEach((r) => {
            Om(t, r.mutationKey) && Object.assign(n, r.defaultOptions);
          }),
          n
        );
      }
      defaultQueryOptions(t) {
        if (t._defaulted) return t;
        const e = {
          ...oe(this, Ec).queries,
          ...this.getQueryDefaults(t.queryKey),
          ...t,
          _defaulted: !0,
        };
        return (
          e.queryHash || (e.queryHash = h_(e.queryKey, e)),
          e.refetchOnReconnect === void 0 &&
            (e.refetchOnReconnect = e.networkMode !== "always"),
          e.throwOnError === void 0 && (e.throwOnError = !!e.suspense),
          !e.networkMode && e.persister && (e.networkMode = "offlineFirst"),
          e.queryFn === m_ && (e.enabled = !1),
          e
        );
      }
      defaultMutationOptions(t) {
        return t != null && t._defaulted
          ? t
          : {
              ...oe(this, Ec).mutations,
              ...((t == null ? void 0 : t.mutationKey) &&
                this.getMutationDefaults(t.mutationKey)),
              ...t,
              _defaulted: !0,
            };
      }
      clear() {
        oe(this, On).clear(), oe(this, bc).clear();
      }
    }),
    (On = new WeakMap()),
    (bc = new WeakMap()),
    (Ec = new WeakMap()),
    (zd = new WeakMap()),
    (Wd = new WeakMap()),
    (Cc = new WeakMap()),
    (Hd = new WeakMap()),
    (qd = new WeakMap()),
    _5),
  xc,
  Sc,
  vi,
  fa,
  Ca,
  V0,
  TS,
  I5,
  x0e =
    ((I5 = class extends mg {
      constructor(n, r) {
        super();
        Ct(this, Ca);
        Ct(this, xc);
        Ct(this, Sc);
        Ct(this, vi);
        Ct(this, fa);
        tt(this, xc, n),
          this.setOptions(r),
          this.bindMethods(),
          Mn(this, Ca, V0).call(this);
      }
      bindMethods() {
        (this.mutate = this.mutate.bind(this)),
          (this.reset = this.reset.bind(this));
      }
      setOptions(n) {
        var i;
        const r = this.options;
        (this.options = oe(this, xc).defaultMutationOptions(n)),
          i0e(this.options, r) ||
            oe(this, xc)
              .getMutationCache()
              .notify({
                type: "observerOptionsUpdated",
                mutation: oe(this, vi),
                observer: this,
              }),
          r != null &&
          r.mutationKey &&
          this.options.mutationKey &&
          lu(r.mutationKey) !== lu(this.options.mutationKey)
            ? this.reset()
            : ((i = oe(this, vi)) == null ? void 0 : i.state.status) ===
                "pending" && oe(this, vi).setOptions(this.options);
      }
      onUnsubscribe() {
        var n;
        this.hasListeners() ||
          (n = oe(this, vi)) == null ||
          n.removeObserver(this);
      }
      onMutationUpdate(n) {
        Mn(this, Ca, V0).call(this), Mn(this, Ca, TS).call(this, n);
      }
      getCurrentResult() {
        return oe(this, Sc);
      }
      reset() {
        var n;
        (n = oe(this, vi)) == null || n.removeObserver(this),
          tt(this, vi, void 0),
          Mn(this, Ca, V0).call(this),
          Mn(this, Ca, TS).call(this);
      }
      mutate(n, r) {
        var i;
        return (
          tt(this, fa, r),
          (i = oe(this, vi)) == null || i.removeObserver(this),
          tt(
            this,
            vi,
            oe(this, xc).getMutationCache().build(oe(this, xc), this.options)
          ),
          oe(this, vi).addObserver(this),
          oe(this, vi).execute(n)
        );
      }
    }),
    (xc = new WeakMap()),
    (Sc = new WeakMap()),
    (vi = new WeakMap()),
    (fa = new WeakMap()),
    (Ca = new WeakSet()),
    (V0 = function () {
      var r;
      const n = ((r = oe(this, vi)) == null ? void 0 : r.state) ?? PL();
      tt(this, Sc, {
        ...n,
        isPending: n.status === "pending",
        isSuccess: n.status === "success",
        isError: n.status === "error",
        isIdle: n.status === "idle",
        mutate: this.mutate,
        reset: this.reset,
      });
    }),
    (TS = function (n) {
      Pr.batch(() => {
        var r, i, s, o, a, l, d, p;
        if (oe(this, fa) && this.hasListeners()) {
          const f = oe(this, Sc).variables,
            m = oe(this, Sc).context;
          (n == null ? void 0 : n.type) === "success"
            ? ((i = (r = oe(this, fa)).onSuccess) == null ||
                i.call(r, n.data, f, m),
              (o = (s = oe(this, fa)).onSettled) == null ||
                o.call(s, n.data, null, f, m))
            : (n == null ? void 0 : n.type) === "error" &&
              ((l = (a = oe(this, fa)).onError) == null ||
                l.call(a, n.error, f, m),
              (p = (d = oe(this, fa)).onSettled) == null ||
                p.call(d, void 0, n.error, f, m));
        }
        this.listeners.forEach((f) => {
          f(oe(this, Sc));
        });
      });
    }),
    I5);
function S0e(t) {
  return {
    mutationFn(e) {
      return SS(t, e);
    },
    mutationKey: ["switchChain"],
  };
}
var RL = N.createContext(void 0),
  A0e = (t) => {
    const e = N.useContext(RL);
    if (!e)
      throw new Error("No QueryClient set, use QueryClientProvider to set one");
    return e;
  },
  _0e = ({ client: t, children: e }) => (
    N.useEffect(
      () => (
        t.mount(),
        () => {
          t.unmount();
        }
      ),
      [t]
    ),
    O.jsx(RL.Provider, { value: t, children: e })
  );
function I0e(t, e) {
  return typeof t == "function" ? t(...e) : !!t;
}
function T0e() {}
function P0e(t, e) {
  const n = A0e(),
    [r] = N.useState(() => new x0e(n, t));
  N.useEffect(() => {
    r.setOptions(t);
  }, [r, t]);
  const i = N.useSyncExternalStore(
      N.useCallback((o) => r.subscribe(Pr.batchCalls(o)), [r]),
      () => r.getCurrentResult(),
      () => r.getCurrentResult()
    ),
    s = N.useCallback(
      (o, a) => {
        r.mutate(o, a).catch(T0e);
      },
      [r]
    );
  if (i.error && I0e(r.options.throwOnError, [i.error])) throw i.error;
  return { ...i, mutate: s, mutateAsync: i.mutate };
}
function R0e(t = {}) {
  const e = eb(t);
  return N.useSyncExternalStore(
    (n) => Vye(e, { onChange: n }),
    () => jk(e),
    () => jk(e)
  );
}
function N0e(t = {}) {
  const { mutation: e } = t,
    n = eb(t),
    r = S0e(n),
    { mutate: i, mutateAsync: s, ...o } = P0e({ ...e, ...r });
  return {
    ...o,
    chains: R0e({ config: n }),
    switchChain: i,
    switchChainAsync: s,
  };
}
let NL = { account: null, chainIdArray: [], chainId: 0 };
const g_ = 1,
  nb = N.createContext(NL),
  O0e = ({ children: t }) => {
    const { address: e, isDisconnected: n, chainId: r } = Jye(),
      { chains: i } = eb(),
      s = i == null ? void 0 : i.map((l) => (l == null ? void 0 : l.id)),
      [o, a] = N.useState(NL);
    return (
      N.useEffect(() => {
        a({ account: e ?? null });
      }, [n, e]),
      O.jsx(nb.Provider, {
        value: { account: o.account, chainIdArray: s, chainId: r },
        children: t,
      })
    );
  },
  n5 = ({ width: t }) => {
    const { account: e } = N.useContext(nb),
      { open: n } = nL();
    return O.jsx(hL, {
      width: t,
      onClick: async () => await n(),
      children: e ? e.slice(0, 4) + "..." + e.slice(-4) : "Connect Wallet",
    });
  };
var eh = {},
  r5;
function k0e() {
  if (r5) return eh;
  (r5 = 1),
    Object.defineProperty(eh, "__esModule", { value: !0 }),
    (eh.parse = o),
    (eh.serialize = d);
  const t = /^[\u0021-\u003A\u003C\u003E-\u007E]+$/,
    e = /^[\u0021-\u003A\u003C-\u007E]*$/,
    n =
      /^([.]?[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)([.][a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)*$/i,
    r = /^[\u0020-\u003A\u003D-\u007E]*$/,
    i = Object.prototype.toString,
    s = (() => {
      const m = function () {};
      return (m.prototype = Object.create(null)), m;
    })();
  function o(m, y) {
    const g = new s(),
      v = m.length;
    if (v < 2) return g;
    const b = (y == null ? void 0 : y.decode) || p;
    let E = 0;
    do {
      const S = m.indexOf("=", E);
      if (S === -1) break;
      const C = m.indexOf(";", E),
        _ = C === -1 ? v : C;
      if (S > _) {
        E = m.lastIndexOf(";", S - 1) + 1;
        continue;
      }
      const A = a(m, E, S),
        I = l(m, S, A),
        R = m.slice(A, I);
      if (g[R] === void 0) {
        let D = a(m, S + 1, _),
          k = l(m, _, D);
        const T = b(m.slice(D, k));
        g[R] = T;
      }
      E = _ + 1;
    } while (E < v);
    return g;
  }
  function a(m, y, g) {
    do {
      const v = m.charCodeAt(y);
      if (v !== 32 && v !== 9) return y;
    } while (++y < g);
    return g;
  }
  function l(m, y, g) {
    for (; y > g; ) {
      const v = m.charCodeAt(--y);
      if (v !== 32 && v !== 9) return y + 1;
    }
    return g;
  }
  function d(m, y, g) {
    const v = (g == null ? void 0 : g.encode) || encodeURIComponent;
    if (!t.test(m)) throw new TypeError(`argument name is invalid: ${m}`);
    const b = v(y);
    if (!e.test(b)) throw new TypeError(`argument val is invalid: ${y}`);
    let E = m + "=" + b;
    if (!g) return E;
    if (g.maxAge !== void 0) {
      if (!Number.isInteger(g.maxAge))
        throw new TypeError(`option maxAge is invalid: ${g.maxAge}`);
      E += "; Max-Age=" + g.maxAge;
    }
    if (g.domain) {
      if (!n.test(g.domain))
        throw new TypeError(`option domain is invalid: ${g.domain}`);
      E += "; Domain=" + g.domain;
    }
    if (g.path) {
      if (!r.test(g.path))
        throw new TypeError(`option path is invalid: ${g.path}`);
      E += "; Path=" + g.path;
    }
    if (g.expires) {
      if (!f(g.expires) || !Number.isFinite(g.expires.valueOf()))
        throw new TypeError(`option expires is invalid: ${g.expires}`);
      E += "; Expires=" + g.expires.toUTCString();
    }
    if (
      (g.httpOnly && (E += "; HttpOnly"),
      g.secure && (E += "; Secure"),
      g.partitioned && (E += "; Partitioned"),
      g.priority)
    )
      switch (
        typeof g.priority == "string" ? g.priority.toLowerCase() : void 0
      ) {
        case "low":
          E += "; Priority=Low";
          break;
        case "medium":
          E += "; Priority=Medium";
          break;
        case "high":
          E += "; Priority=High";
          break;
        default:
          throw new TypeError(`option priority is invalid: ${g.priority}`);
      }
    if (g.sameSite)
      switch (
        typeof g.sameSite == "string" ? g.sameSite.toLowerCase() : g.sameSite
      ) {
        case !0:
        case "strict":
          E += "; SameSite=Strict";
          break;
        case "lax":
          E += "; SameSite=Lax";
          break;
        case "none":
          E += "; SameSite=None";
          break;
        default:
          throw new TypeError(`option sameSite is invalid: ${g.sameSite}`);
      }
    return E;
  }
  function p(m) {
    if (m.indexOf("%") === -1) return m;
    try {
      return decodeURIComponent(m);
    } catch {
      return m;
    }
  }
  function f(m) {
    return i.call(m) === "[object Date]";
  }
  return eh;
}
k0e();
var i5 = "popstate";
function D0e(t = {}) {
  function e(r, i) {
    let { pathname: s, search: o, hash: a } = r.location;
    return PS(
      "",
      { pathname: s, search: o, hash: a },
      (i.state && i.state.usr) || null,
      (i.state && i.state.key) || "default"
    );
  }
  function n(r, i) {
    return typeof i == "string" ? i : km(i);
  }
  return M0e(e, n, null, t);
}
function _n(t, e) {
  if (t === !1 || t === null || typeof t > "u") throw new Error(e);
}
function Uo(t, e) {
  if (!t) {
    typeof console < "u" && console.warn(e);
    try {
      throw new Error(e);
    } catch {}
  }
}
function $0e() {
  return Math.random().toString(36).substring(2, 10);
}
function s5(t, e) {
  return { usr: t.state, key: t.key, idx: e };
}
function PS(t, e, n = null, r) {
  return {
    pathname: typeof t == "string" ? t : t.pathname,
    search: "",
    hash: "",
    ...(typeof e == "string" ? $p(e) : e),
    state: n,
    key: (e && e.key) || r || $0e(),
  };
}
function km({ pathname: t = "/", search: e = "", hash: n = "" }) {
  return (
    e && e !== "?" && (t += e.charAt(0) === "?" ? e : "?" + e),
    n && n !== "#" && (t += n.charAt(0) === "#" ? n : "#" + n),
    t
  );
}
function $p(t) {
  let e = {};
  if (t) {
    let n = t.indexOf("#");
    n >= 0 && ((e.hash = t.substring(n)), (t = t.substring(0, n)));
    let r = t.indexOf("?");
    r >= 0 && ((e.search = t.substring(r)), (t = t.substring(0, r))),
      t && (e.pathname = t);
  }
  return e;
}
function M0e(t, e, n, r = {}) {
  let { window: i = document.defaultView, v5Compat: s = !1 } = r,
    o = i.history,
    a = "POP",
    l = null,
    d = p();
  d == null && ((d = 0), o.replaceState({ ...o.state, idx: d }, ""));
  function p() {
    return (o.state || { idx: null }).idx;
  }
  function f() {
    a = "POP";
    let b = p(),
      E = b == null ? null : b - d;
    (d = b), l && l({ action: a, location: v.location, delta: E });
  }
  function m(b, E) {
    a = "PUSH";
    let S = PS(v.location, b, E);
    d = p() + 1;
    let C = s5(S, d),
      _ = v.createHref(S);
    try {
      o.pushState(C, "", _);
    } catch (A) {
      if (A instanceof DOMException && A.name === "DataCloneError") throw A;
      i.location.assign(_);
    }
    s && l && l({ action: a, location: v.location, delta: 1 });
  }
  function y(b, E) {
    a = "REPLACE";
    let S = PS(v.location, b, E);
    d = p();
    let C = s5(S, d),
      _ = v.createHref(S);
    o.replaceState(C, "", _),
      s && l && l({ action: a, location: v.location, delta: 0 });
  }
  function g(b) {
    return L0e(b);
  }
  let v = {
    get action() {
      return a;
    },
    get location() {
      return t(i, o);
    },
    listen(b) {
      if (l) throw new Error("A history only accepts one active listener");
      return (
        i.addEventListener(i5, f),
        (l = b),
        () => {
          i.removeEventListener(i5, f), (l = null);
        }
      );
    },
    createHref(b) {
      return e(i, b);
    },
    createURL: g,
    encodeLocation(b) {
      let E = g(b);
      return { pathname: E.pathname, search: E.search, hash: E.hash };
    },
    push: m,
    replace: y,
    go(b) {
      return o.go(b);
    },
  };
  return v;
}
function L0e(t, e = !1) {
  let n = "http://localhost";
  typeof window < "u" &&
    (n =
      window.location.origin !== "null"
        ? window.location.origin
        : window.location.href),
    _n(n, "No window.location.(origin|href) available to create URL");
  let r = typeof t == "string" ? t : km(t);
  return (
    (r = r.replace(/ $/, "%20")),
    !e && r.startsWith("//") && (r = n + r),
    new URL(r, n)
  );
}
function OL(t, e, n = "/") {
  return U0e(t, e, n, !1);
}
function U0e(t, e, n, r) {
  let i = typeof e == "string" ? $p(e) : e,
    s = Ta(i.pathname || "/", n);
  if (s == null) return null;
  let o = kL(t);
  B0e(o);
  let a = null;
  for (let l = 0; a == null && l < o.length; ++l) {
    let d = Z0e(s);
    a = K0e(o[l], d, r);
  }
  return a;
}
function kL(t, e = [], n = [], r = "") {
  let i = (s, o, a) => {
    let l = {
      relativePath: a === void 0 ? s.path || "" : a,
      caseSensitive: s.caseSensitive === !0,
      childrenIndex: o,
      route: s,
    };
    l.relativePath.startsWith("/") &&
      (_n(
        l.relativePath.startsWith(r),
        `Absolute route path "${l.relativePath}" nested under path "${r}" is not valid. An absolute child route path must start with the combined path of all its parent routes.`
      ),
      (l.relativePath = l.relativePath.slice(r.length)));
    let d = Ea([r, l.relativePath]),
      p = n.concat(l);
    s.children &&
      s.children.length > 0 &&
      (_n(
        s.index !== !0,
        `Index routes must not have child routes. Please remove all child routes from route path "${d}".`
      ),
      kL(s.children, e, p, d)),
      !(s.path == null && !s.index) &&
        e.push({ path: d, score: V0e(d, s.index), routesMeta: p });
  };
  return (
    t.forEach((s, o) => {
      var a;
      if (s.path === "" || !((a = s.path) != null && a.includes("?"))) i(s, o);
      else for (let l of DL(s.path)) i(s, o, l);
    }),
    e
  );
}
function DL(t) {
  let e = t.split("/");
  if (e.length === 0) return [];
  let [n, ...r] = e,
    i = n.endsWith("?"),
    s = n.replace(/\?$/, "");
  if (r.length === 0) return i ? [s, ""] : [s];
  let o = DL(r.join("/")),
    a = [];
  return (
    a.push(...o.map((l) => (l === "" ? s : [s, l].join("/")))),
    i && a.push(...o),
    a.map((l) => (t.startsWith("/") && l === "" ? "/" : l))
  );
}
function B0e(t) {
  t.sort((e, n) =>
    e.score !== n.score
      ? n.score - e.score
      : G0e(
          e.routesMeta.map((r) => r.childrenIndex),
          n.routesMeta.map((r) => r.childrenIndex)
        )
  );
}
var j0e = /^:[\w-]+$/,
  F0e = 3,
  z0e = 2,
  W0e = 1,
  H0e = 10,
  q0e = -2,
  o5 = (t) => t === "*";
function V0e(t, e) {
  let n = t.split("/"),
    r = n.length;
  return (
    n.some(o5) && (r += q0e),
    e && (r += z0e),
    n
      .filter((i) => !o5(i))
      .reduce((i, s) => i + (j0e.test(s) ? F0e : s === "" ? W0e : H0e), r)
  );
}
function G0e(t, e) {
  return t.length === e.length && t.slice(0, -1).every((r, i) => r === e[i])
    ? t[t.length - 1] - e[e.length - 1]
    : 0;
}
function K0e(t, e, n = !1) {
  let { routesMeta: r } = t,
    i = {},
    s = "/",
    o = [];
  for (let a = 0; a < r.length; ++a) {
    let l = r[a],
      d = a === r.length - 1,
      p = s === "/" ? e : e.slice(s.length) || "/",
      f = Ww(
        { path: l.relativePath, caseSensitive: l.caseSensitive, end: d },
        p
      ),
      m = l.route;
    if (
      (!f &&
        d &&
        n &&
        !r[r.length - 1].route.index &&
        (f = Ww(
          { path: l.relativePath, caseSensitive: l.caseSensitive, end: !1 },
          p
        )),
      !f)
    )
      return null;
    Object.assign(i, f.params),
      o.push({
        params: i,
        pathname: Ea([s, f.pathname]),
        pathnameBase: ewe(Ea([s, f.pathnameBase])),
        route: m,
      }),
      f.pathnameBase !== "/" && (s = Ea([s, f.pathnameBase]));
  }
  return o;
}
function Ww(t, e) {
  typeof t == "string" && (t = { path: t, caseSensitive: !1, end: !0 });
  let [n, r] = Y0e(t.path, t.caseSensitive, t.end),
    i = e.match(n);
  if (!i) return null;
  let s = i[0],
    o = s.replace(/(.)\/+$/, "$1"),
    a = i.slice(1);
  return {
    params: r.reduce((d, { paramName: p, isOptional: f }, m) => {
      if (p === "*") {
        let g = a[m] || "";
        o = s.slice(0, s.length - g.length).replace(/(.)\/+$/, "$1");
      }
      const y = a[m];
      return (
        f && !y ? (d[p] = void 0) : (d[p] = (y || "").replace(/%2F/g, "/")), d
      );
    }, {}),
    pathname: s,
    pathnameBase: o,
    pattern: t,
  };
}
function Y0e(t, e = !1, n = !0) {
  Uo(
    t === "*" || !t.endsWith("*") || t.endsWith("/*"),
    `Route path "${t}" will be treated as if it were "${t.replace(
      /\*$/,
      "/*"
    )}" because the \`*\` character must always follow a \`/\` in the pattern. To get rid of this warning, please change the route path to "${t.replace(
      /\*$/,
      "/*"
    )}".`
  );
  let r = [],
    i =
      "^" +
      t
        .replace(/\/*\*?$/, "")
        .replace(/^\/*/, "/")
        .replace(/[\\.*+^${}|()[\]]/g, "\\$&")
        .replace(
          /\/:([\w-]+)(\?)?/g,
          (o, a, l) => (
            r.push({ paramName: a, isOptional: l != null }),
            l ? "/?([^\\/]+)?" : "/([^\\/]+)"
          )
        );
  return (
    t.endsWith("*")
      ? (r.push({ paramName: "*" }),
        (i += t === "*" || t === "/*" ? "(.*)$" : "(?:\\/(.+)|\\/*)$"))
      : n
      ? (i += "\\/*$")
      : t !== "" && t !== "/" && (i += "(?:(?=\\/|$))"),
    [new RegExp(i, e ? void 0 : "i"), r]
  );
}
function Z0e(t) {
  try {
    return t
      .split("/")
      .map((e) => decodeURIComponent(e).replace(/\//g, "%2F"))
      .join("/");
  } catch (e) {
    return (
      Uo(
        !1,
        `The URL path "${t}" could not be decoded because it is a malformed URL segment. This is probably due to a bad percent encoding (${e}).`
      ),
      t
    );
  }
}
function Ta(t, e) {
  if (e === "/") return t;
  if (!t.toLowerCase().startsWith(e.toLowerCase())) return null;
  let n = e.endsWith("/") ? e.length - 1 : e.length,
    r = t.charAt(n);
  return r && r !== "/" ? null : t.slice(n) || "/";
}
function Q0e(t, e = "/") {
  let {
    pathname: n,
    search: r = "",
    hash: i = "",
  } = typeof t == "string" ? $p(t) : t;
  return {
    pathname: n ? (n.startsWith("/") ? n : X0e(n, e)) : e,
    search: twe(r),
    hash: nwe(i),
  };
}
function X0e(t, e) {
  let n = e.replace(/\/+$/, "").split("/");
  return (
    t.split("/").forEach((i) => {
      i === ".." ? n.length > 1 && n.pop() : i !== "." && n.push(i);
    }),
    n.length > 1 ? n.join("/") : "/"
  );
}
function LC(t, e, n, r) {
  return `Cannot include a '${t}' character in a manually specified \`to.${e}\` field [${JSON.stringify(
    r
  )}].  Please separate it out to the \`to.${n}\` field. Alternatively you may provide the full path as a string in <Link to="..."> and the router will parse it for you.`;
}
function J0e(t) {
  return t.filter(
    (e, n) => n === 0 || (e.route.path && e.route.path.length > 0)
  );
}
function $L(t) {
  let e = J0e(t);
  return e.map((n, r) => (r === e.length - 1 ? n.pathname : n.pathnameBase));
}
function ML(t, e, n, r = !1) {
  let i;
  typeof t == "string"
    ? (i = $p(t))
    : ((i = { ...t }),
      _n(
        !i.pathname || !i.pathname.includes("?"),
        LC("?", "pathname", "search", i)
      ),
      _n(
        !i.pathname || !i.pathname.includes("#"),
        LC("#", "pathname", "hash", i)
      ),
      _n(!i.search || !i.search.includes("#"), LC("#", "search", "hash", i)));
  let s = t === "" || i.pathname === "",
    o = s ? "/" : i.pathname,
    a;
  if (o == null) a = n;
  else {
    let f = e.length - 1;
    if (!r && o.startsWith("..")) {
      let m = o.split("/");
      for (; m[0] === ".."; ) m.shift(), (f -= 1);
      i.pathname = m.join("/");
    }
    a = f >= 0 ? e[f] : "/";
  }
  let l = Q0e(i, a),
    d = o && o !== "/" && o.endsWith("/"),
    p = (s || o === ".") && n.endsWith("/");
  return !l.pathname.endsWith("/") && (d || p) && (l.pathname += "/"), l;
}
var Ea = (t) => t.join("/").replace(/\/\/+/g, "/"),
  ewe = (t) => t.replace(/\/+$/, "").replace(/^\/*/, "/"),
  twe = (t) => (!t || t === "?" ? "" : t.startsWith("?") ? t : "?" + t),
  nwe = (t) => (!t || t === "#" ? "" : t.startsWith("#") ? t : "#" + t);
function rwe(t) {
  return (
    t != null &&
    typeof t.status == "number" &&
    typeof t.statusText == "string" &&
    typeof t.internal == "boolean" &&
    "data" in t
  );
}
var LL = ["POST", "PUT", "PATCH", "DELETE"];
new Set(LL);
var iwe = ["GET", ...LL];
new Set(iwe);
var Mp = N.createContext(null);
Mp.displayName = "DataRouter";
var rb = N.createContext(null);
rb.displayName = "DataRouterState";
var UL = N.createContext({ isTransitioning: !1 });
UL.displayName = "ViewTransition";
var swe = N.createContext(new Map());
swe.displayName = "Fetchers";
var owe = N.createContext(null);
owe.displayName = "Await";
var jo = N.createContext(null);
jo.displayName = "Navigation";
var gg = N.createContext(null);
gg.displayName = "Location";
var Oa = N.createContext({ outlet: null, matches: [], isDataRoute: !1 });
Oa.displayName = "Route";
var y_ = N.createContext(null);
y_.displayName = "RouteError";
function awe(t, { relative: e } = {}) {
  _n(
    yg(),
    "useHref() may be used only in the context of a <Router> component."
  );
  let { basename: n, navigator: r } = N.useContext(jo),
    { hash: i, pathname: s, search: o } = wg(t, { relative: e }),
    a = s;
  return (
    n !== "/" && (a = s === "/" ? n : Ea([n, s])),
    r.createHref({ pathname: a, search: o, hash: i })
  );
}
function yg() {
  return N.useContext(gg) != null;
}
function yu() {
  return (
    _n(
      yg(),
      "useLocation() may be used only in the context of a <Router> component."
    ),
    N.useContext(gg).location
  );
}
var BL =
  "You should call navigate() in a React.useEffect(), not when your component is first rendered.";
function jL(t) {
  N.useContext(jo).static || N.useLayoutEffect(t);
}
function cwe() {
  let { isDataRoute: t } = N.useContext(Oa);
  return t ? Ewe() : lwe();
}
function lwe() {
  _n(
    yg(),
    "useNavigate() may be used only in the context of a <Router> component."
  );
  let t = N.useContext(Mp),
    { basename: e, navigator: n } = N.useContext(jo),
    { matches: r } = N.useContext(Oa),
    { pathname: i } = yu(),
    s = JSON.stringify($L(r)),
    o = N.useRef(!1);
  return (
    jL(() => {
      o.current = !0;
    }),
    N.useCallback(
      (l, d = {}) => {
        if ((Uo(o.current, BL), !o.current)) return;
        if (typeof l == "number") {
          n.go(l);
          return;
        }
        let p = ML(l, JSON.parse(s), i, d.relative === "path");
        t == null &&
          e !== "/" &&
          (p.pathname = p.pathname === "/" ? e : Ea([e, p.pathname])),
          (d.replace ? n.replace : n.push)(p, d.state, d);
      },
      [e, n, s, i, t]
    )
  );
}
N.createContext(null);
function wg(t, { relative: e } = {}) {
  let { matches: n } = N.useContext(Oa),
    { pathname: r } = yu(),
    i = JSON.stringify($L(n));
  return N.useMemo(() => ML(t, JSON.parse(i), r, e === "path"), [t, i, r, e]);
}
function uwe(t, e) {
  return FL(t, e);
}
function FL(t, e, n, r) {
  var S;
  _n(
    yg(),
    "useRoutes() may be used only in the context of a <Router> component."
  );
  let { navigator: i, static: s } = N.useContext(jo),
    { matches: o } = N.useContext(Oa),
    a = o[o.length - 1],
    l = a ? a.params : {},
    d = a ? a.pathname : "/",
    p = a ? a.pathnameBase : "/",
    f = a && a.route;
  {
    let C = (f && f.path) || "";
    zL(
      d,
      !f || C.endsWith("*") || C.endsWith("*?"),
      `You rendered descendant <Routes> (or called \`useRoutes()\`) at "${d}" (under <Route path="${C}">) but the parent route path has no trailing "*". This means if you navigate deeper, the parent won't match anymore and therefore the child routes will never render.

Please change the parent <Route path="${C}"> to <Route path="${
        C === "/" ? "*" : `${C}/*`
      }">.`
    );
  }
  let m = yu(),
    y;
  if (e) {
    let C = typeof e == "string" ? $p(e) : e;
    _n(
      p === "/" || ((S = C.pathname) == null ? void 0 : S.startsWith(p)),
      `When overriding the location using \`<Routes location>\` or \`useRoutes(routes, location)\`, the location pathname must begin with the portion of the URL pathname that was matched by all parent routes. The current pathname base is "${p}" but pathname "${C.pathname}" was given in the \`location\` prop.`
    ),
      (y = C);
  } else y = m;
  let g = y.pathname || "/",
    v = g;
  if (p !== "/") {
    let C = p.replace(/^\//, "").split("/");
    v = "/" + g.replace(/^\//, "").split("/").slice(C.length).join("/");
  }
  let b =
    !s && n && n.matches && n.matches.length > 0
      ? n.matches
      : OL(t, { pathname: v });
  Uo(
    f || b != null,
    `No routes matched location "${y.pathname}${y.search}${y.hash}" `
  ),
    Uo(
      b == null ||
        b[b.length - 1].route.element !== void 0 ||
        b[b.length - 1].route.Component !== void 0 ||
        b[b.length - 1].route.lazy !== void 0,
      `Matched leaf route at location "${y.pathname}${y.search}${y.hash}" does not have an element or Component. This means it will render an <Outlet /> with a null value by default resulting in an "empty" page.`
    );
  let E = mwe(
    b &&
      b.map((C) =>
        Object.assign({}, C, {
          params: Object.assign({}, l, C.params),
          pathname: Ea([
            p,
            i.encodeLocation
              ? i.encodeLocation(C.pathname).pathname
              : C.pathname,
          ]),
          pathnameBase:
            C.pathnameBase === "/"
              ? p
              : Ea([
                  p,
                  i.encodeLocation
                    ? i.encodeLocation(C.pathnameBase).pathname
                    : C.pathnameBase,
                ]),
        })
      ),
    o,
    n,
    r
  );
  return e && E
    ? N.createElement(
        gg.Provider,
        {
          value: {
            location: {
              pathname: "/",
              search: "",
              hash: "",
              state: null,
              key: "default",
              ...y,
            },
            navigationType: "POP",
          },
        },
        E
      )
    : E;
}
function dwe() {
  let t = bwe(),
    e = rwe(t)
      ? `${t.status} ${t.statusText}`
      : t instanceof Error
      ? t.message
      : JSON.stringify(t),
    n = t instanceof Error ? t.stack : null,
    r = "rgba(200,200,200, 0.5)",
    i = { padding: "0.5rem", backgroundColor: r },
    s = { padding: "2px 4px", backgroundColor: r },
    o = null;
  return (
    console.error("Error handled by React Router default ErrorBoundary:", t),
    (o = N.createElement(
      N.Fragment,
      null,
      N.createElement("p", null, " Hey developer "),
      N.createElement(
        "p",
        null,
        "You can provide a way better UX than this when your app throws errors by providing your own ",
        N.createElement("code", { style: s }, "ErrorBoundary"),
        " or",
        " ",
        N.createElement("code", { style: s }, "errorElement"),
        " prop on your route."
      )
    )),
    N.createElement(
      N.Fragment,
      null,
      N.createElement("h2", null, "Unexpected Application Error!"),
      N.createElement("h3", { style: { fontStyle: "italic" } }, e),
      n ? N.createElement("pre", { style: i }, n) : null,
      o
    )
  );
}
var pwe = N.createElement(dwe, null),
  fwe = class extends N.Component {
    constructor(t) {
      super(t),
        (this.state = {
          location: t.location,
          revalidation: t.revalidation,
          error: t.error,
        });
    }
    static getDerivedStateFromError(t) {
      return { error: t };
    }
    static getDerivedStateFromProps(t, e) {
      return e.location !== t.location ||
        (e.revalidation !== "idle" && t.revalidation === "idle")
        ? { error: t.error, location: t.location, revalidation: t.revalidation }
        : {
            error: t.error !== void 0 ? t.error : e.error,
            location: e.location,
            revalidation: t.revalidation || e.revalidation,
          };
    }
    componentDidCatch(t, e) {
      console.error(
        "React Router caught the following error during render",
        t,
        e
      );
    }
    render() {
      return this.state.error !== void 0
        ? N.createElement(
            Oa.Provider,
            { value: this.props.routeContext },
            N.createElement(y_.Provider, {
              value: this.state.error,
              children: this.props.component,
            })
          )
        : this.props.children;
    }
  };
function hwe({ routeContext: t, match: e, children: n }) {
  let r = N.useContext(Mp);
  return (
    r &&
      r.static &&
      r.staticContext &&
      (e.route.errorElement || e.route.ErrorBoundary) &&
      (r.staticContext._deepestRenderedBoundaryId = e.route.id),
    N.createElement(Oa.Provider, { value: t }, n)
  );
}
function mwe(t, e = [], n = null, r = null) {
  if (t == null) {
    if (!n) return null;
    if (n.errors) t = n.matches;
    else if (e.length === 0 && !n.initialized && n.matches.length > 0)
      t = n.matches;
    else return null;
  }
  let i = t,
    s = n == null ? void 0 : n.errors;
  if (s != null) {
    let l = i.findIndex(
      (d) => d.route.id && (s == null ? void 0 : s[d.route.id]) !== void 0
    );
    _n(
      l >= 0,
      `Could not find a matching route for errors on route IDs: ${Object.keys(
        s
      ).join(",")}`
    ),
      (i = i.slice(0, Math.min(i.length, l + 1)));
  }
  let o = !1,
    a = -1;
  if (n)
    for (let l = 0; l < i.length; l++) {
      let d = i[l];
      if (
        ((d.route.HydrateFallback || d.route.hydrateFallbackElement) && (a = l),
        d.route.id)
      ) {
        let { loaderData: p, errors: f } = n,
          m =
            d.route.loader &&
            !p.hasOwnProperty(d.route.id) &&
            (!f || f[d.route.id] === void 0);
        if (d.route.lazy || m) {
          (o = !0), a >= 0 ? (i = i.slice(0, a + 1)) : (i = [i[0]]);
          break;
        }
      }
    }
  return i.reduceRight((l, d, p) => {
    let f,
      m = !1,
      y = null,
      g = null;
    n &&
      ((f = s && d.route.id ? s[d.route.id] : void 0),
      (y = d.route.errorElement || pwe),
      o &&
        (a < 0 && p === 0
          ? (zL(
              "route-fallback",
              !1,
              "No `HydrateFallback` element provided to render during initial hydration"
            ),
            (m = !0),
            (g = null))
          : a === p &&
            ((m = !0), (g = d.route.hydrateFallbackElement || null))));
    let v = e.concat(i.slice(0, p + 1)),
      b = () => {
        let E;
        return (
          f
            ? (E = y)
            : m
            ? (E = g)
            : d.route.Component
            ? (E = N.createElement(d.route.Component, null))
            : d.route.element
            ? (E = d.route.element)
            : (E = l),
          N.createElement(hwe, {
            match: d,
            routeContext: { outlet: l, matches: v, isDataRoute: n != null },
            children: E,
          })
        );
      };
    return n && (d.route.ErrorBoundary || d.route.errorElement || p === 0)
      ? N.createElement(fwe, {
          location: n.location,
          revalidation: n.revalidation,
          component: y,
          error: f,
          children: b(),
          routeContext: { outlet: null, matches: v, isDataRoute: !0 },
        })
      : b();
  }, null);
}
function w_(t) {
  return `${t} must be used within a data router.  See https://reactrouter.com/en/main/routers/picking-a-router.`;
}
function gwe(t) {
  let e = N.useContext(Mp);
  return _n(e, w_(t)), e;
}
function ywe(t) {
  let e = N.useContext(rb);
  return _n(e, w_(t)), e;
}
function wwe(t) {
  let e = N.useContext(Oa);
  return _n(e, w_(t)), e;
}
function v_(t) {
  let e = wwe(t),
    n = e.matches[e.matches.length - 1];
  return (
    _n(
      n.route.id,
      `${t} can only be used on routes that contain a unique "id"`
    ),
    n.route.id
  );
}
function vwe() {
  return v_("useRouteId");
}
function bwe() {
  var r;
  let t = N.useContext(y_),
    e = ywe("useRouteError"),
    n = v_("useRouteError");
  return t !== void 0 ? t : (r = e.errors) == null ? void 0 : r[n];
}
function Ewe() {
  let { router: t } = gwe("useNavigate"),
    e = v_("useNavigate"),
    n = N.useRef(!1);
  return (
    jL(() => {
      n.current = !0;
    }),
    N.useCallback(
      async (i, s = {}) => {
        Uo(n.current, BL),
          n.current &&
            (typeof i == "number"
              ? t.navigate(i)
              : await t.navigate(i, { fromRouteId: e, ...s }));
      },
      [t, e]
    )
  );
}
var a5 = {};
function zL(t, e, n) {
  !e && !a5[t] && ((a5[t] = !0), Uo(!1, n));
}
N.memo(Cwe);
function Cwe({ routes: t, future: e, state: n }) {
  return FL(t, void 0, n, e);
}
function WL(t) {
  _n(
    !1,
    "A <Route> is only ever to be used as the child of <Routes> element, never rendered directly. Please wrap your <Route> in a <Routes>."
  );
}
function xwe({
  basename: t = "/",
  children: e = null,
  location: n,
  navigationType: r = "POP",
  navigator: i,
  static: s = !1,
}) {
  _n(
    !yg(),
    "You cannot render a <Router> inside another <Router>. You should never have more than one in your app."
  );
  let o = t.replace(/^\/*/, "/"),
    a = N.useMemo(
      () => ({ basename: o, navigator: i, static: s, future: {} }),
      [o, i, s]
    );
  typeof n == "string" && (n = $p(n));
  let {
      pathname: l = "/",
      search: d = "",
      hash: p = "",
      state: f = null,
      key: m = "default",
    } = n,
    y = N.useMemo(() => {
      let g = Ta(l, o);
      return g == null
        ? null
        : {
            location: { pathname: g, search: d, hash: p, state: f, key: m },
            navigationType: r,
          };
    }, [o, l, d, p, f, m, r]);
  return (
    Uo(
      y != null,
      `<Router basename="${o}"> is not able to match the URL "${l}${d}${p}" because it does not start with the basename, so the <Router> won't render anything.`
    ),
    y == null
      ? null
      : N.createElement(
          jo.Provider,
          { value: a },
          N.createElement(gg.Provider, { children: e, value: y })
        )
  );
}
function Swe({ children: t, location: e }) {
  return uwe(RS(t), e);
}
function RS(t, e = []) {
  let n = [];
  return (
    N.Children.forEach(t, (r, i) => {
      if (!N.isValidElement(r)) return;
      let s = [...e, i];
      if (r.type === N.Fragment) {
        n.push.apply(n, RS(r.props.children, s));
        return;
      }
      _n(
        r.type === WL,
        `[${
          typeof r.type == "string" ? r.type : r.type.name
        }] is not a <Route> component. All component children of <Routes> must be a <Route> or <React.Fragment>`
      ),
        _n(
          !r.props.index || !r.props.children,
          "An index route cannot have child routes."
        );
      let o = {
        id: r.props.id || s.join("-"),
        caseSensitive: r.props.caseSensitive,
        element: r.props.element,
        Component: r.props.Component,
        index: r.props.index,
        path: r.props.path,
        loader: r.props.loader,
        action: r.props.action,
        hydrateFallbackElement: r.props.hydrateFallbackElement,
        HydrateFallback: r.props.HydrateFallback,
        errorElement: r.props.errorElement,
        ErrorBoundary: r.props.ErrorBoundary,
        hasErrorBoundary:
          r.props.hasErrorBoundary === !0 ||
          r.props.ErrorBoundary != null ||
          r.props.errorElement != null,
        shouldRevalidate: r.props.shouldRevalidate,
        handle: r.props.handle,
        lazy: r.props.lazy,
      };
      r.props.children && (o.children = RS(r.props.children, s)), n.push(o);
    }),
    n
  );
}
var G0 = "get",
  K0 = "application/x-www-form-urlencoded";
function ib(t) {
  return t != null && typeof t.tagName == "string";
}
function Awe(t) {
  return ib(t) && t.tagName.toLowerCase() === "button";
}
function _we(t) {
  return ib(t) && t.tagName.toLowerCase() === "form";
}
function Iwe(t) {
  return ib(t) && t.tagName.toLowerCase() === "input";
}
function Twe(t) {
  return !!(t.metaKey || t.altKey || t.ctrlKey || t.shiftKey);
}
function Pwe(t, e) {
  return t.button === 0 && (!e || e === "_self") && !Twe(t);
}
var S0 = null;
function Rwe() {
  if (S0 === null)
    try {
      new FormData(document.createElement("form"), 0), (S0 = !1);
    } catch {
      S0 = !0;
    }
  return S0;
}
var Nwe = new Set([
  "application/x-www-form-urlencoded",
  "multipart/form-data",
  "text/plain",
]);
function UC(t) {
  return t != null && !Nwe.has(t)
    ? (Uo(
        !1,
        `"${t}" is not a valid \`encType\` for \`<Form>\`/\`<fetcher.Form>\` and will default to "${K0}"`
      ),
      null)
    : t;
}
function Owe(t, e) {
  let n, r, i, s, o;
  if (_we(t)) {
    let a = t.getAttribute("action");
    (r = a ? Ta(a, e) : null),
      (n = t.getAttribute("method") || G0),
      (i = UC(t.getAttribute("enctype")) || K0),
      (s = new FormData(t));
  } else if (
    Awe(t) ||
    (Iwe(t) && (t.type === "submit" || t.type === "image"))
  ) {
    let a = t.form;
    if (a == null)
      throw new Error(
        'Cannot submit a <button> or <input type="submit"> without a <form>'
      );
    let l = t.getAttribute("formaction") || a.getAttribute("action");
    if (
      ((r = l ? Ta(l, e) : null),
      (n = t.getAttribute("formmethod") || a.getAttribute("method") || G0),
      (i =
        UC(t.getAttribute("formenctype")) ||
        UC(a.getAttribute("enctype")) ||
        K0),
      (s = new FormData(a, t)),
      !Rwe())
    ) {
      let { name: d, type: p, value: f } = t;
      if (p === "image") {
        let m = d ? `${d}.` : "";
        s.append(`${m}x`, "0"), s.append(`${m}y`, "0");
      } else d && s.append(d, f);
    }
  } else {
    if (ib(t))
      throw new Error(
        'Cannot submit element that is not <form>, <button>, or <input type="submit|image">'
      );
    (n = G0), (r = null), (i = K0), (o = t);
  }
  return (
    s && i === "text/plain" && ((o = s), (s = void 0)),
    { action: r, method: n.toLowerCase(), encType: i, formData: s, body: o }
  );
}
function b_(t, e) {
  if (t === !1 || t === null || typeof t > "u") throw new Error(e);
}
async function kwe(t, e) {
  if (t.id in e) return e[t.id];
  try {
    let n = await import(t.module);
    return (e[t.id] = n), n;
  } catch (n) {
    return (
      console.error(
        `Error loading route module \`${t.module}\`, reloading page...`
      ),
      console.error(n),
      window.__reactRouterContext && window.__reactRouterContext.isSpaMode,
      window.location.reload(),
      new Promise(() => {})
    );
  }
}
function Dwe(t) {
  return t == null
    ? !1
    : t.href == null
    ? t.rel === "preload" &&
      typeof t.imageSrcSet == "string" &&
      typeof t.imageSizes == "string"
    : typeof t.rel == "string" && typeof t.href == "string";
}
async function $we(t, e, n) {
  let r = await Promise.all(
    t.map(async (i) => {
      let s = e.routes[i.route.id];
      if (s) {
        let o = await kwe(s, n);
        return o.links ? o.links() : [];
      }
      return [];
    })
  );
  return Bwe(
    r
      .flat(1)
      .filter(Dwe)
      .filter((i) => i.rel === "stylesheet" || i.rel === "preload")
      .map((i) =>
        i.rel === "stylesheet"
          ? { ...i, rel: "prefetch", as: "style" }
          : { ...i, rel: "prefetch" }
      )
  );
}
function c5(t, e, n, r, i, s) {
  let o = (l, d) => (n[d] ? l.route.id !== n[d].route.id : !0),
    a = (l, d) => {
      var p;
      return (
        n[d].pathname !== l.pathname ||
        (((p = n[d].route.path) == null ? void 0 : p.endsWith("*")) &&
          n[d].params["*"] !== l.params["*"])
      );
    };
  return s === "assets"
    ? e.filter((l, d) => o(l, d) || a(l, d))
    : s === "data"
    ? e.filter((l, d) => {
        var f;
        let p = r.routes[l.route.id];
        if (!p || !p.hasLoader) return !1;
        if (o(l, d) || a(l, d)) return !0;
        if (l.route.shouldRevalidate) {
          let m = l.route.shouldRevalidate({
            currentUrl: new URL(i.pathname + i.search + i.hash, window.origin),
            currentParams: ((f = n[0]) == null ? void 0 : f.params) || {},
            nextUrl: new URL(t, window.origin),
            nextParams: l.params,
            defaultShouldRevalidate: !0,
          });
          if (typeof m == "boolean") return m;
        }
        return !0;
      })
    : [];
}
function Mwe(t, e, { includeHydrateFallback: n } = {}) {
  return Lwe(
    t
      .map((r) => {
        let i = e.routes[r.route.id];
        if (!i) return [];
        let s = [i.module];
        return (
          i.clientActionModule && (s = s.concat(i.clientActionModule)),
          i.clientLoaderModule && (s = s.concat(i.clientLoaderModule)),
          n &&
            i.hydrateFallbackModule &&
            (s = s.concat(i.hydrateFallbackModule)),
          i.imports && (s = s.concat(i.imports)),
          s
        );
      })
      .flat(1)
  );
}
function Lwe(t) {
  return [...new Set(t)];
}
function Uwe(t) {
  let e = {},
    n = Object.keys(t).sort();
  for (let r of n) e[r] = t[r];
  return e;
}
function Bwe(t, e) {
  let n = new Set();
  return (
    new Set(e),
    t.reduce((r, i) => {
      let s = JSON.stringify(Uwe(i));
      return n.has(s) || (n.add(s), r.push({ key: s, link: i })), r;
    }, [])
  );
}
Object.getOwnPropertyNames(Object.prototype).sort().join("\0");
var jwe = new Set([100, 101, 204, 205]);
function Fwe(t, e) {
  let n =
    typeof t == "string"
      ? new URL(
          t,
          typeof window > "u" ? "server://singlefetch/" : window.location.origin
        )
      : t;
  return (
    n.pathname === "/"
      ? (n.pathname = "_root.data")
      : e && Ta(n.pathname, e) === "/"
      ? (n.pathname = `${e.replace(/\/$/, "")}/_root.data`)
      : (n.pathname = `${n.pathname.replace(/\/$/, "")}.data`),
    n
  );
}
function HL() {
  let t = N.useContext(Mp);
  return (
    b_(
      t,
      "You must render this element inside a <DataRouterContext.Provider> element"
    ),
    t
  );
}
function zwe() {
  let t = N.useContext(rb);
  return (
    b_(
      t,
      "You must render this element inside a <DataRouterStateContext.Provider> element"
    ),
    t
  );
}
var E_ = N.createContext(void 0);
E_.displayName = "FrameworkContext";
function qL() {
  let t = N.useContext(E_);
  return (
    b_(t, "You must render this element inside a <HydratedRouter> element"), t
  );
}
function Wwe(t, e) {
  let n = N.useContext(E_),
    [r, i] = N.useState(!1),
    [s, o] = N.useState(!1),
    {
      onFocus: a,
      onBlur: l,
      onMouseEnter: d,
      onMouseLeave: p,
      onTouchStart: f,
    } = e,
    m = N.useRef(null);
  N.useEffect(() => {
    if ((t === "render" && o(!0), t === "viewport")) {
      let v = (E) => {
          E.forEach((S) => {
            o(S.isIntersecting);
          });
        },
        b = new IntersectionObserver(v, { threshold: 0.5 });
      return (
        m.current && b.observe(m.current),
        () => {
          b.disconnect();
        }
      );
    }
  }, [t]),
    N.useEffect(() => {
      if (r) {
        let v = setTimeout(() => {
          o(!0);
        }, 100);
        return () => {
          clearTimeout(v);
        };
      }
    }, [r]);
  let y = () => {
      i(!0);
    },
    g = () => {
      i(!1), o(!1);
    };
  return n
    ? t !== "intent"
      ? [s, m, {}]
      : [
          s,
          m,
          {
            onFocus: th(a, y),
            onBlur: th(l, g),
            onMouseEnter: th(d, y),
            onMouseLeave: th(p, g),
            onTouchStart: th(f, y),
          },
        ]
    : [!1, m, {}];
}
function th(t, e) {
  return (n) => {
    t && t(n), n.defaultPrevented || e(n);
  };
}
function Hwe({ page: t, ...e }) {
  let { router: n } = HL(),
    r = N.useMemo(() => OL(n.routes, t, n.basename), [n.routes, t, n.basename]);
  return r ? N.createElement(Vwe, { page: t, matches: r, ...e }) : null;
}
function qwe(t) {
  let { manifest: e, routeModules: n } = qL(),
    [r, i] = N.useState([]);
  return (
    N.useEffect(() => {
      let s = !1;
      return (
        $we(t, e, n).then((o) => {
          s || i(o);
        }),
        () => {
          s = !0;
        }
      );
    }, [t, e, n]),
    r
  );
}
function Vwe({ page: t, matches: e, ...n }) {
  let r = yu(),
    { manifest: i, routeModules: s } = qL(),
    { basename: o } = HL(),
    { loaderData: a, matches: l } = zwe(),
    d = N.useMemo(() => c5(t, e, l, i, r, "data"), [t, e, l, i, r]),
    p = N.useMemo(() => c5(t, e, l, i, r, "assets"), [t, e, l, i, r]),
    f = N.useMemo(() => {
      if (t === r.pathname + r.search + r.hash) return [];
      let g = new Set(),
        v = !1;
      if (
        (e.forEach((E) => {
          var C;
          let S = i.routes[E.route.id];
          !S ||
            !S.hasLoader ||
            ((!d.some((_) => _.route.id === E.route.id) &&
              E.route.id in a &&
              (C = s[E.route.id]) != null &&
              C.shouldRevalidate) ||
            S.hasClientLoader
              ? (v = !0)
              : g.add(E.route.id));
        }),
        g.size === 0)
      )
        return [];
      let b = Fwe(t, o);
      return (
        v &&
          g.size > 0 &&
          b.searchParams.set(
            "_routes",
            e
              .filter((E) => g.has(E.route.id))
              .map((E) => E.route.id)
              .join(",")
          ),
        [b.pathname + b.search]
      );
    }, [o, a, r, i, d, e, t, s]),
    m = N.useMemo(() => Mwe(p, i), [p, i]),
    y = qwe(p);
  return N.createElement(
    N.Fragment,
    null,
    f.map((g) =>
      N.createElement("link", {
        key: g,
        rel: "prefetch",
        as: "fetch",
        href: g,
        ...n,
      })
    ),
    m.map((g) =>
      N.createElement("link", { key: g, rel: "modulepreload", href: g, ...n })
    ),
    y.map(({ key: g, link: v }) => N.createElement("link", { key: g, ...v }))
  );
}
function Gwe(...t) {
  return (e) => {
    t.forEach((n) => {
      typeof n == "function" ? n(e) : n != null && (n.current = e);
    });
  };
}
var VL =
  typeof window < "u" &&
  typeof window.document < "u" &&
  typeof window.document.createElement < "u";
try {
  VL && (window.__reactRouterVersion = "7.6.0");
} catch {}
function Kwe({ basename: t, children: e, window: n }) {
  let r = N.useRef();
  r.current == null && (r.current = D0e({ window: n, v5Compat: !0 }));
  let i = r.current,
    [s, o] = N.useState({ action: i.action, location: i.location }),
    a = N.useCallback(
      (l) => {
        N.startTransition(() => o(l));
      },
      [o]
    );
  return (
    N.useLayoutEffect(() => i.listen(a), [i, a]),
    N.createElement(xwe, {
      basename: t,
      children: e,
      location: s.location,
      navigationType: s.action,
      navigator: i,
    })
  );
}
var GL = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i,
  ds = N.forwardRef(function (
    {
      onClick: e,
      discover: n = "render",
      prefetch: r = "none",
      relative: i,
      reloadDocument: s,
      replace: o,
      state: a,
      target: l,
      to: d,
      preventScrollReset: p,
      viewTransition: f,
      ...m
    },
    y
  ) {
    let { basename: g } = N.useContext(jo),
      v = typeof d == "string" && GL.test(d),
      b,
      E = !1;
    if (typeof d == "string" && v && ((b = d), VL))
      try {
        let k = new URL(window.location.href),
          T = d.startsWith("//") ? new URL(k.protocol + d) : new URL(d),
          U = Ta(T.pathname, g);
        T.origin === k.origin && U != null
          ? (d = U + T.search + T.hash)
          : (E = !0);
      } catch {
        Uo(
          !1,
          `<Link to="${d}"> contains an invalid URL which will probably break when clicked - please update to a valid URL path.`
        );
      }
    let S = awe(d, { relative: i }),
      [C, _, A] = Wwe(r, m),
      I = Qwe(d, {
        replace: o,
        state: a,
        target: l,
        preventScrollReset: p,
        relative: i,
        viewTransition: f,
      });
    function R(k) {
      e && e(k), k.defaultPrevented || I(k);
    }
    let D = N.createElement("a", {
      ...m,
      ...A,
      href: b || S,
      onClick: E || s ? e : R,
      ref: Gwe(y, _),
      target: l,
      "data-discover": !v && n === "render" ? "true" : void 0,
    });
    return C && !v
      ? N.createElement(N.Fragment, null, D, N.createElement(Hwe, { page: S }))
      : D;
  });
ds.displayName = "Link";
var C_ = N.forwardRef(function (
  {
    "aria-current": e = "page",
    caseSensitive: n = !1,
    className: r = "",
    end: i = !1,
    style: s,
    to: o,
    viewTransition: a,
    children: l,
    ...d
  },
  p
) {
  let f = wg(o, { relative: d.relative }),
    m = yu(),
    y = N.useContext(rb),
    { navigator: g, basename: v } = N.useContext(jo),
    b = y != null && nve(f) && a === !0,
    E = g.encodeLocation ? g.encodeLocation(f).pathname : f.pathname,
    S = m.pathname,
    C =
      y && y.navigation && y.navigation.location
        ? y.navigation.location.pathname
        : null;
  n ||
    ((S = S.toLowerCase()),
    (C = C ? C.toLowerCase() : null),
    (E = E.toLowerCase())),
    C && v && (C = Ta(C, v) || C);
  const _ = E !== "/" && E.endsWith("/") ? E.length - 1 : E.length;
  let A = S === E || (!i && S.startsWith(E) && S.charAt(_) === "/"),
    I =
      C != null &&
      (C === E || (!i && C.startsWith(E) && C.charAt(E.length) === "/")),
    R = { isActive: A, isPending: I, isTransitioning: b },
    D = A ? e : void 0,
    k;
  typeof r == "function"
    ? (k = r(R))
    : (k = [
        r,
        A ? "active" : null,
        I ? "pending" : null,
        b ? "transitioning" : null,
      ]
        .filter(Boolean)
        .join(" "));
  let T = typeof s == "function" ? s(R) : s;
  return N.createElement(
    ds,
    {
      ...d,
      "aria-current": D,
      className: k,
      ref: p,
      style: T,
      to: o,
      viewTransition: a,
    },
    typeof l == "function" ? l(R) : l
  );
});
C_.displayName = "NavLink";
var Ywe = N.forwardRef(
  (
    {
      discover: t = "render",
      fetcherKey: e,
      navigate: n,
      reloadDocument: r,
      replace: i,
      state: s,
      method: o = G0,
      action: a,
      onSubmit: l,
      relative: d,
      preventScrollReset: p,
      viewTransition: f,
      ...m
    },
    y
  ) => {
    let g = eve(),
      v = tve(a, { relative: d }),
      b = o.toLowerCase() === "get" ? "get" : "post",
      E = typeof a == "string" && GL.test(a),
      S = (C) => {
        if ((l && l(C), C.defaultPrevented)) return;
        C.preventDefault();
        let _ = C.nativeEvent.submitter,
          A = (_ == null ? void 0 : _.getAttribute("formmethod")) || o;
        g(_ || C.currentTarget, {
          fetcherKey: e,
          method: A,
          navigate: n,
          replace: i,
          state: s,
          relative: d,
          preventScrollReset: p,
          viewTransition: f,
        });
      };
    return N.createElement("form", {
      ref: y,
      method: b,
      action: v,
      onSubmit: r ? l : S,
      ...m,
      "data-discover": !E && t === "render" ? "true" : void 0,
    });
  }
);
Ywe.displayName = "Form";
function Zwe(t) {
  return `${t} must be used within a data router.  See https://reactrouter.com/en/main/routers/picking-a-router.`;
}
function KL(t) {
  let e = N.useContext(Mp);
  return _n(e, Zwe(t)), e;
}
function Qwe(
  t,
  {
    target: e,
    replace: n,
    state: r,
    preventScrollReset: i,
    relative: s,
    viewTransition: o,
  } = {}
) {
  let a = cwe(),
    l = yu(),
    d = wg(t, { relative: s });
  return N.useCallback(
    (p) => {
      if (Pwe(p, e)) {
        p.preventDefault();
        let f = n !== void 0 ? n : km(l) === km(d);
        a(t, {
          replace: f,
          state: r,
          preventScrollReset: i,
          relative: s,
          viewTransition: o,
        });
      }
    },
    [l, a, d, n, r, e, t, i, s, o]
  );
}
var Xwe = 0,
  Jwe = () => `__${String(++Xwe)}__`;
function eve() {
  let { router: t } = KL("useSubmit"),
    { basename: e } = N.useContext(jo),
    n = vwe();
  return N.useCallback(
    async (r, i = {}) => {
      let {
        action: s,
        method: o,
        encType: a,
        formData: l,
        body: d,
      } = Owe(r, e);
      if (i.navigate === !1) {
        let p = i.fetcherKey || Jwe();
        await t.fetch(p, n, i.action || s, {
          preventScrollReset: i.preventScrollReset,
          formData: l,
          body: d,
          formMethod: i.method || o,
          formEncType: i.encType || a,
          flushSync: i.flushSync,
        });
      } else
        await t.navigate(i.action || s, {
          preventScrollReset: i.preventScrollReset,
          formData: l,
          body: d,
          formMethod: i.method || o,
          formEncType: i.encType || a,
          replace: i.replace,
          state: i.state,
          fromRouteId: n,
          flushSync: i.flushSync,
          viewTransition: i.viewTransition,
        });
    },
    [t, e, n]
  );
}
function tve(t, { relative: e } = {}) {
  let { basename: n } = N.useContext(jo),
    r = N.useContext(Oa);
  _n(r, "useFormAction must be used inside a RouteContext");
  let [i] = r.matches.slice(-1),
    s = { ...wg(t || ".", { relative: e }) },
    o = yu();
  if (t == null) {
    s.search = o.search;
    let a = new URLSearchParams(s.search),
      l = a.getAll("index");
    if (l.some((p) => p === "")) {
      a.delete("index"),
        l.filter((f) => f).forEach((f) => a.append("index", f));
      let p = a.toString();
      s.search = p ? `?${p}` : "";
    }
  }
  return (
    (!t || t === ".") &&
      i.route.index &&
      (s.search = s.search ? s.search.replace(/^\?/, "?index&") : "?index"),
    n !== "/" && (s.pathname = s.pathname === "/" ? n : Ea([n, s.pathname])),
    km(s)
  );
}
function nve(t, e = {}) {
  let n = N.useContext(UL);
  _n(
    n != null,
    "`useViewTransitionState` must be used within `react-router-dom`'s `RouterProvider`.  Did you accidentally import `RouterProvider` from `react-router`?"
  );
  let { basename: r } = KL("useViewTransitionState"),
    i = wg(t, { relative: e.relative });
  if (!n.isTransitioning) return !1;
  let s = Ta(n.currentLocation.pathname, r) || n.currentLocation.pathname,
    o = Ta(n.nextLocation.pathname, r) || n.nextLocation.pathname;
  return Ww(i.pathname, o) != null || Ww(i.pathname, s) != null;
}
[...jwe];
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */ var NS =
  function () {
    return (
      (NS =
        Object.assign ||
        function (e) {
          for (var n, r = 1, i = arguments.length; r < i; r++) {
            n = arguments[r];
            for (var s in n)
              Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s]);
          }
          return e;
        }),
      NS.apply(this, arguments)
    );
  };
function rve(t, e) {
  var n = {};
  for (var r in t)
    Object.prototype.hasOwnProperty.call(t, r) &&
      e.indexOf(r) < 0 &&
      (n[r] = t[r]);
  if (t != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, r = Object.getOwnPropertySymbols(t); i < r.length; i++)
      e.indexOf(r[i]) < 0 &&
        Object.prototype.propertyIsEnumerable.call(t, r[i]) &&
        (n[r[i]] = t[r[i]]);
  return n;
}
var Md = "",
  Ph = null,
  Y0 = null,
  YL = null;
function x_() {
  (Md = ""),
    Ph !== null && Ph.disconnect(),
    Y0 !== null && (window.clearTimeout(Y0), (Y0 = null));
}
function l5(t) {
  var e = ["BUTTON", "INPUT", "SELECT", "TEXTAREA"],
    n = ["A", "AREA"];
  return (
    (e.includes(t.tagName) && !t.hasAttribute("disabled")) ||
    (n.includes(t.tagName) && t.hasAttribute("href"))
  );
}
function u5() {
  var t = null;
  if (Md === "#") t = document.body;
  else {
    var e = Md.replace("#", "");
    (t = document.getElementById(e)),
      t === null && Md === "#top" && (t = document.body);
  }
  if (t !== null) {
    YL(t);
    var n = t.getAttribute("tabindex");
    return (
      n === null && !l5(t) && t.setAttribute("tabindex", -1),
      t.focus({ preventScroll: !0 }),
      n === null && !l5(t) && (t.blur(), t.removeAttribute("tabindex")),
      x_(),
      !0
    );
  }
  return !1;
}
function ive(t) {
  window.setTimeout(function () {
    u5() === !1 &&
      (Ph === null && (Ph = new MutationObserver(u5)),
      Ph.observe(document, { attributes: !0, childList: !0, subtree: !0 }),
      (Y0 = window.setTimeout(function () {
        x_();
      }, t || 1e4)));
  }, 0);
}
function ZL(t) {
  return gt.forwardRef(function (e, n) {
    var r = "";
    typeof e.to == "string" && e.to.includes("#")
      ? (r = "#" + e.to.split("#").slice(1).join("#"))
      : typeof e.to == "object" &&
        typeof e.to.hash == "string" &&
        (r = e.to.hash);
    var i = {};
    t === C_ &&
      (i.isActive = function (a, l) {
        return a && a.isExact && l.hash === r;
      });
    function s(a) {
      x_(),
        (Md = e.elementId ? "#" + e.elementId : r),
        e.onClick && e.onClick(a),
        Md !== "" &&
          !a.defaultPrevented &&
          a.button === 0 &&
          (!e.target || e.target === "_self") &&
          !(a.metaKey || a.altKey || a.ctrlKey || a.shiftKey) &&
          ((YL =
            e.scroll ||
            function (l) {
              return e.smooth
                ? l.scrollIntoView({ behavior: "smooth" })
                : l.scrollIntoView();
            }),
          ive(e.timeout));
    }
    var o = rve(e, ["scroll", "smooth", "timeout", "elementId"]);
    return gt.createElement(
      t,
      NS({}, i, o, { onClick: s, ref: n }),
      e.children
    );
  });
}
var d5 = ZL(ds);
ZL(C_);
const gd = [
  { text: "About Us", link: "/#about" },
  { text: "Roadmap", link: "/#roadmap" },
  { text: "Tokenomics", link: "/#tokenomics" },
  { text: "Contact Us", link: "https://t.me/LittlePepeErc20" },
];
function sve() {
  const [t, e] = N.useState(!1),
    n = xs("(max-width:1279px)"),
    r = (s) => (o) => {
      (o.type === "keydown" && (o.key === "Tab" || o.key === "Shift")) || e(s);
    },
    i = () =>
      O.jsx(be, {
        sx: { width: 250, pt: 3 },
        role: "presentation",
        onClick: r(!1),
        onKeyDown: r(!1),
        children: O.jsxs(U3, {
          children: [
            gd == null
              ? void 0
              : gd.map(({ text: s, link: o }, a) =>
                  O.jsx(
                    MH,
                    {
                      children: O.jsx(
                        d5,
                        {
                          smooth: !0,
                          to: o,
                          style: { textDecoration: "none" },
                          children: O.jsx(be, {
                            sx: {
                              width: "fit-content",
                              display: "flex",
                              alignItems: "center",
                              justifyContent: "center",
                              fontSize: "22px",
                              fontWeight: 700,
                              fontFamily: "Sour Gummy",
                              color: "#000",
                              px: 2,
                              height: "44px",
                              borderRadius: "10px",
                              background:
                                a === 0
                                  ? "#f4eb82"
                                  : a === 1
                                  ? "#c499e1"
                                  : a === 2
                                  ? "#f69e96"
                                  : a === 3
                                  ? "#abe7c0"
                                  : "#fff",
                              border: "2px solid #000",
                              boxShadow: "1px 3px 0 #000",
                              cursor: "pointer",
                              "&:hover": { color: "#006c28" },
                            },
                            children: s,
                          }),
                        },
                        s
                      ),
                    },
                    s
                  )
                ),
            O.jsx(be, {
              ml: 2,
              mt: 2,
              children: O.jsx(n5, { width: "200px" }),
            }),
          ],
        }),
      });
  return O.jsx(O.Fragment, {
    children: O.jsx(be, {
      sx: { background: "transparent" },
      width: "100%",
      py: 1,
      children: O.jsx(Kc, {
        maxWidth: "xl",
        children: O.jsxs(be, {
          display: "flex",
          justifyContent: "space-between",
          alignItems: "center",
          px: n ? 0 : 4,
          children: [
            O.jsx(be, {
              component: "img",
              width: n ? "270px" : "320px",
              src: hv,
              alt: "",
            }),
            O.jsxs(be, {
              display: "flex",
              justifyContent: n ? "end" : "space-between",
              alignItems: "center",
              children: [
                O.jsx(oE, {
                  mdDown: !0,
                  children:
                    gd == null
                      ? void 0
                      : gd.map(({ text: s, link: o }, a) =>
                          O.jsx(
                            d5,
                            {
                              smooth: !0,
                              to: o,
                              target: a === 4 ? "_blank" : "",
                              style: { textDecoration: "none" },
                              children: O.jsx(be, {
                                mr: a === 4 ? 0 : 2,
                                sx: {
                                  width: "fit-content",
                                  display: "flex",
                                  alignItems: "center",
                                  justifyContent: "center",
                                  fontSize: "22px",
                                  fontWeight: 700,
                                  fontFamily: "Sour Gummy",
                                  color: "#000",
                                  px: 2,
                                  height: "44px",
                                  borderRadius: "8px",
                                  background:
                                    a === 0
                                      ? "#f4eb82"
                                      : a === 1
                                      ? "#c499e1"
                                      : a === 2
                                      ? "#f69e96"
                                      : a === 3
                                      ? "#abe7c0"
                                      : "#ff7134",
                                  border: "1px solid #000",
                                  boxShadow: "1px 3px 0 #000",
                                  cursor: "pointer",
                                  "&:hover": { color: "#006c28" },
                                },
                                children: s,
                              }),
                            },
                            s
                          )
                        ),
                }),
                O.jsxs(oE, {
                  mdUp: !0,
                  children: [
                    O.jsx(XS, {
                      onClick: r(!0),
                      children: O.jsx(Yq, {
                        style: {
                          fontSize: "38px",
                          cursor: "pointer",
                          color: "#000000",
                        },
                      }),
                    }),
                    O.jsx(ZW, {
                      anchor: "left",
                      open: t,
                      onClose: r(!1),
                      sx: {
                        display: { xs: "flex", md: "none" },
                        ".MuiDrawer-paper": { backgroundColor: "#fff" },
                      },
                      children: i(),
                    }),
                  ],
                }),
              ],
            }),
            // O.jsx(oE, { mdDown: !0, children: O.jsx(n5, { width: "200px" }) }),
          ],
        }),
      }),
    }),
  });
}
const ove = gt.forwardRef(function (e, n) {
    return O.jsx(D3, { direction: "up", ref: n, ...e });
  }),
  ave = {
    "& .MuiDialog-root": { zIndex: "1301 !important" },
    "&.MuiDialog-container": { overflowY: "hidden !important" },
    "& .MuiDialog-paperScrollPaper": {
      backgroundColor: "black",
      height: "auto",
      boxShadow: "black 0px 0px 8px 1px",
      borderRadius: "10px",
    },
    "& .dialoge__content__section": {
      background: "black!important",
      borderRadius: "10px",
      border: "1px solid transparent",
    },
    "& .MuiDialogContent-root": { paddingTop: "20px", paddingBottom: "20px" },
  };
function cve({ open: t, setOpen: e }) {
  const { switchChain: n } = N0e(),
    r = () => {
      e(!1);
    };
  return O.jsx(MW, {
    sx: ave,
    open: t,
    keepMounted: !0,
    TransitionComponent: ove,
    onClose: r,
    "aria-describedby": "alert-dialog-slide-description",
    children: O.jsx(FW, {
      className: "dialoge__content__section",
      children: O.jsxs(be, {
        borderRadius: "100px",
        display: "flex",
        alignItems: "center",
        flexDirection: "column",
        children: [
          O.jsx(be, {
            display: "flex",
            flexDirection: "column",
            alignItems: "center",
            width: { xs: "35%", sm: "25%" },
            children: O.jsx(be, {
              component: "img",
              width: "100%",
              src: Zq,
              alt: "",
            }),
          }),
          O.jsx(Ft, {
            mt: 2,
            sx: {
              fontSize: { xs: "20px", sm: "26px" },
              fontWeight: "400",
              textAlign: "center",
              color: "#fff",
            },
            children: "Switch to BSC Mainnet Network",
          }),
          O.jsx(Ft, {
            mt: 2,
            sx: {
              fontSize: "16px",
              fontWeight: "400",
              textAlign: "center",
              color: "#ffffff",
            },
            children:
              "You are currently connected to the wrong network. Kindly switch to the appropriate network.",
          }),
          O.jsx(be, {
            mt: 2,
            children: O.jsx(hL, {
              width: "230px",
              onClick: () => {
                n({ chainId: g_ }), e(!1);
              },
              children: "Switch Network",
            }),
          }),
        ],
      }),
    }),
  });
}
const QL = Ki(
    O.jsx("path", {
      d: "M18.244 2.25h3.308l-7.227 8.26 8.502 11.24H16.17l-5.214-6.817L4.99 21.75H1.68l7.73-8.835L1.254 2.25H8.08l4.713 6.231zm-1.161 17.52h1.833L7.084 4.126H5.117z",
    }),
    "X"
  ),
  XL = Ki(
    O.jsx("path", {
      d: "M9.78 18.65l.28-4.23 7.68-6.92c.34-.31-.07-.46-.52-.19L7.74 13.3 3.64 12c-.88-.25-.89-.86.2-1.3l15.97-6.16c.73-.33 1.43.18 1.15 1.3l-2.72 12.81c-.19.91-.74 1.13-1.5.71L12.6 16.3l-1.99 1.93c-.23.23-.42.42-.83.42z",
    }),
    "Telegram"
  ),
  lve = Ki(
    O.jsx("path", {
      d: "M20 4H4c-1.11 0-1.99.89-1.99 2L2 18c0 1.11.89 2 2 2h16c1.11 0 2-.89 2-2V6c0-1.11-.89-2-2-2m0 14H4v-6h16zm0-10H4V6h16z",
    }),
    "CreditCard"
  ),
  p5 = "/assets/eth-CtbDjbsE.png",
  f5 = "/assets/usdt-C3jY3_0p.png",
  JL = JSON.parse(
    '[{"inputs":[{"internalType":"address","name":"_oracle","type":"address"},{"internalType":"address","name":"_usdt","type":"address"},{"internalType":"address","name":"_usdc","type":"address"},{"internalType":"address","name":"_SaleToken","type":"address"},{"internalType":"uint256","name":"_MinTokenTobuy","type":"uint256"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"previousOwner","type":"address"},{"indexed":true,"internalType":"address","name":"newOwner","type":"address"}],"name":"OwnershipTransferred","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"uint256","name":"_id","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"_totalTokens","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"_startTime","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"_endTime","type":"uint256"}],"name":"PresaleCreated","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"uint256","name":"id","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"timestamp","type":"uint256"}],"name":"PresalePaused","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"prevValue","type":"address"},{"indexed":true,"internalType":"address","name":"newValue","type":"address"},{"indexed":false,"internalType":"uint256","name":"timestamp","type":"uint256"}],"name":"PresaleTokenAddressUpdated","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"uint256","name":"id","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"timestamp","type":"uint256"}],"name":"PresaleUnpaused","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"key","type":"bytes32"},{"indexed":false,"internalType":"uint256","name":"prevValue","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"newValue","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"timestamp","type":"uint256"}],"name":"PresaleUpdated","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"user","type":"address"},{"indexed":true,"internalType":"uint256","name":"id","type":"uint256"},{"indexed":true,"internalType":"address","name":"purchaseToken","type":"address"},{"indexed":false,"internalType":"uint256","name":"tokensBought","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"amountPaid","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"timestamp","type":"uint256"}],"name":"TokensBought","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"user","type":"address"},{"indexed":true,"internalType":"uint256","name":"id","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"amount","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"timestamp","type":"uint256"}],"name":"TokensClaimed","type":"event"},{"inputs":[{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"ChangeMinTokenToBuy","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"_oracle","type":"address"}],"name":"ChangeOracleAddress","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"_token","type":"address"}],"name":"ChangeTokenToSell","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"ETH_MULTIPLIER","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"_user","type":"address"},{"internalType":"bool","name":"_status","type":"bool"}],"name":"ExcludeAccouctFromMinBuy","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"MinTokenTobuy","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"SaleToken","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"USDCInterface","outputs":[{"internalType":"contract IERC20Metadata","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"USDTInterface","outputs":[{"internalType":"contract IERC20Metadata","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"USDT_MULTIPLIER","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"WithdrawContractFunds","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"_token","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"WithdrawTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"_user","type":"address"},{"internalType":"bool","name":"_value","type":"bool"}],"name":"blackListUser","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"blockTimeStamp","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"buyWithEth","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"uint256","name":"usdcAmount","type":"uint256"}],"name":"buyWithUSDC","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"usdAmount","type":"uint256"}],"name":"buyWithUSDT","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"_oldAddress","type":"address"},{"internalType":"address","name":"_newWallet","type":"address"}],"name":"changeClaimAddress","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"_wallet","type":"address"}],"name":"changeFundWallet","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"_newAddress","type":"address"}],"name":"changeUSDCToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"_newAddress","type":"address"}],"name":"changeUSDTToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"_id","type":"uint256"}],"name":"claimAmount","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"claimMultiple","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"user","type":"address"},{"internalType":"uint256","name":"_id","type":"uint256"}],"name":"claimableAmount","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"_price","type":"uint256"},{"internalType":"uint256","name":"_nextStagePrice","type":"uint256"},{"internalType":"uint256","name":"_tokensToSell","type":"uint256"},{"internalType":"uint256","name":"_UsdtHardcap","type":"uint256"}],"name":"createPresale","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"currentSale","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"_id","type":"uint256"},{"internalType":"bool","name":"_status","type":"bool"}],"name":"enableClaim","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"_id","type":"uint256"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"ethBuyHelper","outputs":[{"internalType":"uint256","name":"ethAmount","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"_id","type":"uint256"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"ethToTokens","outputs":[{"internalType":"uint256","name":"_tokens","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"fundReceiver","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getLatestPrice","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"","type":"address"}],"name":"isBlackList","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"","type":"address"}],"name":"isExcludeMinToken","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"","type":"address"}],"name":"isExist","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"overalllRaised","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"owner","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"_id","type":"uint256"}],"name":"pausePresale","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"","type":"uint256"}],"name":"paused","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"","type":"uint256"}],"name":"presale","outputs":[{"internalType":"uint256","name":"startTime","type":"uint256"},{"internalType":"uint256","name":"endTime","type":"uint256"},{"internalType":"uint256","name":"price","type":"uint256"},{"internalType":"uint256","name":"nextStagePrice","type":"uint256"},{"internalType":"uint256","name":"Sold","type":"uint256"},{"internalType":"uint256","name":"tokensToSell","type":"uint256"},{"internalType":"uint256","name":"UsdtHardcap","type":"uint256"},{"internalType":"uint256","name":"amountRaised","type":"uint256"},{"internalType":"bool","name":"Active","type":"bool"},{"internalType":"bool","name":"isEnableClaim","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"presaleId","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"renounceOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"_id","type":"uint256"}],"name":"setPresaleStage","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256[]","name":"_id","type":"uint256[]"},{"internalType":"uint256[]","name":"vestingStartTime","type":"uint256[]"},{"internalType":"uint256[]","name":"_initialClaimPercent","type":"uint256[]"},{"internalType":"uint256[]","name":"_vestingTime","type":"uint256[]"},{"internalType":"uint256[]","name":"_vestingPercentage","type":"uint256[]"}],"name":"setPresaleVesting","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"newOwner","type":"address"}],"name":"transferOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"_id","type":"uint256"}],"name":"unPausePresale","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"uniqueBuyers","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"_id","type":"uint256"},{"internalType":"uint256","name":"_price","type":"uint256"},{"internalType":"uint256","name":"_nextStagePrice","type":"uint256"},{"internalType":"uint256","name":"_tokensToSell","type":"uint256"},{"internalType":"uint256","name":"_Hardcap","type":"uint256"},{"internalType":"bool","name":"isclaimAble","type":"bool"}],"name":"updatePresale","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"_id","type":"uint256"},{"internalType":"uint256","name":"_vestingStartTime","type":"uint256"},{"internalType":"uint256","name":"_initialClaimPercent","type":"uint256"},{"internalType":"uint256","name":"_vestingTime","type":"uint256"},{"internalType":"uint256","name":"_vestingPercentage","type":"uint256"}],"name":"updatePresaleVesting","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"_id","type":"uint256"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"usdtBuyHelper","outputs":[{"internalType":"uint256","name":"usdPrice","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"_id","type":"uint256"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"usdtToTokens","outputs":[{"internalType":"uint256","name":"_tokens","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"","type":"address"},{"internalType":"uint256","name":"","type":"uint256"}],"name":"userClaimData","outputs":[{"internalType":"uint256","name":"investedAmount","type":"uint256"},{"internalType":"uint256","name":"claimAt","type":"uint256"},{"internalType":"uint256","name":"claimAbleAmount","type":"uint256"},{"internalType":"uint256","name":"claimedVestingAmount","type":"uint256"},{"internalType":"uint256","name":"claimedAmount","type":"uint256"},{"internalType":"uint256","name":"claimCount","type":"uint256"},{"internalType":"uint256","name":"activePercentAmount","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"","type":"uint256"}],"name":"vesting","outputs":[{"internalType":"uint256","name":"vestingStartTime","type":"uint256"},{"internalType":"uint256","name":"initialClaimPercent","type":"uint256"},{"internalType":"uint256","name":"vestingTime","type":"uint256"},{"internalType":"uint256","name":"vestingPercentage","type":"uint256"},{"internalType":"uint256","name":"totalClaimCycles","type":"uint256"}],"stateMutability":"view","type":"function"}]'
  ),
  e8 = [
    {
      constant: !0,
      inputs: [],
      name: "name",
      outputs: [{ name: "", type: "string" }],
      payable: !1,
      stateMutability: "view",
      type: "function",
    },
    {
      constant: !1,
      inputs: [{ name: "_upgradedAddress", type: "address" }],
      name: "deprecate",
      outputs: [],
      payable: !1,
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      constant: !1,
      inputs: [
        { name: "_spender", type: "address" },
        { name: "_value", type: "uint256" },
      ],
      name: "approve",
      outputs: [],
      payable: !1,
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      constant: !0,
      inputs: [],
      name: "deprecated",
      outputs: [{ name: "", type: "bool" }],
      payable: !1,
      stateMutability: "view",
      type: "function",
    },
    {
      constant: !1,
      inputs: [{ name: "_evilUser", type: "address" }],
      name: "addBlackList",
      outputs: [],
      payable: !1,
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      constant: !0,
      inputs: [],
      name: "totalSupply",
      outputs: [{ name: "", type: "uint256" }],
      payable: !1,
      stateMutability: "view",
      type: "function",
    },
    {
      constant: !1,
      inputs: [
        { name: "_from", type: "address" },
        { name: "_to", type: "address" },
        { name: "_value", type: "uint256" },
      ],
      name: "transferFrom",
      outputs: [],
      payable: !1,
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      constant: !0,
      inputs: [],
      name: "upgradedAddress",
      outputs: [{ name: "", type: "address" }],
      payable: !1,
      stateMutability: "view",
      type: "function",
    },
    {
      constant: !0,
      inputs: [{ name: "", type: "address" }],
      name: "balances",
      outputs: [{ name: "", type: "uint256" }],
      payable: !1,
      stateMutability: "view",
      type: "function",
    },
    {
      constant: !0,
      inputs: [],
      name: "decimals",
      outputs: [{ name: "", type: "uint256" }],
      payable: !1,
      stateMutability: "view",
      type: "function",
    },
    {
      constant: !0,
      inputs: [],
      name: "maximumFee",
      outputs: [{ name: "", type: "uint256" }],
      payable: !1,
      stateMutability: "view",
      type: "function",
    },
    {
      constant: !0,
      inputs: [],
      name: "_totalSupply",
      outputs: [{ name: "", type: "uint256" }],
      payable: !1,
      stateMutability: "view",
      type: "function",
    },
    {
      constant: !1,
      inputs: [],
      name: "unpause",
      outputs: [],
      payable: !1,
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      constant: !0,
      inputs: [{ name: "_maker", type: "address" }],
      name: "getBlackListStatus",
      outputs: [{ name: "", type: "bool" }],
      payable: !1,
      stateMutability: "view",
      type: "function",
    },
    {
      constant: !0,
      inputs: [
        { name: "", type: "address" },
        { name: "", type: "address" },
      ],
      name: "allowed",
      outputs: [{ name: "", type: "uint256" }],
      payable: !1,
      stateMutability: "view",
      type: "function",
    },
    {
      constant: !0,
      inputs: [],
      name: "paused",
      outputs: [{ name: "", type: "bool" }],
      payable: !1,
      stateMutability: "view",
      type: "function",
    },
    {
      constant: !0,
      inputs: [{ name: "who", type: "address" }],
      name: "balanceOf",
      outputs: [{ name: "", type: "uint256" }],
      payable: !1,
      stateMutability: "view",
      type: "function",
    },
    {
      constant: !1,
      inputs: [],
      name: "pause",
      outputs: [],
      payable: !1,
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      constant: !0,
      inputs: [],
      name: "getOwner",
      outputs: [{ name: "", type: "address" }],
      payable: !1,
      stateMutability: "view",
      type: "function",
    },
    {
      constant: !0,
      inputs: [],
      name: "owner",
      outputs: [{ name: "", type: "address" }],
      payable: !1,
      stateMutability: "view",
      type: "function",
    },
    {
      constant: !0,
      inputs: [],
      name: "symbol",
      outputs: [{ name: "", type: "string" }],
      payable: !1,
      stateMutability: "view",
      type: "function",
    },
    {
      constant: !1,
      inputs: [
        { name: "_to", type: "address" },
        { name: "_value", type: "uint256" },
      ],
      name: "transfer",
      outputs: [],
      payable: !1,
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      constant: !1,
      inputs: [
        { name: "newBasisPoints", type: "uint256" },
        { name: "newMaxFee", type: "uint256" },
      ],
      name: "setParams",
      outputs: [],
      payable: !1,
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      constant: !1,
      inputs: [{ name: "amount", type: "uint256" }],
      name: "issue",
      outputs: [],
      payable: !1,
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      constant: !1,
      inputs: [{ name: "amount", type: "uint256" }],
      name: "redeem",
      outputs: [],
      payable: !1,
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      constant: !0,
      inputs: [
        { name: "_owner", type: "address" },
        { name: "_spender", type: "address" },
      ],
      name: "allowance",
      outputs: [{ name: "remaining", type: "uint256" }],
      payable: !1,
      stateMutability: "view",
      type: "function",
    },
    {
      constant: !0,
      inputs: [],
      name: "basisPointsRate",
      outputs: [{ name: "", type: "uint256" }],
      payable: !1,
      stateMutability: "view",
      type: "function",
    },
    {
      constant: !0,
      inputs: [{ name: "", type: "address" }],
      name: "isBlackListed",
      outputs: [{ name: "", type: "bool" }],
      payable: !1,
      stateMutability: "view",
      type: "function",
    },
    {
      constant: !1,
      inputs: [{ name: "_clearedUser", type: "address" }],
      name: "removeBlackList",
      outputs: [],
      payable: !1,
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      constant: !0,
      inputs: [],
      name: "MAX_UINT",
      outputs: [{ name: "", type: "uint256" }],
      payable: !1,
      stateMutability: "view",
      type: "function",
    },
    {
      constant: !1,
      inputs: [{ name: "newOwner", type: "address" }],
      name: "transferOwnership",
      outputs: [],
      payable: !1,
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      constant: !1,
      inputs: [{ name: "_blackListedUser", type: "address" }],
      name: "destroyBlackFunds",
      outputs: [],
      payable: !1,
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        { name: "_initialSupply", type: "uint256" },
        { name: "_name", type: "string" },
        { name: "_symbol", type: "string" },
        { name: "_decimals", type: "uint256" },
      ],
      payable: !1,
      stateMutability: "nonpayable",
      type: "constructor",
    },
    {
      anonymous: !1,
      inputs: [{ indexed: !1, name: "amount", type: "uint256" }],
      name: "Issue",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [{ indexed: !1, name: "amount", type: "uint256" }],
      name: "Redeem",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [{ indexed: !1, name: "newAddress", type: "address" }],
      name: "Deprecate",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        { indexed: !1, name: "feeBasisPoints", type: "uint256" },
        { indexed: !1, name: "maxFee", type: "uint256" },
      ],
      name: "Params",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        { indexed: !1, name: "_blackListedUser", type: "address" },
        { indexed: !1, name: "_balance", type: "uint256" },
      ],
      name: "DestroyedBlackFunds",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [{ indexed: !1, name: "_user", type: "address" }],
      name: "AddedBlackList",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [{ indexed: !1, name: "_user", type: "address" }],
      name: "RemovedBlackList",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        { indexed: !0, name: "owner", type: "address" },
        { indexed: !0, name: "spender", type: "address" },
        { indexed: !1, name: "value", type: "uint256" },
      ],
      name: "Approval",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        { indexed: !0, name: "from", type: "address" },
        { indexed: !0, name: "to", type: "address" },
        { indexed: !1, name: "value", type: "uint256" },
      ],
      name: "Transfer",
      type: "event",
    },
    { anonymous: !1, inputs: [], name: "Pause", type: "event" },
    { anonymous: !1, inputs: [], name: "Unpause", type: "event" },
  ],
  t8 = [
    {
      constant: !1,
      inputs: [{ name: "newImplementation", type: "address" }],
      name: "upgradeTo",
      outputs: [],
      payable: !1,
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      constant: !1,
      inputs: [
        { name: "newImplementation", type: "address" },
        { name: "data", type: "bytes" },
      ],
      name: "upgradeToAndCall",
      outputs: [],
      payable: !0,
      stateMutability: "payable",
      type: "function",
    },
    {
      constant: !0,
      inputs: [],
      name: "implementation",
      outputs: [{ name: "", type: "address" }],
      payable: !1,
      stateMutability: "view",
      type: "function",
    },
    {
      constant: !1,
      inputs: [{ name: "newAdmin", type: "address" }],
      name: "changeAdmin",
      outputs: [],
      payable: !1,
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      constant: !0,
      inputs: [],
      name: "admin",
      outputs: [{ name: "", type: "address" }],
      payable: !1,
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [{ name: "_implementation", type: "address" }],
      payable: !1,
      stateMutability: "nonpayable",
      type: "constructor",
    },
    { payable: !0, stateMutability: "payable", type: "fallback" },
    {
      anonymous: !1,
      inputs: [
        { indexed: !1, name: "previousAdmin", type: "address" },
        { indexed: !1, name: "newAdmin", type: "address" },
      ],
      name: "AdminChanged",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [{ indexed: !1, name: "implementation", type: "address" }],
      name: "Upgraded",
      type: "event",
    },
  ],
  BC = "0x79937da178932489Ee32290baa5622690De709CA",
  Id = "0x5584197Ce066aAbc11919aCe52B6DF5948b1e930",
  n8 = "0xdAC17F958D2ee523a2206206994597C13D831ec7",
  r8 = "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48";
function uve(t) {
  let e = [],
    n,
    r;
  function i(a) {
    return jh.parseEvmChainId(a) || 1;
  }
  function s() {
    return (
      n ||
        (n = Wl.getInstance({
          projectId: t.options.projectId,
          enableLogger: t.options.enableAuthLogger,
          onTimeout: (a) => {
            a === "iframe_load_failed"
              ? ti.open(pr.ALERT_ERRORS.IFRAME_LOAD_FAILED, "error")
              : a === "iframe_request_timeout"
              ? ti.open(pr.ALERT_ERRORS.IFRAME_REQUEST_TIMEOUT, "error")
              : a === "unverified_domain" &&
                ti.open(pr.ALERT_ERRORS.UNVERIFIED_DOMAIN, "error");
          },
          abortController: pr.EmbeddedWalletAbortController,
        })),
      n
    );
  }
  async function o(a = {}) {
    var v, b;
    const l = s();
    let d = a.chainId;
    if (a.isReconnecting) {
      const E = jh.parseEvmChainId(l.getLastUsedChainId() || ""),
        S = (v = t.chains) == null ? void 0 : v[0].id;
      if (((d = E || S), !d)) throw new Error("ChainId not found in provider");
    }
    const p = (b = Be.state.preferredAccountTypes) == null ? void 0 : b.eip155,
      {
        address: f,
        chainId: m,
        accounts: y,
      } = await l.connect({ chainId: d, preferredAccountType: p });
    e = (y == null ? void 0 : y.map((E) => E.address)) || [f];
    const g = i(m);
    return {
      accounts: e,
      account: f,
      chainId: g,
      chain: { id: g, unsuported: !1 },
    };
  }
  return (a) => ({
    id: ye.CONNECTOR_ID.AUTH,
    name: ye.CONNECTOR_NAMES.AUTH,
    type: "AUTH",
    chain: ye.CHAIN.EVM,
    async connect(l = {}) {
      if (r) return r;
      r ||
        (r = new Promise((p) => {
          p(o(l));
        }));
      const d = await r;
      return (r = void 0), d;
    },
    async disconnect() {
      await (await this.getProvider()).disconnect();
    },
    getAccounts() {
      return e != null && e.length
        ? (a.emitter.emit("change", { accounts: e }), Promise.resolve(e))
        : Promise.resolve([]);
    },
    async getProvider() {
      return (
        this.provider ||
          (this.provider = Wl.getInstance({
            projectId: t.options.projectId,
            enableLogger: t.options.enableAuthLogger,
            abortController: pr.EmbeddedWalletAbortController,
            onTimeout: (l) => {
              l === "iframe_load_failed"
                ? ti.open(pr.ALERT_ERRORS.IFRAME_LOAD_FAILED, "error")
                : l === "iframe_request_timeout"
                ? ti.open(pr.ALERT_ERRORS.IFRAME_REQUEST_TIMEOUT, "error")
                : l === "unverified_domain" &&
                  ti.open(pr.ALERT_ERRORS.UNVERIFIED_DOMAIN, "error");
            },
          })),
        Promise.resolve(this.provider)
      );
    },
    async getChainId() {
      const l = await this.getProvider(),
        { chainId: d } = await l.getChainId();
      return i(d);
    },
    async isAuthorized() {
      const l = await this.getProvider();
      return Promise.resolve(l.getLoginEmailUsed());
    },
    async switchChain({ chainId: l }) {
      var d, p;
      try {
        const f = a.chains.find((v) => v.id === l);
        if (!f) throw new $o(new Error("chain not found on connector."));
        const m = await this.getProvider(),
          y = (d = Be.state.preferredAccountTypes) == null ? void 0 : d.eip155,
          g = await m.connect({ chainId: l, preferredAccountType: y });
        return (
          (e = ((p = g == null ? void 0 : g.accounts) == null
            ? void 0
            : p.map((v) => v.address)) || [g.address]),
          a.emitter.emit("change", { chainId: Number(l), accounts: e }),
          f
        );
      } catch (f) {
        throw f instanceof Error ? new $o(f) : f;
      }
    },
    onAccountsChanged(l) {
      l.length === 0
        ? this.onDisconnect()
        : a.emitter.emit("change", { accounts: l.map(Nl) });
    },
    onChainChanged(l) {
      const d = Number(l);
      a.emitter.emit("change", { chainId: d });
    },
    async onDisconnect(l) {
      await (await this.getProvider()).disconnect();
    },
  });
}
S_.type = "walletConnect";
function S_(t, e) {
  const n = t.isNewChainsStale ?? !0;
  let r, i, s, o, a, l, d;
  return (p) => ({
    id: "walletConnect",
    name: "WalletConnect",
    type: S_.type,
    async setup() {
      const f = await this.getProvider().catch(() => null);
      f &&
        (o || ((o = this.onConnect.bind(this)), f.on("connect", o)),
        l ||
          ((l = this.onSessionDelete.bind(this)), f.on("session_delete", l)));
    },
    async connect({ ...f } = {}) {
      var m, y, g;
      try {
        const v = Y.getCaipNetworks(),
          b = await this.getProvider();
        if (!b) throw new hc();
        a || ((a = this.onDisplayUri), b.on("display_uri", a));
        const E = await this.isChainsStale();
        b.session && E && (await b.disconnect());
        const S = me.state.universalProviderConfigOverride;
        if (!b.session || E) {
          const k = Ih.createNamespaces(v, S);
          await b.connect({
            optionalNamespaces: k,
            ...("pairingTopic" in f ? { pairingTopic: f.pairingTopic } : {}),
          }),
            this.setRequestedChainsIds(v.map((T) => Number(T.id)));
        }
        const C = await this.getAccounts(),
          _ = await this.getChainId(),
          A =
            (g =
              (y = (m = b.session) == null ? void 0 : m.namespaces) == null
                ? void 0
                : y.eip155) == null
              ? void 0
              : g.chains,
          I = A == null ? void 0 : A.some((k) => Number(k.split(":")[1]) === _);
        let R = 1;
        I ? (R = _) : A != null && A[0] && (R = Number(A[0].split(":")[1])),
          a && (b.removeListener("display_uri", a), (a = void 0)),
          o && (b.removeListener("connect", o), (o = void 0)),
          i ||
            ((i = this.onAccountsChanged.bind(this)),
            b.on("accountsChanged", i)),
          s || ((s = this.onChainChanged.bind(this)), b.on("chainChanged", s)),
          d || ((d = this.onDisconnect.bind(this)), b.on("disconnect", d)),
          l ||
            ((l = this.onSessionDelete.bind(this)), b.on("session_delete", l));
        const D = S == null ? void 0 : S.defaultChain;
        return (
          b.setDefaultChain(D ?? `eip155:${R}`), { accounts: C, chainId: R }
        );
      } catch (v) {
        throw /(user rejected|connection request reset)/i.test(
          v == null ? void 0 : v.message
        )
          ? new Qn(v)
          : v;
      }
    },
    async disconnect() {
      const f = await this.getProvider();
      try {
        await (f == null ? void 0 : f.disconnect());
      } catch (m) {
        if (!/No matching key/i.test(m.message)) throw m;
      } finally {
        s && (f == null || f.removeListener("chainChanged", s), (s = void 0)),
          d && (f == null || f.removeListener("disconnect", d), (d = void 0)),
          o ||
            ((o = this.onConnect.bind(this)), f == null || f.on("connect", o)),
          i &&
            (f == null || f.removeListener("accountsChanged", i), (i = void 0)),
          l &&
            (f == null || f.removeListener("session_delete", l), (l = void 0)),
          this.setRequestedChainsIds([]);
      }
    },
    async getAccounts() {
      var g, v, b;
      const f = await this.getProvider();
      if (!((g = f == null ? void 0 : f.session) != null && g.namespaces))
        return [];
      const m =
        (b =
          (v = f == null ? void 0 : f.session) == null
            ? void 0
            : v.namespaces[ye.CHAIN.EVM]) == null
          ? void 0
          : b.accounts;
      return (m == null ? void 0 : m.map((E) => E.split(":")[2])) ?? [];
    },
    async getProvider({ chainId: f } = {}) {
      var g, v;
      r ||
        ((r = await e.getUniversalProvider()),
        r == null || r.events.setMaxListeners(Number.POSITIVE_INFINITY));
      const m = Ie.getActiveNamespace(),
        y = (g = e.getCaipNetwork()) == null ? void 0 : g.id;
      if (f && y !== f && m) {
        const b = Ie.getStoredActiveCaipNetworkId(),
          E = e.getCaipNetworks(m),
          S = E == null ? void 0 : E.find((C) => C.id === b);
        S &&
          S.chainNamespace === ye.CHAIN.EVM &&
          (await ((v = this.switchChain) == null
            ? void 0
            : v.call(this, { chainId: Number(S.id) })));
      }
      return r;
    },
    async getChainId() {
      var v, b, E, S;
      const f = (v = e.getCaipNetwork(ye.CHAIN.EVM)) == null ? void 0 : v.id;
      if (f) return f;
      const y =
          (S =
            (E =
              (b = (await this.getProvider()).session) == null
                ? void 0
                : b.namespaces[ye.CHAIN.EVM]) == null
              ? void 0
              : E.chains) == null
            ? void 0
            : S[0],
        g = Y.getCaipNetworks().find((C) => C.id === y);
      return g == null ? void 0 : g.id;
    },
    async isAuthorized() {
      try {
        const [f, m] = await Promise.all([
          this.getAccounts(),
          this.getProvider(),
        ]);
        return f.length
          ? (await this.isChainsStale()) && m.session
            ? (await m.disconnect().catch(() => {}), !1)
            : !0
          : !1;
      } catch {
        return !1;
      }
    },
    async switchChain({ addEthereumChainParameter: f, chainId: m }) {
      var v, b, E, S;
      const y = await this.getProvider();
      if (!y) throw new hc();
      const g = Y.getCaipNetworks().find((C) => C.id === m);
      if (!g) throw new $o(new Rm());
      try {
        await y.request({
          method: "wallet_switchEthereumChain",
          params: [{ chainId: Et(m) }],
        }),
          g != null &&
            g.caipNetworkId &&
            y.setDefaultChain(g == null ? void 0 : g.caipNetworkId),
          p.emitter.emit("change", { chainId: Number(m) });
        const C = await this.getRequestedChainsIds();
        return this.setRequestedChainsIds([...C, m]), { ...g, id: g.id };
      } catch (C) {
        const _ = C;
        if (/(?:user rejected)/iu.test(_.message)) throw new Qn(_);
        try {
          let A;
          f != null && f.blockExplorerUrls
            ? (A = f.blockExplorerUrls)
            : (A =
                (v = g.blockExplorers) != null && v.default.url
                  ? [(b = g.blockExplorers) == null ? void 0 : b.default.url]
                  : []);
          const I =
              ((S = (E = g.rpcUrls) == null ? void 0 : E.chainDefault) == null
                ? void 0
                : S.http) || [],
            R = {
              blockExplorerUrls: A,
              chainId: Et(m),
              chainName: g.name,
              iconUrls: f == null ? void 0 : f.iconUrls,
              nativeCurrency: g.nativeCurrency,
              rpcUrls: I,
            };
          await y.request({ method: "wallet_addEthereumChain", params: [R] });
          const D = await this.getRequestedChainsIds();
          return this.setRequestedChainsIds([...D, m]), { ...g, id: g.id };
        } catch (A) {
          throw new Qn(A);
        }
      }
    },
    onAccountsChanged(f) {
      f.length === 0
        ? this.onDisconnect()
        : p.emitter.emit("change", { accounts: f.map((m) => Nl(m)) });
    },
    onChainChanged(f) {
      const m = Number(f);
      p.emitter.emit("change", { chainId: m });
    },
    onConnect(f) {
      this.setRequestedChainsIds(Y.getCaipNetworks().map((m) => Number(m.id)));
    },
    async onDisconnect(f) {
      this.setRequestedChainsIds([]), p.emitter.emit("disconnect");
      const m = await this.getProvider();
      i && (m.removeListener("accountsChanged", i), (i = void 0)),
        s && (m.removeListener("chainChanged", s), (s = void 0)),
        d && (m.removeListener("disconnect", d), (d = void 0)),
        l && (m.removeListener("session_delete", l), (l = void 0)),
        o || ((o = this.onConnect.bind(this)), m.on("connect", o));
    },
    onDisplayUri(f) {
      p.emitter.emit("message", { type: "display_uri", data: f });
    },
    onSessionDelete() {
      this.onDisconnect();
    },
    getNamespaceChainsIds() {
      var y, g, v;
      if (!((y = r == null ? void 0 : r.session) != null && y.namespaces))
        return [];
      const f =
        (v =
          (g = r == null ? void 0 : r.session) == null
            ? void 0
            : g.namespaces[ye.CHAIN.EVM]) == null
          ? void 0
          : v.accounts;
      return (
        (f == null
          ? void 0
          : f.map((b) => Number.parseInt(b.split(":")[1] ?? ""))) ?? []
      );
    },
    async getRequestedChainsIds() {
      var m;
      const f =
        (await ((m = p.storage) == null
          ? void 0
          : m.getItem(this.requestedChainsStorageKey))) ?? [];
      return [...new Set(f)];
    },
    async isChainsStale() {
      if (!n) return !1;
      const f = p.chains.map((g) => g.id),
        m = this.getNamespaceChainsIds();
      if (m.length && !m.some((g) => f.includes(g))) return !1;
      const y = await this.getRequestedChainsIds();
      return !f.every((g) => y.includes(Number(g)));
    },
    async setRequestedChainsIds(f) {
      var m;
      await ((m = p.storage) == null
        ? void 0
        : m.setItem(this.requestedChainsStorageKey, f));
    },
    get requestedChainsStorageKey() {
      return `${this.id}.requestedChains`;
    },
  });
}
const nh = wn({ pendingTransactions: 0 }),
  h5 = {
    state: nh,
    subscribeKey(t, e) {
      return si(nh, t, e);
    },
    increase(t) {
      nh[t] += 1;
    },
    decrease(t) {
      nh[t] -= 1;
    },
    reset(t) {
      nh[t] = 0;
    },
  };
function dve(t) {
  try {
    return JSON.parse(t);
  } catch {
    throw new Error("Error parsing wallet capabilities");
  }
}
const pve = { enable: !1, pollingInterval: 3e4 };
class fve extends tL {
  constructor(e) {
    const n = _o.extendCaipNetworks(e.networks, {
      projectId: e.projectId,
      customNetworkImageUrls: {},
      customRpcUrls: e.customRpcUrls,
    });
    super({
      projectId: e.projectId,
      adapterType: ye.ADAPTER_TYPES.WAGMI,
      namespace: ye.CHAIN.EVM,
    }),
      (this.balancePromises = {}),
      (this.pendingTransactionsFilter = {
        ...pve,
        ...(e.pendingTransactionsFilter ?? {}),
      }),
      this.createConfig({ ...e, networks: n }),
      this.setupWatchers();
  }
  async getAccounts(e) {
    var s;
    const n = this.getWagmiConnector(e.id);
    if (!n) return { accounts: [] };
    if (n.id === ye.CONNECTOR_ID.AUTH) {
      const o = n.provider;
      if (!o.user) return { accounts: [] };
      const { address: a, accounts: l } = o.user;
      return Promise.resolve({
        accounts: (l || [{ address: a, type: "eoa" }]).map((d) =>
          Je.createAccount("eip155", d.address, d.type)
        ),
      });
    }
    const { addresses: r, address: i } = Nm(this.wagmiConfig);
    return Promise.resolve({
      accounts:
        (s = r || [i]) == null
          ? void 0
          : s.map((o) => Je.createAccount("eip155", o || "", "eoa")),
    });
  }
  getWagmiConnector(e) {
    return this.wagmiConfig.connectors.find((n) => n.id === e);
  }
  createConfig(e) {
    this.wagmiChains = e.networks.filter(
      (i) => i.chainNamespace === ye.CHAIN.EVM
    );
    const n = {},
      r = [...(e.connectors ?? [])];
    this.wagmiChains.forEach((i) => {
      var a, l;
      const s = (a = e.transports) == null ? void 0 : a[i.id],
        o = _o.getCaipNetworkId(i);
      s
        ? (n[i.id] = _o.extendWagmiTransports(i, e.projectId, s))
        : (n[i.id] = _o.getViemTransport(
            i,
            e.projectId,
            (l = e.customRpcUrls) == null ? void 0 : l[o]
          ));
    }),
      (this.wagmiConfig = Uye({
        ...e,
        chains: this.wagmiChains,
        connectors: r,
        transports: n,
      }));
  }
  setupWatchPendingTransactions() {
    if (
      !this.pendingTransactionsFilter.enable ||
      this.unwatchPendingTransactions
    )
      return;
    this.unwatchPendingTransactions = wye(this.wagmiConfig, {
      pollingInterval: this.pendingTransactionsFilter.pollingInterval,
      onError: () => {},
      onTransactions: () => {
        this.emit("pendingTransactions"), h5.increase("pendingTransactions");
      },
    });
    const e = h5.subscribeKey("pendingTransactions", (n) => {
      var r;
      n >= ye.LIMITS.PENDING_TRANSACTIONS &&
        ((r = this.unwatchPendingTransactions) == null || r.call(this), e());
    });
  }
  setupWatchers() {
    vL(this.wagmiConfig, {
      onChange: (e, n) => {
        e.status === "disconnected" && n.address && this.emit("disconnect"),
          e.status === "connected" &&
            ((e.address !== (n == null ? void 0 : n.address) ||
              n.status !== "connected") &&
              (this.setupWatchPendingTransactions(),
              this.emit("accountChanged", {
                address: e.address,
                chainId: e.chainId,
              })),
            e.chainId !== (n == null ? void 0 : n.chainId) &&
              this.emit("switchNetwork", {
                address: e.address,
                chainId: e.chainId,
              }));
      },
    });
  }
  async addThirdPartyConnectors(e) {
    var r, i;
    const n = [];
    if (e.enableCoinbase !== !1)
      try {
        const { coinbaseWallet: s } = await ei(async () => {
          const { coinbaseWallet: o } = await import("./index-BCW5JtTV.js");
          return { coinbaseWallet: o };
        }, []);
        s &&
          n.push(
            s({
              version: "4",
              appName:
                ((r = e.metadata) == null ? void 0 : r.name) ?? "Unknown",
              appLogoUrl:
                ((i = e.metadata) == null ? void 0 : i.icons[0]) ?? "Unknown",
              preference: e.coinbasePreference ?? "all",
            })
          );
      } catch (s) {
        console.error("Failed to import Coinbase Wallet SDK:", s);
      }
    n.forEach((s) => {
      const o = this.wagmiConfig._internal.connectors.setup(s);
      this.wagmiConfig._internal.connectors.setState((a) => [...a, o]);
    });
  }
  addWagmiConnectors(e, n) {
    var o, a, l, d, p, f;
    const r = [];
    e.enableWalletConnect !== !1 && r.push(S_(e, n)),
      e.enableInjected !== !1 && r.push(Jv({ shimDisconnect: !0 }));
    const i =
        ((o = e.features) == null ? void 0 : o.email) === void 0
          ? er.DEFAULT_FEATURES.email
          : (a = e.features) == null
          ? void 0
          : a.email,
      s =
        (l = e.features) != null && l.socials
          ? ((p = (d = e.features) == null ? void 0 : d.socials) == null
              ? void 0
              : p.length) > 0
          : ((f = e.features) == null ? void 0 : f.socials) ??
            er.DEFAULT_FEATURES.socials;
    (i || s) &&
      r.push(
        uve({
          chains: this.wagmiChains,
          options: {
            projectId: e.projectId,
            enableAuthLogger: e.enableAuthLogger,
          },
        })
      ),
      r.forEach((m) => {
        const y = this.wagmiConfig._internal.connectors.setup(m);
        this.wagmiConfig._internal.connectors.setState((g) => [...g, y]);
      });
  }
  async signMessage(e) {
    try {
      return {
        signature: await mye(this.wagmiConfig, {
          message: e.message,
          account: e.address,
        }),
      };
    } catch {
      throw new Error("WagmiAdapter:signMessage - Sign message failed");
    }
  }
  async sendTransaction(e) {
    const { chainId: n, address: r } = Nm(this.wagmiConfig),
      i = {
        account: r,
        to: e.to,
        value: Number.isNaN(Number(e.value)) ? BigInt(0) : BigInt(e.value),
        gas: e.gas ? BigInt(e.gas) : void 0,
        gasPrice: e.gasPrice ? BigInt(e.gasPrice) : void 0,
        data: e.data,
        chainId: n,
        type: "legacy",
        parameters: ["nonce"],
      };
    await fye(this.wagmiConfig, i);
    const s = await hye(this.wagmiConfig, i);
    return await Qv(this.wagmiConfig, { hash: s, timeout: 25e3 }), { hash: s };
  }
  async writeContract(e) {
    var o;
    const { caipNetwork: n, ...r } = e,
      i = Number(jh.caipNetworkIdToNumber(n.caipNetworkId));
    return {
      hash: await Xv(this.wagmiConfig, {
        chain: (o = this.wagmiChains) == null ? void 0 : o[i],
        chainId: i,
        address: r.tokenAddress,
        account: r.fromAddress,
        abi: r.abi,
        functionName: r.method,
        args: r.args,
        __mode: "prepared",
      }),
    };
  }
  async estimateGas(e) {
    try {
      return {
        gas: await uye(this.wagmiConfig, {
          account: e.address,
          to: e.to,
          data: e.data,
          type: "legacy",
        }),
      };
    } catch {
      throw new Error("WagmiAdapter:estimateGas - error estimating gas");
    }
  }
  parseUnits(e) {
    return bd(e.value, e.decimals);
  }
  formatUnits(e) {
    return Ln(e.value, e.decimals);
  }
  async addWagmiConnector(e, n) {
    var i;
    if (
      e.id === ye.CONNECTOR_ID.AUTH ||
      e.id === ye.CONNECTOR_ID.WALLET_CONNECT
    )
      return;
    const r = await e.getProvider().catch(() => {});
    this.addConnector({
      id: e.id,
      explorerId: Pc.ConnectorExplorerIds[e.id],
      imageUrl:
        ((i = n == null ? void 0 : n.connectorImages) == null
          ? void 0
          : i[e.id]) ?? e.icon,
      name: Pc.ConnectorNamesMap[e.id] ?? e.name,
      imageId: Pc.ConnectorImageIds[e.id],
      type: Pc.ConnectorTypesMap[e.type] ?? "EXTERNAL",
      info: e.id === ye.CONNECTOR_ID.INJECTED ? void 0 : { rdns: e.id },
      provider: r,
      chain: this.namespace,
      chains: [],
    });
  }
  async syncConnectors(e, n) {
    yye(this.wagmiConfig, {
      onChange: (r) => r.forEach((i) => this.addWagmiConnector(i, e)),
    }),
      await Promise.all(
        this.wagmiConfig.connectors.map((r) => this.addWagmiConnector(r, e))
      ),
      this.addWagmiConnectors(e, n),
      await this.addThirdPartyConnectors(e);
  }
  async syncConnection(e) {
    const { id: n } = e,
      i = gl(this.wagmiConfig).find((a) => a.connector.id === n),
      s = this.getWagmiConnector(n),
      o = await (s == null ? void 0 : s.getProvider());
    return {
      chainId: Number(i == null ? void 0 : i.chainId),
      address: i == null ? void 0 : i.accounts[0],
      provider: o,
      type: i == null ? void 0 : i.connector.type,
      id: i == null ? void 0 : i.connector.id,
    };
  }
  async connectWalletConnect(e) {
    const n = this.getWalletConnectConnector();
    await n.authenticate();
    const r = this.getWagmiConnector("walletConnect");
    if (!r)
      throw new Error(
        "UniversalAdapter:connectWalletConnect - connector not found"
      );
    const i = await Uk(this.wagmiConfig, {
      connector: r,
      chainId: e ? Number(e) : void 0,
    });
    return (
      i.chainId !== Number(e) &&
        (await SS(this.wagmiConfig, { chainId: i.chainId })),
      { clientId: await n.provider.client.core.crypto.getClientId() }
    );
  }
  async connect(e) {
    var d, p, f, m, y;
    const { id: n, provider: r, type: i, info: s, chainId: o } = e,
      a = this.getWagmiConnector(n);
    if (!a)
      throw new Error(
        "connectionControllerClient:connectExternal - connector is undefined"
      );
    if (
      (r &&
        s &&
        a.id === ye.CONNECTOR_ID.EIP6963 &&
        ((d = a.setEip6963Wallet) == null ||
          d.call(a, { provider: r, info: s })),
      a.uid ===
        ((f = (p = this.wagmiConfig) == null ? void 0 : p.state) == null
          ? void 0
          : f.current))
    ) {
      const g =
        (y = (m = this.wagmiConfig.state) == null ? void 0 : m.connections) ==
        null
          ? void 0
          : y.get(a.uid);
      if (g)
        return {
          address: g == null ? void 0 : g.accounts[0],
          chainId: g == null ? void 0 : g.chainId,
          provider: r,
          type: i,
          id: n,
        };
    }
    const l = await Uk(this.wagmiConfig, {
      connector: a,
      chainId: o ? Number(o) : void 0,
    });
    return {
      address: l.accounts[0],
      chainId: l.chainId,
      provider: r,
      type: i,
      id: n,
    };
  }
  async reconnect(e) {
    const { id: n } = e,
      r = this.getWagmiConnector(n);
    if (!r)
      throw new Error(
        "connectionControllerClient:connectExternal - connector is undefined"
      );
    await xS(this.wagmiConfig, { connectors: [r] });
  }
  async getBalance(e) {
    const n = e.address,
      r = this.getCaipNetworks().find((i) => i.id === e.chainId);
    if (!n) return Promise.resolve({ balance: "0.00", symbol: "ETH" });
    if (r && this.wagmiConfig) {
      const i = `${r.caipNetworkId}:${e.address}`,
        s = this.balancePromises[i];
      if (s) return s;
      const o = Ie.getNativeBalanceCacheForCaipAddress(i);
      return o
        ? { balance: o.balance, symbol: o.symbol }
        : ((this.balancePromises[i] = new Promise(async (a) => {
            var l, d;
            try {
              const p = Number(e.chainId),
                f = await wL(this.wagmiConfig, {
                  address: e.address,
                  chainId: p,
                  token:
                    (d =
                      (l = e.tokens) == null ? void 0 : l[r.caipNetworkId]) ==
                    null
                      ? void 0
                      : d.address,
                });
              Ie.updateNativeBalanceCache({
                caipAddress: i,
                balance: f.formatted,
                symbol: f.symbol,
                timestamp: Date.now(),
              }),
                a({ balance: f.formatted, symbol: f.symbol });
            } catch (p) {
              console.warn(
                "Appkit:WagmiAdapter:getBalance - Error getting balance",
                p
              ),
                a({ balance: "0.00", symbol: "ETH" });
            }
          }).finally(() => {
            delete this.balancePromises[i];
          })),
          this.balancePromises[i] || { balance: "0.00", symbol: "ETH" });
    }
    return { balance: "", symbol: "" };
  }
  getWalletConnectProvider() {
    var e;
    return (e = this.getWagmiConnector("walletConnect")) == null
      ? void 0
      : e.provider;
  }
  async disconnect() {
    const e = gl(this.wagmiConfig);
    await Promise.all(
      e.map(async (n) => {
        const r = this.getWagmiConnector(n.connector.id);
        r && (await lye(this.wagmiConfig, { connector: r }));
      })
    );
  }
  async switchNetwork(e) {
    await SS(this.wagmiConfig, { chainId: e.caipNetwork.id }),
      await super.switchNetwork(e);
  }
  async getCapabilities(e) {
    var a, l;
    if (!this.wagmiConfig)
      throw new Error(
        "connectionControllerClient:getCapabilities - wagmiConfig is undefined"
      );
    const r = gl(this.wagmiConfig)[0],
      i = r ? this.getWagmiConnector(r.connector.id) : null;
    if (!i)
      throw new Error(
        "connectionControllerClient:getCapabilities - connector is undefined"
      );
    const s = await i.getProvider();
    if (!s)
      throw new Error(
        "connectionControllerClient:getCapabilities - provider is undefined"
      );
    const o =
      (l = (a = s.session) == null ? void 0 : a.sessionProperties) == null
        ? void 0
        : l.capabilities;
    if (o) {
      const p = dve(o)[e];
      if (p) return p;
    }
    return await s.request({ method: "wallet_getCapabilities", params: [e] });
  }
  async grantPermissions(e) {
    if (!this.wagmiConfig)
      throw new Error(
        "connectionControllerClient:grantPermissions - wagmiConfig is undefined"
      );
    const r = gl(this.wagmiConfig)[0],
      i = r ? this.getWagmiConnector(r.connector.id) : null;
    if (!i)
      throw new Error(
        "connectionControllerClient:grantPermissions - connector is undefined"
      );
    const s = await i.getProvider();
    if (!s)
      throw new Error(
        "connectionControllerClient:grantPermissions - provider is undefined"
      );
    return s.request({ method: "wallet_grantPermissions", params: e });
  }
  async revokePermissions(e) {
    if (!this.wagmiConfig)
      throw new Error(
        "connectionControllerClient:revokePermissions - wagmiConfig is undefined"
      );
    const r = gl(this.wagmiConfig)[0],
      i = r ? this.getWagmiConnector(r.connector.id) : null;
    if (!i)
      throw new Error(
        "connectionControllerClient:revokePermissions - connector is undefined"
      );
    const s = await i.getProvider();
    if (!s)
      throw new Error(
        "connectionControllerClient:revokePermissions - provider is undefined"
      );
    return s.request({ method: "wallet_revokePermissions", params: e });
  }
  async walletGetAssets(e) {
    if (!this.wagmiConfig)
      throw new Error(
        "connectionControllerClient:walletGetAssets - wagmiConfig is undefined"
      );
    const r = gl(this.wagmiConfig)[0],
      i = r ? this.getWagmiConnector(r.connector.id) : null;
    if (!i)
      throw new Error(
        "connectionControllerClient:walletGetAssets - connector is undefined"
      );
    const s = await i.getProvider();
    if (!s)
      throw new Error(
        "connectionControllerClient:walletGetAssets - provider is undefined"
      );
    return s.request({ method: "wallet_getAssets", params: [e] });
  }
  setUniversalProvider(e) {
    e.on("connect", () => {
      const n = gl(this.wagmiConfig),
        r = this.getWagmiConnector("walletConnect");
      r &&
        !n.find((i) => i.connector.id === r.id) &&
        xS(this.wagmiConfig, { connectors: [r] });
    }),
      this.addConnector(
        new u_({
          provider: e,
          caipNetworks: this.getCaipNetworks(),
          namespace: "eip155",
        })
      );
  }
}
const hve = new C0e(),
  i8 = "cba73ada547c01c1a64d7725fb732495",
  s8 = [gge],
  _t = new fve({ networks: s8, projectId: i8, ssr: !0 });
Sge({
  adapters: [_t],
  networks: s8,
  projectId: i8,
  themeMode: "dark",
  allowUnsupportedChain: !0,
  features: { swaps: !1, onramp: !1, email: !1, socials: [] },
});
function mve({ children: t }) {
  return O.jsx(Fye, {
    config: _t == null ? void 0 : _t.wagmiConfig,
    children: O.jsx(_0e, {
      client: hve,
      children: O.jsx(O0e, {
        children: O.jsx(tye, {
          autoHideDuration: 2e3,
          anchorOrigin: { vertical: "top", horizontal: "center" },
          children: t,
        }),
      }),
    }),
  });
}
const Pa = 1,
  lc = async (t, e) =>
    await Zv(_t == null ? void 0 : _t.wagmiConfig, {
      address: Id,
      abi: JL,
      chainId: Pa,
      functionName: t,
      args: e,
    }),
  m5 = async (t, e) =>
    await Zv(_t == null ? void 0 : _t.wagmiConfig, {
      address: n8,
      abi: e8,
      chainId: Pa,
      functionName: t,
      args: e,
    }),
  gve = async (t, e) =>
    await Zv(_t == null ? void 0 : _t.wagmiConfig, {
      address: r8,
      abi: t8,
      chainId: Pa,
      functionName: t,
      args: e,
    }),
  jC = async (t, e, n) => {
    const r = await Xv(_t == null ? void 0 : _t.wagmiConfig, {
        address: Id,
        abi: JL,
        chainId: Pa,
        functionName: t,
        args: e,
        value: n,
      }),
      i = await Qv(_t == null ? void 0 : _t.wagmiConfig, {
        hash: r,
        chainId: Pa,
      });
    return i == null ? void 0 : i.transactionHash;
  },
  yve = async (t, e) => {
    const n = await Xv(_t == null ? void 0 : _t.wagmiConfig, {
        address: n8,
        abi: e8,
        chainId: Pa,
        functionName: t,
        args: e,
      }),
      r = await Qv(_t == null ? void 0 : _t.wagmiConfig, {
        hash: n,
        chainId: Pa,
      });
    return r == null ? void 0 : r.transactionHash;
  },
  wve = async (t, e) => {
    const n = await Xv(_t == null ? void 0 : _t.wagmiConfig, {
        address: r8,
        abi: t8,
        chainId: Pa,
        functionName: t,
        args: e,
      }),
      r = await Qv(_t == null ? void 0 : _t.wagmiConfig, {
        hash: n,
        chainId: Pa,
      });
    return r == null ? void 0 : r.transactionHash;
  };
function vve({ loading: t }) {
  return O.jsx("div", {
    children: O.jsx(cA, {
      sx: { zIndex: 22e7 },
      open: t,
      children: O.jsx(be, {
        width: "100%",
        height: "100%",
        sx: {
          background: "linear-gradient(rgba(5, 4, 1, 0.6), rgba(5, 4, 1, 0.7))",
          backdropFilter: "blur(20px)",
          display: "flex",
          justifyContent: "center",
          alignItems: "center",
        },
        children: O.jsx(be, {
          component: "img",
          src: hv,
          className: "fadeinout",
          width: { xs: "160px", md: "180px" },
          alt: "",
        }),
      }),
    }),
  });
}
function FC(t) {
  return t.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
}
const bve = bp`
  0% {
    background-position: 0 0;
  }
  100% {
    background-position: 40px 0;
  }
`,
  zC = zm(Hq)(() => ({
    flex: 1,
    fontWeight: "bold",
    borderRadius: "8px !important",
    margin: "4px",
    padding: "10px 0",
    backgroundColor: "#eef0f4",
    border: "none",
    color: "#000",
    "&.Mui-selected": {
      boxShadow: "1px 3px #000",
      border: "1px solid #000 !important",
    },
    "&:hover": { backgroundColor: "#eef0f4" },
  })),
  Eve = () => {
    const [t, e] = N.useState("ETH"),
      n = Ii(),
      r = xs(n.breakpoints.down("sm")),
      i = (ee, J) => {
        J !== null && e(J);
      },
      s = zm(be)(() => ({
        border: "2px solid #000",
        borderRadius: "20px",
        backgroundColor: "#fff",
        width: r ? "100%" : "80%",
        margin: "auto",
        boxShadow: "2px 5px #000",
      })),
      { open: o } = nL(),
      { account: a } = N.useContext(nb),
      [l, d] = N.useState(0),
      [p, f] = N.useState(0),
      [m, y] = N.useState(!1),
      [g, v] = N.useState(""),
      [b, E] = N.useState(0),
      [S, C] = N.useState(""),
      [_, A] = N.useState(!1),
      [I, R] = N.useState(0),
      [D, k] = N.useState(0),
      [T, U] = N.useState(0),
      [q, K] = N.useState(0),
      [H, $] = N.useState(0),
      [M, z] = N.useState(0),
      B = (ee) => {
        const J = ee.target.value;
        v(J), console.log("Input value (direct):", J);
      },
      [j, V] = N.useState({ open: !1, message: "", severity: void 0 }),
      W = (ee, J = "error") => {
        V({ open: !0, message: ee, severity: J });
      };
    N.useEffect(() => {
      (async () => {
        try {
          let ee = await lc("currentSale");
          f(ee.toString()), console.log(ee.toString(), "currentsales");
          let J = await lc("presale", [ee]),
            re = 1 / +Ln(J[2].toString(), 18);
          $(re);
          let ce = 1 / +Ln(J[3].toString(), 18);
          E(ce);
          let le = 0,
            Se = 0,
            je = 0,
            Pe = 0;
          for (let We = 1; We <= Number(ee); We++) {
            const Ne = await lc("presale", [We.toString()]);
            (le += +Ln(Ne[4].toString(), 18)),
              (Se += +Ln(Ne[5].toString(), 18)),
              (je += +Ln(Ne[7].toString(), 6)),
              (Pe += +Ln(Ne[6].toString(), 6));
          }
          if ((U(le), K(Se), R(je), k(Pe), t === "USDT")) {
            let We = await m5("balanceOf", [a]);
            console.log(+Ln(We.toString(), 6), "usdtBalance"),
              z(+Ln(We.toString(), 6));
          } else {
            const We = await wL(_t == null ? void 0 : _t.wagmiConfig, {
              address: a,
              chainId: g_,
            });
            let Ne = +(We == null ? void 0 : We.formatted) - 0.0075;
            console.log(Ne, "ethBalance"), z(Ne);
          }
          console.log(t, "token");
        } catch (ee) {
          console.log(ee);
        }
      })(),
        A(!1);
    }, [a, _, t]),
      N.useEffect(() => {
        (async () => {
          try {
            let ee = await lc("currentSale");
            f(ee.toString()), console.log(ee.toString(), "currentsales");
            let J = (+T / +q) * 100;
            console.log(J, "progressBar"), d(J);
          } catch (ee) {
            console.log(ee);
          }
        })(),
          A(!1);
      }, [T, q]),
      N.useEffect(() => {
        (async () => {
          try {
            if (g > 0)
              if (t === "USDT" || t === "USDC") {
                let ee = await lc("currentSale"),
                  J = await lc("usdtToTokens", [
                    ee.toString(),
                    bd(g.toString(), 6),
                  ]);
                console.log(+Ln(J.toString(), 8), "usdtToTokens"),
                  C(+Ln(J.toString(), 18));
              } else {
                let ee = await lc("currentSale"),
                  J = await lc("ethToTokens", [
                    ee.toString(),
                    bd(g.toString(), 18),
                  ]);
                console.log(J, "ethToTokens"), C(+Ln(J.toString(), 18));
              }
          } catch (ee) {
            console.log(ee);
          }
        })();
      }, [g, t]);
    const Z = async () => {
      try {
        if (!a) return W("Please connect your wallet");
        if (!g) return W("Please enter amount");
        if ((console.log(g, t, "check"), y(!0), t === "USDT")) {
          let ee = await m5("allowance", [a, Id]);
          console.log(+Ln(ee.toString(), 6).toString(), "allowance"),
            +Ln(ee.toString(), 6).toString() < g &&
              (await yve("approve", [Id, "999999999999999999999999999999"])),
            await jC("buyWithUSDT", [bd(g.toString(), 6).toString()]);
        } else if (t === "USDC") {
          let ee = await gve("allowance", [a, Id]);
          console.log(+Ln(ee.toString(), 6), "allowanceusdc"),
            +Ln(ee.toString(), 6).toString() < g &&
              (await wve("approve", [Id, "999999999999999999999999999999"])),
            await jC("buyWithUSDC", [bd(g.toString(), 6).toString()]);
        } else await jC("buyWithEth", [], bd(g.toString(), 18).toString());
        A(!0),
          y(!1),
          v(0),
          V({
            open: !0,
            message: "Transaction confirmed!!!",
            severity: "success",
          });
      } catch (ee) {
        console.error(ee), y(!1);
        const J = ee == null ? void 0 : ee.shortMessage;
        W(J);
      }
    };
    return O.jsxs(O.Fragment, {
      children: [
        O.jsx(vve, { loading: m }),
        O.jsx(nye, { alertState: j, setAlertState: V }),
        O.jsx(s, {
          children: O.jsxs(be, {
            p: r ? 2 : 3,
            children: [
              O.jsx("iframe", {
                src: "https://app.uniswap.org/swap?inputCurrency=ETH&outputCurrency=0x79937da178932489Ee32290baa5622690De709CA",
                width: "100%",
                height: "400px",
              }),
              // O.jsxs(be, {
              //   display: "flex",
              //   justifyContent: "space-between",
              //   alignItems: "center",
              //   children: [
              //     O.jsxs(Ft, {
              //       sx: {
              //         lineHeight: r ? "20px" : "24px",
              //         fontSize: r ? "20px" : "24px",
              //         fontFamily: "Sour Gummy",
              //         fontWeight: 900,
              //       },
              //       children: ["Next Stage Price: $", parseFloat(b).toFixed(4)],
              //     }),
              //     O.jsxs(be, {
              //       sx: {
              //         backgroundColor: "#f4eb82",
              //         border: "1px solid #000",
              //         borderRadius: "12px",
              //         padding: "5px 12px",
              //         width: "100px",
              //         display: "flex",
              //         justifyContent: "center",
              //         height: "35px",
              //         alignItems: "center",
              //         fontWeight: "900",
              //         fontSize: r ? "20px" : "24px",
              //         boxShadow: "2px 3px #006c28",
              //         fontFamily: "Sour Gummy",
              //       },
              //       children: ["Stage ", p],
              //     }),
              //   ],
              // }),
              // O.jsx(be, {
              //   display: "flex",
              //   justifyContent: "center",
              //   mt: 2,
              //   children: O.jsxs(be, {
              //     mb: 1,
              //     sx: {
              //       backgroundColor: "#ffccbc",
              //       border: "2px solid #000",
              //       borderRadius: "12px",
              //       padding: "5px 20px",
              //       height: "35px",
              //       transform: "rotate(-5deg)",
              //       boxShadow: "2px 3px #000",
              //       display: "flex",
              //       alignItems: "center",
              //       fontFamily: "Sour Gummy",
              //       fontSize: r ? "17px" : "20px",
              //       fontWeight: 900,
              //     },
              //     children: ["1 LILPEPE = $", parseFloat(H).toFixed(4)],
              //   }),
              // }),
              // O.jsxs(be, {
              //   my: 2,
              //   children: [
              //     O.jsxs(Ft, {
              //       sx: {
              //         textAlign: "center",
              //         fontSize: r ? "18px" : "22px",
              //         lineHeight: r ? "18px" : "22px",
              //         fontFamily: "Sour Gummy",
              //         fontWeight: 900,
              //       },
              //       children: [
              //         "USD Raised: $",
              //         FC(parseFloat(I).toFixed(0)),
              //         " / $",
              //         FC(D),
              //       ],
              //     }),
              //     O.jsxs(Ft, {
              //       mt: 1,
              //       sx: {
              //         textAlign: "center",
              //         fontSize: r ? "18px" : "22px",
              //         lineHeight: r ? "18px" : "22px",
              //         fontFamily: "Sour Gummy",
              //         fontWeight: 900,
              //       },
              //       children: [
              //         "Tokens Sold:",
              //         " ",
              //         FC(parseFloat(T).toFixed(0)),
              //         " /",
              //         " ",
              //         q.toLocaleString(),
              //       ],
              //     }),
              //   ],
              // }),
              // O.jsx(cx, {
              //   mt: 1,
              //   sx: {
              //     height: { xs: "20px", md: "20px" },
              //     width: "100%",
              //     background: "#FFFFFF",
              //     mt: 0.5,
              //     borderRadius: "20px",
              //     overflow: "hidden",
              //     border: "1px solid #000",
              //   },
              //   children: O.jsxs(cx, {
              //     height: "100%",
              //     alignItems: "start",
              //     justifyContent: "center",
              //     position: "relative",
              //     children: [
              //       O.jsx(be, {
              //         sx: {
              //           position: "absolute",
              //           left: 0,
              //           top: 0,
              //           bottom: 0,
              //           width: `${l}%`,
              //           backgroundColor: "#f4eb82",
              //           borderRadius: "26px",
              //           backgroundSize: "100% 100%",
              //           backgroundRepeat: "no-repeat",
              //           zIndex: 0,
              //           "&::after": {
              //             content: '""',
              //             display: "block",
              //             position: "absolute",
              //             top: 0,
              //             left: 0,
              //             height: "100%",
              //             width: "100%",
              //             backgroundImage:
              //               "linear-gradient(135deg, transparent 25%, #00000020 25%,#00000020 50%, transparent 50%, transparent 75%, #00000020 75%, #00000020)",
              //             backgroundSize: "20px 20px",
              //             animation: `${bve} 2s linear infinite`,
              //           },
              //         },
              //       }),
              //       O.jsxs(be, {
              //         sx: {
              //           position: "absolute",
              //           top: 1,
              //           left: "45%",
              //           color: "#000",
              //           fontSize: "16px",
              //           fontWeight: "700",
              //         },
              //         children: [
              //           +l > 0 ? parseFloat(l).toFixed(2) : "0.00",
              //           "%",
              //         ],
              //       }),
              //     ],
              //   }),
              // }),
              // O.jsxs(Kq, {
              //   value: t,
              //   exclusive: !0,
              //   onChange: i,
              //   fullWidth: !0,
              //   sx: { mt: 3, display: "flex", gap: r ? 1 : 2 },
              //   children: [
              //     O.jsxs(zC, {
              //       value: "ETH",
              //       children: [
              //         O.jsx(be, {
              //           component: "img",
              //           src: p5,
              //           mr: 1,
              //           width: "25px",
              //           alt: "",
              //         }),
              //         "ETH",
              //       ],
              //     }),
              //     O.jsxs(zC, {
              //       value: "USDT",
              //       children: [
              //         O.jsx(be, {
              //           component: "img",
              //           src: f5,
              //           mr: 1,
              //           width: "25px",
              //           alt: "",
              //         }),
              //         "USDT",
              //       ],
              //     }),
              //     O.jsxs(zC, {
              //       value: "CARD",
              //       href: "https://littlepepe.cool/how-to-buy#card",
              //       target: "_blank",
              //       children: [O.jsx(lve, { sx: { mr: 1 } }), " CARD"],
              //     }),
              //   ],
              // }),
              // O.jsxs(be, {
              //   display: "flex",
              //   flexDirection: r ? "column" : "row",
              //   gap: r ? 0 : 2,
              //   mt: 3,
              //   children: [
              //     O.jsx(IP, {
              //       fullWidth: !0,
              //       autoFocus: !!g,
              //       type: "number",
              //       placeholder: "0.0",
              //       value: g,
              //       onChange: B,
              //       InputProps: {
              //         endAdornment: O.jsxs(be, {
              //           display: "flex",
              //           alignItems: "center",
              //           gap: "5px",
              //           children: [
              //             O.jsx(ha, {
              //               width: "50px",
              //               onClick: () => {
              //                 v(M);
              //               },
              //               style: {
              //                 borderRadius: "5px",
              //                 height: "30px",
              //                 boxShadow: "none",
              //                 background: "#fff5ae",
              //                 border: "2px solid #227c3c",
              //                 color: "#227c3c",
              //                 textTransform: "capitalize",
              //                 fontFamily: "Sour Gummy",
              //                 fontWeight: "700",
              //               },
              //               children: "Max",
              //             }),
              //             O.jsx(be, {
              //               component: "img",
              //               src: t === "ETH" ? p5 : f5,
              //               width: "25px",
              //               alt: "",
              //             }),
              //           ],
              //         }),
              //       },
              //     }),
              //     O.jsx(IP, {
              //       fullWidth: !0,
              //       type: "number",
              //       placeholder: "0",
              //       readOnly: !0,
              //       value: S,
              //       sx: { mt: r ? 2 : 0 },
              //       InputProps: {
              //         endAdornment: O.jsx(be, {
              //           component: "img",
              //           src: "/favlogo.png",
              //           width: "30px",
              //           alt: "",
              //         }),
              //       },
              //     }),
              //   ],
              // }),
              // a
              //   ? O.jsx(ha, {
              //       onClick: () => Z(),
              //       sx: {
              //         color: "#000",
              //         background: "#f87113",
              //         boxShadow:
              //           "inset 0 -4px 0 rgba(0, 0, 0, 0.25), 0 3px 0 #000",
              //         height: "58px",
              //         fontSize: "22px",
              //         fontFamily: "Sour Gummy",
              //         fontWeight: "700",
              //         borderRadius: "10px",
              //         width: "100%",
              //         border: "2px solid #000",
              //         mt: 3,
              //         "&.Mui-disabled": { color: "#979EA7" },
              //         "&:hover": { background: "#006c28", color: "#ffffff" },
              //       },
              //       children: "BUY NOW",
              //     })
              //   : O.jsx(ha, {
              //       onClick: async () => o(),
              //       sx: {
              //         color: "#000",
              //         background: "#f87113",
              //         boxShadow:
              //           "inset 0 -4px 0 rgba(0, 0, 0, 0.25), 0 3px 0 #000",
              //         height: "58px",
              //         fontSize: "22px",
              //         fontFamily: "Sour Gummy",
              //         fontWeight: "700",
              //         borderRadius: "10px",
              //         width: "100%",
              //         border: "2px solid #000",
              //         mt: 3,
              //         "&.Mui-disabled": { color: "#979EA7" },
              //         "&:hover": { background: "#006c28", color: "#ffffff" },
              //       },
              //       children: "Connect Wallet",
              //     }),
              // O.jsxs(be, {
              //   display: "flex",
              //   justifyContent: "space-between",
              //   mt: 2,
              //   gap: 2,
              //   children: [
              //     O.jsx(ha, {
              //       href: "https://littlepepe.cool/how-to-buy/",
              //       target: "_blank",
              //       sx: {
              //         color: "#000",
              //         background: "#abe7c0",
              //         height: "50px",
              //         fontSize: r ? "13px" : "18px",
              //         fontFamily: "Poppins",
              //         fontWeight: "700",
              //         borderRadius: "10px",
              //         width: "100%",
              //         border: "2px solid #000",
              //       },
              //       children: "How To Buy",
              //     }),
              //     O.jsx(ha, {
              //       href: "https://littlepepe.cool/777k-giveaway/",
              //       target: "_blank",
              //       sx: {
              //         color: "#000",
              //         background: "#f69e96",
              //         height: "50px",
              //         fontSize: r ? "13px" : "18px",
              //         fontFamily: "Poppins",
              //         fontWeight: "700",
              //         borderRadius: "10px",
              //         width: "100%",
              //         border: "2px solid #000",
              //       },
              //       children: "+777k Giveaway",
              //     }),
              //   ],
              // }),
            ],
          }),
        }),
      ],
    });
  },
  Cve = "/assets/banner-DmYd4jJC.png";
var A0 = {},
  g5;
function xve() {
  if (g5) return A0;
  g5 = 1;
  function t(s) {
    if (typeof window > "u") return;
    const o = document.createElement("style");
    return (
      o.setAttribute("type", "text/css"),
      (o.innerHTML = s),
      document.head.appendChild(o),
      s
    );
  }
  Object.defineProperty(A0, "__esModule", { value: !0 });
  var e = wp();
  function n(s) {
    return s && typeof s == "object" && "default" in s ? s : { default: s };
  }
  var r = n(e);
  t(`.rfm-marquee-container {
  overflow-x: hidden;
  display: flex;
  flex-direction: row;
  position: relative;
  width: var(--width);
  transform: var(--transform);
}
.rfm-marquee-container:hover div {
  animation-play-state: var(--pause-on-hover);
}
.rfm-marquee-container:active div {
  animation-play-state: var(--pause-on-click);
}

.rfm-overlay {
  position: absolute;
  width: 100%;
  height: 100%;
}
.rfm-overlay::before, .rfm-overlay::after {
  background: linear-gradient(to right, var(--gradient-color), rgba(255, 255, 255, 0));
  content: "";
  height: 100%;
  position: absolute;
  width: var(--gradient-width);
  z-index: 2;
  pointer-events: none;
  touch-action: none;
}
.rfm-overlay::after {
  right: 0;
  top: 0;
  transform: rotateZ(180deg);
}
.rfm-overlay::before {
  left: 0;
  top: 0;
}

.rfm-marquee {
  flex: 0 0 auto;
  min-width: var(--min-width);
  z-index: 1;
  display: flex;
  flex-direction: row;
  align-items: center;
  animation: scroll var(--duration) linear var(--delay) var(--iteration-count);
  animation-play-state: var(--play);
  animation-delay: var(--delay);
  animation-direction: var(--direction);
}
@keyframes scroll {
  0% {
    transform: translateX(0%);
  }
  100% {
    transform: translateX(-100%);
  }
}

.rfm-initial-child-container {
  flex: 0 0 auto;
  display: flex;
  min-width: auto;
  flex-direction: row;
  align-items: center;
}

.rfm-child {
  transform: var(--transform);
}`);
  const i = e.forwardRef(function (
    {
      style: o = {},
      className: a = "",
      autoFill: l = !1,
      play: d = !0,
      pauseOnHover: p = !1,
      pauseOnClick: f = !1,
      direction: m = "left",
      speed: y = 50,
      delay: g = 0,
      loop: v = 0,
      gradient: b = !1,
      gradientColor: E = "white",
      gradientWidth: S = 200,
      onFinish: C,
      onCycleComplete: _,
      onMount: A,
      children: I,
    },
    R
  ) {
    const [D, k] = e.useState(0),
      [T, U] = e.useState(0),
      [q, K] = e.useState(1),
      [H, $] = e.useState(!1),
      M = e.useRef(null),
      z = R || M,
      B = e.useRef(null),
      j = e.useCallback(() => {
        if (B.current && z.current) {
          const re = z.current.getBoundingClientRect(),
            fe = B.current.getBoundingClientRect();
          let ce = re.width,
            le = fe.width;
          (m === "up" || m === "down") && ((ce = re.height), (le = fe.height)),
            K(l && ce && le && le < ce ? Math.ceil(ce / le) : 1),
            k(ce),
            U(le);
        }
      }, [l, z, m]);
    e.useEffect(() => {
      if (H && (j(), B.current && z.current)) {
        const re = new ResizeObserver(() => j());
        return (
          re.observe(z.current),
          re.observe(B.current),
          () => {
            re && re.disconnect();
          }
        );
      }
    }, [j, z, H]),
      e.useEffect(() => {
        j();
      }, [j, I]),
      e.useEffect(() => {
        $(!0);
      }, []),
      e.useEffect(() => {
        typeof A == "function" && A();
      }, []);
    const V = e.useMemo(
        () => (l ? (T * q) / y : T < D ? D / y : T / y),
        [l, D, T, q, y]
      ),
      W = e.useMemo(
        () =>
          Object.assign(Object.assign({}, o), {
            "--pause-on-hover": !d || p ? "paused" : "running",
            "--pause-on-click": !d || (p && !f) || f ? "paused" : "running",
            "--width": m === "up" || m === "down" ? "100vh" : "100%",
            "--transform":
              m === "up"
                ? "rotate(-90deg)"
                : m === "down"
                ? "rotate(90deg)"
                : "none",
          }),
        [o, d, p, f, m]
      ),
      Z = e.useMemo(
        () => ({
          "--gradient-color": E,
          "--gradient-width": typeof S == "number" ? `${S}px` : S,
        }),
        [E, S]
      ),
      ee = e.useMemo(
        () => ({
          "--play": d ? "running" : "paused",
          "--direction": m === "left" ? "normal" : "reverse",
          "--duration": `${V}s`,
          "--delay": `${g}s`,
          "--iteration-count": v ? `${v}` : "infinite",
          "--min-width": l ? "auto" : "100%",
        }),
        [d, m, V, g, v, l]
      ),
      J = e.useMemo(
        () => ({
          "--transform":
            m === "up"
              ? "rotate(90deg)"
              : m === "down"
              ? "rotate(-90deg)"
              : "none",
        }),
        [m]
      ),
      se = e.useCallback(
        (re) =>
          [...Array(Number.isFinite(re) && re >= 0 ? re : 0)].map((fe, ce) =>
            r.default.createElement(
              e.Fragment,
              { key: ce },
              e.Children.map(I, (le) =>
                r.default.createElement(
                  "div",
                  { style: J, className: "rfm-child" },
                  le
                )
              )
            )
          ),
        [J, I]
      );
    return H
      ? r.default.createElement(
          "div",
          { ref: z, style: W, className: "rfm-marquee-container " + a },
          b &&
            r.default.createElement("div", {
              style: Z,
              className: "rfm-overlay",
            }),
          r.default.createElement(
            "div",
            {
              className: "rfm-marquee",
              style: ee,
              onAnimationIteration: _,
              onAnimationEnd: C,
            },
            r.default.createElement(
              "div",
              { className: "rfm-initial-child-container", ref: B },
              e.Children.map(I, (re) =>
                r.default.createElement(
                  "div",
                  { style: J, className: "rfm-child" },
                  re
                )
              )
            ),
            se(q - 1)
          ),
          r.default.createElement(
            "div",
            { className: "rfm-marquee", style: ee },
            se(q)
          )
        )
      : null;
  });
  return (A0.default = i), A0;
}
var Sve = xve();
const A_ = Hc(Sve);
function Ave() {
  const t = xs("(max-width:950px)");
  return O.jsxs(O.Fragment, {
    children: [
      O.jsx("div", {
        style: {
          background: "#f4eb82",
          borderTop: "1px solid #000",
          borderBottom: "1px solid #000",
        },
        children: O.jsx(A_, {
          speed: 50,
          pauseOnClick: !0,
          pauseOnHover: !0,
          gradient: !1,
          children: O.jsx(be, {
            style: { display: "flex", alignItems: "center" },
            children: O.jsx(Ft, {
              sx: {
                fontWeight: 700,
                fontFamily: "Sour Gummy",
                fontSize: t ? "15px" : "18px",
                color: "#000",
                py: "2px",
              },
              children:
                " - Safety Warning | Beware of Scams! | The Little Pepe Team will NEVER contact you directly through social media or messaging platforms. Always verify official links only through our Community | NEVER share your seed phrase or private key with anyone, not even with someone claiming to be from the team. No legitimate team member will ever ask for it.   -  | ",
            }),
          }),
        }),
      }),
      O.jsxs(Kc, {
        maxWidth: "xl",
        children: [
          O.jsxs(be, {
            sx: { px: t ? 0 : 4 },
            pb: t ? 0 : 5,
            children: [
              O.jsxs(xn, {
                container: !0,
                spacing: 5,
                mt: t ? 5 : 10,
                children: [
                  O.jsxs(xn, {
                    size: { xs: 12, md: 6 },
                    children: [
                      O.jsx(Ft, {
                        sx: {
                          fontSize: t ? "30px" : "75px",
                          lineHeight: t ? "32px" : "75px",
                          fontWeight: 900,
                          fontFamily: "Sour Gummy",
                          color: "#000",
                          textTransform: "uppercase",
                          textAlign: t ? "center" : "left",
                        },
                        children: "Little PEPE Arising",
                      }),
                      O.jsx(Ft, {
                        sx: {
                          fontSize: t ? "20px" : "28px",
                          lineHeight: t ? "20px" : "30px",
                          fontWeight: 900,
                          fontFamily: "Sour Gummy",
                          color: "#000",
                          textAlign: t ? "center" : "left",
                          my: t ? 2 : 4,
                        },
                        children:
                          " Enter the new world order with LILPEPE, where the unstoppable force of memes meets their home.",
                      }),
                      O.jsxs(be, {
                        display: "flex",
                        justifyContent: t ? "center" : "flex-start",
                        gap: 3,
                        mb: 3,
                        children: [
                          O.jsx(ds, {
                            to: "https://t.me/LittlePepeErc20",
                            target: "_blank",
                            style: { textDecoration: "none" },
                            children: O.jsx(XL, {
                              sx: { color: "#000", fontSize: "45px" },
                            }),
                          }),
                          O.jsx(ds, {
                            to: "https://x.com/LittlePepeErc20",
                            target: "_blank",
                            style: { textDecoration: "none" },
                            children: O.jsx(QL, {
                              sx: { color: "#000", fontSize: "40px" },
                            }),
                          }),
                        ],
                      }),
                      O.jsxs(be, {
                        display: "flex",
                        justifyContent: t ? "center" : "flex-start",
                        gap: 3,
                        children: [
                          O.jsx(ha, {
                            href: "https://dextools.io/app/en/ether/pair-explorer/0x79937da178932489Ee32290baa5622690De709CA",
                            target: "_blank",
                            sx: {
                              color: "#000",
                              background: "#f87113",
                              boxShadow:
                                "inset 0 -4px 0 rgba(0, 0, 0, 0.25), 0 3px 0 #000",
                              height: "58px",
                              fontSize: "22px",
                              fontFamily: "Sour Gummy",
                              fontWeight: "700",
                              borderRadius: "10px",
                              width: "fit-content",
                              border: "2px solid #000",
                              px: 3,
                              "&.Mui-disabled": { color: "#979EA7" },
                              "&:hover": {
                                background: "#006c28",
                                color: "#ffffff",
                              },
                            },
                            children: "DexTools",
                          }),
                          O.jsx(ha, {
                            href: "https://dexscreener.com/ethereum/0x79937da178932489Ee32290baa5622690De709CA",
                            target: "_blank",
                            sx: {
                              color: "#000",
                              background: "#fff",
                              boxShadow:
                                "inset 0 -4px 0 rgba(0, 0, 0, 0.25), 0 3px 0 #000",
                              height: "58px",
                              fontSize: "22px",
                              fontWeight: "700",
                              fontFamily: "Sour Gummy",
                              borderRadius: "10px",
                              width: "fit-content",
                              border: "2px solid #000",
                              px: 3,
                              "&.Mui-disabled": { color: "#979EA7" },
                              "&:hover": {
                                background: "#006c28",
                                color: "#ffffff",
                              },
                            },
                            children: "Dexscreener",
                          }),
                        ],
                      }),
                    ],
                  }),
                  O.jsx(xn, {
                    size: { xs: 12, md: 6 },
                    children: O.jsx(Eve, {}),
                  }),
                ],
              }),
              t &&
                O.jsx(be, {
                  component: "img",
                  src: Cve,
                  mt: 5,
                  width: "100%",
                  alt: "",
                }),
            ],
          }),
          // O.jsx(Ft, {
          //   mt: t ? 0 : 5,
          //   sx: {
          //     fontFamily: "Sour Gummy",
          //     fontWeight: 900,
          //     fontSize: "32px",
          //     color: "#000",
          //     textAlign: "center",
          //     textTransform: "uppercase",
          //   },
          //   children: "Featured In",
          // }),
        ],
      }),
    ],
  });
}
const _ve = "/assets/herobg-C9P7QZ-w.png";
function Ive() {
  const t = xs("(max-width:950px)"),
    e = [
      " LILPEPE ",
      " Little Pepe ",
      " LILPEPE ",
      " Little Pepe ",
      " LILPEPE ",
      " Little Pepe ",
      " LILPEPE ",
      " Little Pepe ",
      " LILPEPE ",
      " LILPEPE ",
      " Little Pepe ",
      " LILPEPE ",
      " Little Pepe ",
      " LILPEPE ",
      " Little Pepe ",
      " LILPEPE ",
      " Little Pepe ",
      " LILPEPE ",
    ];
  return O.jsx("div", {
    style: {
      background: "#f4eb82",
      borderTop: "2px solid #000",
      borderBottom: "2px solid #000",
    },
    children: O.jsx(A_, {
      speed: 50,
      pauseOnClick: !0,
      pauseOnHover: !0,
      gradient: !1,
      children: O.jsx(be, {
        style: { display: "flex", alignItems: "center" },
        children: e.map((n, r) =>
          O.jsx(
            Ft,
            {
              sx: {
                fontWeight: 700,
                fontFamily: "Sour Gummy",
                fontSize: t ? "18px" : "28px",
                color: "#000",
                ml: 4.2,
                py: 1,
              },
              children: n,
            },
            r
          )
        ),
      }),
    }),
  });
}
const Tve = "/assets/aboutbg-CtVfcIDb.png",
  Pve = "/assets/aboutbd-BtXfsPQK.png",
  y5 = "/assets/about-pepe-Ct26GPwb.png";
function Rve() {
  const t = xs("(max-width:1050px)");
  return O.jsxs(be, {
    id: "about",
    sx: {
      backgroundImage: `url(${Tve})`,
      backgroundSize: "cover",
      backgroundPosition: "center",
      height: t ? "100%" : "65rem",
      pb: 5,
      position: "relative",
      zIndex: 1,
    },
    children: [
      !t &&
        O.jsx(be, {
          component: "img",
          src: y5,
          sx: { position: "absolute", zIndex: 0, bottom: "2%", left: "5%" },
          width: "400px",
          alt: "",
        }),
      O.jsxs(Kc, {
        maxWidth: "xl",
        children: [
          t &&
            O.jsx(be, {
              component: "img",
              src: y5,
              mt: 5,
              width: "100%",
              alt: "",
            }),
          O.jsx(be, {
            display: "flex",
            justifyContent: "flex-end",
            px: t ? 0 : 4,
            sx: { position: "relative", zIndex: 1 },
            children: O.jsxs(be, {
              width: t ? "100%" : "80%",
              mt: t ? 5 : 15,
              sx: {
                background: t ? "#f4eb82" : `url(${Pve})`,
                backgroundSize: "100% 100%",
                backgroundPosition: "100% 100%",
                height: t ? "100%" : "57rem",
                borderRadius: t ? "14px" : "0px",
              },
              children: [
                O.jsx(Ft, {
                  pl: t ? 2 : 10,
                  pt: t ? 2 : 8,
                  sx: {
                    fontSize: t ? "40px" : "120px",
                    lineHeight: t ? "40px" : "120px",
                    fontWeight: 900,
                    fontFamily: "Sour Gummy",
                    color: "#000",
                    textTransform: "uppercase",
                    textAlign: "left",
                  },
                  children: "About LILPEPE",
                }),
                O.jsxs(Ft, {
                  sx: {
                    fontSize: t ? "24px" : "28px",
                    lineHeight: t ? "24px" : "36px",
                    fontWeight: 900,
                    fontFamily: "Sour Gummy",
                    color: "#000",
                    textAlign: "left",
                    mt: t ? 2 : 4,
                    px: t ? 2 : 10,
                  },
                  children: [
                    "The next evolution of meme coins.",
                    O.jsx("br", {}),
                    " Little Pepe is a new-born engineered pepe for speed, security, ultra-low feesand powered by memes.",
                  ],
                }),
                O.jsx(Ft, {
                  sx: {
                    fontSize: t ? "24px" : "28px",
                    lineHeight: t ? "24px" : "36px",
                    fontWeight: 900,
                    fontFamily: "Sour Gummy",
                    color: "#000",
                    textAlign: "left",
                    px: t ? 2 : 10,
                    my: 2,
                  },
                  children:
                    "At the heart of the ecosystem lies $LILPEPE, the utility token fueling every corner of the Little Pepe network. You're still earlyjust in time to witness the rise of a new golden era for meme coins, with Pepe reigning supreme as King and Little Pepe.",
                }),
              ],
            }),
          }),
        ],
      }),
    ],
  });
}
const Nve = "/assets/buybg-Ct3FzdEw.png",
  Ove = "/assets/buy-Bnbp7ned.png",
  kve = "/assets/buy1-D7XU5AW3.png",
  Dve = "/assets/buy2-VG2To-Uj.png",
  $ve = [
    {
      img: Ove,
      title: "Create A Wallet",
      text: O.jsxs(O.Fragment, {
        children: [
          "Download metamask or your wallet of choice from the app store or google play store for free. Desktop users, download the google chrome extension by going to",
          " ",
          O.jsx("a", {
            href: "https://metamask.io",
            target: "_blank",
            children: "metamask.io",
          }),
          ".",
        ],
      }),
      bg: "#fbc5a0",
    },
    {
      img: kve,
      title: "Get Some ETH",
      text: O.jsxs(O.Fragment, {
        children: [
          "Have ETH in your wallet to switch to $LILPEPE. If you dont have any ETH, you can buy directly on metamask, transfer from another wallet, or buy on another exchange and send it to your wallet.",
          // O.jsx("a", {
          //   href: "https://littlepepe.cool/how-to-buy",
          //   target: "_blank",
          //   children: "Learn More",
          // }),
        ],
      }),
      bg: "#f4eb82",
    },
    {
      img: Dve,
      title: "Go to Uniswap And Switch ETH for $LILPEPE.",
      text: O.jsxs(O.Fragment, {
        children: [
          "Switch ETH for $BITPEPE. We have ZERO taxes so you dont need to worry about buying with a specific slippage, although you may need to use slippage during times of market volatility.",
          // O.jsx("a", {
          //   href: "https://littlepepe.cool/how-to-buy",
          //   target: "_blank",
          //   children: "Learn More",
          // }),
        ],
      }),
      bg: "#c499e1",
    },
  ];
function Mve() {
  const t = xs("(max-width:1050px)");
  return O.jsx(be, {
    sx: {
      backgroundImage: `url(${Nve})`,
      backgroundSize: t ? "cover" : "100% 100%",
      backgroundPosition: t ? "center" : "100% 100%",
      height: t ? "100%" : "90rem",
      pb: 5,
    },
    children: O.jsx(Kc, {
      maxWidth: "xl",
      children: O.jsxs(be, {
        px: t ? 0 : 4,
        children: [
          O.jsx(Ft, {
            pt: t ? 5 : 10,
            sx: {
              fontSize: t ? "40px" : "120px",
              lineHeight: t ? "40px" : "120px",
              fontWeight: 900,
              fontFamily: "Sour Gummy",
              color: "#000",
              textTransform: "uppercase",
              textAlign: "center",
            },
            children: "HOW TO BUY",
          }),
          O.jsx(xn, {
            container: !0,
            spacing: 5,
            mt: 5,
            children: $ve.map(({ title: e, img: n, text: r, bg: i }, s) =>
              O.jsx(
                xn,
                {
                  size: { md: 4, xs: 12 },
                  children: O.jsx(be, {
                    mt: s === 1 && !t ? 5 : 0,
                    sx: {
                      background: i,
                      width: "100%",
                      borderRadius: "16px",
                      border: "2px solid #000",
                      boxShadow: "3px 5px #000;",
                    },
                    children: O.jsxs(be, {
                      p: t ? 2 : 3,
                      children: [
                        O.jsx(be, {
                          component: "img",
                          src: n,
                          width: s === 2 ? "90%" : "100%",
                          alt: "",
                        }),
                        O.jsx(Ft, {
                          sx: {
                            fontSize: t ? "26px" : "32px",
                            fontWeight: 900,
                            fontFamily: "Sour Gummy",
                            color: "#000",
                            my: 2,
                          },
                          children: e,
                        }),
                        O.jsx(Ft, {
                          sx: {
                            fontSize: "18px",
                            fontFamily: "Poppins",
                            color: "#525252",
                          },
                          children: r,
                        }),
                      ],
                    }),
                  }),
                },
                s
              )
            ),
          }),
        ],
      }),
    }),
  });
}
const Lve = "/assets/rd1-bLCBH5Gx.png",
  Uve = "/assets/rd2-Qjocg_GW.png",
  Bve = "/assets/rd3-CTq3VPS5.png",
  jve = bp`
  0% { transform: translateX(-100%); }
  100% { transform: translateX(100%); }
`,
  Fve = bp`
  0% { transform: translateX(100%); }
  100% { transform: translateX(-100%); }
`,
  zve = [
    {
      title: "1. PREGNANCY",
      text: O.jsxs(O.Fragment, {
        children: [
          " Cooking in the cryptowomb",
          O.jsx("br", {}),
          " Mumma Pepe got a baby on the way!",
          O.jsx("br", {}),
          " Launch $LILPEPE",
          O.jsx("br", {}),
          " Big Name Partnerships",
          O.jsx("br", {}),
          " Community Hype = Max Vibes",
          O.jsx("br", {}),
          ' "Wen birth?"',
        ],
      }),
      bgColor: "#fff176",
      image: Lve,
    },
    {
      title: "2. BIRTH",
      text: O.jsxs(O.Fragment, {
        children: [
          " Its a boy! And hes moon-ready!",
          O.jsx("br", {}),
          " Listed on Top Exchanges & Uniswap",
          O.jsx("br", {}),
          " 1 BILLION MCAP or bust",
          O.jsx("br", {}),
          " Massive Marketing Blitz",
          O.jsx("br", {}),
          ' "LILPEPE GO BRRRRR"',
        ],
      }),
      bgColor: "#ffccbc",
      image: Uve,
    },
    {
      title: "3. GROWTH",
      text: O.jsxs(O.Fragment, {
        children: [
          " From baby meme to blockchain beast",
          O.jsx("br", {}),
          " Ultra-fast.  Secure.  Cheap.",
          O.jsx("br", {}),
          " Little Pepe becomes the KING",
          O.jsx("br", {}),
          " Hits TOP 100 CMC",
          O.jsx("br", {}),
          ' "All hail the LILPEPE on Ethereum network!"',
        ],
      }),
      bgColor: "#ce93d8",
      image: Bve,
    },
  ],
  Wve = () => {
    const t = xs("(max-width:1050px)");
    return O.jsxs(be, {
      id: "roadmap",
      sx: {
        position: "relative",
        overflow: "hidden",
        minHeight: "100%",
        bgcolor: "#006c28",
      },
      children: [
        [...Array(18)].map((e, n) =>
          O.jsx(
            be,
            {
              sx: {
                position: "absolute",
                top: `${n * 70}px`,
                width: "200%",
                overflow: "hidden",
                whiteSpace: "nowrap",
                zIndex: 0,
              },
              children: O.jsx(be, {
                sx: {
                  display: "inline-block",
                  animation: `${n % 2 === 0 ? jve : Fve} 300s linear infinite`,
                },
                children: O.jsx(Ft, {
                  sx: {
                    display: "inline",
                    fontSize: t ? "3rem" : "6rem",
                    fontFamily: "Sour Gummy",
                    fontWeight: "900",
                    color: "#f2c53b",
                    mx: 2,
                  },
                  children: "ROADMAP ".repeat(50),
                }),
              }),
            },
            n
          )
        ),
        O.jsx(Kc, {
          maxWidth: "xl",
          children: O.jsx(be, {
            sx: {
              position: "relative",
              zIndex: 1,
              display: "flex",
              flexDirection: "column",
              alignItems: "center",
              gap: 4,
              py: 8,
            },
            children: zve.map((e, n) =>
              O.jsx(
                aW,
                {
                  sx: {
                    width: t ? "85%" : "90%",
                    borderRadius: "16px",
                    border: "2px solid #000",
                    boxShadow: "3px 5px #000",
                    p: t ? 3 : 4,
                    backgroundColor: e.bgColor,
                  },
                  children: O.jsxs(xn, {
                    container: !0,
                    spacing: 3,
                    children: [
                      O.jsxs(xn, {
                        size: { md: 6, xs: 12 },
                        children: [
                          O.jsx(Ft, {
                            sx: {
                              fontSize: t ? "26px" : "32px",
                              fontWeight: 900,
                              fontFamily: "Sour Gummy",
                              color: "#000",
                              my: 2,
                            },
                            children: e.title,
                          }),
                          O.jsx(Ft, {
                            sx: {
                              fontSize: t ? "13px" : "18px",
                              fontFamily: "Poppins",
                              color: "#525252",
                              lineHeight: t ? "24px" : "50px",
                              my: 2,
                            },
                            children: e.text,
                          }),
                        ],
                      }),
                      O.jsx(xn, {
                        size: { md: 6, xs: 12 },
                        children: O.jsx(be, {
                          component: "img",
                          src: e.image,
                          alt: "step",
                          sx: { width: "100%", height: t ? "auto" : "400px" },
                        }),
                      }),
                    ],
                  }),
                },
                n
              )
            ),
          }),
        }),
      ],
    });
  },
  Hve = "/assets/tok1-DfTIJjUi.png",
  qve = "/assets/tok2-IeBdbCbz.png",
  Vve = "/assets/tok3-DKscWhzS.png",
  Gve = "/assets/tok4-CzizE6eK.png",
  Kve = "/assets/tok5-Cgcv5gkJ.png",
  Yve = "/assets/tok6-CEw4dUPl.png",
  Zve = "/assets/tok7-BvvnLfhw.png",
  Qve = "/assets/tokenbg-CBoAsHyF.png",
  Xve = "/assets/star-left-BysBeBQw.png",
  Jve = "/assets/star-right-B9HcfA9z.png",
  ebe = Ki(
    O.jsx("path", {
      d: "M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2m0 16H8V7h11z",
    }),
    "ContentCopy"
  );
function tbe() {
  const t = xs("(max-width:1050px)"),
    [e, n] = N.useState(!1),
    r = async () => {
      try {
        await navigator.clipboard.writeText(BC),
          n(!0),
          setTimeout(() => n(!1), 2e3);
      } catch (i) {
        console.error("Copy failed:", i);
      }
    };
  return O.jsxs(be, {
    id: "tokenomics",
    sx: {
      backgroundImage: `url(${Qve})`,
      backgroundSize: t ? "cover" : "100% 100%",
      backgroundPosition: t ? "center" : "100% 100%",
      height: "100%",
      pb: 5,
      position: "relative",
      zIndex: 1,
    },
    children: [
      O.jsx(be, {
        component: "img",
        src: Xve,
        sx: {
          position: "absolute",
          zIndex: 1,
          top: t ? "2%" : "14%",
          left: "2%",
        },
        width: t ? "100px" : "200px",
        alt: "",
      }),
      O.jsx(be, {
        component: "img",
        src: Jve,
        sx: {
          position: "absolute",
          zIndex: 1,
          top: t ? "2%" : "14%",
          right: "2%",
        },
        width: t ? "100px" : "200px",
        alt: "",
      }),
      O.jsx(Kc, {
        maxWidth: "xl",
        children: O.jsxs(be, {
          px: t ? 0 : 4,
          sx: { position: "relative", zIndex: 1 },
          children: [
            O.jsx(Ft, {
              pt: t ? 5 : 10,
              sx: {
                fontSize: t ? "40px" : "120px",
                lineHeight: t ? "40px" : "120px",
                fontWeight: 900,
                fontFamily: "Sour Gummy",
                color: "#000",
                textTransform: "uppercase",
                textAlign: "center",
              },
              children: "Our Tokennomics",
            }),
            O.jsxs(xn, {
              container: !0,
              spacing: 3,
              mt: 5,
              display: "flex",
              justifyContent: "center",
              children: [
                O.jsx(xn, {
                  size: { md: 3.5, xs: 6 },
                  children: O.jsx(be, {
                    sx: {
                      display: "flex",
                      justifyContent: "center",
                      alignItems: "center",
                      border: "1px solid #000",
                      borderRadius: "12px",
                      backgroundColor: "#fff",
                      margin: "auto",
                      boxShadow: "2px 5px #000",
                      height: t ? "40px" : "70px",
                      fontSize: t ? "14px" : "25px",
                      textTransform: "Uppercase",
                      fontFamily: "Sour Gummy",
                      fontWeight: 900,
                    },
                    children: "Name: Little Pepe",
                  }),
                }),
                O.jsx(xn, {
                  size: { md: 3.5, xs: 6 },
                  children: O.jsx(be, {
                    sx: {
                      display: "flex",
                      justifyContent: "center",
                      alignItems: "center",
                      border: "1px solid #000",
                      borderRadius: "12px",
                      backgroundColor: "#fff",
                      margin: "auto",
                      boxShadow: "2px 5px #000",
                      height: t ? "40px" : "70px",
                      fontSize: t ? "14px" : "25px",
                      textTransform: "Uppercase",
                      fontFamily: "Sour Gummy",
                      fontWeight: 900,
                    },
                    children: "Symbol: LILPEPE",
                  }),
                }),
                O.jsx(xn, {
                  size: { md: 5, xs: 12 },
                  children: O.jsxs(be, {
                    sx: {
                      display: "flex",
                      justifyContent: "center",
                      alignItems: "center",
                      border: "1px solid #000",
                      borderRadius: "12px",
                      backgroundColor: "#fff",
                      margin: "auto",
                      boxShadow: "2px 5px #000",
                      height: t ? "50px" : "70px",
                      fontSize: t ? "18px" : "25px",
                      textTransform: "Uppercase",
                      fontFamily: "Sour Gummy",
                      fontWeight: 900,
                      gap: 1,
                    },
                    children: [
                      "Contract Address:",
                      " ",
                      BC.slice(0, 4) + "..." + BC.slice(-4),
                      O.jsx($q, {
                        title: e ? "Copied!" : "Copy",
                        arrow: !0,
                        children: O.jsx(XS, {
                          onClick: r,
                          size: "small",
                          children: O.jsx(ebe, {
                            fontSize: "medium",
                            sx: { color: "#000" },
                          }),
                        }),
                      }),
                    ],
                  }),
                }),
                // O.jsx(xn, {
                //   size: { md: 3, xs: 6 },
                //   children: O.jsx(be, {
                //     component: "img",
                //     src: Hve,
                //     width: "100%",
                //     alt: "",
                //   }),
                // }),
                // O.jsx(xn, {
                //   size: { md: 3, xs: 6 },
                //   children: O.jsx(be, {
                //     component: "img",
                //     src: qve,
                //     width: "100%",
                //     alt: "",
                //   }),
                // }),
                // O.jsx(xn, {
                //   size: { md: 3, xs: 6 },
                //   children: O.jsx(be, {
                //     component: "img",
                //     src: Vve,
                //     width: "100%",
                //     alt: "",
                //   }),
                // }),
                // O.jsx(xn, {
                //   size: { md: 3, xs: 6 },
                //   children: O.jsx(be, {
                //     component: "img",
                //     src: Gve,
                //     width: "100%",
                //     alt: "",
                //   }),
                // }),
                // O.jsx(xn, {
                //   size: { md: 3, xs: 6 },
                //   children: O.jsx(be, {
                //     component: "img",
                //     src: Kve,
                //     width: "100%",
                //     alt: "",
                //   }),
                // }),
                // O.jsx(xn, {
                //   size: { md: 3, xs: 6 },
                //   children: O.jsx(be, {
                //     component: "img",
                //     src: Yve,
                //     width: "100%",
                //     alt: "",
                //   }),
                // }),
                // O.jsx(xn, {
                //   size: { md: 3, xs: 6 },
                //   children: O.jsx(be, {
                //     component: "img",
                //     src: Zve,
                //     width: "100%",
                //     alt: "",
                //   }),
                // }),
              ],
            }),
          ],
        }),
      }),
    ],
  });
}
const nbe = Ki(
    O.jsx("path", { d: "M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6z" }),
    "Add"
  ),
  rbe = Ki(O.jsx("path", { d: "M19 13H5v-2h14z" }), "Remove"),
  ibe = "/assets/faqbg-X4aLXisi.png";
function sbe() {
  const t = xs("(max-width:950px)"),
    [e, n] = N.useState(!1),
    r = (s) => (o, a) => {
      n(a ? s : !1);
    },
    i = [
      {
        id: 1,
        question: "What is Little Pepe (LILPEPE)?",
        answer:
          "Little Pepe is a new born pepe, all wrapped in the power of memes. LILPEPE is the ERC-20 token that fuels the entire Little Pepe ecosystem.",
      },
      // {
      //   id: 2,
      //   question: "How Can I Buy LILPEPE?",
      //   answer:
      //     "LILPEPE is currently in its presale phase and can only be purchased via the official website: littlepepe.cool | Caution: Do not attempt to buy LILPEPE from Uniswap, PancakeSwap, Raydium, or any other platform. These are not official listings and may be scams.",
      // },
      {
        id: 2,
        question: "How Can I Contact the Little Pepe Team?",
        answer:
          "You can reach the Little Pepe team via Community",
      },
      // {
      //   id: 4,
      //   question: "How Can I Claim My Tokens?",
      //   answer:
      //     "$LILPEPE tokens will be claimable once all presale stages are sold out, in accordance with the vesting schedule. Claiming and vesting information will be provided via the official website and communication channels.",
      // },
      {
        id: 3,
        question: "How can I check the amount of tokens I bought?",
        answer: "You can check the amount of tokens you own on etherscan.io",
      },
    ];
  return O.jsx(be, {
    id: "faqs",
    sx: {
      backgroundImage: `url(${ibe})`,
      backgroundSize: "cover",
      backgroundPosition: "center",
      height: "100%",
      pb: 5,
    },
    children: O.jsxs(Kc, {
      maxWidth: "lg",
      children: [
        O.jsx(Ft, {
          pt: t ? 5 : 10,
          sx: {
            fontSize: t ? "40px" : "120px",
            lineHeight: t ? "40px" : "120px",
            fontWeight: 900,
            fontFamily: "Sour Gummy",
            color: "#000",
            textTransform: "uppercase",
            textAlign: "center",
          },
          children: "Frequently Asked Questions",
        }),
        O.jsx(be, {
          display: "flex",
          justifyContent: "center",
          pt: 5,
          children: O.jsx(be, {
            sx: { width: t ? "100%" : "80%", pb: 10 },
            position: "relative",
            zIndex: 1,
            children: i.map((s, o) => {
              const { id: a, question: l, answer: d } = s;
              return O.jsx(
                be,
                {
                  mt: 2,
                  sx: { width: "100%" },
                  children: O.jsxs(I9, {
                    expanded: e === `{panel${a}}`,
                    onChange: r(`{panel${a}}`),
                    style: {
                      background: "#fff",
                      boxShadow: "0px 5px #000",
                      border: "2px solid #000",
                      borderRadius: "14px",
                    },
                    children: [
                      O.jsx(Q9, {
                        expandIcon:
                          e === `{panel${a}}`
                            ? O.jsx(be, {
                                sx: {
                                  borderRadius: "50%",
                                  height: "35px",
                                  width: "35px",
                                  background: "#F2C53B",
                                  display: "flex",
                                  justifyContent: "center",
                                  alignItems: "center",
                                  border: "1px solid #000",
                                },
                                children: O.jsx(rbe, {
                                  style: { color: "#000", fontSize: "30px" },
                                }),
                              })
                            : O.jsx(be, {
                                sx: {
                                  borderRadius: "50%",
                                  height: "35px",
                                  width: "35px",
                                  background: "#F2C53B",
                                  display: "flex",
                                  justifyContent: "center",
                                  alignItems: "center",
                                  border: "1px solid #000",
                                },
                                children: O.jsx(nbe, {
                                  style: { color: "#000", fontSize: "30px" },
                                }),
                              }),
                        "aria-controls": "panel1bh-content",
                        id: "panel1bh-header",
                        children: O.jsx(be, {
                          px: 2,
                          textAlign: "left",
                          sx: {
                            fontSize: t ? "22px" : "32px",
                            fontWeight: 900,
                            fontFamily: "Sour Gummy",
                            color: e === `{panel${a}}` ? "green" : "#000",
                            textTransform: "uppercase",
                          },
                          children: l,
                        }),
                      }),
                      O.jsx(N9, {
                        children: O.jsx(be, {
                          pl: 2,
                          pb: 3,
                          sx: {
                            fontSize: "18px",
                            fontFamily: "Poppins",
                            color: "#525252",
                          },
                          children: d,
                        }),
                      }),
                    ],
                  }),
                },
                o
              );
            }),
          }),
        }),
      ],
    }),
  });
}
const obe = "/assets/footbg-BU8FREcb.png",
  abe = "/assets/footpepe-DMmKo7m8.png";
function cbe() {
  const t = xs("(max-width:1050px)"),
    e = [
      {
        icon: O.jsx(XL, {}),
        label: "TELEGRAM",
        link: "https://t.me/LittlePepeErc20",
      },
      {
        icon: O.jsx(QL, {}),
        label: "TWITTER",
        link: "https://x.com/LittlePepeErc20",
      },
    ];
  return O.jsx("div", {
    children: O.jsx(be, {
      sx: {
        backgroundImage: `url(${obe})`,
        backgroundSize: t ? "cover" : "100% 100%",
        backgroundPosition: t ? "center" : "100% 100%",
        height: "100%",
        pt: 10,
      },
      children: O.jsx(Kc, {
        maxWidth: "xl",
        children: O.jsx(be, {
          px: t ? 0 : 2,
          children: O.jsxs(xn, {
            container: !0,
            spacing: 3,
            children: [
              O.jsxs(xn, {
                size: { xs: 12, md: 3.5 },
                display: "flex",
                flexDirection: "column",
                justifyContent: "flex-end",
                children: [
                  O.jsx(be, {
                    component: "img",
                    width: t ? "270px" : "320px",
                    src: hv,
                    alt: "",
                  }),
                  O.jsx(ds, {
                    to: "https://littlepepe.cool/little-pepe-whitepaper.pdf",
                    target: "_blank",
                    style: {
                      textDecoration: "none",
                      opacity: 0,
                      pointerEvents: "none",
                    },
                    children: O.jsx(Ft, {
                      sx: {
                        fontSize: "24px",
                        fontWeight: 600,
                        fontFamily: "Sour Gummy",
                        color: "#000",
                        textTransform: "uppercase",
                        mt: 3,
                      },
                      children: "Whitepaper",
                    }),
                  }),
                  O.jsx(ds, {
                    to: "https://littlepepe.cool/how-to-buy/",
                    target: "_blank",
                    style: {
                      textDecoration: "none",
                      opacity: 0,
                      pointerEvents: "none",
                    },
                    children: O.jsx(Ft, {
                      sx: {
                        fontSize: "24px",
                        fontWeight: 600,
                        fontFamily: "Sour Gummy",
                        color: "#000",
                        textTransform: "uppercase",
                        mt: 2,
                      },
                      children: "How to Buy",
                    }),
                  }),
                  O.jsx(ds, {
                    to: "https://littlepepe.cool/777k-giveaway/",
                    target: "_blank",
                    style: {
                      textDecoration: "none",
                      opacity: 0,
                      pointerEvents: "none",
                    },
                    children: O.jsx(Ft, {
                      sx: {
                        fontSize: "24px",
                        fontWeight: 600,
                        fontFamily: "Sour Gummy",
                        color: "#000",
                        textTransform: "uppercase",
                        mt: 2,
                      },
                      children: "Win $777k",
                    }),
                  }),
                  O.jsx(ds, {
                    to: "https://littlepepe.cool/terms/",
                    target: "_blank",
                    style: {
                      textDecoration: "none",
                      opacity: 0,
                      pointerEvents: "none",
                    },
                    children: O.jsx(Ft, {
                      sx: {
                        fontSize: "24px",
                        fontWeight: 600,
                        fontFamily: "Sour Gummy",
                        color: "#000",
                        textTransform: "uppercase",
                        mt: 2,
                      },
                      children: "Terms & Conditions",
                    }),
                  }),
                  O.jsx(ds, {
                    to: "https://littlepepe.cool/privacy/",
                    target: "_blank",
                    style: {
                      textDecoration: "none",
                      opacity: 0,
                      pointerEvents: "none",
                    },
                    children: O.jsx(Ft, {
                      sx: {
                        fontSize: "24px",
                        fontWeight: 600,
                        fontFamily: "Sour Gummy",
                        color: "#000",
                        textTransform: "uppercase",
                        mt: 2,
                      },
                      children: "Privacy Policy",
                    }),
                  }),
                  O.jsx(ds, {
                    to: "https://littlepepe.cool/cookies/",
                    target: "_blank",
                    style: {
                      textDecoration: "none",
                      opacity: 0,
                      pointerEvents: "none",
                    },
                    children: O.jsx(Ft, {
                      sx: {
                        fontSize: "24px",
                        fontWeight: 600,
                        fontFamily: "Sour Gummy",
                        color: "#000",
                        textTransform: "uppercase",
                        mt: 2,
                      },
                      children: "Cookies",
                    }),
                  }),
                  O.jsx(Ft, {
                    sx: {
                      fontSize: "20px",
                      fontFamily: "Poppins",
                      color: "#000",
                      mt: 4,
                      mb: 2,
                    },
                    children: " 2025 LILPEPE all rights reserved.",
                  }),
                ],
              }),
              O.jsxs(xn, {
                size: { xs: 12, md: 5 },
                order: t ? 3 : 2,
                children: [
                  O.jsx(be, {
                    component: "img",
                    src: abe,
                    width: "100%",
                    alt: "",
                  }),
                  O.jsx(Ft, {
                    sx: {
                      fontFamily: "Poppins",
                      fontSize: t ? "11px" : "14px",
                      textAlign: "center",
                      px: t ? 0 : 5,
                      pb: 1,
                    },
                    children:
                      "Disclaimer: Cryptocurrency may be unregulated in your jurisdiction. The value of cryptocurrencies may fluctuate Profits may be subject to capital gains or other taxes applicable in your jurisdiction",
                  }),
                ],
              }),
              O.jsxs(xn, {
                size: { xs: 12, md: 3.5 },
                order: t ? 2 : 3,
                display: "flex",
                justifyContent: t ? "flex-start" : "flex-end",
                alignItems: "center",
                position: "relative",
                zIndex: 1,
                children: [
                  !t &&
                    O.jsx(be, {
                      sx: {
                        width: "15px",
                        height: "63%",
                        background: "#000",
                        borderRadius: "4px",
                        position: "absolute",
                        zIndex: 1,
                        bottom: 0,
                        right: 0,
                      },
                    }),
                  O.jsx(cx, {
                    spacing: 2,
                    children: e.map((n, r) =>
                      O.jsx(
                        ds,
                        {
                          to: n.link,
                          target: "_blank",
                          style: { textDecoration: "none" },
                          children: O.jsx(ha, {
                            variant: "contained",
                            startIcon: n.icon,
                            sx: {
                              backgroundColor: "#000",
                              border: "1px solid #fff",
                              color: "#fbc02d",
                              borderRadius: "10px",
                              padding: "10px 20px",
                              justifyContent: "flex-start",
                              minWidth: "250px",
                              boxShadow: "0 0 5px rgba(0,0,0,0.5)",
                              textTransform: "none",
                              "&:hover": { backgroundColor: "#111" },
                            },
                            children: O.jsx(Ft, {
                              fontWeight: "bold",
                              children: n.label,
                            }),
                          }),
                        },
                        r
                      )
                    ),
                  }),
                ],
              }),
            ],
          }),
        }),
      }),
    }),
  });
}
const lbe = "/assets/part1-BAiaOlvg.png",
  ube = "/assets/part2-BHtImr6a.png",
  dbe = "/assets/part3-BZabr5AB.png",
  pbe = "/assets/part4-CZF_GrMl.png",
  fbe =
    "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAO4AAAAxCAYAAADdhpXYAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAA2/SURBVHgB7Z3NbtxGEseL+ggS28DOdU+hn8DybS+JqSew/AQeP4GlQ4BYY0AUQlsBcpD0BB49geXb3jwOcvfktjfRT7BaIHGcWBK3/jNFheJ0NZscUlaU/gEDjdgk+7Oqu6urewL6RHzzTbyyuEi98vXvv49H5Lmy+Hq7Gix9+23cpwYEAR1nGR1/+EDjvb34mGqyvEwv+R2h6dXkubL4ersaLLH2fEFzcPMm0WAQp/x1dHpKB17zejzds0DtEPKnz0rgNQvxC+7FQ/J4PJ3RluAWmQjw5ma8Qh6PpxO6EFwQ8jzo5fp63COPx9M6XQkuCHn+u0sej6d1lrQA7jFXk8RsaIrjODw5oZCtyn3+9yHp9LnX3WhidfZ4PDpL1AAW3JT/4DNiQ1SMOS2RcYmAbtygNf4zJI/H0xpzD5V5+Sfl3vmR5ZaQPB5Pq7Qyx014SM3D5pQ8Hs+l0JpxinvdlDwez6XQaI6rEJouLizQiDqG59nR4mLG68bBl/xvvgTFBrHs3elpMG7bmwvLXF98QdHCQhZynHcKQXAD/fnsjEaYQlAHGPKa5/OwKk44xvCza4ZnOymjzz+nNbZ/3KGO6ySPi9saliG/zK9zXbzjz/i332jUtoFU4lzhOCOJ85jr/c3OTnxoe06ck6JiWpukMxgM4swYYLEqGxITiYGqTPrsWXzb9MzmZnxk8nnl+518XlFwN24Ej1l41jnT1vVi8as+PD2l7XkESvK5xe9bqYqTSfme7efP4yE5wPWA8ovK78jLL4/bcE8RuJ0+KufR8Vmn9FbVGxrm0hLt8rvWyE6t8jHx5EkMYX1M9nzVqn/OX5/vn3EDlrTG+P706TbHmcWGNmBr73jvw6q0MsNiOpV2Mf9QearFzf7OnNAD6gAU3K1bxA3IWHgzyD3w6Dra3NzeopogjyhAUU6RS5w0dUJ5wc8dodJoDgaD7Yd53BW3QkDfFr3WUFaOz07S26R8iulkoX3rILTn8aF86rrIIn+oDxbal1Sdr2L9v4aw0xxw3C+yLNtzbAN523kryiByeATpfPvkyda67aZGPa4UNAT2Pt/XVzIxZu1zlxSa9LjoZW/edKusClLWaqsuvS8aCTeQ164VpZFlQfz8+da2Fq71uOhBldGMjWN+7q4M42pvIjk7yzZ2drb3TGFavQVBsI4GTc1A7/uAe7Rx1Y1QDlyaQ5qDivypPS5f/wd/tQnUhR53/rYT9Dlm/sy2d3WOy5FhwwBVkRnEnjN4+Msv1iWi2ojQogG34QMNpfOa33nXNqdoS2gBRgfcm5FNeE003L3Vk+Fqo7JaWAi2uGyGdeaFcwgtmLjIcodgVaYYPdjiwZCY55nHXGc9W51x/nafPo3HSeI+z+Z336MaHQY6t/nbziSvqSmkTeMUGHEGt5Ok/a19LLQYwlkbIpakcuu2wzw0lN571RSIgkdjqir4OnFCeLnHYK285TqFCC3xIZ4VS7rWZuOfzPVS+ddWlmx8m2j6eYSxdn2IklLrwyK0Q0zLkkK7E8HBiAPtJjSkDXHdJneiGvdC4VYKbaE+oCBN9anWcZuCi8jHJyfUOjJHtA1RhlwA++Whlsy/Y9LdMiO822QgEWNOaHoIBc5/9nlUsVfulViTr3Fadkl1PMn2uDd7VdfKify9f09x8TnJH5RPVc86cZJJSg2be2VMc4xzWu6V7lNDwYXyNpUNRjAchnpU64PLL0oMil+fLmQbz57NDnul5x5yPkdKGYVa3TvA7Sw7WF4ODo+PJ20BHoJwAQ7xXdprqD2MESn/2U9K+ZwaXGlNUzZF2hRcaId1LqR1bKx3nUO6IBkxwlr10XffmQtf4u8PBltc0MGu8m5cv/C8zOH7ZCZl5aTmLUkmywGH3ABhwHhsuAWVg8YbkyMQBJ47zdyPNMRxvMrpObJod2NdyP8xp7OnpLP2MFsU2oNEGXGJYu1znKmmMOT6hec1QZiO7ratygX55Pp8IEazXul5KJAh1UA6CFMnMpZP4/Yqis6mbP58D3UDeoKjqSFhPrCUQXrvtaEVQpGpRs42lOAetHzxgvS2JpwVUpJMKndkCuOKfUzupPyuWAtkwcW8Th16w6hiSy8Lvdbwe4NB8iXVAIa0xGGaxPfEXAb7SnBUjlcEbAZO+5AcQP45ba9McdXcejpUhPYcseiHpjAoGpf2Kul9IIrQiCq4qHD+PNI+EARoHxIto7xlWBaKurCGWlOCxqYhkobcOzKFccMvxxGZ7qsSgjJoyEpQz7Vc2AK673CbWgdVQ0HkJ2vHXXVY5XxQhHvAWGuYZ2cfH+TfWTFBsCLDbbWcXDiukek6HGnIEayvVt3DdoxICbIq4DLIG7dLte7VoTI8nhJHIxMaoUz2w3IYrldZb21wgd8xXRelUZOMtW4QGeLAfG6iSfOlLtPT8IiiGqDwedqAZ6Jy2OkpvJ+q37e4GIyr7uF0pTxKMDEiB8SAFM5eP4Hx5h05UHfNHiMF7p32TcNKnl+f1/mHD7Si5A29W0yOcHu+o6yAoB5cFI6TouBlsXumeBwV8AU++4z2Pn40j/5ameMmLOAw5ZvmEUw4j4USE/7AsLLLGaps0GXgFsiNwDTXLaY5VB5v6MaoKYsgpI7hsvsfXRJJg5UEdA7KXDfMv4h7p+lxWIwjciTLzNeLLpIVz//seJ9x6O2igMuIcktN6+atzXGlazdqXbFQNgJrcqbrP/wQ1y4Ii+Cdx8HKxxhfUyHIssA40pDFfIfnl46oIRzHf+lySKkBPEdNlaDzOuDyqzMH7RLXEaMxvb//7vz8BQJl807bxilNmGpbKHOwoE6ea4mmlIkutc5DapE2nHVc6PLMqSKtZ6auxRNYTp48byiYL5pu0ObaDoSmi5c5jL0EwiYHA3JZuzyT0l8IrYdcXm7WeckcfIZWPafYotajlg+0Z608zhe2i2TZCSy2MdVgavEzpu98pMAGgZTnzyYmjbOukU0MX9Y4rwNNjihie4Nxmac4n+T6T03zU8t66icFaTfNvZusGWMpVOvBW+5x1bls46FPlmVvjDFxQdTX8sFjcxx/NhQYBLTlEXGccEbWoI0as4lx7SqjrbVq5PtSleDzsmGbw9i0bGRRiJ8arV6jukujmmIDrQnudI+iuv75hhqyvBwMlaBQ/JedkO1qoSmMtfph6ZLRyIalC9eD3qFULBsE0ibGtStOVGdLIDZBkMOymyhSU1mFdQWB01fH8aURPGI71NansTTquoVRyrKvhc8tuGigvFa5W7E75JAagoojfT1y3aWxIH1w8FeCZ3aJYP1MK3y+/rqqwaByZCdTaAqHIwddQ2QHlLU+0F6me1pVx5qZZTd4HJludBWEPE5O3x7/fdnlT+SIonmlBIdVe4JzebK01wm2bX0POZORFi7rXyvk4OA+zykHkpYNju8tGdOBHTcxnOW3i0fGFI5pgZYNLe+e8W6yOQcwPdnyiJMKDoq/VoihMS993as4lWPu8rjKFOvj/Xs6LJRNyGXzkMP7ZK+PmdFOwopVcWTJBWFD89qS0z/OnYO4TnGczkrVFsJ54HYR84jivtIGsGvp5TQ/2Ssc45NfxzE/lv3tF7AZp/pBC3amiqNbnYBz+mCwtaFtFCA5TQEeNhf3EAdVaYPzvnHIKl4rmGOEyuM4qaAvv1ZYuJypi/0Avs50/ZnUB5fNi3LZVDDUlFrhQIGwHFcuCJiS5asCctYVOpXI8LpwehpK/KgLJTr1mMO+68D2Sx4RHHPKXmFZZRFN6XQ5CDshkpb25oqvcS23ugqwfzPWAtHripCl1BIoj660/CcGyi+l+UhtvsDiU21zvJ/svUXvKj0sDIkR6YwxIqCOaKm9plpAV4ILN61Vl50QdeDesa/Nd+qApQS8q+o+2aUxt/CisXVRHleI4wqhqsJp1xVGXicnhOOQUpqP0a+/0mrXP40zZ3tNbaOztgUXw5VHOHcn6eAUDJBMt4Q1FaaJQqmz/ofGhPzMUQEjNLako/K4KkCoeJhau16wqZyF6K7rSKSgTGv3ZlPFgo33cedCm5NwexU7SlrjsVGFIkuXmmzpEs2KTyoeQOOiIcLxHanreL5MMhWC29hgzcPP+xYLZX48CBrVfp1tZ4Y4YzZoDOU4FBi8Vmxxwm8by0yJo8Dy/e9MXjcudgaOR1t7dvLOqhO3Um+Teofw8hTj7h9/2E9xkDo5LB8340p+QIL8blXM3++R3eCVchkdTE/l2La2UZSlyXuOjWqNBV3m0cO8vZLhpFBTmdis3+26OX1CZImmV3Kjg0JJu9CuMNvfukUrHF+YX0Olw2FAfhTtb48ctheW68TlNMe6yFE84V+lPtB+er1pueD4G1MblaN+TKspo2sjuB7PdcNyVOyry9pk4PF4aiLD6hmyLPM9rsfTFfkpnDg/qu4yoDxr3IvN77vte1yPpwPEV31ygH/dnz4RoVWOoyX8YFra9oHoHo+HJgf4FzdR5N5dEzdZ7ZcKp7/WkWFeu6W5PeZnrfmhssfTMi4/lSI7ntLCZViQwwo/5fPfJvI9rsfTItO1V/vOHhHOyHBdBcKOg/jz/xfJ4/G0xk8/jY6//jr6J3/9F7WEOPSs7uzE/8mvecH1eFrmxx9H//7qq+idnBdVuUWvgjHcH4tCC/wc1+PpkBq/RF8Gfv8H2rZDL7gezyUgLrIRD3lX5FcVZnyVpz7jWYpfAaxy0/w/3GccYSNpjskAAAAASUVORK5CYII=",
  hbe =
    "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAANYAAAAyCAYAAAAgNiW6AAAACXBIWXMAAAPwAAAD8AHY5UrEAAALw0lEQVR4nO1dTW4rxxHuJwjJJgDHyCor0WsH0fgEmgdkkVU0PoHoE2QCZG/qBOY7gUcnMIUcwENkG8DkCUydIBTiTRYBg8n7Su9Dsbrnh8Mfyf0BDYkz/VvdVdVdXd3zbrvduhYYO+cyhPr/m0CSlXNu6ZyrENY7MSIi3jiaGGuCoBnpGcyjUTPdlXq2cM6VCBERvwj4GCt3zs2ISWpGmiPUWmizk+ITEtJuOeXxBCatdlJERLwxaMZKoFluB9Q2NXMVpPU+4HdExJsFM1YCbXINDVUMPH3Lkd8I67CsQfNFRLxaCGMxUx1y0HM5C5RzjkhRV4e1ZBMtxggOca31p46n8xVarA2Dj7zjvLmOPnBeTfF5im6V50OoD33pE9THKpvB9BK06Y+20PVoqo9r3U81Y2232/n2I5bb7TbBs64h2Z4H1j3rX4cU6TVKD10Soh1jjbx0/CnFydQ7wcYoS1DRs2qn1F1MO8RvKs8XQrDST9FGRv174olrYa3aZoWS0hXGe4c+8GFp9BG31yr/hW4X4LJbTP/20VQhyXVMhKRNCCnSsrFFcAfDjUZF61EHGjrkURnStg3qqfL0TGg5NGqD2DdooyMa17+/w3KhDa6QT4hOnNdk520z6lnVDx6N1ogLMiRM91SxUoGv6inmCcI9yremHm0wpQ7/K5jiM0xZHYwvTOQCxK/x6Jz7HGmkHiMMpD74S4sOzYjG9/ScaW8NvIWnb/bFvZEnC9sx2uXAUO/x7D3FCTGA5MnxfUawnPrSoZ+ahNx75P8Z+l9g0bARFyRx9zVUCBFPZU6Xgdi3fKHDMzHERtGF1ygsEQvMtzfoCJHErM26oi9TniuYXjPqp/rvAxi+jTNBRcJutPP2I6SsZ+NZEzaon/RhaF3qxSVeLAZYEN7A8HEqS18W2LjuAj3la9puWBkDYk7SuSsWoOUNJHio7D4YG1K4NNrQFZnKdx0QSprGIU2lkdLWzePO248QJpoj/jXKaCusLEcHK453+XO586QfzkFbjQKE7oKuA8wSJNaztpAN+FsMBGtttw9kfcIYwvXsRnnoLAJCQcqaGVNe32DVngxPhoBwahoo7bqm6aCvnROUnShG99H/DsGEMFafRTZDiLGvtti3/HP06kh6MFqBNh3CkGFp9SFmGU9q0LYZC6nhLtcWvjrzlG+Osf0NvfNpLYtJHgLxgxDGukIj+zLGqQf2kOVricl7HdYeimVksJ51wZosaH2nlD4sjTYOgbKDEMgx6AvSENbAZojRoqbtt9BApUFrXl9ZU04fozwowTBv4Id7o70vWpWngtMOCzyNG0NiHROpRxJ3wRMEjJagE3SkQ+cK8wqDjQyhxIYQn2RtwhRlN831Xwt4bORq4LZhdDZ2yBbRtYrD08CR0Zeh6WA5pGJgxrrtuVg+tbaSheZi5003lDRlqCDZEmXSZeaZEQNJ/LWSYj7p2BYT7KUMicQzkK3+s+L6vCmsxTzHnYMeI9JOJcroKtCXRHueanM+bJZPSTiGpoPDgXb75a/lMRAKhWfnOoRQfn29OKyd8C4hwW67D5ZnQOmJu/V4sbTxvNDtYM8Oy5NB52u97+t5YUHXIQQdNw/ErTFr2S5+ntNzGcdLo/3WO/a8sLwsrCCwxttLP4nGWkLa1pLkR+fc1x00V9JSWyTkI9gE0RJdzPc+601bbCBxC0g1mWYsAta5Ca0VZNqxIums676m9ut3C4rDKJTfooV1C7r60loI5aXz6RK3psuX0Oq8x+ejsa9dJWnHlMzqS3qvMaM0ouU2gf7wwddPjt4t3/1fFHxyiJ3SdOiRNj73RT1N+Ltz7veeRZ/GGo1vszmXGx0SEXFSXKDwGwziKVySniFRfvJYXtoiRfqfwFTOM5dnyILdkjqChJjeWi9ERJwUorGcmv7JwC2Uw+ScNt2sqUVKi9hcWbR+ds79Br5YIbVbgdG/NMpIUSdZ/MZzXRFnCWasZzAFD9KETgBr06ZgQZ4PGisw6z+dc//A75D2S7HG0/F8d29YzBcRcXKwuX0EJmCT5YZ85cT0mqqFowx2WbiJRmM3mQm9C0GMFiWYfKK05jP9fx+ZKuJcIRrrCYwj/naTgadXM3gQfBUwNNTl/wv/L5R2egCzzeiUc0jzRUScFGK8WJN3+O0B3F7a+BLyRuwN6vIB55zEQVLu4+hzcC0i4mgQxkqImVYwOvywp0VQ8AcwRJPLkzDLEx00FMtfStsA0wYGjYg4Odh48TntH2mL4Iosgm1cl9gyKBuBDwFNMyF3KsvMvnwFF9BERLyAGUsPfGEwyxE05BGhLYT/cc79Glqoj4+WbFo/I++Q1tsHoVuMKnguD8XYYpQZQ5D4jpifKxL0ZY5xEC9iVWDGcsp7m5FR8JnWGSvSbkVgX6oJY6QZdXSz6oPKMOcL3g3MWBuyuOqTthZycrc6B0xw+csjOR77BO0vE3Aa7OOEO4bjIoexEU/ytfJoCuI4Om+IN0RI0Q5xKi6pXdKOCo61WcBpM/XQQTuilpRHpugutBUn3oqu40qpDmNVruSXUPpE5dWmjuykarVTHINzz3iR8sZGPXVdfG3Wz7mNVvpE1cWKa9XnIIEHTEFMkA9UWEb5W+9DgetjEfJQQeqsvZe3uM+O78RjT+lcecfPjXqn211wH0g88d7OjHsLK08dRQhxG9j7PmtZR2d4+vM9flZ9dPqt4U2v7xPkus9U3JKYRGjB9WEFkKh2rpWA5FMJUndLGAwadKdOFNH35WwhiuViHwpj6oShmLyrMLAYS55ndLFnSsdcQp0qg0BrxCbGSjGoWGNZdbQYS/oxB025jlJG6DjMHHFLipvSINeaVtNqoo4VzYl2G1XXJeop8StFC3kvTFiquhaU95L6ZEm03+55oWvrIOZ2MamXWGc9KSfcvuuKP+KvtW4LQe54fwhsKJ8KU7SH/SqFfrIfKEYQbQXlg3/rlnRZ0pqs6rhOXZH3P1+NzP1pHTLM6W9FpxEydT1BqD4L2tQXFEgzR/9mVJcZHbfRDgL8Xuoi97RIXRPyG5WTwg/0f075HByXWIDy6eGKnF0Luo3mmY5TL42TpGMKKW3ouoYBpC9bKeio/7lZy6yzQY4Yi0/RLgKDrgk+62RXsFAa01+uo8/Kym2VOF0uHbLaLvlYhg5fPZrSjugWZ6fOWJUYuzm9P4qgvkRBt5AEc5KOUzKpigNs8MonD1b245f77TLV6SKRhnarOiRkEC09GqANmJmsGQIP6o3xzGfRFEgdK0OTWnFTEno5pW2Ltn0n9eK2jNVlmyHIXSUTD3Ou8O6arJgHxyW4WhhnpoiunXBTmur4PDLE+fYL59zfjM7Q38viuwBlCvjBSHfOqGj6LFp9bNyB4YPMGsT52DpJcEX3ashNrbk6GRuC1PGOPG3k1K2uY53n9+QUwM7RQ0PqNXOfZjtXGANtIHeVVKSNcmLUGbYG3FGXFdtdY4HvyxpdA5tkZdFufclDFuAFLTaPaQXUIcXCWS/qK3UnwwTPZPE+VhYz39cqrPwz9cWXQuXNX0GROuSUZo7nVaAMea7v0LDqKPlXGBczZciaeayBTKuJ+l0FaCf12pCxxRfX6osp0WdNhg02WvTd8ukV+MNz8rWNEalPa57cFhsyQPC1VPXzX0HV/w7GkjVtBMczVhFDosANTSGXusFxQRnK1GCFqciPNDXpCvbOuMP/P+N3rfb/BKaScmUKGM9YRQwFURTfQogf9dNIF+q3eJLfozJ3MLlX5NvWBn9GnH/DV7DGf5Fvnf9v8eyJ1nerN/xdqIjTYYEZ01Evk/V9Nd8FnHDlxln9qUixImnrlHwWh79oIQcfV8Ssh3SwjYg4KkKMxZAjIG0vsWcnXMsSs1SWr76e7xERZ4m2jKVhfXTZGZvGPnCh8YxVxJtDX8baBxndR37oM1YRESeBNl4cA6ydfLvlERGvGqdkrEfP+isi4tXjFFPBredy0IiIN4NjayzxL3xNDrYREZ1xbMbK4FwZp4ARbxrHZqxx9K6IePNwzv0PMiF4kM3xwI0AAAAASUVORK5CYII=",
  mbe =
    "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAVgAAAAxCAYAAACf4LFmAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAwiSURBVHgB7Z09dhzHEcdr8RxDB7B1AjgXl7lAHoCgchDODSg3QOcgmAtSbpC5SSpf2LnBC0A+gKgDUP1f1EALcGZRVV093T3bv/f2LSXs7nx1V1fXJ1Gj0Wg0kjD7/PnzTnjfpjxczWazTxRJ5mvouL2WcD5/CW9fkw2Xe7JKOB/cmx3BR6/DsX/p+X4J93dJOL/LdX8P5zqniN+Rfr+H3nsXS+z1pIDH91d0d0xgzF57j13h+VifWR+u8w8C9iC8v6R8XIfXx/B6Fy7sggyEa3gb3jxvsoVvugnGAgnnZBFK5+F3jsmRcD7Pw9uZ4KOn4diver7/H7IvGK6E8/vzur+Hc/0/RfxOxFjCpPzWW8gKrweC7RElgIXpU7pZoHFfHhoHuA9X4fUuvC7DeV1RYpxl2HE453NyYot/7AfKBx7Yk/A6w0RmYVA1PKisQvIg3IO/USMX+3Sz6GvBYvqaJgB2POH1PS82/6Ub4YV5KVlkcR/m/J0PY8xplmEm5ayHp+TIFr9Da0m+0gjAA4Sg/cArZ7WwNm5duI5qv/5a4e3hC7rRxLTMw3PLuRuMohOsdCNUj8hnV9jN6dSCFgqNhwybe5oclgI2clClYLnFnoCQPQlvFtsYtIC3bDttjIzDDiS3uUoN75o6wZpi3K0KWvd57SzDnpATnQaLE8S2aJ/KAQ9kCkLmkGxbTlz/99TIQuQO5KdalINwnl+zKeCExnFkYlz/HI7pJsQ6HGXYd15yZ2v1P9gT6WXL8KB6IcMP/ZBsHEzBJl0rvAOxbDursMeyM/YNje8gxv35ic0RrjjJsM6OHM1Wz/+zaFspOZiAFhvjWX7Z7LFZsW455ykEiBcrkS45o0OOEjl0Pa7J5by2qA4OaHNZrvbUqJGjEu2xkWGE3px43iOYPMhH+5x7KHZ/IjtQw7UOnC7gXRJPtwq2ya8oHjguUjnyUjoId+Cd9o6PVYDjfkW+QCvXani5rj8GOHZ2cwTg98EC6EeyCVdcw//C6z3/e3W3u0O2uQ1gLvCKIT4iP6DYRcmdGAF7aU0MAOGG4kZIJxgM8dsOg/RdimybkYCpZBHO/z2NTIpjcvKChgvPAPARgbDBDuQZlQESTrQCEIJ0GWu6Zg7eKlvsNzhSHAfC/p/k46CSaK+fSLbAwEwQJWCzmQg4Y0jjpS0ikygzr6dgj2XbpOZ5YoKfUr3MS0geYcGn3T7jvkMDP5cqOFC8OLNM8sw+8ef+TpHw9UnGFY4n8TVtx5ovcttgIWSlWmmLCZ1AthCH52i3cc8q3nl0nLDtMwtsGtDcd8xL3PdX1p0jK1G7NDzHIei+iTnGPaShX0jjle6+oxyVWQUs39TSohZKp9psIZ7k2nM/nYBw7fgxY0SMVLsDnXCNLiDDSRvP6K6QXZCvYO3GliTNdcHjSWpuinJ2lRBFIL3BJaTylkKV2UJ041zRmAYu+orPVAyuPdcOZE/x2WPPIi0rmXEQrBDcewkWTan2+obPCXJHuoCYo5hKELCS1SFLGbTCOavJHst2V80WuXa76xBPxrbHKmyT4CLGeT0E22X3ZunKKkqF4LuBf6/DXAAmq4Blm5Rk0o1W6zIzmkUkpzakgrXtqdtdNc/uaGR7rCYttbpFjceXZAG5HwWBhUTy3HasO8ZsAnYlHk/CFDWZPhBjqImsKDpbCPBzltSiXaVGu6vmuWHXNqY9VqqBXVRq75amk9/RWFnYLmRftRWAGV3Ackk0qPOwhUhXnak4OSTA5qhx/BWZLbSCNu7yfaV2V+yyNIkQFoefGuXYqC7OmBdwiYC9Hojnll6zqQBMTKLBS04W0JIz/hHVuciJJFtYrKrhHFF2TZPKWFS2UAdr15oJjuf9D6oUxIqGa4a2KL3m5+HzH8P3Uha8l5oirmcjdB9IgPRe95oZYRMOz0CSeIC/Q5CrFqEYAbtNaWNTl/UdnYVYFckKGOjhoWNhkWo4pWULdfZ17QL8YgK7FVRO+0DyuYEdyL8TXrfUEfqR6kTq3FonGP9FsuIuT2lEAZsSrKT7G2YauANrQ49JbvtZZgsl1oZEKO3rHaeValB3QHnKcP1I+Xwr/EpXXD3VDkSqVEhtkUs4MsE7ikVlDlQ4yR/SzmE6kAjYZbcDTSREaQIWD/lNijCRSkH6ILQh6SQ54XoFuQWVJg8d1Gp37YW3nVjopOFYXd3jFMVspEV6tAk/EDIaTV36mxqlSqq9rh1b/LxwbIm5AQqPWMCWVK4QD/gXapldt7BGoy3WnTNbqLO7aoqEV213HcJQrDt3cXWV9syF5HNXN5PaXxdOnwEqZ1dJArbzBmK7VH0/Li94O6L1TmeJjzXku4Mp2F2H0PaIqqq4Ou80s4RQKpInFsLxJbWtqrodlFpwGxfw8+fWLmUJl+nTJFvkyBbCwHuj+9Y07K5DsJanqRKVs7i6yQHMpp0ciUBS2SAak8rUWfHcKrmjAQbbWYrmaJWibZ44drYQIh40k3QxJbvrEBx7qXE8Lourkx/SMRNjVtqnEU17yq4F0nRYzWfFBWBinFzXZL+pjxWffe1Y7RyZUl6e2lFjTtk7DSGr8U7DHrtLiWFtWWt3tTaCrBEsJBjz0gXPs7j6r8LPmRdjjt1GMRlvp9cQUjPUhTIyAyYP+BAk1yDqdhAjYF9Zvf0s/TEhJRfT1UD1iPGs2t4X4Z1Otg1nbeKEdBxuUgjeSvKIRgAtFQuKRxrfihhP86LHCgDMIWOYOKTaq0o+8XOCFitRFkTdDrKYCHAhbFe8XydyiGX8GTU677TG5nVAiZpGRthdN6V4zy1sj9U4hLyKq0vvdXT1fta4cY2LnpcLbDKUmKKujeNMKpRF9ytrHCxnLEEjkxQsUcWfTRxttlAqW6y29ctG2F2H4OQRPAupOSVaqWDNUtqDKnqO9T1f3uVoe7ANITZFGVP5NWD8r91Zl5BoAE1WImC/I/1WdJKMvB3rhe2uGs140+yuQyDkztJ5NQZpKihiPM9LNd8ouhaAzjyWkvlDzVizRxEo2sZst9jYPzB4p90wxrtulN11CB7vL2hcpM6yrrtrqZRoJlyrZJQcptVHtqZxhYLtWI44UthdNd7ijbS7DrHSQmWs4+HeS+//6DHUClJv+S2s1aizC1h2lEi3S9K86o1gRRsaLWSMYzQ129urTba7DsFOXo8wLCkaj/pJaU5lRdeCsVnb7aAEDVbT70Ya07cxGLzTZjizTmt33afGELCjjxKgzyGVml3EW0dN1iMjs+SszsFkqNw9uSy92hv3YG0oqT3WaHc9bnbXYYzFfGLQLsTQZM3NNaHZoa4IRW7teZdrbjw4AoMFYLIIWG4bAw+fphQfaK27h9G2mtEibfHTceqUiTRpDMV8Yo+lXYi7AkziQjQrghUvD1MDhGu2CnECusSpL4gJ03pusNPAhoqHZHFWLWbxBYlfO7aMuUM4t6zdBIytZkTwYqi1fz3mguHeJGkrnRNDq5mYY0Er/avyWHj2y4SV8F0oOUgcwM5kdT5iXne/ax1/Q/O7hqJPvd0OYgTsnMYNm9BmDPUx6WwwQ6sZKXukJ9W9dssKKgxt8kgMXccFi6Ij7SKg5bCvspqysEuKWGvEmkueSW+3g1JbxtznempaSyoMrWYaBWBoNRNzrG63g7Y+JYQ+Hq6Z3xr77aV3OKAi0xR8kQlXSxxsC/PRMZp3uuGH0UZqPRbGB8xaORUXnMPuA8qTZieUIppGs3P+wtlVg4D9oWmvOjJ4pxtOGFrNxBwLRZcwTuBkGztCB6ae3dmaguuKrgXL30sRscILkbhgDt1bEEoXsBc84BpKxvRON9wZNXmEw/xQN3gMRWYZGx2OuSdwWmucWx4+miE0RbvvxA6XKmBx4495dW0YMbSaaRSAodWMyzF5vj2iNIK2a5K4KwnfUzq3QErnJ+6HdMG70+2gNAGLi4AN6lsWDo14MGlagkZl5Crmc0/QQiDGCC6MOwinZ+E3H2FOK0ItNZErFykTWvicNVrsbbZjXxSBtLqVF1d8PAyoq5kt1hXfL73SluSe/kbOrHinzwQfH7r3JTnMHhof3ueac2zBuYvY0oeO7/58WIuGknPOGhmiDeb8vs2v+7VBMJc/8fvlLK6hJSJhpNelEX5WsFBINWpEEzTHfKPRaKTkd0FlDHlE/G00AAAAAElFTkSuQmCC",
  gbe =
    "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAP8AAAAyCAYAAACTfg2gAAAACXBIWXMAAAUrAAAFKwGljfN0AAAIuElEQVR4nO2d4XXjNgyAeffuv90Jok4QbWB1grgTnDtBfRM0naDuBE0mqDNBdRv4Jqi8gTOB+tSALQIBEElJlhLhe0/vcrJEASBBgjQFf6jrunbj8NU5V4xUtmEYPfloBjSMZWLObxgL5ZNz7ldQvQnRM+fcjWCKR+fcQ+vsCwfn3C05d2pdZRjGbGic/x4J0/z9iyBc5ZwrW2dfuLTO8OcMw5gJFvYbxkIZyvmliGAqtiCTP2r75sEwXvOpdWY4ppzzN86/aZ01DOM/xgz7p5zzb1tnDMN4xVDO3ywUfkDHdxOO/LlzbtU6axjGK8YK+/uO+hkcuLzQzmTXOjMP1tAxZfD3KVIvTA5/03v72G1MMnR43Ss4hmIM3XOQt0D1lbq+5ev/FOkfRcI9QYw556cUxAEy+PuIHHYPB7fX4AwRBt1rsIbz3iHy1p0v7MiiX0XKCpEvgynFlkQYj0qnswOd6D6IEL1yRq4bdJ9v7Fsog3vGGcq+b33y+jkZOXK4bz+B7p6x2oxGBvdslQjyEa6hnZe30Zp0dlj/n4g8Ifd8gb00GM4ua1jrwtfnUH5B6u2La7b2o+O+lrkn14YehVjiC5e6rvO6rk+tT3geyHO7ypco626da5Avg+dqUHus4Rkx8qwj9coD5JLKD9G9At2PrU9eQ3XPIuqzhvJjdO/bZqRjB2WHcIHrY+zpdY29p4y8pwQbau3v0mfkxyNJ2SMcWsG9Ui9L+Qw9rjSSDc0Kwi5Nvmfy/zXIqN1D2YAdpMiF40EZVbnyD8oozdGMpn8z5zFn8v88sj4b7kCX0IXaMdqMtsGNo3n2HxCOH5nPJdbCeY3Yb66aOvirdfY1p9QFvwIM5Y++36HHLtDtE42IiZkPdslHy9Ia5lcIG2mH4cCRfQO9wLUaoY7v+TzCfgcc+q7BiSXdn0B3jjs0xQhBeoaE1ma2iuOfQeZvrU9eeEDllrBd/kmoXw58D+1IUwmzTWLYv1c+444CDq38GsK4Jiw6QMipQUOugpELc0By4BBzjc53hbelEEqVATakoVuuhJgZo5vGHsrz+kgy1CTsxLp3hdBHoU5wSH1ofRqn+wXVTWibqXq0GW8DTpYano+vlaZY3LSCayc1Y4tQ/6PTKm+fLp2leruPeXgJn98zDSV0PUBrxJwBNWfknqmVTyuSOzT9M8VGXhatIXENT+qsqG6aXpwdtIZaM3N/rbGe0PWcc/vnZ61P/mfLPI+zYw026dNmNL05W0lyVMy1a8GRLoxNJXsO4fyD1FtM2L9BYX5suBkCNxfVwsBrb9etyL8cOyXk4uaF0io0ZwsJaa1Fm9/G2O6Cvmbivm7y9pBkfhZ0p6vXHqkcDs5+sW1Gup6TWZrfr2a4sayr3pLn/Neiipg7XVMmip/zSw3gq1AB0rz+hnxnnSqnNIeMWVSkZUrnJN2lzukizKNvlbl5CBdFb0oR2Vlr57mOZS5w9Ra12n9GhVxzF91pZvv0G3l+YM45RU5tcbEU7iuEkS2Gk/D9d2pDPTIN6QQdlRQNdunO3ZcrnUYIlaA3RbODJLckl1bW1LD1FuP8eKNIE7L93LpiGUi7vLTK53rers/6jvwOGvBd62w6ku5aJMFd7+GiIQe21O4bCqnOnhXZHAyEtHMJ6Wymgq231LC/VZChOqs0iriRnV9Cc9YUJCfqQrPLNZBs3CXXFHU2OKmbfCxFVxut4r2z0f3njvl/1/khuOaLTym6D905SUij9Rp1aFzHJsmdKR3D7Eh1/gre4DPC+G3BdkrRve8Grr7cBuyQe/NYGq/58mZGkBF4q5Hlm6qza77VZ3TzjBq+9D34ewV/m/SWdP+GXh825zda/DCzRdKh9pCHMDfdQ1jEr00NFfavYadUgY5rLdrMBa2Bz80WQ49QWnlTz981uA1Wbiltd6iRPxcWdpa0KKg5gLQ6/F7Q5ui5situaiphg9UKOi3tu/43jy34DYe2nVba+jo20gimRSkpnJRt2HNOpqrZ4d0ngR3K+aVGtjSkEe5mojmkFHJrI3Uqku63M458JJndiLkgZ+MrQ875DX2V+jCBnbiQ1nWMeKlouvd9R2EsLkpykU3PDkCy8UrpDK/aPoZyfkmZOXGNHrdSGtMtyfrCUSivmMYiha1PI81lT8oC2iZA9+2Ausegvfp8UOzoUPJYrv1rNuY6yvzamac/wUN9FlDt4ZkSus4llNEW3Xy2VVwpUu/ch72S+fUOZQ0uQZYC2dZvN+XewpLw2Wnx9Vul0XINbyh2Sr5Dn0LsqOj+DLpojjM0FaTR4tJ4NXr8CZ3aEb3B6GX2kRXnO0dhEdyRduBQlmbObuOhZAIZApz9JiTTaslkcumSr0QprFxk1lic/YXL0IK5oKyoXEaVmLRbXcRk8onhwMgqpXmiuh8Ddd+17o5jP0Gb6esHXCafrqxCKZSQFclnVJayRnkqrd7GXu334VAhvLdN2SgjlsSGhJNaGCfJ91l5ycOzgmdJ0Q+mGdl+VFbANc4dC1GpPDJhdQajUIjud4G6P0Bu+lTdfTR2zTbjoIyn1pVhSNHKXkhYIvGtw24bFKXfBUQKN1q9fWSMMAbcnGgsjtD4QhhTriNUlLQGQDlD+JkPvBr/DOVyU7pY/UPlegA9pDUAyhnqLJtwX/8FOoCYjusJdjBKaxV+ahNih9/RtEgjZarK2vTDv1k8x8PPRWOeQX8DYBfQSOmc16F5GO31KjBGieZwnGNIpPxGQYZ+NQV3tn5P+FGqIKBQ3jL7XtDT55s7CqOSS9Cds3MX/hl5pO4xbYb++lJqm8HgX7nBnJDckl058C/nYEoiS8FcQ+V2Q9Rb4/ytK43ZoTm/vVptJGE7/AxjoZjzG8ZCMec3jIVizm8YC8Wc3zAWijm/YSwUc37DWCjm/G8D7cUpbUOIYYiY88+bZmdWrbwd5mDzTz3jd+aNmWLOP29i9t6/9zyBxsCY888bLdynvOtkk8bAOOf+AVIXJwCaVetYAAAAAElFTkSuQmCC",
  ybe =
    "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAPEAAAAyCAYAAACNtz0TAAAACXBIWXMAAAOkAAADpAGRLZh1AAAIUElEQVR4nO2d63HbOBCAkZv7H3ZgdWCmAjEVRKkgSgXRVWC5gpMrCFNB5AosV3B0BUdVEKoC3TBenNfgPkCJoklpvxmMbRAEQWB3sXgQfrff751hGOPlD2s7wxg3psSGMXJMiQ1j5JgSG8bIMSU2jJHzpzXg2ZE451LnXOacm8Dv1865d5deMeeKKfH5sAGFfX/pFXFpaOvEy0ZMu+tGf4gNaT3x+aIpsXjRBGNQWFtdKDaxZRgjx8bEw2QOk1IUGwiG8RtT4mFSK/FUKJkpsfE/5k5fBo+XXgHnjPXE58XWOVdCT13A78WlV8q5Y0p8Ptjs84XyVkqcws4iTzWAHsPvbkqD+A30aGXjDp0E5Zl0kF/fJER9HFJ2Xwd+sq5E9WAcS71OLAQNf+9SSLcJ0lWNFM/U8fl+v08g7bqR4nVaqdxLeC4VVkHaDNJolJBvQjwvDPOIPKX8YsqDibknJu8lpEmgLThKlFYKc0jL4ds7Vn4sEIGMRCFGeGKUuG6oonGFplbQCQiAxIworw+coahZIEGVDAVHLZQp8UwH8ZLQUlTwrkNR4lSpPwynYG3auwDDysE9wwKEvman17AJP4Z6728O90hkzLVM2T+cg5tYu3OfGld1rtA+ZUwK8Vct86vL+l14nz7x9SLVH2ZKbM31ecS29zUsqRkH0ocST5U1T4opjJ9+ENc8s0bMM1x8zT2Mv/MWQkbxHowMHtevjvz4YNWI6Z9vB7xDqICrA+p2yB9tJGBgs6C9B8OQ14nnSm98RfSGTlHiNTSG1APXiv4Rwn3j6uvnL+D3VDBU9bLPZ8jvr8bVF66Z9xk6V8iLqH9+iSjvE4RTMQFjUsCechw20G6SQibgYdQTb7+ccw8QfqFOgPKcUrSjzgdvnGfwNy5LwXgyK3i2T1eB7NLyoYwrNGLGxJ4NjGNnyqQJTh87vvVh0kjxQhUxJqTGX1L6EtIsGldeCCeApPFfFvHMAtLh0NWY2LOEvOeRY1v/jlq7VsF8QhqRP9UmUoiRRV+WjMhnpsgchpokpcqv1UuB6kN7dmMuSKqMLpW4IPKmXhjjG0+qgLCBJWXKFSXfExNMvlElMuX918EMdEIooQ8+naRonFBL9+xbpKNmnSXDg+/RBJBSmlg5iAmSrHCkLdqaIlfeJdYgLCMnRRsrM32509R4r3Ytdo3YJnkj5oVp4BZJrvSKcYHCMsXEYbQ8P4EbViBXzo+vysD1qhp39w9V39KwxqMdSPAk1O+2EdsezpWvn3vrnLtj5M3LZsK8+w7uvWXK+UWRAV8nO9j+SpWh5gZNikrp3ody3pcSc4v6MRs8tEb2L5Qo49JC+DLI8y8xhvrVSPWaNPI9rqF8NxB+wvM2ihD0DdVWVFyINMZ0jAK3yV+D6igeoX2WyHiGTCHNgjBCO7hnAXmkzFheOxzjCWTPH5l010jx8rwPyMh/baR45tXYeCwfQEg9QRb8pKAauCsSKB9nOTWmMGky5GUWzfjFcEovY8LMiC+CvwtmsjJl6j8PDHRF5OnQagrHHL0/l4cDY4Cfl8d8vDKWvdM5LH9QxCixZAS6om6Av4/I67ttRTwYqu13jIe0IuIrZn2fkhvOo5CUmCrHE2F4qLxLwcP8zViUuGBe2kHlT9jp92dL1odirKBXvmlciWchWOk+kIYtx3LKNVZKgSjFccyhCpQRkPJ4JBQrI/J1Qk9KeSbU81TZHdNXTLnQ02VEpeL7YvnMVK4ETr8E672Asbo00UPBGaK+OMbYafXGKYob6iaKN5ho5AyByJiUeC0oMTexsAtcoo3SU1YdnJpRoPHVBHkJ+DzoczxWlupFMNeMkGaMh2VEMiYlLhWXmmIdWFNN0GaEkCXM2Mjje3rKpXNgYHCefmnpUEX2kyhDHDvfK7vh1kEdz0846ci1R0Z4BZzhpoyOYzwmKl0vjO1QgBVMAMUSKl+lCNqcmJFcCa66g/TSmVjhGKwLF22DjEfZcshwStZC3TowXA+N2Hgol7xgPKwrxthlRNqK6SBSQjm59fCCUe6TM7YztqQeMWTLpJcsf904/yDFK5gNBJiN0sOv0UaTufKVUBH85LhC683U0shbEbUkcgQPREiFvQRh3SREnIP7KVmh9lhTQ7fHt9yo05cSd+VqVMw6HwXVKL4sWh7+yyvKdcfcgaXXDMM3EL7vQo/tUD5c2cfAvOWa+ZbZQNEWqg1u0McK3oCGQy+/EWhFlNt/djqDPDhPg1Ls3hjjaZexAk41qmfegeA8ocYrYVveMdwi128z4hMqS3BjY8q/AwXpohdbMW36BRlQyij7Jb2K6aWvYXfdA6PAd299hPAYlTgnLGbIEzEWwlRgWaXvlSXu4P5weYnbTqdxS1jzGSOUY8DX7weok3AvsN/PPFGGIm3JWhq/r0GnsIa4WE/i7o3X9X+jTWzFVkh5YM8hNaB0TfuYIWaip0ITWfOIdd0tGt9yBmIBaeaR39X+YHYQOaQIC8iPm4H3UHlQSOm4a5XSvlx9FB0IOTaUVBmq4HfvOi+Ynldrxxx61qUgE/dwf9gDU/XE1SkVT3kklG69Krf2D9UujfAUTlzhVAVL4HXhsAFKQgBiyA4sS1/MGZfUvzd1LVE+MqG8lFjC0zoPOakTt98QTmVtYEpsdMmSWL7BfCSMV654LdQ9BsIOjze6ROulHsAV9elmjMvr2ZoC61hPbHRNecCJnxyfR77c1gv2D9WMrpkd8W015ocpcBymxEbXFDAZdOjy2A5OBaUmwQwCc6eNU+KX7qhNEiFbmOTK7WCEdpgSG33hl+/8sk8V7BUf6rLZ4DElNoyRY2Niwxg5psSGMXJMiQ1jzDjn/gPQVDlWavVD/AAAAABJRU5ErkJggg==",
  wbe =
    "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAARgAAAAyCAYAAACHzsRoAAAACXBIWXMAAAUoAAAFKAEINNIZAAANvUlEQVR4nO1dS5IbuRGFJmbfdYMunaBrDuAQ5wSiTtClEzR1gqF23g3nAA5RG4cXjhC19UbsnXcuRXjj1bA33rr6BHSwlTnKzspMJIpV/HTjRUAfFgqFz0MikQASL7bbbUhEHUKYhRCu2Gt3IYQ1hFUIoVWSLUIIU/h70Xn6HRMICyOtAPlZdn7NeApArux4UAmcQ9yGEDYhhAb413RixDEF3mYMiBQBU0FH1hqZ4ysIhjX8PgHC4Ps/k2ccBZDkEgTXgpCngLxUIOgaIIeGipAUMTe+fQrAjoWCOEA5Z8+I/HMo70XnSRz3ZLCzBA7W826QKiFkDImdgHGEervdttvh0ES+uUj4UiW8H+D3hsWdb7fbQoh7SmHO6roxynhKoYC81nvmSWq3IbBmgX9jCd8vByrHsw8PyoujIqYjNPZC+A6GSSe2jjnkb806YS28cWqEWUCgAm/N8rw5A4FIhQtiJsTxhHLggSwFE+AQ/X4WMnuGWAK8wvti4+zshRBXw5K8t4R8VhA4lsK3TiFsoGMWitY2OQMSceGC6FPnUjqHwNrgusbVHBzB0+AtNMAK/vYKgC3EnQkNp3WchRBXAteASvI9rgVsQcuRvnfsMIP8rTo5/lYP5ypcEClCZt55+zDY1fOfIrzLQqZnsIy8tbHSU5BVngqMY5dgXGsgrIhhlhuGJQPvFIx6E/j27v+vWZzPkB/JQLuBPEh4Ifx2CtiV9YuSj1tmmD5F7Iz+15F8/WQYWSlaYtC9A/6soF038Dsa9tHQr7W3F1+BaztOvYq885LkI8OLkSWYpPZvBQ0Gp0alkIY3SJoL4pSlvIa5EPfUQkyD8Y78aOdrFfsN1UDnwJ99NJ6WGfytcrRZg+kffhxREu9GmZvOrzKWMIrkEeK80IKWtRI0gLcJ+5Mq0CamjAMlpJG6P+UdpDOFNFDjbYlWTYHl4Nr2PfzeZ1/Ns8cOYwkYun/DEzcoU7GM0wd2TjpdShEuiAnbUFmRPSyp3EAhgnmbd2J0wYVMFi4DYAwBgwLDs2kJbTxV50nGuaGG/K57CBcuAFC4XJB0DwGqkc2ycNkfP4yQZhXZ2k+xhIb0xs/wwas9epCS1hDHNkoiXD4eYdrcwiB5KsKlPGJ7avCmUYwhYLyoQRgd6/xHAZ1hKCJNgZzHPheFdgzPtGDItCqIu6/GsSKrSUOUIRXThHIU5OydB5PEtpmRFdkhMOk55aSooQwrY5ZSwvPFGJZjj5WfHj1YD7RbNWUVacL28+yzEa8Q9rGkpKchdRVJykff/T9SWtrepQDfoftI+h5tmJE0tOMkHn5hXieJ9UhXPdtIOSaszNLqF61PvqJqtU0p8HmfVUWpPa3vS6EAXnM0kPYcnuNq3MMudCmhfYOHAHxTU6wxPcEjYKSGRvRZiuQdi8IrZDSkEErLR9tj6V87d9YqA8GsE1OPa4WCfVc7TjKGgCmVZepGKYdU5q0ihPlgRutI4ry0MRXRZ8AYght9zoc9lO1YUyR+Qnb3/3+NbNBD9VBbOv+QYGwuQAX8JJQFcQ3fG3L+nJqPiwT1Gm0fHxLS2k0Hf+3E/BZX2gxpYcq+eygbSAnfkrwEXAlT3pVS5sCmDdg2X5QNgReQNvID6/9Xpf4DxNemJRxebsT4WQvL9xruIbzD9jumDUbCB6FBh8DC4VcmOCsc5+h8l7GEK+JiYmh483HlmHPjXD+2m/UVSauM7OL1fJfngeJQxt1N5Fuvmc3EEpzYadFIvOPy+06s78A6mpEFj7edWN30YxiKGws24KAAkfCR7LL/I81TEzABSDv0snULaU6MCgow0mjflkaEu0h6YQQhgyMdz4eFG0U7lEbNWHluCIHfdZ5243rL5PUzNAZivKBHNhbQmTRcsQWMORxx0XBNjt6gUIqlr6HswdFrgRulou038OwNCM73wIGXUC9TntYpCpgQcSCVilsyArVCZXrzI40IGwc5A5BiCJW/VjQNT2fn+400raVxpIWqeqyzeXHsM1dtYh5msPNYA9eW68ggwFeVYulLQG5IHI05KuPcsBzLtURwzklZxS0nxxIwscobUsBw7Crnt86vNizPao1TyEjz8FTURj4WkZGSz/mtub4nLVTV+3QGjlPwJNfAYORBm+hdMHX7QttjadriRkwr8tpjNCzg/c708VgCZhYp8NXIpBt6741XyIyNOtLZU+wisVEXDaB9OgPHqZ8afwqIDQSXPe2feN5L3Ntz7I12FoHPjXSnIGRwCmjloXKOVK1Dk9TsVUMgC51h4eFGql9iPIyq8uRYAgZVKWvkUzN9wmhOYIu55hz8HoxyKUc5GmVVA5cixxQw+Xza8GgUGyTlhrWi9go0FRygVrHp1ZgCRpOEVGvpzNkIPMvAGTL4nPsWyCOqsRHwtD5DWmOfft9Hg7E6iYTnpC1xG2QqN34hRwXQEPyKuMd4hGMIGDrPszSYIGU4w40NjExvyBmYvtjAwPBG8NkyFvqepP6amL9S0fieMhrgxtue3LgQFIALWB5fUG3m0Kep74SRz1qtyAImHRXZd1PuaYCtyG7kMQ+matNKS8CIKrnArxhq4/tPDbjvaULsJ0PjBr7xMMUdQ8DgJh0+h74nJ44prGlSNvSlYQ6kmUt7EhJQkLTqA7jU0EbQVwIHCogv2WhuEztN8Yz8vuBlg3NoU6s9F5EFmBiuUDkYWsCUpPHpmvyd4R3MEjDWztqMx/WOdVtF6jSGkniDq5Q2GxpWfpdMW6kUAfO1h8a77Hlu6pxAuVE6y4pnqt4Jq07evUIPGFrAzMmOPsTHCFGbiLS01OSM75gO6D9lemAXphYHLtn5p41wMPJWcLkZQw12hM/PwOFZX24soM7fg6D5CvX8k9FejzCkgJmQkeYaBMtLhzoWIlK1NubbGd8QO7CXgiHTSoE1tbkmjuHnZADD5fI+wuUD/Nv67lPAvu3ZEof8qCGiCcTaLPuAvgKmJPfJoGPmLzAifII4U0KKmBNwy3h4kR2CPwvEOvo1sZlUMKqWPY26KFzuItzL+Aa061FB5Tr+kCJgSmIQ+x0a6QYMcdLBqAt4dgNC53+QIclwa2kwAchlueg7FiyheUhUA04lh0wrBZuIa4NA+FQD4VO0FlxR+0B+85Zz7HZOTT8lfrXnLIC6yEyGR8DgctbvcEBOEiZeXIOmwx3zrB3Go9eQhxSnO4HsPvRikdAYV+QIuwfcYGlhJhgyNVxAx9mwnZZ9QNM69PTUu3rxCTjjyR/lL9278VuCcVdyPGVhkcjRVHce0iqthn24URFh3g+CezzqXlLywTkU8Ba/Btw0plx8vwUXmVPi0u/fnRiPQV1YTjpPH4Pe5qe5U6Sg8WNxG+bS0QK96bB0lBHBby6UghextCYD36pZdVKIg/qFnYO7zbXiKnJruMK0yrGF58jVP3eedtuAusS0XHxugfsp8Xm7/LMTQ4aHG9j/1yRPJbT1hLja1PjbYBwpYcuP59BomR/Tqud3d+/8o/NrF+hgvHR+BwXeXztPdHiF5Aby8J/Oky4w7t86T2wgmSpSv3NI77/mm120IKRraLMa6nMdGYgkfsVC3UllOGjCxfK1K+HvDg5Rfnu43bK28nC0hfCXxL4jcWNGBkBs61rh9EZwJL7lvpSlStacYg8NzelxqoNhmo5FdB43tcE9QhfJ6+kgGNe6F5nGpSPJPprlkoxAGnk82BAN0hptJY55hczQg5znBgtP21Gt0tN2KdymHdTDDSrEikhbxIDcqOG7qf2w45ScV65F3DUUfkZUJR7w6oIYaRuHR3MP+SUhpZVB+qbVgFJ8i1B8ZOTXWlAsWVxrOrpSOkWqoFkK5Umpa8RGuIHBIrX0PW/o481eQ8otDdbgw8suXQmCkLSlwpiKSTdRWNyQOLovN6yya9Dy8UjASJrLUpJKCY20EDIrVboVpkqDSMJFG4Wsb0pCRuvUWoNr6UuNZRGdp2vF9ZKJC5aCDAq8/mqhLmh9a3P3sQRMHwEYK7838MGkFYSL1XYxnvP4knCx6pgPUlJI5UYgZW7JFNiyZ2nXyzwSMFPhpT6NIgWqtqUKF95ZsbIs4cKFjOd+Iio0zAoT0o+VCYkaIyglnqhuRkLFBDEnD3/OiUbrkxpuLcGikZ9Cit83TBM05CE4jNqJ996uFM4FYvPx3slVk/aQnmuBCxpJsASoM0lD1fpglKMvdn/AEtYlbAUe63RpOdAOUVz+86RlHVGQkBq/hL0Ysf0YBTmk5023b13haXb6fs32f2h4y5ZjpbQkLAQP9IgXnV+GQaEs1Y5xriilPfpwKKWtiz2ONsT6jvducS8vHgQMku+zc1t/xnkBD7tJDqE/wx6HhjgdWvbYVLUWbif4g2OdXzKeDXYCBjf5pJ7nyDgPaNrFrbKrOnWERM2MC7Bbw31nxjPBjzDy/JyFy5OFNI0IxlQilQc1u+RrDhpQ5lPGg4C5M8iWkWGBXlfxfkB3ERlPBD8c6Wh+xuGgte++BxrxKt0N+AfJwiWjgx9O8IRyxrDQDLaXewgFdBS9NjwVZmQ8CJhGMfZlPA2sjJPqvySe8MaTyXjZ1ti+ejPOHLtVJPTTOc0j0ZMFusTQXG3ck+Vpbo+rIExhIFoIl7tnZIjAjXYVcYu3hqDN3TPOE3hTgLRkHcM98GOZeZGRAhQwCHpvcV5ZepooQRuZCrc/UOA+lrVhx8nI0BFC+D8l2PTMyr9EbwAAAABJRU5ErkJggg==",
  vbe =
    "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAANwAAAAyCAMAAAAAykVBAAAABGdBTUEAALGPC/xhBQAAAAFzUkdCAK7OHOkAAALfUExURQAAAP///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////3aZaXQAAAD0dFJOUwDYxaMF29yaBJXW+iHJ0Kkv7N0T/OkgawMKF0KRSO0V+Iw/p43l/hm/FPRM9f2o1+PkLUco6CKQAh4Gz6UuDOdYnNXK2cDhvZk53wfLtQ141PFSH1mOpEZgMRESGK25+RY6oWfMNguAq1DG4j4akp+i+zTmgkDyHJQrO85vbUXehrHTvkQBvLh9hXfwHXVsEEqXtLrqadJXxOCvakE87q4O9jd2zaqgNSdyOGFkKbZwinT3liOD2phUD57rKmUJc+9NXKYknccIPbLCi4TB0bCbXSyTYl5/Q4cmY7dTyE5Vw095u1ZfiEtbgYlas48lUTAycRub91alAAAGuElEQVRo3u2Z918TSRTAJwISAT0hIUIECUIiAQlNOsJ59HqAgoWiAqKiAuLJ2c7e9axnOXvvvdez93KWs13vvV/+gNvd7E7Zzab4gY+Qj+8n3pt5M/Nldt68NwGgWaRwWbEdJx/7xljg8Vsu5uHvAVqw3NFjMsbTAo+lhEfiq1x8UIHEySCuOmPt7+BLdZBaMKIv7tHW/lXC9UMLmWhzcG+ihbR5DWdLcD9aDfe49cAtcu8QIrcK7v2z8W6tBC7GA0QNtArOQwr6txI4ShTOVsFR0qOFwH2C4O6LdHGxGi68hcA17CjyN0ivf20OzgJpsXBxJTJZHHHcB8i0FmSIcTJZSbVVcNkymSxxlgm47MXabj0mLwmi5FKD1sqc85eKdqycuTOAsXS99rVDqFrddlkm22W812qntDB1WvJe1nC3vh2UhK1wqOE1bmFhoW730x+sk1oWULxTp9AeKwOWTpAaCSiHl6XHS9LUrkdYs9w9q4NugsG1UtcOl6PbCylj3wTMNOwvEIndnZUArK9IQfokqn/H6IkaaJjDLDNGjV+4K9mF5q3BjCNmnM8MNAc3IBf3mL2iDx/OSW9Mam7Sbbl8cwZlnEtYHgM3TLv9U3vS4dT+GtJwiJlUgpu4q2A2bzKV2Z2boRcTFu4tkebhVJsf3+hPGd8mLF4EnEC6q3iGLloxuIPio4jAbdW/LNyG/4zA+VoLJ5RCETh7B3NwpTs7GqTBxZDESF4aTv+0eeDeE4H7Um8ODh3JUCZwrdJbDie/vjx9+b3usN0tzzK4D62DW0RP6iCE241Z5IFHNEI4FB0uKmm9COuhkWuMwUEXd+YKmAzbGxVgO39ljoKAUgvScHX0lJzcsmm4SV01Z+NGLIB2omfJEsJ5Yf/CbkrFuYbBQ0XhuvjQuh3yWN7TJTwz4qsM0Z0LY3TlZhisXoCN+BrkV+pmXKZ6XCp3nIPv3JDBSxph/Ahixly4AbbvZgynQwi4WZmT9x/mwaVCfRobL3qrTMOVQ71KLHH+O2LsuvU7/+n5SMGoPui77ArCn+1MRhzrUenEWoKfZNJeHknwMMgMHbZBpz0Ggx+5c/R1ScJVo+vyoEiGwoOLOQH1qaxHT7H0K065ZeTIm+GrgjE4OttAcAFc14WhcNsY8XSFn3Y3gyUeOnU2GN4QwHmTcCUFUA+yDM4zkozAdL4ggNMWri3a5tAoPPoMHDjOC3SU6LicoEQMroPVcOegGnzVMri8D6A+WATO/nmBWFwzwEnRcdkQy1iecfpa0HRwQ9DZjrIMTgFfIfT9ReB8xYN2V8ELYzSRJh0ArxYu2Bzc4jFm4bCQGzyEUj/lrpZHTQmHYoH8mFm4i6X0Z3nW3Gc5FrFI/C9cmPTDUI0ArgcKoLco9QtiG5sKzgedDm8ROMcFEoMktZeRAeUb43Ao3cjPZtoHdRfAgUMoEegPPueuNBdUDsKjnaTkw40Vg4sg4TZ1Ieok5oEIvn6dYH6zibGXckIXp/YoNZpn/J5DOchJQ3sUOqYj4erbYMN8xv61D90iN6yBWyGAu827PVLZHjNHw50z+oPUaujhpOW/OjFwv0N1HJsWOBuB6wxtU86wx/g6bLyVnwNXocpx6EXCOVWlDyLgUmpCtoA1KfdQRua6Oj9ACx6gAzK9aGqtXXkIChjOyfllcQI4HfIoGLbUL3U6VgI7VyUnV9dCNd3gcQztnETylBunSBBt1sE5eCEpmYTT6wMXEnCURIARvNE29zZVnNGS9ZEArtZMip6NlQ0Vl1d0mp/QFm8u5sYpVRspyVnhlTwBfDhXJR+uM+BXYoHvgoemVyoR1quVZuASFSabe8GBzpMNC3o3Odyu0dbCRalMw40CYZbBYUk7LUNBk8OBOmvhQIJpuD/BHxbCbcHt8XnNABebRNq+q5xuBk4RSXq0eY8YdxcYRRbSTg+nGYfDi0nm8QgKb005dA0Ugi88lv+OFgFChQGFSlLckcE9ekkc+NZ0QCE9Ir2G34C1GAsHXHLQW1rdqWrwPdacgA0kRY8t14gZ5vk5YjJsPm2bq4OG+ujTlGFtGTTUFb8Azwkfx4ToTbTXqKkrma0+MK7fIEZ33MH18Dtu9KorvTuRyTXLWQ/Z0QrOY0cGffktnl8WonaL9/Pax5SrypP1cKF78YFmcue3MarZXuE9xvf13iOz1mOCSQ/7TZb80pDPwv0KbE8y+AW5TUiiS2xsrOdM9DZ31cd24ProNQMHqri0TLNApa+3HbifBfffFVvaOb7Y2TJc8eudaxXyRACnsx24iJRt7QnJwouC/wGxuOvyc0nUhgAAAABJRU5ErkJggg==",
  bbe =
    "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAOYAAAAxCAYAAADOUdUsAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAziSURBVHgB7V0/cxvHFV9kVGUm1ExchkiZQnSR0vQHsPQBJNYZSZm0MdWHUZOOtPtImrSm2aWhlNSE0xP2jEuDrQrCRUp6f8Bb6uHh7d+72ztA/M3cHA53t7e3u+/vvrc3Mne4Q0u4ubnZsTtsZjQaXZkC2DJ27e4+Hc5sOXPzEWJk7nCHhrDE9MLunthtLE5N7HZkiWsauR/E/Ge7PTdE2Ay495Ut49RsEeid98yyzcCAJvz8yF6wb/dfee5/a284Mv7CX1PhGh6Xcs1Ngm2Dv9vdI+XUnG3ndrvwtYdSxjNtMNvr0Inf8v/sdZ+x83+wuz+x0+/t+WN2/qHdvWTnT3wD3l57Zne77K+1/qT6hMYAf86x5znuncaRMk5tGV/a6/9ofx+YPPxo7/0Xe6Z8NwcwgFfGX0cNaBP08aVZ0kuQCVF5YEK/M0vGhftBpKDDK9cf9+haX6OgI48CzxibeINuO6B2xdoA7YgO8Q1QWQY6ydfBsWd9EjinPccniXZN/Flg6DGiBA7tu19IqUBIIUrgwJbxvVkSwCcmD78Vx/ue60LvMo78jz5+Yev41u7/FmDC0C7QFv8Upyb23HMQLc79yoRxP3I+pVPu8AGH1DEx1GrXfVMI+x4Hyv0XZsnIwXxm4twLTxlywE8DZRyahiDp50NsvKcABHpGqqr27GswKGiqdntjt69o2yVp/Rvcey/ykB264Up5yCCIkjkLeENAtejLcTAzHwYU6vSpOA/i/Cai5hcTTCbGGASF7STVSbT3E3dgy4Uk/I6d31ee9VCWYZYq85yV8c586Fun8jXBbuDcA5OOC/b7c3EOBAh7+UT8/4z9h2vOoboSLR3QObzzQYwwAdykDaIdUxnEhWCL7dM2jlyPDgYHdvr/xHQP2EInrA6o5xuz2l6uE3wY+xhiB0D93pp8SMa88j627jP7DhOzSkjoO646y/57xQmXypiKMub2/7/wm+w1/zCr6u2xveZHk49UiSmZkGZrw46UfTwXjAnMarE3S3vTvfNOTJUNVbaKxEQlSfeGwf6DWdo1mgqkwXFYNBLUix9IbaglkQwxA2lPfJpw6+emDrLbgk+LMMyUS+V/8h45hqYJZYQkXgpC42ZHU0FjADHZ3ZdKWbKumscZ986d08c9XyNMqdb4xHvTBgqCCBJ2yf/M0pPYBjHhpUHUINIzsnFqQA64FJUpR61qghQmIVFqi7WhZTW1A+W4leO9yJlJ3thZpKyJEApzYtw37H9oFRONMK/F8e+NDvnQmWkJRDAgSBj7KZ25sCnNqn0Xw2KaiAzwTpmMxfcmH7Uk5sfmwNOcTRxNxsJV6FmWCGEyOGEAgjyn31B5r0haPgCxajYmBjZ3pvg491jc0xikq0NVDUlHNy+IBsXLqU4eNoHr7FHfQIcD4mFgKqMLpHDlvQaOmRxAM9lLmX/bEsi2x1ji460Nz2wIJzRvfWtPY09jH4JoMQZ9zh9IzZ1IRSVhNprPJM/U60A58IKdpDpw6KUntDmiRwccep5xSJLzaDScMDC0SQ2HVWjedNsQs407NSHIuQMJ+YhpaqgTggtu7VQfYaKT3OBdmzJRjP8r04AwSXV9aXS1NYsgfSADHdspPU8j0MXcnD0/lKilWoT5MamzWtggR9cS0wmNYIihzysruche5LhYlSUigfqqcTIQyJO2pzngAaNQNk11RcedVbA7UzBYz+wGY2WcEZHw8TsIJuUjzKARa3S3bzYodlOL04WR/EXX84403/jY6N60sxLXecuoGmhgthxK1I/rd266DKIdfIQpbSwpPfYi10dBjfS1cgqTw09r2XlE/Jgs1ojzjekXOxUl98cgNWVbzsQeGETst48wpQSUUyaNVFnizgg9ktzpmEfN1ALZnxpxwt58afrFnTrbHuR4+5n2K/0+BDPG5/yJeapWDGQ4Sii0KBUY7JIz9UKUDuQtA3HKbAdEHZ1XCufTMORAgxgwjnhMaYlDTZbRxHssx9xPtJf1um/K6toaVMKkeRWoko7DyBfiEjOroVjALse0T6J0IOJEoDHC/zh3hR38mekH1QIN2p43baNPWx4XUmLOxd4BY7TX6aNQrOxKBJAT78pUybXJw2txDI741AwENNEuvbVjSm5tCzmq/14lx4wLyOgTXb+nFDBOKsZiekuRSxu3CBGm5Biu02IhTV548u9OBjJneAvKi5Oq62EDAsm9T+PgXSA2LVYbLztOMPB5ZeX4a8vGLNY+QoTpC8iNBQGH8Fw+YzTctVyk1HQB8CXIdZZdiOOuBqtkqrXUZh/cNFVKMnkJVFWWnH8cvvjwGFqb3w8Rpo+LFElMsi2DOXxDAjl7pNR8ZDJBUlZm3n8buQ1tyhleVwTj8lUdantmvzD64D3sKLkglHjB2zv7ucRMOOHPmmiCoURpHxcplZibJC0dIDXP2DGmT/YjHtoxqWNu9QK5elzqe/ME4S5VzAtWvnfFihQQE3oeuGTC2w72PHnC4aWXqxng+AGccS0G2GtRPw4Y7z5zbQ1M5ca12jIrR6YBQoQpO8e57aVbPbXRZMVfmYGD1mbh3mngNtvcgwPjV3kR0fRXk4ZL86HNugw0kClpkM6lDBPTDCE1FIxudZnGpRr51L7foXIvBv27NjJ/btaXwpkpx5xBhTzUC5Xbc26RNN10eq3ExlxZWyfFvU6NoqXbbAK+EcelaiUY2HnGdERjNbrwObXmTVdA0yJdqraxrJJ55PoUuIymxmmQXsKkAbRSWWoYznlSK7DGrYbmiQ1ArodTOn2BNkBi9neJ90+U+1sHy7px6M0BRCorVFttDSK3+lwpcfqifhza8FA7B+F/KA68GLE1f2RlpYqWSlySC5dk9PcFqaqj8ceR60/ZpmkeITtsASXroUvHDGcCTeZNMW93zLZs2xCMArHSxp/5U+qx9UX9OGjRPz64tC23Se0P7fe1aYDYKnlc7wakffmTSYO878JsCCgKSiaChyJDzmW0CtQws+rcgFRK8UhP2HOx72oC3jdnnQViJnyFwHGDsk5o+crUBaFjiDktcxb9uuZJzQA5g7jd2ciRlisxJddOfWhMvx86NKmZA7lKXqo6Jp9baz5zEDmJpGa3FaPsi/rxHWcxA3L2TJuUwRGTmLKypQQmKziUpTtS0dQxUGpPy0HZJWFy73MVOxP2tvirzakRCamayrErw+dKbNk2HEgL5EpMiVKJuWmEKVElZ48GKW+rrhxAfQUajMXWZaxsUJVVnJ1t9HHxMiUxwow5aTZNJR0Kcjp9WnhfLi7Z75iDaxORstzqdeD6qoipsqHo+KQ5TIJ0ntTIlugSNRkSHGU1JBjU5jYzaAYDj5f5jZJDfF/cV+szFWsIEqaSl8lxacoBIu0r8bgEfXLPWu20Sf2RC63/UphdbwnTKd8u8UmHn006mno1+0Yri48VosqzlHnTbULpeOvNO51CmL6BkSMxh5b3lwy2ojtHNS5amWC2VWqWajy9CZCUz/D57Mwcz6p0Im3Swk9rTGRU/3MCPNCgS2zrauzSI4uQPy1WG+PyIHBfNaQQpk865HSi5MTjPg3rTMiYxz6iltB+Nb5Mtq0SU0q+Sy31jiK8eDuXJkw3RhMbM1liUgSHvL7WJ/CaQmZ1lHzktSmqEIwyb7otiEX9+P7vTWKmEKY6l1mgzsn0qcG75in+Mfati87hYWxdYRvV2VjUj4M023rzxqcQpmZjljgjpKTZuan4ZedCyCyQ6ai/z9XVUqFTnHrFq79F0JWzJUnyKdE/RV+YbgNRwvR4BbMJ07OGTleLLjUGZUZINbbPVRcGM5+p5eoanahioZjy+H5CGSVCISXqx+E68vwqSJGYgGzAnDlMDpljt9/yeq1tQi6Y1WSNojUJU8CJa0nqVAYg67PCxDzTTNPI8UFBGUFo7RxxOjbJtGltfdpUwpSVLYr68UjNw5thfPLuFrTi2dr6t6YQGRImhKEFGkjV+gDthmVkWG4ib8O5sg7O2jKdkTKA3HbIkZZAihT3oY0MlQVSCVM+sMk0h7Zea6Ns7zbBPrnN0caKfnJAZKVWKRkgXSJFampLcKLd3pklQUlJo80bwjSYZ5RxWjDFlpvZlJMwLSHrVvw9mFTClJ7Z4kgU4poycXgIX9VyRKkNuMemOaR0KFn0qpYDKMoAyFOcunKdei0xm0ZlJEBKzJjjqknCdGvrNN2jivAX1jiS/J6H1nHgfisr6Bk/oBZKFQEesL0evZ4AFoKS6vY0wqUhCTij8kkbEDxvk3kLZUi8t9u/2fH/xfmUfgTgQY9KGlr+Az9DTjy81zNfG+JzFGQHxsp4HOiH/9rt1+z4vbg35Z35eXn9tfhP7QNaJ3eFeZR+qGlk7nCHhiBN45lZlRAgosXCZIlLnKIMRFm5xbJdGVhDqY+gjl7xC5LkDLOaB87MAAAAAElFTkSuQmCC",
  Ebe =
    "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAM4AAAAyCAMAAAAjkRSUAAAABGdBTUEAALGPC/xhBQAAAAFzUkdCAK7OHOkAAALZUExURQAAAP///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////xd7qKEAAADydFJOUwA3w5mFypXPPcx5MJbQJMXt3wfv3tQE+Qgly4kc5cZXlHbqagYOLAEKdzEZ3ejI+10gzW7n5k1EDeMW9PYyLWJ+ppNyBROwDLk+QR4/rXUVa2ad+FGg8oT699OGrMA2n1pvp0mzEl/9sQ9FVtK1ZxDhvo6/ektIzoch6ZzaUwMax9eiTidVF7cYM7aDczVei6XJkpePnuCaWdER81hgZPBtaRTE26R46zRhRinir0dwgjp7bDx87OSj1gtCUFwoObsJQPVl3E+8wv5/JgK92ai4G+6y2FsvoR0rY9UiQ5GraHQ7qUqAUh+uqpCbTPGYI7SMCPzUWQAABx1JREFUaN7dmedXFUcUwEeKKPpA3qOJgALSFARRDCggJYKCYkEBsYGAgIA9dmONvffeY+89xt5ij1Fjeu89uX9BZmZ3Zmf37eOdY07OcbkfmLmzd+/Ob5i5c2ceQjoycez63CpUTyR7LGBpFtS6PsA0yARZjpQYHuZjRxDknbcMDWN2ygO1jM82Ls02D7CWYe2NCdPTHXQlpiDceDD+/cCm7C2OMBjN0iSoS3INBXOocZ0wYMkxEExoU7AjjQxE80ZHezTjDERz0B4MeDBT7/JXH+c9uziHmWn37199nCGazjunt8KSvnZcL7khiFm6wsmX+sLrdT18Uy7nX2nv/dIM3Q70DJMd+alp8rnT5lJDHN+ZAN7VuFnp1W4mV+aZvE6TMnmTyYWJaVMKQqXTa7Zzq8iiTT254ugVaCZlSrrJByCgdukHim/XItmFySGtpC3ttJ/imD5wo4adg8Z3wf08n3aJaF5qnB7c3xdSQ2+mzwbopME5j7NUrgwFaErKkSp/E+k43OZWFpw2sXoEgB8pc7m1jyP/V74veknqgFtmaldBMrE7voXrjb9F6LbKopXS19dow6dMnYyVGRocZ9y2gilNAJxI2QjAIb0pE5LxLQBgwx6G3whgb4wAqCahFbf5pResfoIHeQefHA3VXR+BUFstThts9raqJRWNEVVPpMFZzLQDRNuog8NnoIDTUm2Gu32LzTVxGxsMMTh7ehgPsJTqvTOClQEjOPmBgYHuq8hUgi5vot2PPTw9owKIFh/l6enpMQ+hObTbhc7XXGjFBcWLOM01OF18ZSU8mDxeboWD507SRSucnZpzRx5kytU98E8ttJBDxB9QS9YcgBezTPBW4dyVosQQ9q8gsowoZ2RlBu31IH9cPYxfGBOB9gs0+5AGhy+WAfR5VyucDSUAT6xwOmjsnsHNh7RSBZAVC8+l1hsA/XGxCMCkE60IjrtUTSbfHipMV2nVYKGDzM6YfTteQaiZQuOONDgDWL2TZHDLCicTxQGU2MPBs+0OrWyHLegFgHSEWgE+18kUAwlLB8dBqh4jxxQ2TxoI07U/iIsXJSAVTmf1+Qd2sINOgo9kMMoKpx1doM01ONUau80V8shUQhoK3wG75FBZScvh2ENBjh7OKrPZ3DrrhieuTkA6OCQODDSrXlNwYtX+flSC9gLZ4msrHDx+H8ppkIAzrLolla3VvmyvjqarZSCUku4/opsNwGUpXpNDcMXwjVVWOIVTg4OjLSTPOoH0cNzFYKXB6aXpa9BgVgthJiF6ODhAwTo1jiL+kmGstJRHgo+Z8pfTJAMS5JReum95eiFbg8Pk3hyki7MXVxvq4+Sza7UUOav5iTUo8b6PLo43Tsnn2sBpK3e4goazX+EZ/lteCMW4COThDmcgkbOo+Rp9HIDobD2c6epXRBw+s6LGazqt5A2ndXEICHQjEZThLHGT5IEbC7zXIAr/9ZBi42JYiVOWe6C69nLrQL7TT4WTmHr/h9QTR+m3c3RwHHA1UBeHpwOXtcebAmWM9CcbQqnEa3sFZ7lVnOpL4sUiOdrsgqfeaCPEZGmMzuJPpIg4j2QCiwAq4gwQJoAKh6cDm/GupHreRPiX77KBQ9ZkMbIdqBHaDZCB7stbAU7iGuCcrNbKKhPguIgzS6jP1sEh6REc5a+TuHNOnQ7gOdxC9QnxrDrKFk55DFSERNeBg49Vf2NoefHV4OTKB7ZJysKF3GgngKvONorKhExPxEGJRJnMEqhEvNVOJS3cSQZocKaJC7KvLRy6z+bbSnLolSQk/uUj759oEJQNhZjNkvKLJYwZpQFst95GI3KldEwHZy7t1oJD11Hone4ANz9BAWI68DlocCaq4ktXmzhoHXnOcLYivdkWB49l5QVYaqBMDgH4vbVufENYKOJsaYfFj2YyfMRVOOiC1LH9URZaJqL1YjowXYNzcaAKZ7ltHOQh4LivcZRlQyniyaf8nMh6ZdfuTAfiruPafiSyZdgI1OAXrotDUwouAaXouZAOOIEGp0ztUzvqATT8KodXneMbP6t1BRIAZPkTK6FMuVTErU8pvr9TufmKH+t6EHWksNsrI74ylIwwTwdOSq3fcNNRmvOSNlOcY5omxOJJLnSlt4lrrIgLn59Vq0yV3PZqnMtqwc/vvzlbkqKHTH4gtEW6yC4m7fl5yTKlPQy7n9RGMJx5yoFc4RZ9SRujgf/KNlXq9NhIVyr7zmqPf8f+vxuYrG7/4ce+3ouuTpGrNXy6fmT3iqrJq38xNUVzpqnr/tDXOLehvnn2aHqNNtDlbnc7MPGxRvpNZIIdmg0JRqLxja8TxvmMsX59C5+/pNAmTMcQZDyZkmaDZnUWMqQ00gsHg8OQYaX4Mw2M31xkaOkj3LvBkYPI6DLaSb4jhHMTzKgeSA49geY5jUb1RJIrxwzyN2TP/wXWbYohEHfs4wAAAABJRU5ErkJggg==",
  Cbe = "/assets/part14-CdOxARaq.png",
  xbe = "/assets/part15-DuSmbU6F.png",
  Sbe = "/assets/part16-Ddy7l0E9.png";
function Abe() {
  const t = xs("(max-width:950px)");
  return O.jsx(O.Fragment, {
    children: O.jsx(be, {
      py: t ? 2 : 3,
      sx: { background: "#000" },
      children: O.jsx(be, {
        children: O.jsx(A_, {
          speed: 50,
          pauseOnClick: !0,
          pauseOnHover: !0,
          gradient: !1,
          children: O.jsxs(be, {
            style: { display: "flex", alignItems: "center" },
            children: [
              O.jsx("img", {
                src: lbe,
                width: t ? "120px" : "200px",
                style: { marginRight: t ? "30px" : "55px" },
                alt: "",
              }),
              O.jsx("img", {
                src: ube,
                width: t ? "120px" : "200px",
                style: { marginRight: t ? "70px" : "85px" },
                alt: "",
              }),
              O.jsx("img", {
                src: dbe,
                width: t ? "120px" : "200px",
                style: { marginRight: t ? "70px" : "85px" },
                alt: "",
              }),
              O.jsx("img", {
                src: pbe,
                width: t ? "120px" : "200px",
                style: { marginRight: t ? "70px" : "85px" },
                alt: "",
              }),
              O.jsx("img", {
                src: fbe,
                width: t ? "120px" : "200px",
                style: { marginRight: t ? "70px" : "85px" },
                alt: "",
              }),
              O.jsx("img", {
                src: hbe,
                width: t ? "120px" : "200px",
                style: { marginRight: t ? "70px" : "85px" },
                alt: "",
              }),
              O.jsx("img", {
                src: mbe,
                width: t ? "120px" : "200px",
                style: { marginRight: t ? "70px" : "85px" },
                alt: "",
              }),
              O.jsx("img", {
                src: gbe,
                width: t ? "120px" : "200px",
                style: { marginRight: t ? "70px" : "85px" },
                alt: "",
              }),
              O.jsx("img", {
                src: ybe,
                width: t ? "120px" : "200px",
                style: { marginRight: t ? "70px" : "85px" },
                alt: "",
              }),
              O.jsx("img", {
                src: wbe,
                width: t ? "120px" : "200px",
                style: { marginRight: t ? "70px" : "85px" },
                alt: "",
              }),
              O.jsx("img", {
                src: vbe,
                width: t ? "120px" : "200px",
                style: { marginRight: t ? "70px" : "85px" },
                alt: "",
              }),
              O.jsx("img", {
                src: bbe,
                width: t ? "120px" : "200px",
                style: { marginRight: t ? "70px" : "85px" },
                alt: "",
              }),
              O.jsx("img", {
                src: Ebe,
                width: t ? "120px" : "200px",
                style: { marginRight: t ? "70px" : "85px" },
                alt: "",
              }),
              O.jsx("img", {
                src: Cbe,
                width: t ? "120px" : "200px",
                style: { marginRight: t ? "70px" : "85px" },
                alt: "",
              }),
              O.jsx("img", {
                src: xbe,
                width: t ? "120px" : "200px",
                style: { marginRight: t ? "70px" : "85px" },
                alt: "",
              }),
              O.jsx("img", {
                src: Sbe,
                width: t ? "120px" : "200px",
                style: { marginRight: t ? "70px" : "85px" },
                alt: "",
              }),
            ],
          }),
        }),
      }),
    }),
  });
}
function _be() {
  const { account: t, chainId: e } = N.useContext(nb),
    [n, r] = N.useState(!1);
  return (
    N.useEffect(() => {
      t && e > 0 && e !== g_ && r(!0);
    }, [e, t]),
    O.jsxs(O.Fragment, {
      children: [
        O.jsx(cve, { open: n, setOpen: r }),
        O.jsx(Swe, {
          children: O.jsx(WL, {
            path: "/",
            element: O.jsxs(O.Fragment, {
              children: [
                O.jsxs(be, {
                  sx: {
                    backgroundImage: `url(${_ve})`,
                    backgroundSize: "cover",
                    backgroundPosition: "center",
                    height: { xs: "100%", md: "60rem" },
                  },
                  children: [O.jsx(sve, {}), O.jsx(Ave, {})],
                }),
                O.jsx(Abe, {}),
                O.jsx(Rve, {}),
                O.jsx(Mve, {}),
                O.jsx(Ive, {}),
                O.jsx(Wve, {}),
                O.jsx(tbe, {}),
                O.jsx(sbe, {}),
                O.jsx(cbe, {}),
              ],
            }),
          }),
        }),
      ],
    })
  );
}
uU.createRoot(document.getElementById("root")).render(
  O.jsx(N.StrictMode, {
    children: O.jsx(mve, {
      children: O.jsx(Kwe, { children: O.jsx(_be, {}) }),
    }),
  })
);
export {
  wS as $,
  Be as A,
  K3 as B,
  Rm as C,
  Xe as D,
  U6 as E,
  wn as F,
  ri as G,
  si as H,
  nk as I,
  Pbe as J,
  Ze as K,
  Tbe as L,
  jn as M,
  dV as N,
  me as O,
  iue as P,
  Ws as Q,
  zt as R,
  $o as S,
  Hr as T,
  Qn as U,
  tc as V,
  Rr as W,
  mV as X,
  Gt as Y,
  H1e as Z,
  ei as _,
  Dd as a,
  F0 as a0,
  Ch as a1,
  Hc as a2,
  B1e as a3,
  hr as a4,
  F1e as a5,
  vS as a6,
  K6 as a7,
  hp as a8,
  Cw as a9,
  Ew as aA,
  Lv as aB,
  k1e as aC,
  D1e as aD,
  hpe as aE,
  jX as aF,
  d1e as aG,
  RR as aH,
  QD as aI,
  RX as aJ,
  FX as aK,
  p1e as aL,
  u1e as aM,
  Ev as aN,
  f1e as aO,
  m1e as aP,
  Ia as aQ,
  Pye as aR,
  nU as aS,
  q1e as aT,
  IV as aU,
  Eo as aV,
  Iye as aW,
  qA as aa,
  Bc as ab,
  P1e as ac,
  zv as ad,
  VA as ae,
  T1e as af,
  I1e as ag,
  XM as ah,
  jv as ai,
  vw as aj,
  due as ak,
  mue as al,
  $1e as am,
  ude as an,
  ge as ao,
  YA as ap,
  gs as aq,
  Sde as ar,
  xpe as as,
  P6 as at,
  lp as au,
  xh as av,
  jc as aw,
  WM as ax,
  O1e as ay,
  BA as az,
  nt as b,
  V1e as c,
  ga as d,
  er as e,
  z1e as f,
  Nl as g,
  ye as h,
  Jv as i,
  Je as j,
  Y as k,
  fn as l,
  qs as m,
  Et as n,
  W1e as o,
  Fi as p,
  an as q,
  W0 as r,
  pn as s,
  Zme as t,
  ti as u,
  Qme as v,
  Ie as w,
  U1e as x,
  pr as y,
  rk as z,
};
